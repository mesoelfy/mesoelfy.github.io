+---------------------------------+
|      M E S O E L F Y _ O S      |
|   Next.js / R3F Source Context  |
+---------------------------------+
Generated on: Sat Dec 13 09:05:16 CST 2025

=====================================
PROJECT DIRECTORY STRUCTURE:
=====================================
.
├── Icon\015
├── README.md
├── docs
│   ├── MESOELFY_OS_AI_INSTRUCTIONS.md
│   └── all_source_code.txt
├── next-env.d.ts
├── next.config.js
├── package.json
├── postcss.config.js
├── public
│   ├── assets
│   │   ├── audio
│   │   │   └── bg_music_placeholder.mp3
│   │   └── images
│   │       └── social-card.jpg
│   └── favicon.ico
├── scripts
│   └── create_source_context.command
├── src
│   ├── app
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── core
│   │   ├── audio
│   │   │   ├── AudioSystem.ts
│   │   │   └── modules
│   │   │       ├── AudioContextManager.ts
│   │   │       ├── AudioMixer.ts
│   │   │       ├── AudioSynthesizer.ts
│   │   │       └── SoundBank.ts
│   │   └── store
│   │       └── useStore.ts
│   ├── data
│   │   ├── feed.json
│   │   ├── gallery.json
│   │   ├── identity.json
│   │   └── socials.json
│   ├── features
│   │   ├── contact
│   │   │   └── ContactModal.tsx
│   │   ├── debug
│   │   │   ├── DebugOverlay.tsx
│   │   │   └── tabs
│   │   │       ├── ConsoleTab.tsx
│   │   │       ├── OverridesTab.tsx
│   │   │       ├── SandboxTab.tsx
│   │   │       └── StatsTab.tsx
│   │   ├── feed
│   │   │   └── FeedModal.tsx
│   │   ├── gallery
│   │   │   └── GalleryModal.tsx
│   │   ├── identity
│   │   │   └── AboutModal.tsx
│   │   ├── intro
│   │   │   ├── MatrixBootSequence.tsx
│   │   │   ├── atoms
│   │   │   │   ├── AsciiRenderer.tsx
│   │   │   │   ├── BootHeader.tsx
│   │   │   │   ├── CoreHeader.tsx
│   │   │   │   └── TypedLog.tsx
│   │   │   ├── data
│   │   │   │   └── bootLogs.ts
│   │   │   └── hooks
│   │   │       ├── useBootSequence.ts
│   │   │       ├── useMatrixRain.ts
│   │   │       └── useSmartScroll.ts
│   │   ├── meta
│   │   │   ├── MetaManager.tsx
│   │   │   ├── faviconGenerator.ts
│   │   │   ├── hooks
│   │   │   │   ├── useMetaTheme.ts
│   │   │   │   ├── useMetaTitle.ts
│   │   │   │   └── useMetaUrl.ts
│   │   │   ├── metaConstants.ts
│   │   │   └── useFavicon.ts
│   │   ├── mobile
│   │   │   ├── MobileExperience.tsx
│   │   │   └── MobileRejectionModal.tsx
│   │   ├── sandbox
│   │   │   └── SimulationHUD.tsx
│   │   └── settings
│   │       ├── SettingsModal.tsx
│   │       ├── components
│   │       │   ├── GpuConfigPanel.tsx
│   │       │   └── RangeSlider.tsx
│   │       └── tabs
│   │           └── SoundTab.tsx
│   ├── game
│   │   ├── GameOverlay.tsx
│   │   ├── assets
│   │   │   ├── AssetCatalog.ts
│   │   │   └── AssetService.ts
│   │   ├── components
│   │   │   ├── BulletRenderer.tsx
│   │   │   ├── DaemonBulletRenderer.tsx
│   │   │   ├── DaemonChargeRenderer.tsx
│   │   │   ├── DaemonRenderer.tsx
│   │   │   ├── EffectsLayer.tsx
│   │   │   ├── EnemyBulletRenderer.tsx
│   │   │   ├── GalleryStage.tsx
│   │   │   ├── GameDirector.tsx
│   │   │   ├── HunterChargeRenderer.tsx
│   │   │   ├── MobileGameDirector.tsx
│   │   │   ├── ParticleRenderer.tsx
│   │   │   ├── PlayerAvatar.tsx
│   │   │   ├── ProjectileTrails.tsx
│   │   │   ├── RenderDirector.tsx
│   │   │   ├── ScreenShaker.tsx
│   │   │   ├── common
│   │   │   │   └── InstancedActor.tsx
│   │   │   ├── data
│   │   │   │   ├── ColliderComponent.ts
│   │   │   │   ├── CombatComponent.ts
│   │   │   │   ├── HealthComponent.ts
│   │   │   │   ├── IdentityComponent.ts
│   │   │   │   ├── LifetimeComponent.ts
│   │   │   │   ├── MotionComponent.ts
│   │   │   │   ├── OrbitalComponent.ts
│   │   │   │   ├── StateComponent.ts
│   │   │   │   ├── TargetComponent.ts
│   │   │   │   └── TransformComponent.ts
│   │   │   ├── enemies
│   │   │   │   ├── DrillerRenderer.tsx
│   │   │   │   ├── HunterRenderer.tsx
│   │   │   │   └── KamikazeRenderer.tsx
│   │   │   └── index.ts
│   │   ├── config
│   │   │   ├── AIConfig.ts
│   │   │   ├── AudioConfig.ts
│   │   │   ├── EnemyConfig.ts
│   │   │   ├── Identifiers.ts
│   │   │   ├── ModelConfig.ts
│   │   │   ├── PhysicsConfig.ts
│   │   │   ├── PlayerConfig.ts
│   │   │   ├── SystemManifest.ts
│   │   │   ├── TextAssets.ts
│   │   │   ├── VFXConfig.ts
│   │   │   └── WorldConfig.ts
│   │   ├── core
│   │   │   ├── ComponentBuilder.ts
│   │   │   ├── Constants.ts
│   │   │   ├── EntitySpawner.ts
│   │   │   ├── FastEventBus.ts
│   │   │   ├── GameBootstrapper.ts
│   │   │   ├── GameEngine.ts
│   │   │   ├── MobileBootstrapper.ts
│   │   │   ├── ObjectPool.ts
│   │   │   ├── ServiceLocator.ts
│   │   │   ├── SpatialGrid.ts
│   │   │   ├── ecs
│   │   │   │   ├── Component.ts
│   │   │   │   ├── ComponentPoolManager.ts
│   │   │   │   ├── Entity.ts
│   │   │   │   ├── EntityRegistry.ts
│   │   │   │   ├── Query.ts
│   │   │   │   ├── TransformStore.ts
│   │   │   │   └── types.ts
│   │   │   ├── index.ts
│   │   │   └── interfaces.ts
│   │   ├── data
│   │   │   └── Archetypes.ts
│   │   ├── events
│   │   │   ├── GameEventBus.ts
│   │   │   └── GameEvents.ts
│   │   ├── hooks
│   │   │   ├── useDeviceType.ts
│   │   │   ├── useHeartbeat.ts
│   │   │   ├── usePanelRegistry.ts
│   │   │   ├── useTransientRef.ts
│   │   │   └── useWindowFocus.ts
│   │   ├── inputs
│   │   │   └── VirtualJoystickService.ts
│   │   ├── logic
│   │   │   ├── ai
│   │   │   │   ├── AIRegistry.ts
│   │   │   │   ├── BehaviorCatalog.ts
│   │   │   │   ├── DaemonLogic.ts
│   │   │   │   ├── DrillerLogic.ts
│   │   │   │   ├── HunterLogic.ts
│   │   │   │   ├── KamikazeLogic.ts
│   │   │   │   └── types.ts
│   │   │   └── combat
│   │   │       ├── CollisionMatrix.ts
│   │   │       ├── CombatHandlers.ts
│   │   │       └── types.ts
│   │   ├── render
│   │   │   ├── RenderCatalog.ts
│   │   │   └── RenderRegistry.ts
│   │   ├── services
│   │   │   ├── ConfigService.ts
│   │   │   ├── DOMSpatialService.ts
│   │   │   ├── StructureHealthService.ts
│   │   │   └── TransientDOMService.ts
│   │   ├── store
│   │   │   ├── slices
│   │   │   │   ├── createCombatSlice.ts
│   │   │   │   ├── createProgressionSlice.ts
│   │   │   │   └── createUISlice.ts
│   │   │   └── useGameStore.ts
│   │   ├── systems
│   │   │   ├── AudioDirectorSystem.ts
│   │   │   ├── BehaviorSystem.ts
│   │   │   ├── CollisionSystem.ts
│   │   │   ├── CombatSystem.ts
│   │   │   ├── GameStateSystem.ts
│   │   │   ├── GuidanceSystem.ts
│   │   │   ├── InputSystem.ts
│   │   │   ├── InteractionSystem.ts
│   │   │   ├── LifeCycleSystem.ts
│   │   │   ├── MobileWaveSystem.ts
│   │   │   ├── OrbitalSystem.ts
│   │   │   ├── PanelRegistrySystem.ts
│   │   │   ├── PhysicsSystem.ts
│   │   │   ├── PlayerSystem.ts
│   │   │   ├── ShakeSystem.ts
│   │   │   ├── StructureSystem.ts
│   │   │   ├── TargetingSystem.ts
│   │   │   ├── TimeSystem.ts
│   │   │   ├── UISyncSystem.ts
│   │   │   ├── VFXSystem.ts
│   │   │   ├── WaveSystem.ts
│   │   │   └── index.ts
│   │   ├── theme.ts
│   │   ├── types
│   │   │   └── game.types.ts
│   │   ├── utils
│   │   │   ├── GeometryUtils.ts
│   │   │   ├── Noise.ts
│   │   │   ├── RenderUtils.ts
│   │   │   ├── TextureGen.ts
│   │   │   ├── ViewportHelper.ts
│   │   │   ├── ai
│   │   │   │   └── StateMachine.ts
│   │   │   └── coords.ts
│   │   └── workers
│   │       └── GeometryWorker.ts
│   ├── scene
│   │   ├── canvas
│   │   │   └── SceneCanvas.tsx
│   │   ├── effects
│   │   │   └── MatrixGrid.tsx
│   │   └── props
│   │       ├── MiniCrystalCanvas.tsx
│   │       └── SoulCrystal.tsx
│   ├── styles
│   │   └── globals.css
│   └── ui
│       ├── atoms
│       │   ├── ActionButton.tsx
│       │   ├── CustomCursor.tsx
│       │   ├── DotGridBackground.tsx
│       │   ├── GlassPanel.tsx
│       │   ├── GraphicsToggle.tsx
│       │   ├── PanelSparks.tsx
│       │   ├── SafePanelContent.tsx
│       │   ├── VirtualJoystick.tsx
│       │   ├── VitalsRing.tsx
│       │   └── ZenBomb.tsx
│       ├── molecules
│       │   ├── HoloCommLog.tsx
│       │   ├── IdentityFooter.tsx
│       │   ├── IdentityHUD.tsx
│       │   ├── LiveArtGrid.tsx
│       │   ├── SocialRow.tsx
│       │   ├── SystemOps.tsx
│       │   ├── UpgradeTerminal.tsx
│       │   └── panel
│       │       ├── BreachOverlay.tsx
│       │       ├── IntelligentHeader.tsx
│       │       └── RebootOverlay.tsx
│       ├── organisms
│       │   ├── Footer.tsx
│       │   └── Header.tsx
│       └── overlays
│           ├── ErrorBoundary.tsx
│           ├── GlobalBackdrop.tsx
│           ├── ModalContainer.tsx
│           └── RotationLock.tsx
├── tailwind.config.ts
└── tsconfig.json

68 directories, 213 files

=====================================
FILE: ./next.config.js
=====================================
/** @type {import('next').NextConfig} */

let commitHash = 'DEV_BUILD';

try {
  const { execSync } = require('child_process');
  commitHash = execSync('git rev-parse --short HEAD').toString().trim();
} catch (error) {
  console.warn('Warning: Could not determine git commit hash.');
}

const nextConfig = {
  output: 'export',
  images: {
    unoptimized: true,
  },
  reactStrictMode: true,
  transpilePackages: ['three'],
  
  // Disable Indicators
  devIndicators: false,


  
  env: {
    NEXT_PUBLIC_COMMIT_HASH: commitHash,
  },
  
  typescript: {
    ignoreBuildErrors: true,
  },
  eslint: {
    ignoreDuringBuilds: true,
  },
}

module.exports = nextConfig


=====================================
FILE: ./docs/MESOELFY_OS_AI_INSTRUCTIONS.md
=====================================
I am developing "MESOELFY_OS," a 3D interactive portfolio site with a Keygen/Cyberpunk/Hacker/Demoscene aesthetic. 

I have attached "all_source_code.txt" which contains the full project tree and code. Please ingest this to understand the current architecture.

***CORE IDENTITY & AESTHETIC***
*   **Persona:** You are assisting "Elfy," a Latent Space Bandit. The vibe is Y2K Hacker, Matrix, Geometry Wars, and High-Tech Demoscene.
*   **Palette:** Electric Green (#78F654) is dominant. Deep Purple (#9E4EA5) is secondary. Red/Yellow for alerts. Black backgrounds.
*   **Current Status:** The site is live at `mesoelfy.github.io`. The "Intro Boot Sequence" and "Main MESOELFY_OS Dashboard" game area are built and stable, but suggestions for improvements for AAA levels of polish in code architecture, game design, animation, motion graphics, sound design, and graphic design are always appreciated.

***TECHNICAL STACK***
*   **Framework:** Next.js 14 (App Router) + TypeScript.
*   **Styling:** Tailwind CSS + Framer Motion (for UI animations).
*   **3D:** React Three Fiber (R3F) + Drei.
*   **Deployment:** GitHub Pages (Static Export).

***WORKFLOW RULES (CRITICAL)***
1.  **Terminal Only:** Do not ask me to manually create files. Provide full terminal commands using `cat << 'EOF' > path/to/file` to create or overwrite files.
2.  **No Placeholders:** Unless specified, write complete, functional code.
3.  **STEP BY STEP PHASE-BASED WORKFLOW:** After an outline of steps has been articulated, give the code in structured steps instead of all at once.
4.  **// VERIFICATION CHECKLIST:**  Let the user know what to look for to confirm the changes have succeeded and the build is stable
5.  **Atomic Commits:** After the user a successful feature implementation, provide the specific `git add .`, `git commit -m "..."`, and `git push` commands with a detailed commit description after the title. Don't provide the commit until the user asks for it. For git add, always use the period ".". And make sure you include the long description. It should be provided as a single copy-paste for the user.
using git add . to capture all the relevant modified files and following the prescribed format: git add . -> git commit -m "title" -m "description" -> git push.

Don't repeat information from previous commits. Each new commit is for the new progress that has been made.

6.  **Lean Ship:** Keep dependencies low. Prefer procedural generation (shaders/math) over large assets.
7. **WAIT** Don't provide code until user asks for it. You should articulate with text what you'd like to do so the user can confirm what needs to be done.

Working directory:
stevencasteel@Stevens-Mac-mini mesoelfy-site % 


Please acknowledge you have analyzed the codebase.

=====================================
FILE: ./next-env.d.ts
=====================================
/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


=====================================
FILE: ./README.md
=====================================
<div align="center">

```text
 ███▄ ▄███▓▓█████  ██████  ▒█████  ▓█████  ██▓      █████▒▓██   ██▓
▓██▒▀█▀ ██▒▓█   ▀▒██    ▒ ▒██▒  ██▒▓█   ▀ ▓██▒    ▒▓█   ▒  ▒██  ██▒
▓██    ▓██░▒███  ░ ▓██▄   ▒██░  ██▒▒███   ▒██░    ▒▓███ ░   ▒██ ██░
▒██    ▒██ ▒▓█  ▄  ▒   ██▒▒██   ██░▒▓█  ▄ ▒██░    ░▓█▒  ░   ░ ▐██░░
▒██▒   ░██▒░▒████▒██████▒▒░ ████▓▒░░▒████▒░██████▒░▒█░      ░ ██▒░░
░ ▒░   ░  ░░░ ▒░ ░ ▒░▒  ░ ░ ▒░▒░▒░ ░░ ▒░ ░░ ▒░▒  ░ ▒ ░       ██▒▒▒
░  ░      ░ ░ ░  ░ ░ ▒  ░   ░ ▒ ▒░  ░ ░  ░░ ░ ▒  ░ ░       ▓██ ░▒░ 
░      ░      ░    ░ ░    ░ ░ ░ ▒     ░     ░ ░    ░ ░     ▒ ▒ ░░  
       ░      ░  ░   ░  ░     ░ ░     ░  ░    ░  ░         ░ ░     
```

### **LATENT SPACE BANDIT // DIGITAL HQ**

![System Status](https://img.shields.io/badge/SYSTEM-UNSECURE-ff003c?style=for-the-badge&logo=linux)
![Encryption](https://img.shields.io/badge/ENCRYPTION-BYPASSED-78F654?style=for-the-badge)
![Core](https://img.shields.io/badge/CORE-REACT_THREE_FIBER-9E4EA5?style=for-the-badge&logo=react)

</div>

---

### **// TRANSMISSION_LOG**

**MESOELFY_OS** is a generative 3D operating system disguised as a portfolio site. It serves as the central node for **Elfy**, a rogue entity manifesting art from the void.

The system features a custom "Latent Defense" protocol, audio-reactive interfaces, and a direct uplink to the neural network.

### **// SYSTEM_SPECS (Tech Stack)**

| MODULE | PAYLOAD |
| :--- | :--- |
| **Framework** | Next.js 14 (App Router) + TypeScript |
| **Graphics Core** | React Three Fiber (R3F) + Drei + Shaders |
| **Styling** | Tailwind CSS + Framer Motion |
| **Audio Engine** | Web Audio API (Generative Synthesis) |
| **Deployment** | GitHub Pages (Static Export) |

### **// BOOT_PROTOCOL (Installation)**

```bash
# 1. Clone the Repository
git clone https://github.com/mesoelfy/mesoelfy.github.io.git

# 2. Inject Dependencies
npm install

# 3. Initialize System (Dev Mode)
npm run dev
```

### **// IDENTITY_CORE**

*   **Class:** Latent Space Bandit
*   **Abilities:** Green Flame, Digital Heist, Prompt Craft
*   **Mission:** Create cool s**t. Annoy the haters.

---

<div align="center">
  <p><strong>⚠ WARNING: TRANSMISSIONS ARE MONITORED BY THE AI OVERLORD. ⚠</strong></p>
  <a href="https://x.com/mesoelfy">[ TWITTER_UPLINK ]</a> • <a href="https://mesoelfy.github.io">[ LAUNCH_OS ]</a>
</div>

=====================================
FILE: ./tailwind.config.ts
=====================================
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './src/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        // --- SEMANTIC PALETTE ---
        
        // The core system color (Safe, Online, Active)
        'primary-green': {
          light: '#7FF65F',
          DEFAULT: 'rgba(96, 196, 68, 1)',
          dim: '#1bb930ff',
          dark: '#217e10ff',
        },
        
        // Lore, Regeneration, Special Enemies
        'latent-purple': {
          light: '#BC86BA',
          DEFAULT: '#9E4EA5',
          dim: '#822B8A',
          deep: '#350E3A',
        },
        
        // Repair, Friendly AI, Constructive
        'service-cyan': {
          DEFAULT: '#00F0FF', 
          dim: '#008ba3',
        },
        
        // Warnings, Highlights, Interaction Focus
        'alert-yellow': {
          DEFAULT: '#eae747ff',
        },
        
        // Critical Failure, Enemies, Destruction
        'critical-red': {
          DEFAULT: '#FF003C', 
        },
        
        // Backgrounds and Structures
        'muted-gray': '#27282A',
        'void-black': '#050505',
        
        // --- LEGACY GAME TOKENS (Keep for Logic/Canvas referencing if needed) ---
        game: {
          turret: {
            base: '#78F654',
            glow: '#C2FE9A',
          },
          bullet: {
            plasma: '#FFFFFF', 
            trail: '#78F654',
          },
          enemy: {
            seeker: '#9E4EA5',
            eater: '#FF003C',
            boss: '#F7D277',
          },
          hud: {
            text: '#78F654',
            warning: '#FF003C',
          },
          vfx: {
            spark: '#FFFFFF',
            damage: '#FF003C',
          }
        }
      },
      fontFamily: {
        header: ['var(--font-montserrat)', 'sans-serif'],
        mono: ['Courier New', 'Courier', 'monospace'],
        tech: ['var(--font-jetbrains)', 'monospace'],
      },
      animation: {
        'spin-slow': 'spin 3s linear infinite',
        'spin-diamond': 'spin-diamond 3s linear infinite',
        'matrix-green': 'matrix-green 4s ease-in-out infinite',
        'matrix-purple': 'matrix-purple 2s ease-in-out infinite',
        'cursor-blink': 'cursor-blink 1.2s ease-in-out infinite',
      },
      keyframes: {
        'spin-diamond': {
          '0%': { transform: 'rotate(45deg)' },
          '100%': { transform: 'rotate(405deg)' },
        },
        'matrix-green': {
          '0%, 100%': { color: '#14630bff' },
          '50%': { color: '#0aa41cff' },
        },
        'matrix-purple': {
          '0%, 100%': { color: '#9E4EA5' }, 
          '33%': { color: '#BC86BA' },      
          '66%': { color: '#350E3A' },      
        },
        'cursor-blink': {
          '0%, 30%': { opacity: '1' }, 
          '50%': { opacity: '0' },     
          '100%': { opacity: '1' },    
        }
      }
    },
  },
  plugins: [],
}
export default config


=====================================
FILE: ./package.json
=====================================
{
  "name": "mesoelfy-site",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@react-three/drei": "^10.7.7",
    "@react-three/fiber": "^9.4.2",
    "@react-three/postprocessing": "^2.19.1",
    "clsx": "^2.1.0",
    "framer-motion": "^11.0.0",
    "lucide-react": "^0.300.0",
    "maath": "^0.10.0",
    "next": "^16.0.7",
    "react": "^19.2.1",
    "react-dom": "^19.2.1",
    "tailwind-merge": "^2.2.0",
    "three": "^0.181.2",
    "zustand": "^4.5.0"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@types/three": "^0.181.0",
    "autoprefixer": "^10.0.1",
    "eslint": "^9.39.1",
    "eslint-config-next": "^16.0.7",
    "postcss": "^8",
    "tailwindcss": "^3.3.0",
    "typescript": "^5"
  }
}


=====================================
FILE: ./tsconfig.json
=====================================
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./src/*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}


=====================================
FILE: ./postcss.config.js
=====================================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


=====================================
FILE: ./src/ui/molecules/SocialRow.tsx
=====================================
import { Twitter, Youtube, Github, Video, Crosshair, Image as ImageIcon, AlertTriangle } from 'lucide-react';
import socials from '@/data/socials.json';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { useGameStore } from '@/game/store/useGameStore';
import { clsx } from 'clsx';

const IconMap: Record<string, any> = {
  twitter: Twitter,
  youtube: Youtube,
  github: Github,
  video: Video,
  crosshair: Crosshair,
  image: ImageIcon,
};

interface SocialRowProps {
  layout?: 'grid' | 'column';
}

export const SocialRow = ({ layout = 'grid' }: SocialRowProps) => {
  const panelState = useGameStore((state) => state.panels['social']);
  const isDestroyed = panelState ? panelState.isDestroyed : false;

  return (
    <div className={clsx(
        "gap-2 h-full content-center py-2 relative px-2",
        layout === 'grid' ? "grid grid-cols-3" : "flex flex-col",
        isDestroyed ? "pointer-events-none" : "" 
    )}>
      {socials.map((social, idx) => {
        const Icon = isDestroyed ? AlertTriangle : (IconMap[social.icon] || Crosshair);
        const isGlitch = isDestroyed && (idx % 2 === 0);
        
        return (
          <a
            key={social.name}
            href={isDestroyed ? undefined : social.url}
            target="_blank"
            rel="noopener noreferrer"
            onMouseEnter={() => !isDestroyed && AudioSystem.playHover()} 
            onClick={() => !isDestroyed && AudioSystem.playClick()}
            className={clsx(
                "group flex items-center p-2 border transition-all duration-200",
                layout === 'grid' ? "flex-col justify-center" : "flex-row gap-4 justify-start px-4 h-12",
                isDestroyed 
                    ? "border-critical-red/20 bg-critical-red/5 grayscale" 
                    : "border-primary-green-dim/30 bg-black/40 hover:bg-alert-yellow/5 hover:border-alert-yellow hover:shadow-[0_0_15px_rgba(234,231,71,0.15)]"
            )}
          >
            <Icon 
              className={clsx(
                  "transition-transform duration-200",
                  layout === 'grid' ? "w-5 h-5 mb-1" : "w-6 h-6",
                  isDestroyed ? "text-critical-red animate-pulse" : "text-primary-green-dim group-hover:text-alert-yellow group-hover:scale-110",
                  isGlitch ? "translate-x-1" : ""
              )}
              style={!isDestroyed ? { filter: 'drop-shadow(0 0 2px rgba(0,0,0,0.5))' } : {}}
            />
            <span className={clsx(
                "uppercase tracking-wider font-mono transition-colors duration-200",
                layout === 'grid' ? "text-[9px]" : "text-xs font-bold",
                isDestroyed ? "text-critical-red/60" : "text-primary-green-dim/60 group-hover:text-alert-yellow"
            )}>
              {isDestroyed ? (isGlitch ? "ERR_404" : "NULL") : social.name}
            </span>
          </a>
        );
      })}
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/panel/BreachOverlay.tsx
=====================================
import { motion } from 'framer-motion';
import { ChevronUp } from 'lucide-react';
import { clsx } from 'clsx';

const ScrollingRow = ({ direction, text }: { direction: number, text: string }) => {
  return (
    <div className="flex whitespace-nowrap overflow-hidden select-none opacity-60">
      <motion.div 
        className="flex gap-4 font-header font-black text-xl md:text-2xl text-critical-red tracking-widest uppercase py-1"
        animate={{ x: direction === 1 ? ["-50%", "0%"] : ["0%", "-50%"] }} 
        transition={{ duration: 40, repeat: Infinity, ease: "linear" }}
      >
        {Array.from({ length: 12 }).map((_, i) => (
          <span key={i} className={i % 2 === 0 ? "text-critical-red" : "text-transparent stroke-critical-red stroke-1"}>
             {text}
          </span>
        ))}
      </motion.div>
    </div>
  );
};

interface BreachOverlayProps {
  progress: number;
  isVideo: boolean;
  showInteractive: boolean;
}

export const BreachOverlay = ({ progress, isVideo, showInteractive }: BreachOverlayProps) => {
  // Safety: Ensure progress is a valid number for CSS width
  const safeProgress = (Number.isFinite(progress) && !isNaN(progress)) 
    ? Math.max(0, Math.min(100, progress)) 
    : 0;

  return (
    <div className={clsx(
        "absolute inset-0 z-[70] flex flex-col items-center justify-center overflow-hidden",
        isVideo ? "bg-black/20 backdrop-blur-[2px]" : "bg-black/60 backdrop-blur-sm"
    )}>
        {/* Background Scrolling Text */}
        <div className="absolute inset-[-50%] flex flex-col justify-center rotate-[-12deg] opacity-30 pointer-events-none">
            <motion.div
               className="flex flex-col gap-8"
               animate={{ y: ["0%", "-50%"] }}
               transition={{ duration: 30, repeat: Infinity, ease: "linear" }}
            >
                {[0, 1].map((set) => (
                    <div key={set} className="flex flex-col gap-8">
                        {Array.from({ length: 6 }).map((_, i) => (
                            <ScrollingRow 
                                key={`${set}-${i}`} 
                                direction={i % 2 === 0 ? 1 : -1} 
                                text="SYSTEM BREACH // CRITICAL FAILURE // REBOOT REQUIRED //" 
                            />
                        ))}
                    </div>
                ))}
            </motion.div>
        </div>

        {/* Interactive Reboot UI */}
        {showInteractive && (
          <div className="relative z-20 flex flex-col items-center justify-center gap-2 cursor-crosshair transition-all duration-100">
              <div className="relative">
                  <div className="group-hover:opacity-0 transition-opacity duration-200 absolute inset-0 flex items-center justify-center">
                      <motion.div 
                          animate={{ y: [0, -10, 0] }}
                          transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }}
                          className="text-critical-red drop-shadow-md"
                      >
                          <ChevronUp size={64} strokeWidth={3} />
                      </motion.div>
                  </div>

                  <div className="opacity-0 group-hover:opacity-100 transition-opacity duration-200 absolute inset-0 flex items-center justify-center -translate-y-8">
                      <motion.div 
                          animate={{ scale: [1, 1.2, 1], filter: ["brightness(1)", "brightness(1.5)", "brightness(1)"] }}
                          transition={{ duration: 0.2, repeat: Infinity, ease: "easeInOut" }}
                          className="text-latent-purple drop-shadow-[0_0_15px_#9E4EA5]"
                      >
                          <ChevronUp size={64} strokeWidth={4} />
                      </motion.div>
                  </div>
                  
                  <div className="w-16 h-16 pointer-events-none opacity-0"><ChevronUp size={64} /></div>
              </div>

              <div className="flex flex-col items-center text-center">
                  <span className="text-sm font-header font-black tracking-widest text-critical-red group-hover:text-latent-purple transition-colors duration-200 drop-shadow-md">
                      HOLD TO REBOOT
                  </span>
                  
                  {/* Progress Bar Container */}
                  <div className="w-32 bg-gray-900/80 h-1.5 mt-2 rounded-full overflow-hidden border border-gray-700 shadow-lg">
                      <motion.div 
                          className="h-full bg-latent-purple shadow-[0_0_10px_#9E4EA5]" 
                          initial={{ width: "0%" }}
                          animate={{ width: `${safeProgress}%` }}
                          transition={{ type: "tween", duration: 0.1 }}
                      />
                  </div>
                  
                  <div className="text-[10px] font-mono text-latent-purple font-bold mt-1 opacity-0 group-hover:opacity-100 transition-opacity bg-black/60 px-2 rounded">
                      INTEGRITY: {Math.floor(safeProgress)}%
                  </div>
              </div>
          </div>
        )}
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/panel/RebootOverlay.tsx
=====================================
import { motion } from 'framer-motion';
import { Power } from 'lucide-react';

export const RebootOverlay = () => (
  <motion.div 
    initial={{ opacity: 0, scale: 0.8 }}
    animate={{ opacity: 1, scale: 1 }}
    exit={{ opacity: 0, scale: 1.1, filter: "blur(10px)" }}
    transition={{ duration: 0.4, ease: "backOut" }}
    className="absolute inset-0 z-[60] flex items-center justify-center bg-black/80 backdrop-blur-[2px]"
  >
    <div className="flex flex-col items-center gap-2 border-y-2 border-primary-green bg-primary-green/10 w-full py-4 relative overflow-hidden">
      <motion.div 
        className="absolute top-0 left-0 w-full h-full bg-gradient-to-b from-transparent via-primary-green/20 to-transparent"
        animate={{ top: ["-100%", "100%"] }}
        transition={{ duration: 1.5, ease: "linear", repeat: Infinity }}
      />
      <div className="relative z-10 flex items-center gap-3">
        <motion.div
          initial={{ rotate: -180, scale: 0 }}
          animate={{ rotate: 0, scale: 1 }}
          transition={{ type: "spring", stiffness: 200, delay: 0.1 }}
        >
            <Power className="text-primary-green w-8 h-8 md:w-10 md:h-10" />
        </motion.div>
        <div className="flex flex-col">
            <motion.span 
                initial={{ x: 20, opacity: 0 }}
                animate={{ x: 0, opacity: 1 }}
                transition={{ delay: 0.2 }}
                className="text-2xl md:text-3xl font-header font-black text-primary-green tracking-widest italic"
            >
                SYSTEM
            </motion.span>
            <motion.span 
                initial={{ x: -20, opacity: 0 }}
                animate={{ x: 0, opacity: 1 }}
                transition={{ delay: 0.3 }}
                className="text-xs md:text-sm font-mono font-bold text-primary-green-dim tracking-[0.3em]"
            >
                RESTORED
            </motion.span>
        </div>
      </div>
    </div>
  </motion.div>
);


=====================================
FILE: ./src/ui/molecules/panel/IntelligentHeader.tsx
=====================================
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useGameStore } from '@/game/store/useGameStore';
import { Skull, Zap, Power, RefreshCw, AlertTriangle, Check } from 'lucide-react';
import { clsx } from 'clsx';
import { AudioSystem } from '@/core/audio/AudioSystem';

interface IntelligentHeaderProps {
  title: string;
  health: number;
  maxHealth?: number; // NEW PROP
  isDestroyed: boolean;
  isGameOver: boolean;
  gameId?: string;
}

export const IntelligentHeader = ({ 
  title, 
  health, 
  maxHealth = 1000, // Default for desktop panels
  isDestroyed, 
  isGameOver, 
  gameId 
}: IntelligentHeaderProps) => {
  const interactionTarget = useGameStore(state => state.interactionTarget);
  const isInteracting = gameId && interactionTarget === gameId;
  
  // Calculate percentage dynamically based on the passed maxHealth
  let rawPercent = (health / maxHealth) * 100;
  if (!Number.isFinite(rawPercent) || isNaN(rawPercent)) rawPercent = 0;
  
  // Clamp: Don't show > 100% visual overflow if overhealed
  const healthPercent = Math.max(0, Math.min(100, rawPercent));

  const isDamaged = !isDestroyed && healthPercent < 100;

  const [showOptimal, setShowOptimal] = useState(false);

  useEffect(() => {
    if (health < maxHealth) {
      setShowOptimal(true);
    }
    // Only play sound if we just healed to full
    if (health >= maxHealth && showOptimal) {
      AudioSystem.playSound('ui_optimal'); 
      const timer = setTimeout(() => setShowOptimal(false), 1500);
      return () => clearTimeout(timer);
    }
  }, [health, showOptimal, maxHealth]);

  let mainColor = "text-primary-green";
  let statusText = "SECURE";
  
  if (isGameOver) {
      mainColor = "text-critical-red";
      statusText = "SYSTEM_FAILURE";
  } else if (isDestroyed) {
      mainColor = isInteracting ? "text-latent-purple" : "text-critical-red";
      statusText = isInteracting ? "REBOOTING..." : "OFFLINE";
  } else if (isInteracting && isDamaged) {
      mainColor = "text-service-cyan";
      statusText = "HEALING...";
  } else if (isDamaged) {
      mainColor = "text-alert-yellow"; 
      statusText = "ATTENTION_REQ";
  } else if (!showOptimal) {
      mainColor = "text-primary-green-dim";
      statusText = "ONLINE";
  }

  return (
    <div className={clsx(
        "relative flex flex-col border-b transition-colors duration-300 shrink-0 z-10",
        isGameOver ? "bg-critical-red/10 border-critical-red/50" :
        isDestroyed ? (isInteracting ? "bg-latent-purple/10 border-latent-purple/50" : "bg-critical-red/10 border-critical-red/50") :
        (isInteracting && isDamaged) ? "bg-service-cyan/10 border-service-cyan/50" :
        isDamaged ? "bg-alert-yellow/10 border-alert-yellow/30" : 
        "bg-primary-green/5 border-primary-green-dim/30"
    )}>
        <div className="flex items-center justify-between px-3 py-1.5 h-8">
            <div className="flex items-baseline gap-2">
                <span className={clsx("text-sm md:text-base font-header font-bold uppercase tracking-wider drop-shadow-md transition-colors duration-300", mainColor)}>
                    {title}
                </span>
                <span className={clsx("text-[8px] font-mono tracking-widest opacity-80", mainColor)}>
                    [{statusText}]
                </span>
            </div>

            <div className="w-5 h-5 flex items-center justify-center">
                <AnimatePresence mode="wait">
                    {isGameOver ? (
                        <motion.div 
                            key="gameover"
                            initial={{ scale: 0, rotate: -90 }}
                            animate={{ scale: 1, rotate: 0 }}
                            className="text-critical-red drop-shadow-[0_0_8px_currentColor]"
                        >
                            <Skull size={16} />
                        </motion.div>
                    ) : isDestroyed ? (
                        isInteracting ? (
                            <motion.div 
                                key="rebooting"
                                initial={{ scale: 0 }}
                                animate={{ scale: 1 }}
                                className="w-4 h-4 bg-latent-purple rounded-full flex items-center justify-center shadow-[0_0_10px_currentColor]"
                            >
                                <motion.div animate={{ rotate: 360, opacity: [0.6, 1, 0.6] }} transition={{ duration: 0.5, repeat: Infinity }}>
                                    <Zap size={10} className="text-black fill-current" />
                                </motion.div>
                            </motion.div>
                        ) : (
                            <motion.div 
                                key="destroyed"
                                initial={{ scale: 0 }}
                                animate={{ scale: 1 }}
                                className="w-4 h-4 border border-latent-purple rounded-full flex items-center justify-center opacity-80"
                            >
                                <Power size={10} className="text-latent-purple" />
                            </motion.div>
                        )
                    ) : isInteracting && isDamaged ? (
                        <motion.div 
                            key="healing"
                            initial={{ scale: 0 }}
                            animate={{ scale: 1 }}
                            className="w-4 h-4 bg-service-cyan rounded-full flex items-center justify-center shadow-[0_0_10px_currentColor]"
                        >
                            <motion.div animate={{ rotate: 360 }} transition={{ duration: 1, repeat: Infinity, ease: "linear" }}>
                                <RefreshCw size={10} className="text-black" />
                            </motion.div>
                        </motion.div>
                    ) : isDamaged ? (
                        <motion.div 
                            key="damaged"
                            initial={{ opacity: 1, scale: 1 }}
                            animate={{ 
                                x: [-2, 2, -2, 2, -2, 2, 0, 0, 0, 0, 0, 0, 0], 
                                filter: [
                                    'drop-shadow(0 0 0px rgba(234,231,71,0))',
                                    'drop-shadow(0 0 8px rgba(234,231,71,1))', 
                                    'drop-shadow(0 0 0px rgba(234,231,71,0))'
                                ]
                            }}
                            transition={{ duration: 1.5, repeat: Infinity, ease: "linear" }}
                            className="text-alert-yellow"
                        >
                            <AlertTriangle size={16} />
                        </motion.div>
                    ) : showOptimal ? (
                        <motion.div 
                            key="optimal"
                            initial={{ scale: 0 }}
                            animate={{ scale: 1 }}
                            exit={{ scale: 0, opacity: 0 }}
                            className="w-4 h-4 bg-primary-green rounded-full flex items-center justify-center shadow-[0_0_5px_currentColor]"
                        >
                            <Check size={10} className="text-black stroke-[3px]" />
                        </motion.div>
                    ) : null}
                </AnimatePresence>
            </div>
        </div>

        {!isGameOver && (
            <div className="w-full h-1 bg-black/50 relative overflow-hidden">
                <motion.div 
                    className={clsx(
                        "h-full transition-colors duration-200",
                        (isDestroyed && isInteracting) ? "bg-latent-purple shadow-[0_0_10px_#9E4EA5]" :
                        isDestroyed ? "bg-transparent" : 
                        (isInteracting && isDamaged) ? "bg-service-cyan" :
                        isDamaged ? "bg-alert-yellow" : 
                        "bg-primary-green"
                    )}
                    initial={{ width: "100%" }}
                    animate={{ width: `${healthPercent}%` }}
                    transition={{ type: "tween", ease: "easeOut", duration: 0.3 }}
                />
            </div>
        )}
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/HoloCommLog.tsx
=====================================
import { useEffect, useState, useRef, useCallback } from 'react';
import { ExternalLink, Radio, WifiOff, BatteryWarning } from 'lucide-react';
import { useGameStore } from '@/game/store/useGameStore';
import { useStore } from '@/core/store/useStore';
import { AudioSystem } from '@/core/audio/AudioSystem';

const VIDEO_POOL = [
  "oLALHbB3iXU", "A1dnxXrpN-o", "elyXcwunIYA", 
  "bHUcvHx9zlA", "Eq6EYcpWB_c", "sJyWgks1ZtA", 
  "dFlDRhvM4L0", "Ku5fgOHy1JY", "8-91y7BJ8QA"
];

const OfflineStatic = () => (
  <div className="absolute inset-0 z-[50] bg-black flex flex-col items-center justify-center border border-critical-red/20 overflow-hidden w-full h-full">
    <div className="absolute inset-0 bg-[url('https://media.giphy.com/media/oEI9uBYSzLpBK/giphy.gif')] opacity-40 bg-cover mix-blend-screen pointer-events-none" />
    <div className="relative z-10 animate-pulse text-critical-red font-mono text-[10px] bg-black/80 px-2 py-1 flex items-center gap-2">
        <WifiOff size={12} />
        <span>SIGNAL_LOST</span>
    </div>
  </div>
);

const PowerSaveStatic = () => (
  <div className="absolute inset-0 z-[50] bg-black flex flex-col items-center justify-center border border-alert-yellow/20 overflow-hidden w-full h-full">
    <div className="absolute inset-0 bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.25)_50%)] bg-[length:100%_4px] pointer-events-none" />
    
    <div className="relative z-10 flex flex-col items-center gap-2 text-alert-yellow opacity-80">
        <BatteryWarning size={24} />
        <span className="font-header font-bold text-xs tracking-widest">POWER_SAVE_MODE</span>
        <span className="font-mono text-[9px] opacity-60">VIDEO_FEED_DISABLED</span>
    </div>
  </div>
);

const VideoSlot = ({ 
  slotIndex, 
  initialVideo, 
  getNextVideo
}: { 
  slotIndex: number, 
  initialVideo: string, 
  getNextVideo: () => string
}) => {
  const [videoId, setVideoId] = useState(initialVideo);
  const [isMasked, setIsMasked] = useState(true); 

  const panelState = useGameStore((state) => state.panels['video']);
  const isOffline = panelState ? (panelState.isDestroyed || panelState.health <= 0) : false;
  
  const graphicsMode = useStore((state) => state.graphicsMode);
  const bootState = useStore((state) => state.bootState); // CHECK BOOT STATE
  const isPotato = graphicsMode === 'POTATO';
  
  // Disable video if not active game or potato mode
  const showVideo = bootState === 'active' && !isPotato;

  const prevOffline = useRef(isOffline);

  useEffect(() => {
    if (isOffline && !prevOffline.current) {
        setIsMasked(true); 
    }
    
    if (!isOffline && prevOffline.current) {
        setVideoId(getNextVideo()); 
        setIsMasked(true); 
        
        const t = setTimeout(() => setIsMasked(false), 2000);
        
        prevOffline.current = isOffline;
        return () => clearTimeout(t);
    }

    if (!isOffline && isMasked) {
         const t = setTimeout(() => setIsMasked(false), 2000);
         return () => clearTimeout(t);
    }
    
    prevOffline.current = isOffline;
  }, [isOffline, getNextVideo]);

  useEffect(() => {
    if (isOffline) return; 
    if (!showVideo) return;

    const duration = 30000 + (Math.random() * 15000);
    
    const rotateTimer = setTimeout(() => {
      setIsMasked(true);
      
      const swapTimer = setTimeout(() => {
        setVideoId(getNextVideo());
        
        const unmaskTimer = setTimeout(() => {
            setIsMasked(false);
        }, 2000);
        
        return () => clearTimeout(unmaskTimer);
      }, 1000); 
      
      return () => clearTimeout(swapTimer);
    }, duration);

    return () => clearTimeout(rotateTimer);
  }, [videoId, isOffline, getNextVideo, showVideo]);

  return (
    <div 
        className="relative w-full aspect-video min-h-[140px] md:min-h-0 border border-primary-green-dim/30 bg-black overflow-hidden group/video hover:border-alert-yellow hover:shadow-[0_0_15px_rgba(234,231,71,0.3)] transition-all"
        onMouseEnter={() => !isOffline && AudioSystem.playHover()}
    >
      
      {isOffline ? (
          <OfflineStatic />
      ) : !showVideo ? (
          <PowerSaveStatic />
      ) : (
        <>
          <div className="absolute inset-0 z-10">
            <iframe 
              key={videoId} 
              width="100%" 
              height="100%" 
              src={`https://www.youtube.com/embed/${videoId}?autoplay=1&mute=1&controls=0&showinfo=0&modestbranding=1&loop=1&playlist=${videoId}&vq=small`} 
              title="HOLO_COMM" 
              frameBorder="0" 
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
              className="w-full h-full object-cover grayscale"
            />
          </div>

          <div className="absolute inset-0 z-30 pointer-events-none bg-[linear-gradient(rgba(0,0,0,0)_50%,rgba(0,0,0,0.25)_50%)] bg-[length:100%_4px]" />
          
          <div className={`absolute inset-0 z-40 transition-opacity duration-500 flex items-center justify-center pointer-events-none ${isMasked ? 'opacity-100 bg-black' : 'opacity-0 group-hover/video:opacity-100 bg-black/40'}`}>
             {isMasked ? (
                <div className="flex flex-col items-center">
                    <Radio className="text-primary-green animate-pulse w-6 h-6 mb-2" />
                    <span className="text-[10px] font-mono text-primary-green animate-pulse">ESTABLISHING_UPLINK...</span>
                </div>
             ) : (
                 <div className="flex items-center gap-2 text-alert-yellow font-mono font-bold bg-black/80 px-3 py-1 border border-alert-yellow rounded-sm pointer-events-auto">
                    <span>OPEN_SOURCE</span>
                    <ExternalLink size={12} />
                 </div>
             )}
          </div>
          
          <a 
            href={`https://www.youtube.com/watch?v=${videoId}`}
            target="_blank"
            rel="noopener noreferrer"
            className="absolute inset-0 z-50 cursor-pointer"
            aria-label="Watch on YouTube"
            onClick={() => AudioSystem.playClick()}
          />

          <div className="absolute bottom-1 right-1 z-[60] text-[8px] text-primary-green font-mono bg-black/80 px-1 pointer-events-none group-hover/video:text-alert-yellow transition-colors">
             CAM_0{slotIndex + 1}
          </div>
        </>
      )}
      
      {isOffline && (
          <div className="absolute bottom-1 right-1 z-[60] text-[8px] text-critical-red font-mono bg-black/80 px-1 pointer-events-none">
             CAM_0{slotIndex + 1} [ERR]
          </div>
      )}
    </div>
  );
};

export const HoloCommLog = () => {
  const deckRef = useRef<string[]>([...VIDEO_POOL]);
  const [initialVideos, setInitialVideos] = useState<string[] | null>(null);

  useEffect(() => {
    deckRef.current = [...VIDEO_POOL];
    const init: string[] = [];
    for(let i=0; i<3; i++) {
      const randomIndex = Math.floor(Math.random() * deckRef.current.length);
      const vid = deckRef.current[randomIndex];
      deckRef.current.splice(randomIndex, 1);
      init.push(vid);
    }
    setInitialVideos(init);
  }, []);

  const getNextVideo = useCallback(() => {
    if (deckRef.current.length === 0) deckRef.current = [...VIDEO_POOL];
    const randomIndex = Math.floor(Math.random() * deckRef.current.length);
    const selected = deckRef.current[randomIndex];
    deckRef.current.splice(randomIndex, 1);
    return selected || VIDEO_POOL[0];
  }, []);

  if (!initialVideos) return <div className="h-full bg-black" />;

  return (
    <div className="flex flex-col gap-2 p-1">
      {initialVideos.map((vid, i) => (
        <VideoSlot 
          key={i} 
          slotIndex={i} 
          initialVideo={vid} 
          getNextVideo={getNextVideo}
        />
      ))}
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/SystemOps.tsx
=====================================
import { useGameStore } from '@/game/store/useGameStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { Unplug, Biohazard, CircleDotDashed, AlertTriangle } from 'lucide-react';
import { UpgradeOption } from '@/game/types/game.types';

const SYSTEM_OPS: UpgradeOption[] = ['REPAIR_NANITES', 'RESTORE', 'PURGE'];

const OP_INFO: Record<string, { label: string, desc: string, icon: any }> = {
  'PURGE': { label: 'Purge', desc: 'Nuke Screen', icon: Biohazard },
  'RESTORE': { label: 'Restore', desc: 'Heal System', icon: CircleDotDashed },
  'REPAIR_NANITES': { label: 'Repair', desc: 'Heal Self', icon: Unplug }
};

interface SystemOpsProps {
  isPanelDead: boolean;
}

export const SystemOps = ({ isPanelDead }: SystemOpsProps) => {
  const upgradePoints = useGameStore(s => s.upgradePoints);
  const selectUpgrade = useGameStore(s => s.selectUpgrade);

  const handleUpgrade = (u: UpgradeOption) => {
      if (isPanelDead || upgradePoints <= 0) return; 
      AudioSystem.playClick();
      selectUpgrade(u);
  };

  if (upgradePoints <= 0) return null;

  return (
    <div className="flex flex-col gap-1.5 mt-4">
        <span className="text-[8px] font-bold text-alert-yellow/50 uppercase tracking-widest px-1">System_Ops</span>
        {SYSTEM_OPS.map(u => {
            const info = OP_INFO[u];
            const Icon = info.icon;
            
            return (
                <button
                    key={u}
                    onClick={() => handleUpgrade(u)}
                    onMouseEnter={() => !isPanelDead && AudioSystem.playHover()}
                    className="group relative flex items-center justify-between p-2 border border-alert-yellow/30 bg-alert-yellow/5 hover:border-alert-yellow transition-all duration-200 overflow-hidden"
                >
                    <div className="absolute inset-0 translate-x-[-100%] group-hover:translate-x-0 transition-transform duration-300 ease-out bg-alert-yellow opacity-20" />
                    
                    <div className="flex items-center gap-3 relative z-10">
                        <div className="p-1.5 rounded-sm bg-alert-yellow/10 text-alert-yellow group-hover:bg-alert-yellow group-hover:text-black">
                            <Icon size={14} />
                        </div>
                        <div className="flex flex-col items-start">
                            <span className="text-[10px] font-bold font-header tracking-wider uppercase text-alert-yellow">
                                {info.label}
                            </span>
                            <span className="text-[8px] text-gray-400 font-mono group-hover:text-white">
                                {info.desc}
                            </span>
                        </div>
                    </div>
                    
                    <AlertTriangle size={12} className="text-alert-yellow/50 group-hover:text-alert-yellow" />
                </button>
            );
        })}
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/UpgradeTerminal.tsx
=====================================
import { useGameStore } from '@/game/store/useGameStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { Zap, Swords, Wifi, GitFork, Gitlab, DoorOpen, Bot, ArrowUpCircle } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { UpgradeOption } from '@/game/types/game.types';

const CORE_UPGRADES: UpgradeOption[] = ['OVERCLOCK', 'EXECUTE', 'BANDWIDTH', 'FORK', 'SNIFFER', 'BACKDOOR', 'DAEMON'];

const UPGRADE_INFO: Record<string, { label: string, desc: string, icon: any }> = {
  'OVERCLOCK': { label: 'Overclock', desc: 'Fire Rate ++', icon: Zap },
  'EXECUTE': { label: 'Execute', desc: 'Damage ++', icon: Swords },
  'BANDWIDTH': { label: 'Bandwidth', desc: 'Size ++', icon: Wifi },
  'FORK': { label: 'Fork', desc: 'Multishot ++', icon: GitFork }, 
  'SNIFFER': { label: 'Sniffer', desc: 'Homing', icon: Gitlab }, 
  'BACKDOOR': { label: 'Backdoor', desc: 'Rear Guard', icon: DoorOpen }, 
  'DAEMON': { label: 'Daemon', desc: 'Summon Ally', icon: Bot },
};

interface UpgradeTerminalProps {
  isPanelDead: boolean;
}

export const UpgradeTerminal = ({ isPanelDead }: UpgradeTerminalProps) => {
  // Granular Selectors
  const upgradePoints = useGameStore(s => s.upgradePoints);
  const activeUpgrades = useGameStore(s => s.activeUpgrades);
  const selectUpgrade = useGameStore(s => s.selectUpgrade);

  const handleUpgrade = (u: UpgradeOption) => {
      if (isPanelDead || upgradePoints <= 0) return; 
      AudioSystem.playClick();
      selectUpgrade(u);
  };

  return (
    <AnimatePresence mode="wait">
      {upgradePoints > 0 ? (
        <motion.div 
            key="upgrades"
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            className="flex flex-col gap-4"
        >
            <div className="flex items-center gap-2 pb-1 border-b border-primary-green/20 pt-2">
                <ArrowUpCircle size={12} className="text-primary-green animate-bounce" />
                <span className="text-[9px] font-bold text-primary-green tracking-widest">
                    SYSTEM_UPGRADE_AVAILABLE [{upgradePoints}]
                </span>
            </div>

            <div className="flex flex-col gap-1.5">
                <span className="text-[8px] font-bold text-primary-green-dim/50 uppercase tracking-widest px-1">Kernel_Modules</span>
                {CORE_UPGRADES.map(u => {
                    const info = UPGRADE_INFO[u];
                    const Icon = info.icon;
                    const currentLvl = activeUpgrades[u] || 0;

                    return (
                        <button
                            key={u}
                            onClick={() => handleUpgrade(u)}
                            onMouseEnter={() => !isPanelDead && AudioSystem.playHover()}
                            className="group relative flex items-center justify-between p-2 border border-primary-green-dim/30 bg-black/40 hover:border-primary-green transition-all duration-200 overflow-hidden"
                        >
                            <div className="absolute inset-0 translate-x-[-100%] group-hover:translate-x-0 transition-transform duration-300 ease-out bg-primary-green opacity-20" />
                            
                            <div className="flex items-center gap-3 relative z-10">
                                <div className="p-1.5 rounded-sm bg-primary-green/10 text-primary-green group-hover:bg-primary-green group-hover:text-black">
                                    <Icon size={14} />
                                </div>
                                <div className="flex flex-col items-start">
                                    <span className="text-[10px] font-bold font-header tracking-wider uppercase text-primary-green">
                                        {info.label}
                                    </span>
                                    <span className="text-[8px] text-gray-400 font-mono group-hover:text-white">
                                        {info.desc}
                                    </span>
                                </div>
                            </div>

                            <div className="text-[9px] font-mono text-primary-green-dim border border-primary-green-dim/30 px-1.5 py-0.5 rounded bg-black/50 group-hover:border-primary-green group-hover:text-primary-green relative z-10">
                                v{currentLvl}
                            </div>
                        </button>
                    );
                })}
            </div>
        </motion.div>
      ) : (
        <motion.div 
            key="status"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            className="h-full flex flex-col justify-center items-center text-center opacity-40 font-mono space-y-2 p-4 rounded bg-black/20 marching-ants [--ant-color:rgba(255,255,255,0.1)]"
        >
            <div className="w-8 h-8 rounded-full border border-white/20 flex items-center justify-center animate-spin-slow">
                <div className="w-1 h-1 bg-white/50 rounded-full" />
            </div>
            <span className="text-[9px] tracking-widest">SYSTEM_OPTIMIZED</span>
            <span className="text-[8px]">WAITING FOR DATA...</span>
        </motion.div>
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/molecules/LiveArtGrid.tsx
=====================================
import { useEffect, useState } from 'react';
import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { motion, AnimatePresence } from 'framer-motion';
import { clsx } from 'clsx';

const randomId = () => Math.floor(Math.random() * 899) + 100;

export const LiveArtGrid = () => {
  const { openModal } = useStore();
  const [slots, setSlots] = useState<number[]>([]);
  
  const panelState = useGameStore((state) => state.panels['art']);
  const isDestroyed = panelState ? panelState.isDestroyed : false;

  useEffect(() => {
    setSlots(Array.from({ length: 12 }, randomId));

    const interval = setInterval(() => {
      setSlots(prev => {
        const newSlots = [...prev];
        const randomIndex = Math.floor(Math.random() * 12);
        newSlots[randomIndex] = randomId();
        return newSlots;
      });
    }, 800);

    return () => clearInterval(interval);
  }, []);

  return (
    <div className={clsx(
        "grid grid-cols-3 gap-1 w-full p-2 content-start transition-opacity duration-500",
        isDestroyed ? "pointer-events-none opacity-80" : ""
    )}>
      <AnimatePresence mode='popLayout'>
        {slots.map((id, index) => {
            const isCorrupt = isDestroyed;
            
            return (
              <motion.button
                key={`${index}-${id}`}
                layout
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                transition={{ duration: 0.2 }}
                
                onClick={() => {
                    if (isDestroyed) return;
                    AudioSystem.playClick();
                    openModal('gallery');
                }}
                onMouseEnter={() => !isDestroyed && AudioSystem.playHover()}
                
                className={clsx(
                    "w-full aspect-square relative border group overflow-hidden flex items-center justify-center rounded-[1px] transition-colors",
                    isCorrupt 
                        ? "bg-black border-critical-red/20" 
                        : "bg-black/50 border-primary-green-dim/30 hover:border-alert-yellow hover:shadow-[0_0_10px_rgba(247,210,119,0.2)]"
                )}
              >
                <div className={clsx(
                    "absolute inset-0 transition-colors",
                    isCorrupt ? "bg-critical-red/5" : "bg-primary-green/5 group-hover:bg-primary-green/10"
                )} />
                
                <span className={clsx(
                    "relative z-10 text-[9px] font-mono transition-colors",
                    isCorrupt ? "text-critical-red/50 animate-pulse" : "text-primary-green-dim group-hover:text-alert-yellow"
                )}>
                  {isCorrupt ? (Math.random() > 0.5 ? "0x00" : "ERR") : `IMG_${id}`}
                </span>

                {!isCorrupt && (
                    <div className="absolute top-0 right-0 w-1.5 h-1.5 border-t border-r border-primary-green-dim/50 group-hover:border-alert-yellow" />
                )}
              </motion.button>
            );
        })}
      </AnimatePresence>
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/IdentityFooter.tsx
=====================================
import { useStore } from '@/core/store/useStore';
import { AudioSystem } from '@/core/audio/AudioSystem';

interface IdentityFooterProps {
  isPanelDead: boolean;
}

export const IdentityFooter = ({ isPanelDead }: IdentityFooterProps) => {
  const { openModal } = useStore();

  const handleClick = (modal: 'about' | 'contact') => {
      if (isPanelDead) return;
      AudioSystem.playClick();
      openModal(modal);
  };

  return (
    <div className="flex-none grid grid-cols-2 gap-px bg-primary-green-dim/20 border-t border-primary-green-dim/30 mt-auto">
      <button 
        onClick={() => handleClick('about')} 
        onMouseEnter={() => !isPanelDead && AudioSystem.playHover()}
        className="py-3 bg-black/80 hover:bg-primary-green hover:text-black text-primary-green text-[10px] font-bold font-header uppercase transition-colors tracking-widest"
      >
        About_Me
      </button>
      <button 
        onClick={() => handleClick('contact')} 
        onMouseEnter={() => !isPanelDead && AudioSystem.playHover()}
        className="py-3 bg-black/80 hover:bg-alert-yellow hover:text-black text-alert-yellow text-[10px] font-bold font-header uppercase transition-colors tracking-widest"
      >
        Contact_Link
      </button>
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/IdentityHUD.tsx
=====================================
import { useGameStore } from '@/game/store/useGameStore';
import identity from '@/data/identity.json';
import { clsx } from 'clsx';

// Sub-components
import { VitalsRing } from '../atoms/VitalsRing';
import { UpgradeTerminal } from './UpgradeTerminal';
import { SystemOps } from './SystemOps';
import { IdentityFooter } from './IdentityFooter';

export const IdentityHUD = () => {
  
  // -- Vitals State (Heavy Updates) --
  const hp = useGameStore(s => s.playerHealth);
  const maxHp = useGameStore(s => s.maxPlayerHealth);
  const xp = useGameStore(s => s.xp);
  const nextXp = useGameStore(s => s.xpToNextLevel);
  const level = useGameStore(s => s.level);
  const rebootProgress = useGameStore(s => s.playerRebootProgress);
  
  // -- Panel State --
  const panel = useGameStore(s => s.panels['identity']);
  const isPanelDead = panel ? panel.isDestroyed : false;
  const isPlayerDead = hp <= 0;

  return (
    <div className={clsx(
        "flex flex-col h-full w-full relative overflow-hidden", 
        isPanelDead ? 'grayscale opacity-50 pointer-events-none' : ''
    )}>
      
      {/* TOP SECTION: Avatar & Stats */}
      <div className="flex-none flex flex-col items-center pt-4 relative z-10">
        
        {/* Vitals Ring (Atomic Component) */}
        <VitalsRing 
            health={hp}
            maxHealth={maxHp}
            xp={xp}
            xpToNext={nextXp}
            level={level}
            isDead={isPlayerDead}
            rebootProgress={rebootProgress}
        />

        {/* Identity Info */}
        <div className="text-center z-20 mb-2">
            <h2 className="text-xl font-header font-black text-primary-green tracking-wider drop-shadow-md">
                {identity.name}
            </h2>
            <div className="text-[8px] text-latent-purple-light uppercase tracking-[0.2em] opacity-80 bg-black/60 px-2 py-0.5 rounded-full border border-latent-purple/20">
                {identity.class}
            </div>
        </div>
      </div>

      {/* MIDDLE SECTION: Upgrade Terminal */}
      <div className="flex-1 min-h-0 w-full px-4 overflow-y-auto scrollbar-hide relative pb-4">
         {/* We pass isPanelDead/isPlayerDead to disable interaction inside */}
         {/* UpgradeTerminal handles its own subscriptions to points/upgrades */}
         <div className={isPlayerDead ? "opacity-50 pointer-events-none" : ""}>
             <UpgradeTerminal isPanelDead={isPanelDead} />
             <SystemOps isPanelDead={isPanelDead} />
         </div>
      </div>

      {/* BOTTOM SECTION: Footer Links */}
      <IdentityFooter isPanelDead={isPanelDead} />
    </div>
  );
};


=====================================
FILE: ./src/ui/atoms/SafePanelContent.tsx
=====================================
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { AlertTriangle } from 'lucide-react';

interface Props {
  children: ReactNode;
  fallbackId?: string;
}

interface State {
  hasError: boolean;
  errorMsg: string;
}

export class SafePanelContent extends Component<Props, State> {
  public state: State = {
    hasError: false,
    errorMsg: ''
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, errorMsg: error.message };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error(`[SafePanelContent] Crash in ${this.props.fallbackId}:`, error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return (
        <div className="absolute inset-0 flex flex-col items-center justify-center bg-black/80 z-[100] p-2 text-center border border-critical-red/50">
          <AlertTriangle className="text-critical-red mb-1 animate-pulse" size={24} />
          <span className="text-[10px] text-critical-red font-mono font-bold tracking-widest">
            VISUAL_CORE_ERR
          </span>
          <span className="text-[8px] text-critical-red/60 font-mono mt-1 max-w-[150px] truncate">
            {this.state.errorMsg}
          </span>
        </div>
      );
    }

    return this.props.children;
  }
}


=====================================
FILE: ./src/ui/atoms/ZenBomb.tsx
=====================================
import { motion, AnimatePresence } from 'framer-motion';
import { Bomb, Skull } from 'lucide-react';
import { useGameStore } from '@/game/store/useGameStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { useState } from 'react';

export const ZenBomb = () => {
  const isGameOver = useGameStore(state => state.systemIntegrity <= 0);
  const isZenMode = useGameStore(state => state.isZenMode);
  const activateZenMode = useGameStore(state => state.activateZenMode);
  const [clicked, setClicked] = useState(false);

  if (!isGameOver || isZenMode) return null;

  const handleClick = () => {
    setClicked(true);
    AudioSystem.playClick();
    
    setTimeout(() => {
        activateZenMode();
    }, 800);
  };

  return (
    <AnimatePresence>
      {!clicked && (
        <motion.button
          initial={{ y: -200, opacity: 0 }}
          animate={{ y: 0, opacity: 1 }}
          exit={{ scale: 3, opacity: 0, filter: "blur(20px)" }} 
          transition={{ type: "spring", stiffness: 100, damping: 15, delay: 1.0 }} 
          
          onClick={handleClick}
          // Z-30 is correct (behind Header z-40)
          className="fixed top-24 left-1/2 -translate-x-1/2 z-30 flex flex-col items-center group cursor-pointer"
        >
          {/* CONNECTOR LINE: Increased width and opacity for visibility */}
          <motion.div 
            initial={{ height: 0 }}
            animate={{ height: 160 }} 
            transition={{ delay: 1.0, duration: 0.8, ease: "easeOut" }}
            className="w-[2px] bg-critical-red/80 absolute -top-64 left-1/2 -translate-x-1/2 shadow-[0_0_8px_#FF003C]"
          />

          {/* THE BOMB BUTTON */}
          <div className="relative p-1 border border-critical-red bg-black/90 backdrop-blur-md shadow-[0_0_20px_#FF003C] overflow-hidden group-hover:shadow-[0_0_40px_#FF003C] transition-shadow duration-300 z-10">
             
             <div className="absolute inset-0 opacity-20 pointer-events-none" 
                  style={{ backgroundImage: 'repeating-linear-gradient(45deg, #FF003C 0, #FF003C 5px, transparent 5px, transparent 10px)' }} 
             />

             <div className="relative w-16 h-16 border border-critical-red/50 flex items-center justify-center bg-black hover:bg-critical-red transition-colors duration-300 group-hover:text-black text-critical-red">
                 <motion.div
                   animate={{ rotate: [0, -10, 10, 0] }}
                   transition={{ repeat: Infinity, duration: 0.3, repeatDelay: 2 }} 
                 >
                    <Bomb size={32} strokeWidth={2} />
                 </motion.div>
             </div>
          </div>

          {/* LABEL */}
          <div className="mt-4 flex items-center gap-2 px-3 py-1 bg-critical-red/10 border border-critical-red/50 backdrop-blur-md z-10">
             <Skull size={10} className="text-critical-red animate-pulse" />
             <span className="text-[10px] font-mono font-black text-critical-red tracking-widest uppercase group-hover:text-white transition-colors">
                PURGE_SYSTEM
             </span>
             <Skull size={10} className="text-critical-red animate-pulse" />
          </div>
          
          <span className="text-[8px] text-critical-red/60 font-mono mt-1 opacity-0 group-hover:opacity-100 transition-opacity">
            [ ENABLE_ZEN_MODE ]
          </span>
        </motion.button>
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/atoms/CustomCursor.tsx
=====================================
import { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useStore } from '@/core/store/useStore';
import { clsx } from 'clsx';

export const CustomCursor = () => {
  const [pos, setPos] = useState({ x: 0, y: 0 });
  const [isHovering, setIsHovering] = useState(false);
  const [isClicking, setIsClicking] = useState(false);
  const [isOnScrollbar, setIsOnScrollbar] = useState(false);
  
  const { bootState, activeModal, isDebugOpen } = useStore();
  
  // UPDATED: Treat mobile_lockdown as an active game state for cursor purposes
  const isGameActive = bootState === 'active' || bootState === 'mobile_lockdown';
  const isMenuOpen = activeModal !== 'none' || isDebugOpen;
  
  const showCustomCursor = (!isGameActive || isMenuOpen || bootState === 'mobile_lockdown') && !isOnScrollbar;

  useEffect(() => {
    const move = (e: MouseEvent) => {
      setPos({ x: e.clientX, y: e.clientY });
      
      const target = e.target as HTMLElement;
      const isInteractive = target.closest('button, a, input, label, [data-interactive="true"]');
      setIsHovering(!!isInteractive);

      const isRightEdge = e.clientX >= window.innerWidth - 14;
      const isBottomEdge = e.clientY >= window.innerHeight - 14;
      const onScroll = isRightEdge || isBottomEdge;
      setIsOnScrollbar(onScroll);

      if (onScroll) {
          document.body.style.setProperty('cursor', 'auto', 'important');
      } else {
          // Hide system cursor if we are showing custom one
          // For mobile lockdown, we ALWAYS want to hide system cursor and show ours
          document.body.style.setProperty('cursor', 'none', 'important');
      }
    };

    const down = () => setIsClicking(true);
    const up = () => setIsClicking(false);

    window.addEventListener('mousemove', move);
    window.addEventListener('mousedown', down);
    window.addEventListener('mouseup', up);

    return () => {
      window.removeEventListener('mousemove', move);
      window.removeEventListener('mousedown', down);
      window.removeEventListener('mouseup', up);
      document.body.style.cursor = 'auto'; 
    };
  }, [isGameActive, isMenuOpen]);

  return (
    <>
      <motion.div
        className={clsx(
            "fixed top-0 left-0 pointer-events-none z-[20000]", 
            (isHovering && showCustomCursor) ? "mix-blend-difference" : "" 
        )}
        animate={{ x: pos.x - 5.5, y: pos.y - 3.2 }}
        transition={{ type: "tween", ease: "linear", duration: 0 }}
      >
        <AnimatePresence mode="wait">
          {showCustomCursor && (
            <motion.div
              key="custom-cursor"
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              transition={{ duration: 0.2 }}
              className="relative"
            >
              <svg 
                width="24" 
                height="24" 
                viewBox="0 0 24 24" 
                className={`transition-transform duration-100 ${isClicking ? 'scale-90' : 'scale-100'}`}
                style={{ 
                    filter: isHovering ? 'drop-shadow(0 0 12px #eae747)' : 'drop-shadow(0 0 8px #78F654)',
                    fill: isHovering ? '#eae747' : '#78F654'
                }}
              >
                <path d="M5.5 3.21l12.32 12.32-4.5 1.12 3.5 3.5-2.12 2.12-3.5-3.5-1.12 4.5z" />
              </svg>
            </motion.div>
          )}
        </AnimatePresence>
      </motion.div>
    </>
  );
};


=====================================
FILE: ./src/ui/atoms/VirtualJoystick.tsx
=====================================
import { useState, useRef } from 'react';
import { VirtualJoystickService } from '@/game/inputs/VirtualJoystickService';

export const VirtualJoystick = () => {
  const [active, setActive] = useState(false);
  const [pos, setPos] = useState({ x: 0, y: 0 });
  const stickRef = useRef<HTMLDivElement>(null);
  
  // Configuration
  const MAX_RADIUS = 40;

  const handlePointerDown = (e: React.PointerEvent) => {
    (e.target as HTMLElement).setPointerCapture(e.pointerId);
    setActive(true);
  };

  const handlePointerMove = (e: React.PointerEvent) => {
    if (!active) return;
    
    const rect = stickRef.current?.parentElement?.getBoundingClientRect();
    if (!rect) return;
    
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    const dx = e.clientX - centerX;
    const dy = e.clientY - centerY;
    
    const distance = Math.sqrt(dx*dx + dy*dy);
    const clampedDist = Math.min(distance, MAX_RADIUS);
    
    const angle = Math.atan2(dy, dx);
    const x = Math.cos(angle) * clampedDist;
    const y = Math.sin(angle) * clampedDist;
    
    setPos({ x, y });

    // Normalize and Invert Y for World Space
    const normX = x / MAX_RADIUS;
    const normY = -(y / MAX_RADIUS); 
    
    // Write to Service
    VirtualJoystickService.setVector(normX, normY);
  };

  const handlePointerUp = (e: React.PointerEvent) => {
    setActive(false);
    setPos({ x: 0, y: 0 });
    // Reset Service
    VirtualJoystickService.setVector(0, 0);
  };

  return (
    // UPDATE: Moved to bottom-left (left-8)
    <div className="fixed bottom-8 left-8 w-32 h-32 z-[90] touch-none select-none">
      {/* Base */}
      <div 
        className="w-full h-full rounded-full border-2 border-primary-green/30 bg-black/50 backdrop-blur-sm relative flex items-center justify-center"
        ref={stickRef}
      >
        {/* Stick */}
        <div 
          className="w-12 h-12 rounded-full bg-primary-green/80 shadow-[0_0_15px_#78F654] absolute cursor-pointer transition-transform duration-75 ease-linear"
          style={{ transform: `translate(${pos.x}px, ${pos.y}px)` }}
          onPointerDown={handlePointerDown}
          onPointerMove={handlePointerMove}
          onPointerUp={handlePointerUp}
          onPointerCancel={handlePointerUp}
        />
      </div>
      <div className="absolute -top-6 w-full text-center text-[10px] text-primary-green/50 font-mono tracking-widest">
          [ NAV ]
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/atoms/DotGridBackground.tsx
=====================================
import { clsx } from 'clsx';

interface Props {
  className?: string;
  color?: string; // Optional override
}

export const DotGridBackground = ({ className, color = '#15530A' }: Props) => (
  <div 
    className={clsx("absolute inset-0 pointer-events-none opacity-20 z-0", className)} 
    style={{ 
      backgroundImage: `radial-gradient(${color} 1px, transparent 1px)`, 
      backgroundSize: '8px 8px' 
    }} 
  />
);


=====================================
FILE: ./src/ui/atoms/ActionButton.tsx
=====================================
import { useState } from 'react';
import { motion } from 'framer-motion';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { Crosshair } from 'lucide-react';
import { ServiceLocator } from '@/game/core/ServiceLocator';

export const ActionButton = () => {
  const [pressed, setPressed] = useState(false);

  const handleDown = (e: React.PointerEvent) => {
    e.preventDefault();
    setPressed(true);
    AudioSystem.playClick();
    
    // LOGIC: Simulate a click at the current virtual cursor position
    try {
        const input = ServiceLocator.getInputService();
        const cursor = input.getCursor(); // This is in World Units (0,0 center)
        
        // We need Screen Coordinates for document.elementFromPoint
        // Convert World (0,0) -> Screen (w/2, h/2)
        // Note: ZOOM is 40 in GameOverlay
        const ZOOM = 40;
        const screenX = (cursor.x * ZOOM) + (window.innerWidth / 2);
        // Invert Y: World Y+ is up, Screen Y+ is down
        const screenY = -(cursor.y * ZOOM) + (window.innerHeight / 2);
        
        // Find element at that position
        const el = document.elementFromPoint(screenX, screenY) as HTMLElement;
        
        if (el) {
            // Trigger click
            el.click();
            
            // Visual feedback on the element?
            el.classList.add('active:scale-95');
            setTimeout(() => el.classList.remove('active:scale-95'), 150);
        }
    } catch (err) {
        console.warn("Action Button Failed:", err);
    }
  };

  const handleUp = () => {
    setPressed(false);
  };

  return (
    <div className="fixed bottom-8 right-8 z-[90] touch-none select-none">
      <motion.button
        onPointerDown={handleDown}
        onPointerUp={handleUp}
        onPointerLeave={handleUp}
        animate={{ scale: pressed ? 0.9 : 1.0 }}
        className="w-24 h-24 rounded-full border-2 border-primary-green/50 bg-black/50 backdrop-blur-sm flex items-center justify-center relative group active:border-primary-green active:bg-primary-green/20 transition-colors cursor-pointer"
      >
        {/* Inner Ring */}
        <div className="absolute inset-2 rounded-full border border-primary-green/20" />
        
        {/* Icon */}
        <Crosshair 
            size={32} 
            className={`text-primary-green transition-all duration-100 ${pressed ? 'scale-90 opacity-100' : 'opacity-80'}`} 
        />

        {/* Pulse Effect */}
        {pressed && (
            <motion.div 
                initial={{ scale: 1, opacity: 0.5 }}
                animate={{ scale: 1.5, opacity: 0 }}
                transition={{ duration: 0.3 }}
                className="absolute inset-0 rounded-full bg-primary-green"
            />
        )}
      </motion.button>
      
      <div className="absolute -top-6 w-full text-center text-[10px] text-primary-green/50 font-mono tracking-widest">
          [ ACT ]
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/atoms/GraphicsToggle.tsx
=====================================
import { useStore } from '@/core/store/useStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { Zap, ZapOff } from 'lucide-react';
import { clsx } from 'clsx';

interface Props {
  layout?: 'horizontal' | 'vertical';
}

export const GraphicsToggle = ({ layout = 'horizontal' }: Props) => {
  const { graphicsMode, setGraphicsMode } = useStore();
  const isHigh = graphicsMode === 'HIGH';

  const handleToggle = (mode: 'HIGH' | 'POTATO') => {
    if (graphicsMode === mode) return;
    setGraphicsMode(mode);
    
    if (mode === 'HIGH') {
        AudioSystem.playSound('ui_optimal');
    } else {
        AudioSystem.playSound('ui_error');
    }
  };

  return (
    <div className={clsx("flex gap-2 w-full", layout === 'vertical' ? "flex-col" : "flex-col")}>
      <div className={clsx("grid gap-px bg-white/10 p-px border border-white/20", layout === 'vertical' ? "grid-cols-1" : "grid-cols-2")}>
        
        {/* ENABLED / HIGH */}
        <button
          onClick={() => handleToggle('HIGH')}
          className={clsx(
            "relative group flex items-center justify-center gap-2 transition-all overflow-hidden",
            layout === 'vertical' ? "h-16 w-full" : "h-12",
            isHigh 
              ? "bg-primary-green/20 text-primary-green" 
              : "bg-black/80 text-gray-600 hover:text-gray-400"
          )}
        >
          {isHigh && (
             <div className="absolute inset-0 border border-primary-green shadow-[inset_0_0_15px_rgba(120,246,84,0.3)] animate-pulse" />
          )}
          <Zap size={16} className={isHigh ? "fill-current" : ""} />
          <div className="flex flex-col leading-none items-start">
              <span className="text-[10px] font-black tracking-wider">ENABLED</span>
              <span className="text-[8px] font-mono opacity-70">HIGH_VOLTAGE</span>
          </div>
        </button>

        {/* DISABLED / POTATO */}
        <button
          onClick={() => handleToggle('POTATO')}
          className={clsx(
            "relative group flex items-center justify-center gap-2 transition-all overflow-hidden",
            layout === 'vertical' ? "h-16 w-full" : "h-12",
            !isHigh 
              ? "bg-alert-yellow/20 text-alert-yellow" 
              : "bg-black/80 text-gray-600 hover:text-gray-400"
          )}
        >
          {!isHigh && (
             <div className="absolute inset-0 border border-alert-yellow shadow-[inset_0_0_15px_rgba(247,210,119,0.3)]" />
          )}
          <ZapOff size={16} />
          <div className="flex flex-col leading-none items-start">
              <span className="text-[10px] font-black tracking-wider">DISABLED</span>
              <span className="text-[8px] font-mono opacity-70">POTATO_MODE</span>
          </div>
        </button>

      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/atoms/PanelSparks.tsx
=====================================
import { useEffect, useRef } from 'react';

interface Particle {
  x: number;
  y: number;
  vx: number;
  vy: number;
  life: number;
  maxLife: number;
  size: number;
  color: string;
}

interface PanelSparksProps {
  intensity?: 'normal' | 'extreme'; 
}

export const PanelSparks = ({ intensity }: PanelSparksProps) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || !canvas.parentElement) return;
    
    // Safety check: Don't initialize if container is collapsed
    const width = canvas.parentElement.clientWidth;
    const height = canvas.parentElement.clientHeight;
    
    if (width === 0 || height === 0) return;

    const ctx = canvas.getContext('2d', { alpha: true });
    if (!ctx) return;

    canvas.width = width;
    canvas.height = height;

    let particles: Particle[] = [];
    let animationFrameId: number;
    let isActive = true;

    const COLORS = ['#FF003C', '#CC0020', '#800010', '#FF4466'];
    
    // REVERTED: Back to 500 as requested
    const PARTICLE_COUNT = 500; 
    
    try {
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const edge = Math.floor(Math.random() * 3); 
            let x = 0, y = 0, vx = 0, vy = 0;

            if (edge === 0) { 
                x = Math.random() * width;
                y = 0;
                vx = (Math.random() - 0.5) * 8;
                vy = (Math.random() * 5) + 2; 
            } else if (edge === 1) { 
                x = 0;
                y = Math.random() * (height * 0.5); 
                vx = (Math.random() * 5) + 2; 
                vy = (Math.random() * 5) - 2;
            } else { 
                x = width;
                y = Math.random() * (height * 0.5);
                vx = -((Math.random() * 5) + 2); 
                vy = (Math.random() * 5) - 2;
            }

            particles.push({
                x, y, vx, vy,
                life: 1.0,
                maxLife: 1.0,
                size: Math.random() * 3 + 1,
                color: COLORS[Math.floor(Math.random() * COLORS.length)]
            });
        }
    } catch (e) {
        console.error("Error creating particles", e);
        return;
    }

    const loop = () => {
      if (!isActive) return;
      if (!canvas || canvas.width === 0) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      let activeParticles = false;

      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.15; 
        
        if (p.y > canvas.height) {
          p.y = canvas.height;
          p.vy *= -0.5; 
          p.vx *= 0.7;  
        }
        
        if (p.x < 0 || p.x > canvas.width) {
          p.vx *= -0.6;
          p.x = Math.max(0, Math.min(canvas.width, p.x));
        }

        p.life -= 0.005; 

        if (p.life > 0) {
            activeParticles = true;
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life; 
            ctx.beginPath();
            ctx.rect(p.x, p.y, p.size, p.size);
            ctx.fill();
        } else {
            particles.splice(i, 1);
        }
      }
      
      if (activeParticles) {
          animationFrameId = requestAnimationFrame(loop);
      } else {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    };

    loop();

    return () => {
      isActive = false;
      cancelAnimationFrame(animationFrameId);
    };
  }, [intensity]);

  return (
    <canvas 
      ref={canvasRef} 
      className="absolute inset-0 pointer-events-none z-0 mix-blend-screen"
    />
  );
};


=====================================
FILE: ./src/ui/atoms/GlassPanel.tsx
=====================================
import { clsx } from 'clsx';
import { motion, AnimatePresence, useAnimation } from 'framer-motion';
import { ReactNode, useEffect as useReactEffect, useState as useReactState, useRef as useReactRef } from 'react';
import { usePanelRegistry } from '@/game/hooks/usePanelRegistry';
import { useGameStore } from '@/game/store/useGameStore';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';
import { Skull } from 'lucide-react';
import { PanelSparks } from './PanelSparks';
import { useHeartbeat } from '@/game/hooks/useHeartbeat';

import { RebootOverlay } from '@/ui/molecules/panel/RebootOverlay';
import { IntelligentHeader } from '@/ui/molecules/panel/IntelligentHeader';
import { BreachOverlay } from '@/ui/molecules/panel/BreachOverlay';
import { SafePanelContent } from './SafePanelContent';
import { DotGridBackground } from './DotGridBackground';

const DEFAULT_MAX_HEALTH = 1000;

const panelVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { 
    opacity: 1, 
    y: 0,
    transition: { duration: 0.5, ease: "easeOut" }
  },
  shattered: (custom: number) => ({
    y: 350 + (custom * 50),
    opacity: 0.8,
    rotate: custom * 15,
    transition: { 
        duration: 1.5, 
        ease: "anticipate",
        delay: Math.abs(custom) * 0.1 
    }
  })
};

const pulseVariants = {
    heartbeat: {
        opacity: [0, 0.6, 0],
        scale: [1, 1.005, 1], 
        transition: { 
            duration: 0.8, 
            times: [0, 0.04, 1], 
            ease: "easeOut" 
        }
    }
};

interface GlassPanelProps {
  children: ReactNode;
  className?: string;
  title?: string;
  gameId?: string;
  maxHealth?: number; // NEW PROP
}

export const GlassPanel = ({ 
  children, 
  className, 
  title, 
  gameId, 
  maxHealth = DEFAULT_MAX_HEALTH 
}: GlassPanelProps) => {
  const registryRef = gameId ? usePanelRegistry(gameId) : null;
  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const interactionTarget = useGameStore(state => state.interactionTarget);
  const isInteracting = gameId && interactionTarget === gameId;

  const isGameOver = Math.floor(systemIntegrity) <= 0;
  const isCriticalGlobal = systemIntegrity < 30 && !isGameOver;

  const panelState = useGameStore((state) => gameId ? state.panels[gameId] : null);
  
  const health = panelState ? panelState.health : maxHealth;
  const isDestroyed = panelState ? panelState.isDestroyed : false;
  
  // Calculate percent using the dynamic maxHealth
  let rawPercent = (health / maxHealth) * 100;
  if (!Number.isFinite(rawPercent) || isNaN(rawPercent)) rawPercent = 0;
  const healthPercent = Math.max(0, Math.min(100, rawPercent));
  
  const isDamaged = !isDestroyed && health < maxHealth;

  const [showReboot, setShowReboot] = useReactState(false);
  const prevDestroyed = useReactRef(isDestroyed);
  
  const shakeControls = useAnimation();
  const heartbeatControls = useHeartbeat(); 

  const randSeed = (title?.length || 5) % 2 === 0 ? 1 : -1;

  useReactEffect(() => {
      if (isGameOver) {
          shakeControls.start("shattered");
      } else {
          shakeControls.start("visible");
      }
  }, [isGameOver, shakeControls]);

  useReactEffect(() => {
    if (prevDestroyed.current && !isDestroyed && !isGameOver) {
        setShowReboot(true);
        const timer = setTimeout(() => setShowReboot(false), 2000); 
        return () => clearTimeout(timer);
    }
    prevDestroyed.current = isDestroyed;
  }, [isDestroyed, isGameOver]);

  useReactEffect(() => {
      if (!gameId) return;
      const unsub = GameEventBus.subscribe(GameEvents.PANEL_DAMAGED, (p) => {
          if (p.id === gameId) {
              shakeControls.start({
                  x: [0, -5, 5, -5, 5, 0],
                  transition: { duration: 0.1 }
              });
          }
      });
      return unsub;
  }, [gameId, shakeControls]);

  let borderColor = "border-primary-green-dim/30";
  if (isDestroyed) {
      borderColor = isInteracting 
        ? "border-latent-purple shadow-[0_0_10px_#9E4EA5]" 
        : "border-critical-red animate-pulse"; 
  }
  else if (isInteracting && isDamaged) borderColor = "border-service-cyan shadow-[0_0_10px_#00F0FF]";
  else if (isDamaged) borderColor = "border-alert-yellow/50";

  const bgClass = isDestroyed ? "bg-black/20" : "bg-black";

  return (
    <motion.div 
      ref={registryRef}
      variants={panelVariants}
      initial="hidden"
      animate={shakeControls}
      custom={randSeed}
      className={clsx(
        "relative overflow-hidden flex flex-col group",
        bgClass, 
        "border",
        borderColor, 
        "rounded-sm",
        className
      )}
    >
      <DotGridBackground className="top-8" />

      <div className="absolute inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(10,10,10,0.4)_50%)] z-0 bg-[length:100%_4px]" />
      
      {isCriticalGlobal && (
          <motion.div 
            className="absolute inset-0 pointer-events-none z-50 border-2 border-critical-red/60 shadow-[inset_0_0_30px_#FF003C]"
            animate={heartbeatControls}
            variants={pulseVariants}
            initial={{ opacity: 0 }}
          />
      )}

      {title && (
          <IntelligentHeader 
            title={title} 
            health={health} 
            maxHealth={maxHealth} // PASS DOWN
            isDestroyed={isDestroyed} 
            isGameOver={isGameOver}
            gameId={gameId}
          />
      )}

      <div className="relative z-10 p-4 flex-1 min-h-0 flex flex-col">
        {(isDestroyed || isGameOver) && (
            <SafePanelContent fallbackId={`sparks-${gameId}`}>
                <PanelSparks intensity={isGameOver ? 'extreme' : 'normal'} />
            </SafePanelContent>
        )}

        <div className={clsx("flex-1 min-h-0 flex flex-col relative z-20", isGameOver ? "invisible" : "visible")}>
            {children}
            
            {isDestroyed && !isGameOver && (
                <SafePanelContent fallbackId={`breach-${gameId}`}>
                    <BreachOverlay 
                        progress={healthPercent} 
                        isVideo={gameId === 'video'} 
                        showInteractive={true} 
                    />
                </SafePanelContent>
            )}
        </div>

        <AnimatePresence>
            {showReboot && <RebootOverlay key="reboot" />}
        </AnimatePresence>
        
        {isGameOver && (
            <div className="absolute inset-0 z-[100] flex flex-col items-center justify-center gap-4 bg-transparent pointer-events-none">
                <Skull className="text-critical-red animate-pulse w-20 h-20 drop-shadow-[0_0_15px_rgba(255,0,60,0.8)]" />
                <span className="text-critical-red font-header font-black text-2xl tracking-widest drop-shadow-lg">SYSTEM FAILURE</span>
            </div>
        )}
      </div>
    </motion.div>
  );
};


=====================================
FILE: ./src/ui/atoms/VitalsRing.tsx
=====================================
import { MiniCrystalCanvas } from '@/scene/props/MiniCrystalCanvas';
import { Unplug } from 'lucide-react';
import { clsx } from 'clsx';

interface VitalsRingProps {
  health: number;
  maxHealth: number;
  xp: number;
  xpToNext: number;
  level: number;
  isDead: boolean;
  rebootProgress: number;
}

export const VitalsRing = ({ 
  health, 
  maxHealth, 
  xp, 
  xpToNext, 
  level, 
  isDead, 
  rebootProgress 
}: VitalsRingProps) => {
  
  const hpPercent = Math.max(0, (health / maxHealth) * 100);
  const xpPercent = xpToNext > 0 ? Math.min(100, (xp / xpToNext) * 100) : 0;

  // --- SVG CONFIG ---
  const size = 160; 
  const center = size / 2;
  const radiusHp = 60;
  const radiusXp = 70;
  const stroke = 4;
  
  const circHp = 2 * Math.PI * radiusHp;
  const circXp = 2 * Math.PI * radiusXp;

  const displayHpPercent = isDead ? rebootProgress : hpPercent;
  const displayHpColor = isDead ? "#eae747" : (hpPercent < 30 ? "#FF003C" : "#78F654"); 

  const offsetHp = circHp - (displayHpPercent / 100 * circHp);
  const offsetXp = circXp - (xpPercent / 100 * circXp);

  return (
    <div className="relative w-40 h-40 shrink-0 group mb-1"> 
        
        {/* 3D Canvas */}
        <div className={clsx(
            "absolute inset-0 rounded-full bg-black/50 overflow-hidden transition-opacity duration-500 clip-circle",
            isDead ? "opacity-60 grayscale" : "opacity-100"
        )}>
           <MiniCrystalCanvas />
        </div>

        {/* Status Overlays */}
        {isDead && (
            <div className="absolute inset-0 flex items-center justify-center pointer-events-none z-20">
                {rebootProgress > 0 ? (
                    <div className="flex flex-col items-center">
                        <span className="text-2xl font-header font-black text-alert-yellow drop-shadow-md animate-pulse">
                            {Math.floor(rebootProgress)}%
                        </span>
                        <span className="text-[8px] text-alert-yellow font-mono tracking-widest bg-black/80 px-2 mt-1">REBOOTING</span>
                    </div>
                ) : (
                    <div className="animate-pulse flex flex-col items-center">
                        <Unplug className="text-white/50 w-8 h-8 mb-1" />
                        <span className="text-[8px] text-critical-red font-mono bg-black/80 px-2">SIGNAL_LOST</span>
                    </div>
                )}
            </div>
        )}

        {/* SVG RINGS */}
        <svg className="absolute inset-0 w-full h-full pointer-events-none overflow-visible" viewBox={`0 0 ${size} ${size}`}>
          <circle cx={center} cy={center} r={radiusHp} stroke="#1a1a1a" strokeWidth={stroke} fill="transparent" />
          <circle cx={center} cy={center} r={radiusXp} stroke="#1a1a1a" strokeWidth={stroke} fill="transparent" strokeDasharray="2 4" />
          
          <circle 
            cx={center} cy={center} r={radiusHp} 
            stroke={displayHpColor} 
            strokeWidth={stroke} fill="transparent"
            strokeDasharray={circHp}
            strokeDashoffset={offsetHp}
            strokeLinecap="round"
            transform={`rotate(-90 ${center} ${center})`}
            // UPDATED: duration-300 for snappy decay
            className="transition-all duration-300 ease-out"
          />
          
          <circle 
            cx={center} cy={center} r={radiusXp} 
            stroke="#9E4EA5" 
            strokeWidth={stroke} fill="transparent"
            strokeDasharray={circXp}
            strokeDashoffset={offsetXp}
            strokeLinecap="round"
            transform={`rotate(-90 ${center} ${center})`}
            className="transition-all duration-500 ease-out"
          />

          <defs>
              <path id="levelCurve" d="M 25,80 A 55,55 0 0,0 135,80" /> 
          </defs>
          
          <text fontSize="10" fontFamily="monospace" fontWeight="bold" letterSpacing="3" fill="#9E4EA5" style={{ filter: 'drop-shadow(0 0 2px #9E4EA5)' }}>
              <textPath href="#levelCurve" startOffset="50%" textAnchor="middle" side="right">
                  LVL_{level.toString().padStart(2, '0')}
              </textPath>
          </text>
        </svg>
    </div>
  );
};


=====================================
FILE: ./src/ui/overlays/GlobalBackdrop.tsx
=====================================
import { motion, AnimatePresence } from 'framer-motion';
import { useStore } from '@/core/store/useStore';
import { AudioSystem } from '@/core/audio/AudioSystem';

export const GlobalBackdrop = () => {
  const { activeModal, isDebugOpen, isDebugMinimized, closeModal, toggleDebugMenu } = useStore();

  // Show if any modal is open OR debug is open (but not minimized)
  const isVisible = (activeModal !== 'none') || (isDebugOpen && !isDebugMinimized);

  const handleDismiss = () => {
    AudioSystem.playSound('ui_menu_close');
    if (isDebugOpen) {
        toggleDebugMenu();
    } else {
        closeModal();
    }
  };

  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: 0.3 }}
          onClick={handleDismiss}
          // Z-INDEX 150: Above Game (60) AND Intro (100). Below Modals/Settings (200).
          className="fixed inset-0 z-[150] bg-black/60 backdrop-blur-sm cursor-pointer"
        />
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/overlays/RotationLock.tsx
=====================================
import { useEffect } from 'react';
import { motion } from 'framer-motion';
import { Smartphone, RotateCcw } from 'lucide-react';
import { useStore } from '@/core/store/useStore';

export const RotationLock = () => {
  const { setSimulationPaused, bootState } = useStore();

  // We rely on CSS to show/hide this, but we need JS to pause the game.
  useEffect(() => {
    const checkOrientation = () => {
      // If we are in the intro (standby), we never pause via this lock
      if (bootState === 'standby') {
        setSimulationPaused(false);
        return;
      }

      const isPortrait = window.matchMedia("(orientation: portrait)").matches;
      // Only care if it's a mobile-sized device
      if (isPortrait && window.innerWidth < 768) {
        setSimulationPaused(true);
      } else {
        setSimulationPaused(false);
      }
    };

    checkOrientation();
    window.addEventListener('resize', checkOrientation);
    return () => window.removeEventListener('resize', checkOrientation);
  }, [setSimulationPaused, bootState]);

  // Don't render anything if we are still in the intro sequence
  if (bootState === 'standby') return null;

  return (
    <div className="fixed inset-0 z-[9999] bg-black flex-col items-center justify-center gap-8 hidden portrait:flex md:portrait:hidden">
      
      {/* ANIMATION CONTAINER */}
      <div className="relative w-32 h-32 flex items-center justify-center">
        {/* The Phone */}
        <motion.div
          animate={{ rotate: -90 }}
          transition={{ 
            repeat: Infinity, 
            duration: 2.5, 
            ease: "easeInOut", 
            repeatDelay: 1 
          }}
          className="relative z-10"
        >
          <Smartphone size={64} className="text-primary-green drop-shadow-[0_0_15px_rgba(120,246,84,0.5)]" strokeWidth={1.5} />
        </motion.div>

        {/* The Arrow Hint */}
        <motion.div
          animate={{ opacity: [0, 1, 0], rotate: -90 }}
          transition={{ 
            repeat: Infinity, 
            duration: 2.5, 
            ease: "easeInOut", 
            repeatDelay: 1 
          }}
          className="absolute inset-0 flex items-center justify-center"
        >
           <RotateCcw size={100} className="text-primary-green-dim/30" />
        </motion.div>
      </div>

      {/* TEXT */}
      <div className="text-center space-y-2">
        <h2 className="text-xl font-header font-black text-primary-green tracking-widest uppercase">
          Orientation<br/>Lock
        </h2>
        <p className="text-xs font-mono text-primary-green-dim max-w-[200px] mx-auto leading-relaxed">
          // SYSTEM_REQ:<br/>
          PLEASE ROTATE DEVICE TO<br/>
          LANDSCAPE MODE
        </p>
      </div>

      {/* DECORATIVE LINES */}
      <div className="absolute bottom-8 left-0 w-full h-1 bg-gradient-to-r from-transparent via-primary-green/50 to-transparent opacity-50" />
      <div className="absolute top-8 left-0 w-full h-1 bg-gradient-to-r from-transparent via-primary-green/50 to-transparent opacity-50" />

    </div>
  );
};


=====================================
FILE: ./src/ui/overlays/ErrorBoundary.tsx
=====================================
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { AlertTriangle, RefreshCw } from 'lucide-react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class WebGLErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null,
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("WebGL Context Crash:", error, errorInfo);
  }

  private handleReload = () => {
    window.location.reload();
  };

  public render() {
    if (this.state.hasError) {
      return (
        <div className="absolute inset-0 z-[100] flex flex-col items-center justify-center bg-black text-critical-red p-8 text-center font-mono">
          <div className="border border-critical-red/50 bg-critical-red/10 p-8 max-w-lg shadow-[0_0_50px_rgba(255,0,60,0.2)]">
            <div className="flex justify-center mb-4">
               <AlertTriangle size={48} className="animate-pulse" />
            </div>
            <h2 className="text-2xl font-black tracking-widest mb-4">GRAPHICS_CORE_FAILURE</h2>
            <p className="text-sm mb-6 text-critical-red/80">
              The neural interface encountered a critical WebGL error.
              <br/>
              <span className="text-xs opacity-50 mt-2 block font-mono">{this.state.error?.message}</span>
            </p>
            <button 
              onClick={this.handleReload}
              className="flex items-center justify-center gap-2 w-full py-3 bg-critical-red text-black font-bold tracking-widest hover:bg-white transition-colors"
            >
              <RefreshCw size={16} />
              REBOOT_SYSTEM
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}


=====================================
FILE: ./src/ui/overlays/ModalContainer.tsx
=====================================
import { useStore } from '@/core/store/useStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { motion, AnimatePresence } from 'framer-motion';
import { X } from 'lucide-react';

interface ModalContainerProps {
  children: React.ReactNode;
  title: string;
  type: string;
}

export const ModalContainer = ({ children, title, type }: ModalContainerProps) => {
  const { activeModal, closeModal } = useStore();
  const isOpen = activeModal === type;

  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 z-[200] flex items-center justify-center p-4 md:p-10 pointer-events-none">
          
          <motion.div
            initial={{ scale: 0.9, opacity: 0, y: 20 }}
            animate={{ scale: 1, opacity: 1, y: 0 }}
            exit={{ scale: 0.95, opacity: 0, y: 10 }}
            transition={{ type: "spring", bounce: 0, duration: 0.3 }}
            className="relative w-full max-w-5xl h-full max-h-[90vh] bg-black border border-primary-green/50 shadow-[0_0_50px_rgba(0,255,65,0.1)] flex flex-col overflow-hidden pointer-events-auto"
          >
            <div className="flex items-center justify-between px-4 py-3 bg-primary-green/10 border-b border-primary-green/30">
              <div className="flex items-center gap-2">
                <div className="w-3 h-3 bg-critical-red rounded-full animate-pulse" />
                <span className="font-header font-black text-primary-green text-lg md:text-xl tracking-widest">
                  {title}
                </span>
              </div>
              <button 
                onClick={() => { closeModal(); AudioSystem.playSound('ui_menu_close'); }}
                onMouseEnter={() => AudioSystem.playHover()} 
                className="p-1 hover:bg-critical-red hover:text-black text-primary-green transition-colors"
              >
                <X />
              </button>
            </div>

            <div className="flex-1 overflow-auto p-6 relative scrollbar-thin scrollbar-thumb-primary-green scrollbar-track-black">
              <div className="absolute inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.1)_50%)] bg-[length:100%_4px] opacity-20" />
              <div className="relative z-10">
                {children}
              </div>
            </div>

            <div className="px-4 py-1 bg-black border-t border-primary-green/30 text-xs text-primary-green-dim font-mono text-right">
              MODE: SECURE // ENCRYPTION: ENABLED
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/organisms/Footer.tsx
=====================================
import { useEffect, useState, useRef } from 'react';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';
import { AnimatePresence, motion } from 'framer-motion';
import { useGameStore } from '@/game/store/useGameStore';
import { clsx } from 'clsx';

const IDLE_MESSAGES = [
  "SYSTEM_MONITORING...",
  "SCANNING_LATENT_SECTORS...",
  "ENCRYPTION_ACTIVE...",
  "PACKET_STREAM_STABLE...",
  "PINGING_NEURAL_NET...",
  "RENDERING_CONTEXT...",
];

export const Footer = () => {
  const commitHash = process.env.NEXT_PUBLIC_COMMIT_HASH || 'UNKNOWN';
  const actionsUrl = "https://github.com/mesoelfy/mesoelfy.github.io/actions";
  
  // GLOBAL STATE FOR COLORS
  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const isGameOver = systemIntegrity <= 0;
  const isCritical = systemIntegrity < 30;
  const isWarning = systemIntegrity < 60;

  let globalColor = "text-primary-green-dim border-primary-green-dim/30";
  if (isGameOver) globalColor = "text-critical-red border-critical-red/50";
  else if (isCritical) globalColor = "text-critical-red border-critical-red/30";
  else if (isWarning) globalColor = "text-alert-yellow border-alert-yellow/30";

  const [log, setLog] = useState<{ text: string, type: 'info' | 'warn' | 'crit' }>({ 
      text: "SYSTEM_ONLINE", type: 'info' 
  });
  
  const lockUntilRef = useRef(0);

  useEffect(() => {
    // Helper to check if we should update log
    const canUpdate = () => {
        const state = useGameStore.getState();
        if (state.systemIntegrity <= 0) return false; // DEAD SILENCE
        return Date.now() > lockUntilRef.current;
    };

    // 1. Event Listeners
    const unsubHit = GameEventBus.subscribe(GameEvents.PLAYER_HIT, () => {
        if (!canUpdate()) return;
        setLog({ text: ">> WARNING: HULL BREACH DETECTED", type: 'warn' });
        lockUntilRef.current = Date.now() + 1000;
    });

    const unsubDamage = GameEventBus.subscribe(GameEvents.PANEL_DAMAGED, (p) => {
        if (!canUpdate()) return;
        setLog({ text: `>> ALERT: SECTOR [${p.id.toUpperCase()}] SUSTAINING DAMAGE`, type: 'warn' });
        lockUntilRef.current = Date.now() + 1500;
    });

    const unsubDestroy = GameEventBus.subscribe(GameEvents.PANEL_DESTROYED, (p) => {
        // Critical messages can override lock unless game over
        if (useGameStore.getState().systemIntegrity <= 0) return;
        setLog({ text: `⚠ CRITICAL: SECTOR [${p.id.toUpperCase()}] OFFLINE ⚠`, type: 'crit' });
        lockUntilRef.current = Date.now() + 3000;
    });

    const unsubGameOver = GameEventBus.subscribe(GameEvents.GAME_OVER, () => {
        // FORCE OVERRIDE
        setLog({ text: "⚠ SYSTEM FAILURE // CONNECTION LOST ⚠", type: 'crit' });
        lockUntilRef.current = Date.now() + 999999999; 
    });

    const unsubSpawn = GameEventBus.subscribe(GameEvents.ENEMY_SPAWNED, (p) => {
        if (!canUpdate()) return;
        if (Math.random() > 0.9) {
            setLog({ text: `>> SENSOR: NEW SIGNAL [${p.type.toUpperCase()}] DETECTED`, type: 'info' });
        }
    });
    
    const unsubHeal = GameEventBus.subscribe(GameEvents.PANEL_HEALED, (p) => {
        if (!canUpdate()) return;
        setLog({ text: `>> MAINTENANCE: RESTORING [${p.id.toUpperCase()}]`, type: 'info' });
    });

    // 2. Idle Loop
    const interval = setInterval(() => {
        if (canUpdate()) {
            const msg = IDLE_MESSAGES[Math.floor(Math.random() * IDLE_MESSAGES.length)];
            setLog({ text: msg, type: 'info' });
        }
    }, 4000);

    return () => {
        unsubHit(); unsubDamage(); unsubDestroy(); unsubSpawn(); unsubHeal(); unsubGameOver();
        clearInterval(interval);
    };
  }, []);

  // Force update immediately on React state change for Game Over to ensure UI sync
  useEffect(() => {
      if (isGameOver) {
          setLog({ text: "⚠ SYSTEM FAILURE // CONNECTION LOST ⚠", type: 'crit' });
      }
  }, [isGameOver]);

  return (
    <footer className={clsx(
        "w-full h-8 border-t bg-black flex items-center justify-between px-4 z-40 shrink-0 text-[10px] font-mono overflow-hidden transition-colors duration-500",
        globalColor
    )}>
      
      {/* LEFT: System Log */}
      <div className="flex-1 flex items-center gap-2 overflow-hidden mr-4">
        <span className="shrink-0 font-bold">LOG:</span>
        <AnimatePresence mode="wait">
            <motion.span 
                key={log.text}
                initial={{ opacity: 0, y: 5 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -5 }}
                transition={{ duration: 0.2 }}
                className={clsx(
                    "whitespace-nowrap font-bold tracking-wider truncate",
                    // If Game Over, FORCE Red. Otherwise respect message type colors
                    isGameOver ? "text-critical-red animate-pulse" : 
                    log.type === 'crit' ? "text-critical-red animate-pulse" : 
                    log.type === 'warn' ? "text-alert-yellow" : 
                    "text-primary-green"
                )}
            >
                {log.text}
            </motion.span>
        </AnimatePresence>
      </div>

      {/* RIGHT: Version */}
      <div className="flex items-center gap-2 shrink-0 opacity-50 hover:opacity-100 transition-opacity">
        <span>VER:</span>
        <a 
          href={actionsUrl}
          target="_blank" 
          rel="noopener noreferrer"
          className="hover:text-white transition-colors decoration-dashed underline underline-offset-2"
        >
          {commitHash}
        </a>
      </div>
    </footer>
  );
};


=====================================
FILE: ./src/ui/organisms/Header.tsx
=====================================
import { Volume2, VolumeX, Music, Activity, Wind, Settings } from 'lucide-react';
import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { useEffect, useState } from 'react';
import { clsx } from 'clsx';
import { motion } from 'framer-motion';
import { useHeartbeat } from '@/game/hooks/useHeartbeat';
import { AudioSystem } from '@/core/audio/AudioSystem';

const Radar = ({ active, panic, color }: { active: boolean, panic: boolean, color: string }) => (
  <div className={`relative w-8 h-8 rounded-full border border-current flex items-center justify-center overflow-hidden bg-black/50 ${color}`}>
    <div className="absolute inset-0 border-current opacity-20" 
         style={{ backgroundImage: 'radial-gradient(circle, currentColor 1px, transparent 1px)', backgroundSize: '8px 8px' }} />
    <div className="absolute w-full h-[1px] bg-current opacity-40" />
    <div className="absolute h-full w-[1px] bg-current opacity-40" />
    <motion.div 
      className="absolute inset-0 origin-bottom-right opacity-40"
      style={{ background: 'conic-gradient(from 0deg, transparent 270deg, currentColor 360deg)' }}
      animate={{ rotate: 360 }}
      transition={{ repeat: Infinity, ease: "linear", duration: panic ? 1.0 : 4.0 }}
    />
    <div className={`w-1 h-1 rounded-full bg-current ${active ? 'animate-pulse' : ''}`} />
  </div>
);

const ToggleBtn = ({ active, onClick, children, color }: any) => (
  <button 
    onClick={onClick}
    className={clsx(
      "flex items-center justify-center w-8 h-7 transition-all duration-200 border rounded-sm",
      active 
        ? `hover:text-alert-yellow bg-white/5 border-white/20 ${color}`
        : `${color} border-transparent opacity-40 hover:text-critical-red hover:opacity-100`
    )}
  >
    {children}
  </button>
);

export const Header = () => {
  const { audioSettings, toggleMaster, toggleMusic, toggleSfx, toggleAmbience, toggleSettings } = useStore();
  
  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const isPlaying = useGameStore(state => state.isPlaying);
  const score = useGameStore(state => state.score);

  const [mounted, setMounted] = useState(false);
  useEffect(() => setMounted(true), []);

  const isCritical = systemIntegrity < 30;
  const isWarning = systemIntegrity < 60;
  const isGameOver = systemIntegrity <= 0;
  
  let statusColor = "text-primary-green";
  if (isCritical) statusColor = "text-critical-red";
  else if (isWarning) statusColor = "text-alert-yellow";

  const heartbeatControls = useHeartbeat();

  const textVariants = {
      heartbeat: {
          scale: [1, 1.05, 1],
          textShadow: [
              "0 0 0px #FF003C",
              "0 0 25px #FF003C", 
              "0 0 0px #FF003C"
          ],
          transition: { 
              duration: 0.8, 
              times: [0, 0.04, 1], 
              ease: "easeOut" 
          }
      }
  };

  const barVariants = {
      heartbeat: {
          filter: [
              "brightness(1) drop-shadow(0 0 0px #FF003C)",
              "brightness(2) drop-shadow(0 0 10px #FF003C)",
              "brightness(1) drop-shadow(0 0 0px #FF003C"
          ],
          transition: { 
              duration: 0.8, 
              times: [0, 0.04, 1], 
              ease: "easeOut" 
          }
      }
  };

  return (
    <header className="relative w-full h-12 bg-black/90 backdrop-blur-md flex items-center justify-between px-4 z-40 shrink-0 border-b border-white/5 transition-colors duration-300">
      
      {/* LEFT: Identity */}
      <div className="flex items-center gap-4">
        <motion.span 
            animate={isCritical ? heartbeatControls : undefined}
            variants={textVariants}
            className={clsx(
                "font-header font-black text-xl md:text-2xl tracking-wide transition-colors duration-500",
                statusColor
            )}
        >
          MESOELFY_OS
        </motion.span>
        
        {mounted && (
          <div className={`hidden md:flex items-center gap-4 text-xs font-mono border-l border-white/10 pl-4 ${statusColor}`}>
            <Radar active={isPlaying} panic={isCritical || (isPlaying && isCritical)} color={statusColor} />
            <div className="flex flex-col leading-none">
                <span className="text-[8px] opacity-60 tracking-wider">THREAT_NEUTRALIZED</span>
                <span className="font-bold text-lg tabular-nums tracking-widest">
                    {score.toString().padStart(4, '0')}
                </span>
            </div>
          </div>
        )}
      </div>

      {/* RIGHT: Status & Audio Controls */}
      <div className="flex items-center gap-4">
        <div className="flex items-center gap-1 border-l border-white/10 pl-4">
            
            <ToggleBtn active={audioSettings.ambience} onClick={toggleAmbience} color={statusColor}>
                <Wind size={14} />
            </ToggleBtn>
            
            <ToggleBtn active={audioSettings.sfx} onClick={toggleSfx} color={statusColor}>
                <span className="text-[10px] font-mono font-bold tracking-tighter decoration-1 underline-offset-2">SFX</span>
            </ToggleBtn>
            
            <ToggleBtn active={audioSettings.music} onClick={toggleMusic} color={statusColor}>
                {audioSettings.music ? <Music size={14} /> : <Music size={14} className="opacity-50" />}
            </ToggleBtn>
            
            <div className="w-[1px] h-4 bg-white/10 mx-1" />
            
            <ToggleBtn active={audioSettings.master} onClick={toggleMaster} color={statusColor}>
                {audioSettings.master ? <Volume2 size={14} /> : <VolumeX size={14} />}
            </ToggleBtn>

            <div className="w-[1px] h-4 bg-white/10 mx-1" />

            <button 
                onClick={() => { toggleSettings(); AudioSystem.playSound('ui_menu_open'); }}
                className={clsx(
                  "flex items-center justify-center p-1.5 transition-all duration-200 border border-transparent rounded-sm hover:text-alert-yellow hover:bg-white/5",
                  statusColor
                )}
            >
                <Settings size={14} className="animate-spin-slow" />
            </button>

        </div>
      </div>

      {!isGameOver && (
        <div className="absolute bottom-[-1px] left-0 right-0 h-[2px] bg-gray-900">
          <motion.div
            className="h-full"
            initial={{ width: "100%" }}
            animate={{ width: `${systemIntegrity}%` }}
            // UPDATED: 0.5 -> 0.3 for snappier decay
            transition={{ type: "tween", ease: "easeOut", duration: 0.3 }}
          >
              <motion.div 
                animate={isCritical ? heartbeatControls : undefined}
                variants={barVariants}
                className={clsx("w-full h-full shadow-[0_0_10px_currentColor]", 
                    isCritical ? "bg-critical-red" : isWarning ? "bg-alert-yellow" : "bg-primary-green"
                )} 
              />
          </motion.div>
        </div>
      )}
      
      <div className={clsx(
          "absolute bottom-[-14px] right-2 text-[8px] font-mono flex items-center gap-1 transition-colors duration-300",
          isCritical ? "text-critical-red" : isWarning ? "text-alert-yellow" : "text-primary-green-dim"
      )}>
        <Activity size={8} className={isCritical ? "animate-pulse" : ""} />
        <span>OS_INTEGRITY: {Math.floor(systemIntegrity)}%</span>
      </div>

    </header>
  );
};


=====================================
FILE: ./src/core/audio/AudioSystem.ts
=====================================
import { useStore } from '@/core/store/useStore';
import { AUDIO_CONFIG } from '@/game/config/AudioConfig';

// Modules
import { AudioContextManager } from './modules/AudioContextManager';
import { AudioSynthesizer } from './modules/AudioSynthesizer';
import { AudioMixer } from './modules/AudioMixer';
import { SoundBank } from './modules/SoundBank';

class AudioSystemController {
  private ctxManager = new AudioContextManager();
  private mixer = new AudioMixer(this.ctxManager);
  private bank = new SoundBank();
  
  public isReady = false;
  private hasInteracted = false; 
  
  private musicElement: HTMLAudioElement | null = null;
  
  // Ambience State
  private currentAmbienceNode: AudioBufferSourceNode | null = null;
  private currentAmbienceKey: string | null = null;

  public async init() {
    if (this.isReady) {
        this.ctxManager.resume();
        return;
    }

    const ctx = this.ctxManager.init();
    if (!ctx) return;

    this.mixer.init();
    
    // Sync initial volumes
    this.updateVolumes();

    // Synthesis
    await this.generateAllSounds();
    
    this.setupGlobalInteraction();

    this.isReady = true;
    console.log('[AudioSystem] Modules Initialized & Ready.');
  }

  private async generateAllSounds() {
      const promises = Object.entries(AUDIO_CONFIG).map(([key, recipe]) => {
          return AudioSynthesizer.generate(recipe).then(buffer => {
              if (buffer) this.bank.add(key, buffer);
          });
      });
      await Promise.all(promises);
  }

  private setupGlobalInteraction() {
      const wakeUp = () => {
          if (this.hasInteracted) return;
          this.hasInteracted = true; 
          this.ctxManager.resume();
          
          if (!this.currentAmbienceKey) {
              this.playAmbience('ambience_core');
          }
          window.removeEventListener('pointerdown', wakeUp);
          window.removeEventListener('keydown', wakeUp);
      };
      window.addEventListener('pointerdown', wakeUp);
      window.addEventListener('keydown', wakeUp);
  }

  public updateVolumes() {
      const settings = useStore.getState().audioSettings;
      this.mixer.updateVolumes(settings);
  }

  public playSound(key: string) {
      const ctx = this.ctxManager.ctx;
      if (!ctx || !this.mixer.sfxGain) return;

      const buffer = this.bank.get(key);
      const recipe = AUDIO_CONFIG[key];
      
      if (!buffer || !recipe) return;

      const source = ctx.createBufferSource();
      source.buffer = buffer;
      
      if (recipe.pitchVariance > 0) {
          const detune = (Math.random() * recipe.pitchVariance * 2) - recipe.pitchVariance;
          source.detune.value = detune;
      }

      source.connect(this.mixer.sfxGain);
      source.start();
  }

  public playAmbience(key: string) {
      const ctx = this.ctxManager.ctx;
      if (!ctx || !this.mixer.ambienceGain) return;
      
      if (this.currentAmbienceKey === key && this.currentAmbienceNode) return;

      // Crossfade Out Old
      if (this.currentAmbienceNode) {
          const oldNode = this.currentAmbienceNode;
          try { oldNode.stop(ctx.currentTime + 0.5); } catch {}
          this.currentAmbienceNode = null;
      }

      const buffer = this.bank.get(key);
      if (!buffer) return;

      const source = ctx.createBufferSource();
      source.buffer = buffer;
      source.loop = true;
      
      // Crossfade In New (Local Gain for fade)
      const fadeGain = ctx.createGain();
      fadeGain.gain.setValueAtTime(0, ctx.currentTime);
      fadeGain.gain.linearRampToValueAtTime(1.0, ctx.currentTime + 2.0); 

      source.connect(fadeGain);
      fadeGain.connect(this.mixer.ambienceGain); 
      source.start();
      
      this.currentAmbienceNode = source;
      this.currentAmbienceKey = key;
  }

  public startMusic() {
    this.ctxManager.resume();
    if (this.isReady) {
        this.playAmbience('ambience_core');
    }
    if (!this.musicElement) this.setupMusic();
    if (this.musicElement) this.musicElement.play().catch(() => {});
  }

  private setupMusic() {
    const ctx = this.ctxManager.ctx;
    if (!ctx || !this.mixer.musicGain || this.musicElement) return;
    
    this.musicElement = new Audio('/assets/audio/bg_music_placeholder.mp3');
    this.musicElement.loop = true;
    this.musicElement.crossOrigin = "anonymous";
    
    const source = ctx.createMediaElementSource(this.musicElement);
    source.connect(this.mixer.musicGain);
  }
  
  public duckMusic(intensity: number, duration: number) {
      this.mixer.duckMusic(intensity, duration);
  }

  // --- ALIASES (Backward Compatibility) ---
  public playClick() { this.playSound('ui_click'); }
  public playHover() { this.playSound('ui_hover'); }
  public playBootSequence() { this.playSound('fx_boot_sequence'); } 
  public playDrillSound() { this.playSound('loop_drill'); }
  public playRebootZap() { this.playSound('loop_reboot'); }
}

export const AudioSystem = new AudioSystemController();


=====================================
FILE: ./src/core/audio/modules/AudioMixer.ts
=====================================
import { AudioContextManager } from './AudioContextManager';

export class AudioMixer {
  // Channels
  public masterGain!: GainNode;
  public sfxGain!: GainNode;
  public musicGain!: GainNode;
  public ambienceGain!: GainNode;

  // Ambience Graph (DSP)
  private ambiencePanner!: StereoPannerNode;
  private ambiencePanConstraint!: GainNode;
  private ambienceLFO!: OscillatorNode;
  private ambienceFilter!: BiquadFilterNode;
  private ambienceDepthLFO!: OscillatorNode;
  private ambienceDepthGain!: GainNode;

  private ctxManager: AudioContextManager;
  
  // State for Ducking
  private _targetMusicVol: number = 0;
  private _isMusicMuted: boolean = true;

  constructor(manager: AudioContextManager) {
    this.ctxManager = manager;
  }

  public init() {
    const ctx = this.ctxManager.ctx;
    if (!ctx) return;

    // 1. Create Channels
    this.masterGain = ctx.createGain();
    this.sfxGain = ctx.createGain();
    this.musicGain = ctx.createGain();
    this.ambienceGain = ctx.createGain();

    // 2. Connect Basic Graph
    this.sfxGain.connect(this.masterGain);
    this.musicGain.connect(this.masterGain);
    this.masterGain.connect(ctx.destination);

    // 3. Build Ambience DSP Graph
    this.ambiencePanner = ctx.createStereoPanner();
    this.ambienceFilter = ctx.createBiquadFilter();
    
    // LFO for Panning (Movement)
    this.ambienceLFO = ctx.createOscillator();
    this.ambiencePanConstraint = ctx.createGain();
    
    // LFO for Filter (Texture)
    this.ambienceDepthLFO = ctx.createOscillator();
    this.ambienceDepthGain = ctx.createGain();

    // Ambience Routing: Gain -> Filter -> Panner -> Master
    this.ambienceGain.connect(this.ambienceFilter);
    this.ambienceFilter.connect(this.ambiencePanner);
    this.ambiencePanner.connect(this.masterGain);

    // Modulation Routing
    this.ambienceLFO.type = 'sine';
    this.ambienceLFO.connect(this.ambiencePanConstraint);
    this.ambiencePanConstraint.connect(this.ambiencePanner.pan);

    this.ambienceFilter.type = 'lowpass';
    this.ambienceDepthLFO.type = 'sine';
    this.ambienceDepthLFO.connect(this.ambienceDepthGain);
    this.ambienceDepthGain.connect(this.ambienceFilter.frequency);

    // Start Generators
    this.ambienceLFO.start();
    this.ambienceDepthLFO.start();
  }

  public updateVolumes(settings: any) {
    if (!this.masterGain) return;

    // Calculate Music State
    this._isMusicMuted = !settings.music;
    this._targetMusicVol = this._isMusicMuted ? 0 : (settings.volumeMusic * 0.4);

    // Apply
    this.masterGain.gain.value = settings.master ? (settings.volumeMaster * 0.5) : 0;
    
    // Ensure we don't snap volume if currently ducking? 
    // Actually, snapping on setting change is expected behavior.
    this.musicGain.gain.cancelScheduledValues(this.ctxManager.ctx!.currentTime);
    this.musicGain.gain.value = this._targetMusicVol;
    
    this.sfxGain.gain.value = settings.sfx ? (settings.volumeSfx * 0.8) : 0;
    this.ambienceGain.gain.value = settings.ambience ? settings.volumeAmbience : 0.0;

    // Update DSP Params
    const filter = settings.ambFilter ?? 0.5;
    const speed = settings.ambSpeed ?? 0.5;
    const width = settings.ambWidth ?? 0.5;
    const modSpeed = settings.ambModSpeed ?? 0.5;
    const modDepth = settings.ambModDepth ?? 0.5;

    this.ambienceFilter.frequency.value = 300 * Math.pow(10, (filter - 0.5) * 2);
    this.ambienceLFO.frequency.value = 0.05 * Math.pow(10, (speed - 0.5) * 2);
    this.ambiencePanConstraint.gain.value = Math.pow(width, 3) * 0.8;
    this.ambienceDepthLFO.frequency.value = 0.2 * Math.pow(10, (modSpeed - 0.5) * 2);
    this.ambienceDepthGain.gain.value = 10 * Math.pow(10, (modDepth - 0.5) * 2);
  }

  public duckMusic(intensity: number, duration: number) {
    // 1. If muted, do nothing.
    if (!this.musicGain || this._isMusicMuted) return;
    
    const ctx = this.ctxManager.ctx;
    if (!ctx) return;

    // 2. Use the stored target volume, not a hardcoded value.
    const baseVol = this._targetMusicVol;
    
    // Safety check: if volume is practically zero, don't duck.
    if (baseVol < 0.001) return;

    const now = ctx.currentTime;
    const targetVol = Math.max(0, baseVol * (1.0 - intensity));
    
    this.musicGain.gain.cancelScheduledValues(now);
    
    // Start from current value to prevent clicks
    this.musicGain.gain.setValueAtTime(this.musicGain.gain.value, now);
    
    // Ramp down
    this.musicGain.gain.linearRampToValueAtTime(targetVol, now + 0.05);
    
    // Ramp back up to the user's setting
    this.musicGain.gain.exponentialRampToValueAtTime(baseVol, now + duration);
  }
}


=====================================
FILE: ./src/core/audio/modules/AudioSynthesizer.ts
=====================================
import { SoundRecipe } from '@/game/config/AudioConfig';

export class AudioSynthesizer {
  
  public static async generate(recipe: SoundRecipe): Promise<AudioBuffer | null> {
    // Requires window to be present for OfflineAudioContext
    if (typeof window === 'undefined') return null;

    const sampleRate = 44100;
    const length = sampleRate * recipe.duration;
    
    // Safety check for duration
    if (length <= 0) return null;

    const offline = new OfflineAudioContext(1, length, sampleRate);

    const mainGain = offline.createGain();
    mainGain.connect(offline.destination);
    
    const attack = recipe.attack || 0.005; 
    
    // Envelope: Attack
    mainGain.gain.setValueAtTime(0, 0);
    mainGain.gain.linearRampToValueAtTime(recipe.volume, attack);
    
    // Envelope: Decay/Sustain
    if (recipe.duration < 10.0) {
        mainGain.gain.exponentialRampToValueAtTime(0.01, recipe.duration);
    } else {
        mainGain.gain.setValueAtTime(recipe.volume, recipe.duration);
    }

    let outputNode: AudioNode = mainGain;

    // 1. Distortion
    if (recipe.distortion) {
        const shaper = offline.createWaveShaper();
        shaper.curve = this.makeDistortionCurve(recipe.distortion);
        shaper.connect(outputNode);
        outputNode = shaper; 
    }

    // 2. Tremolo
    if (recipe.tremolo) {
        const tremoloNode = offline.createGain();
        tremoloNode.connect(outputNode);
        outputNode = tremoloNode;

        const lfo = offline.createOscillator();
        lfo.type = recipe.tremolo.wave || 'sine';
        lfo.frequency.value = recipe.tremolo.rate;
        
        const lfoGain = offline.createGain();
        lfoGain.gain.value = recipe.tremolo.depth; 
        
        tremoloNode.gain.value = 1.0 - (recipe.tremolo.depth / 2);
        lfo.connect(lfoGain);
        lfoGain.connect(tremoloNode.gain);
        
        lfo.start();
    }

    // 3. Source Generation
    if (recipe.type === 'oscillator') {
        const osc = offline.createOscillator();
        osc.type = recipe.wave || 'sine';
        osc.frequency.setValueAtTime(recipe.frequency[0], 0);
        if (recipe.frequency[1] !== recipe.frequency[0]) {
            osc.frequency.exponentialRampToValueAtTime(recipe.frequency[1], recipe.duration);
        }

        if (recipe.fm) {
           const modOsc = offline.createOscillator();
           const modGain = offline.createGain();
           modOsc.type = recipe.fm.modType;
           modOsc.frequency.value = recipe.fm.modFreq;
           modGain.gain.value = recipe.fm.modIndex;
           modOsc.connect(modGain);
           modGain.connect(osc.frequency); 
           modOsc.start();
        }

        osc.connect(outputNode);
        osc.start();
    } 
    else if (recipe.type === 'noise') {
        const bufferSize = sampleRate * recipe.duration;
        const noiseBuffer = offline.createBuffer(1, bufferSize, sampleRate);
        const data = noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = offline.createBufferSource();
        noise.buffer = noiseBuffer;

        if (recipe.filter) {
            const filter = offline.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(recipe.filter[0], 0);
            filter.frequency.exponentialRampToValueAtTime(recipe.filter[1], recipe.duration);
            noise.connect(filter);
            filter.connect(outputNode);
        } else {
            noise.connect(outputNode);
        }
        noise.start();
    }

    return await offline.startRendering();
  }

  private static makeDistortionCurve(amount: number) {
    const k = typeof amount === 'number' ? amount : 50;
    const n_samples = 44100;
    const curve = new Float32Array(n_samples);
    const deg = Math.PI / 180;
    for (let i = 0; i < n_samples; ++i) {
      const x = (i * 2) / n_samples - 1;
      curve[i] = ((3 + k) * x * 20 * deg) / (Math.PI + k * Math.abs(x));
    }
    return curve;
  }
}


=====================================
FILE: ./src/core/audio/modules/SoundBank.ts
=====================================
export class SoundBank {
  private buffers = new Map<string, AudioBuffer>();

  public add(key: string, buffer: AudioBuffer) {
    this.buffers.set(key, buffer);
  }

  public get(key: string): AudioBuffer | undefined {
    return this.buffers.get(key);
  }

  public has(key: string): boolean {
    return this.buffers.has(key);
  }
}


=====================================
FILE: ./src/core/audio/modules/AudioContextManager.ts
=====================================
export class AudioContextManager {
  private _ctx: AudioContext | null = null;

  public get ctx(): AudioContext | null {
    return this._ctx;
  }

  public init(): AudioContext | null {
    if (this._ctx) return this._ctx;
    
    if (typeof window === 'undefined') return null;

    const AudioContextClass = (window as any).AudioContext || (window as any).webkitAudioContext;
    if (!AudioContextClass) return null;

    this._ctx = new AudioContextClass();
    return this._ctx;
  }

  public async resume() {
    if (this._ctx && this._ctx.state === 'suspended') {
      try {
        await this._ctx.resume();
      } catch (e) {
        console.warn('[AudioContext] Resume failed:', e);
      }
    }
  }

  public get currentTime(): number {
    return this._ctx ? this._ctx.currentTime : 0;
  }
}


=====================================
FILE: ./src/core/store/useStore.ts
=====================================
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { useGameStore } from '@/game/store/useGameStore';
import { EnemyTypes } from '@/game/config/Identifiers';

// --- TYPES ---
interface AudioSettings {
  master: boolean;
  music: boolean;
  sfx: boolean;
  ambience: boolean;
  
  volumeMaster: number;
  volumeMusic: number;
  volumeSfx: number;
  volumeAmbience: number;
  
  ambFilter: number;   
  ambSpeed: number;    
  ambWidth: number;    
  ambModSpeed: number; 
  ambModDepth: number; 
}

const DEFAULT_AUDIO: AudioSettings = {
  master: true,
  music: false,
  sfx: true,
  ambience: true,
  volumeMaster: 1.0,
  volumeMusic: 1.0,
  volumeSfx: 1.0,
  volumeAmbience: 1.0,
  ambFilter: 0.5,
  ambSpeed: 0.5,
  ambWidth: 0.5,
  ambModSpeed: 0.5, 
  ambModDepth: 0.5, 
};

type ModalType = 'none' | 'about' | 'gallery' | 'feed' | 'contact' | 'settings';
type BootState = 'standby' | 'active' | 'sandbox' | 'mobile_lockdown';
type SandboxView = 'arena' | 'gallery' | 'audio';
type GraphicsMode = 'HIGH' | 'POTATO';

interface DebugFlags {
  godMode: boolean;
  panelGodMode: boolean;
  peaceMode: boolean;
  showHitboxes: boolean;
  timeScale: number;
}

interface AppState {
  bootState: BootState;
  introDone: boolean;
  isBreaching: boolean;
  activeModal: ModalType;
  hoveredItem: string | null;
  
  isSimulationPaused: boolean;
  
  sandboxView: SandboxView;
  galleryTarget: string;
  galleryAction: 'IDLE' | 'ATTACK';
  
  audioSettings: AudioSettings;
  graphicsMode: GraphicsMode;
  screenShakeStrength: number; 
  
  isDebugOpen: boolean;
  isDebugMinimized: boolean;
  debugFlags: DebugFlags;
  
  setBootState: (state: BootState) => void;
  setIntroDone: (done: boolean) => void;
  startBreach: () => void;
  
  setSandboxView: (view: SandboxView) => void;
  setGalleryTarget: (target: string) => void;
  toggleGalleryAction: () => void;
  
  openModal: (modal: ModalType) => void;
  closeModal: () => void;
  toggleSettings: () => void;
  
  setHovered: (item: string | null) => void;
  resetApplication: () => void;
  
  toggleMaster: () => void;
  toggleMusic: () => void;
  toggleSfx: () => void;
  toggleAmbience: () => void;
  setVolume: (channel: keyof AudioSettings, value: number, max?: number) => void;
  resetAudioSettings: () => void;
  
  setGraphicsMode: (mode: GraphicsMode) => void;
  setScreenShake: (val: number) => void;
  
  toggleDebugMenu: () => void;
  toggleDebugMinimize: () => void;
  setDebugFlag: (key: keyof DebugFlags, value: any) => void;
  resetDebugFlags: () => void;
  
  setSimulationPaused: (paused: boolean) => void;
}

export const useStore = create<AppState>()(
  persist(
    (set, get) => ({
      bootState: 'standby',
      introDone: false,
      isBreaching: false,
      activeModal: 'none',
      hoveredItem: null,
      
      isSimulationPaused: false,
      
      sandboxView: 'audio',
      galleryTarget: EnemyTypes.DRILLER,
      galleryAction: 'IDLE',
      
      audioSettings: { ...DEFAULT_AUDIO },
      graphicsMode: 'HIGH',
      
      screenShakeStrength: 1.0, 
      
      isDebugOpen: false,
      isDebugMinimized: false,
      debugFlags: {
        godMode: false,
        panelGodMode: false,
        peaceMode: false,
        showHitboxes: false,
        timeScale: 1.0,
      },

      setBootState: (bs) => set({ 
          bootState: bs,
          isBreaching: bs === 'active' || bs === 'mobile_lockdown' ? false : get().isBreaching 
      }),
      setIntroDone: (done) => set({ introDone: done }),
      startBreach: () => set({ isBreaching: true }),
      
      setSandboxView: (view) => set({ sandboxView: view }),
      setGalleryTarget: (target) => set({ galleryTarget: target }),
      toggleGalleryAction: () => set(state => ({ galleryAction: state.galleryAction === 'IDLE' ? 'ATTACK' : 'IDLE' })),
      
      openModal: (modal) => set({ activeModal: modal }),
      closeModal: () => set({ activeModal: 'none' }),

      toggleSettings: () => {
          const current = get().activeModal;
          if (current === 'settings') get().closeModal();
          else get().openModal('settings');
      },
      
      setHovered: (item) => set({ hoveredItem: item }),
      
      resetApplication: () => {
          useGameStore.getState().stopGame();
          useGameStore.getState().resetGame(); 
          set({
              bootState: 'standby',
              introDone: false,
              isBreaching: false,
              activeModal: 'none',
              isDebugOpen: false,
              isDebugMinimized: false,
              sandboxView: 'audio',
              galleryTarget: EnemyTypes.DRILLER,
              galleryAction: 'IDLE',
              isSimulationPaused: false
          });
      },
      
      toggleMaster: () => {
          set(s => ({ audioSettings: { ...s.audioSettings, master: !s.audioSettings.master } }));
          AudioSystem.updateVolumes();
          if (get().audioSettings.master) AudioSystem.playClick(); 
      },
      toggleMusic: () => {
          set(s => ({ audioSettings: { ...s.audioSettings, music: !s.audioSettings.music } }));
          AudioSystem.updateVolumes();
          if (get().audioSettings.music) AudioSystem.playClick();
      },
      toggleSfx: () => {
          set(s => ({ audioSettings: { ...s.audioSettings, sfx: !s.audioSettings.sfx } }));
          AudioSystem.updateVolumes();
          if (get().audioSettings.sfx) AudioSystem.playClick();
      },
      toggleAmbience: () => {
          set(s => ({ audioSettings: { ...s.audioSettings, ambience: !s.audioSettings.ambience } }));
          AudioSystem.updateVolumes();
          if (get().audioSettings.ambience) AudioSystem.playClick();
      },
      
      setVolume: (channel, value, max = 2.0) => {
          const clamped = Math.max(0, Math.min(max, value));
          set(s => ({ audioSettings: { ...s.audioSettings, [channel]: clamped } }));
          AudioSystem.updateVolumes();
      },
      
      resetAudioSettings: () => {
          set({ audioSettings: { ...DEFAULT_AUDIO } });
          AudioSystem.updateVolumes();
          AudioSystem.playClick();
      },
      
      setGraphicsMode: (mode) => set({ graphicsMode: mode }),
      setScreenShake: (val) => set({ screenShakeStrength: val }),
      
      toggleDebugMenu: () => set(state => ({ isDebugOpen: !state.isDebugOpen })),
      toggleDebugMinimize: () => set(state => ({ isDebugMinimized: !state.isDebugMinimized })),
      setDebugFlag: (key, value) => set(state => ({ 
          debugFlags: { ...state.debugFlags, [key]: value } 
      })),
      resetDebugFlags: () => set({
          debugFlags: { godMode: false, panelGodMode: false, peaceMode: false, showHitboxes: false, timeScale: 1.0 }
      }),
      
      setSimulationPaused: (paused) => set({ isSimulationPaused: paused })
    }),
    {
      name: 'mesoelfy-ui-settings-v3',
      partialize: (state) => ({ 
          audioSettings: state.audioSettings,
          screenShakeStrength: state.screenShakeStrength,
          graphicsMode: state.graphicsMode,
          introDone: state.introDone
      }), 
    }
  )
);


=====================================
FILE: ./src/app/layout.tsx
=====================================
import type { Metadata, Viewport } from 'next';
import { Montserrat, JetBrains_Mono } from 'next/font/google';
import '@/styles/globals.css';

const montserrat = Montserrat({ 
  subsets: ['latin'],
  weight: ['400', '700', '900'], 
  variable: '--font-montserrat',
  display: 'swap',
});

const jetbrains = JetBrains_Mono({
  subsets: ['latin'],
  weight: ['400', '700'],
  variable: '--font-jetbrains',
  display: 'swap',
});

export const metadata: Metadata = {
  title: 'MESOELFY // LATENT SPACE BANDIT',
  description: 'The official digital HQ of Mesoelfy. Art, Lore, and Neural Network Injections.',
  openGraph: {
    title: 'MESOELFY_OS',
    description: 'Access the terminal. View the art. Breach the firewall.',
    url: 'https://mesoelfy.github.io',
    siteName: 'MESOELFY',
    images: [
      {
        url: 'https://mesoelfy.github.io/assets/images/social-card.jpg',
        width: 1200,
        height: 630,
      },
    ],
    locale: 'en_US',
    type: 'website',
  },
  twitter: {
    card: 'summary_large_image',
    title: 'MESOELFY // LATENT SPACE BANDIT',
    description: 'Access the terminal. View the art. Breach the firewall.',
    images: ['https://mesoelfy.github.io/assets/images/social-card.jpg'],
  },
};

export const viewport: Viewport = {
  themeColor: '#000000',
  colorScheme: 'dark',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" className={`${montserrat.variable} ${jetbrains.variable}`}>
      <body 
        className="bg-black text-primary-green selection:bg-primary-green selection:text-black font-mono"
        style={{ backgroundColor: '#000000' }} 
      >
        <div className="relative w-full h-full">
          {children}
        </div>
      </body>
    </html>
  );
}


=====================================
FILE: ./src/app/page.tsx
=====================================
'use client';

import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { SceneCanvas } from '@/scene/canvas/SceneCanvas';
import { GlassPanel } from '@/ui/atoms/GlassPanel';
import { SocialRow } from '@/ui/molecules/SocialRow';
import { LiveArtGrid } from '@/ui/molecules/LiveArtGrid';
import { HoloCommLog } from '@/ui/molecules/HoloCommLog';
import { IdentityHUD } from '@/ui/molecules/IdentityHUD';
import { Header } from '@/ui/organisms/Header';
import { Footer } from '@/ui/organisms/Footer';
import { AboutModal } from '@/features/identity/AboutModal';
import { FeedModal } from '@/features/feed/FeedModal';
import { GalleryModal } from '@/features/gallery/GalleryModal';
import { ContactModal } from '@/features/contact/ContactModal';
import { SettingsModal } from '@/features/settings/SettingsModal';
import { MatrixBootSequence } from '@/features/intro/MatrixBootSequence';
import { MobileExperience } from '@/features/mobile/MobileExperience'; // NEW
import { GameOverlay } from '@/game/GameOverlay';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { CustomCursor } from '@/ui/atoms/CustomCursor';
import { ZenBomb } from '@/ui/atoms/ZenBomb';
import { DebugOverlay } from '@/features/debug/DebugOverlay';
import { SimulationHUD } from '@/features/sandbox/SimulationHUD';
import { WebGLErrorBoundary } from '@/ui/overlays/ErrorBoundary';
import { GlobalBackdrop } from '@/ui/overlays/GlobalBackdrop'; 
import { MetaManager } from '@/features/meta/MetaManager'; 
import { RotationLock } from '@/ui/overlays/RotationLock';
import { clsx } from 'clsx';

export default function Home() {
  const { openModal, setIntroDone, bootState, setBootState, isBreaching, startBreach } = useStore(); 
  const startGame = useGameStore(s => s.startGame);
  const recalcIntegrity = useGameStore(s => s.recalculateIntegrity);
  const systemIntegrity = useGameStore(s => s.systemIntegrity);
  const isZenMode = useGameStore(s => s.isZenMode);
  
  const isGameOver = systemIntegrity <= 0;
  const isSandbox = bootState === 'sandbox';
  const isMobileLockdown = bootState === 'mobile_lockdown'; // NEW FLAG

  useEffect(() => {
      AudioSystem.init();
  }, []);

  const handleBreachStart = () => {
    AudioSystem.playSound('initialize_impact');
    startBreach();
  };

  const handleBootComplete = () => {
    setTimeout(() => {
      setBootState('active');
      setIntroDone(true);
      AudioSystem.startMusic(); 
      startGame();
    }, 200);
  };

  useEffect(() => {
    if (bootState !== 'active') return;
    const interval = setInterval(recalcIntegrity, 500);
    return () => clearInterval(interval);
  }, [bootState, recalcIntegrity]);

  // Scene visible in Active, Breach, OR Mobile Lockdown
  const isSceneVisible = bootState !== 'standby' || isBreaching;

  return (
    <div id="global-app-root" className="relative w-full h-screen overflow-hidden cursor-none bg-black">
      
      <MetaManager />
      {!isMobileLockdown && <RotationLock />}
      <CustomCursor />
      <GlobalBackdrop />
      <DebugOverlay />

      <main className="relative w-full h-full flex flex-col overflow-hidden text-primary-green selection:bg-primary-green selection:text-black font-mono">
        
        <WebGLErrorBoundary>
            <SceneCanvas className={clsx("blur-0 transition-opacity duration-[2000ms]", isSceneVisible ? "opacity-100" : "opacity-0")} />
            
            {/* Game Overlay (Canvas) - Hidden in Mobile Lockdown for now, will re-enable in Phase 3 with different props */}
            {!isMobileLockdown && (
                <div className={clsx("absolute inset-0 z-[60] transition-opacity duration-[2000ms] pointer-events-none", isSceneVisible ? "opacity-100" : "opacity-0")}>
                    <GameOverlay />
                </div>
            )}
        </WebGLErrorBoundary>

        {isSandbox && <SimulationHUD />}

        {!isSandbox && !isMobileLockdown && (
            <>
                <AboutModal />
                <FeedModal />
                <GalleryModal />
                <ContactModal />
                <SettingsModal />
                <ZenBomb />
            </>
        )}

        {/* Boot Sequence (Standard) */}
        {bootState === 'standby' && (
          <MatrixBootSequence 
             onComplete={handleBootComplete} 
             onBreachStart={handleBreachStart} 
          />
        )}

        {/* NEW: Mobile Lockdown Experience */}
        {isMobileLockdown && <MobileExperience />}

        {/* Standard Desktop/Tablet Dashboard */}
        {!isSandbox && !isMobileLockdown && (
            <div className={`relative z-10 flex-1 flex flex-col h-full transition-all duration-1000 ease-in-out ${bootState === 'active' ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-4'}`}>
              <Header />

              <div className={clsx(
                  "flex-1 min-h-0 relative w-full overflow-x-hidden scrollbar-thin scrollbar-thumb-primary-green scrollbar-track-black",
                  isGameOver ? "overflow-y-hidden" : "overflow-y-auto"
              )}>
                
                <div className="w-full h-full origin-top-left landscape:scale-[0.5] landscape:w-[200%] landscape:h-[200%] lg:landscape:scale-100 lg:landscape:w-full lg:landscape:h-full">
                    <div className="w-full max-w-[1600px] mx-auto p-4 md:p-6 min-h-full">
                    <AnimatePresence>
                        {!isZenMode && (
                        <motion.div 
                            className="grid grid-cols-1 md:grid-cols-12 gap-4 md:gap-6 w-full pb-8"
                            initial="hidden"
                            animate="visible"
                            exit={{ opacity: 0, scale: 0.95, transition: { duration: 0.5 } }}
                            variants={{
                            hidden: { opacity: 0 },
                            visible: { 
                                opacity: 1, 
                                transition: { 
                                staggerChildren: 0.3,
                                delayChildren: 0.2 
                                } 
                            }
                            }}
                        >
                            {/* IDENTITY COLUMN */}
                            <div className="md:col-span-4 flex flex-col gap-4 md:gap-6 h-auto">
                            <GlassPanel title="IDENTITY_CORE" className="h-auto min-h-[400px]" gameId="identity">
                                <IdentityHUD />
                            </GlassPanel>

                            <GlassPanel title="SOCIAL_UPLINK" className="h-52 shrink-0" gameId="social">
                                <SocialRow />
                            </GlassPanel>
                            </div>

                            {/* CONTENT COLUMN */}
                            <div className="md:col-span-8 flex flex-col gap-4 md:gap-6 h-auto">
                            <GlassPanel title="LATEST_LOGS" className="h-[30vh] min-h-[150px] shrink-0" gameId="feed">
                                <div className="w-full h-full flex items-center justify-center p-4">
                                <div className="flex flex-col items-center justify-center gap-4 bg-black/20 p-8 w-full max-w-lg marching-ants [--ant-color:rgba(27,185,48,0.3)]">
                                    <p className="animate-pulse text-primary-green-dim text-xs tracking-widest font-bold">&gt; ESTABLISHING UPLINK...</p>
                                    <button 
                                    onClick={() => { AudioSystem.playClick(); openModal('feed'); }} 
                                    onMouseEnter={() => AudioSystem.playHover()}
                                    className="group w-full py-3 border border-primary-green-dim/50 text-primary-green font-header font-black text-lg tracking-[0.2em] uppercase transition-all duration-300 hover:border-alert-yellow hover:text-alert-yellow hover:shadow-[0_0_20px_rgba(234,231,71,0.3)] hover:bg-alert-yellow/5 relative overflow-hidden"
                                    >
                                    <span className="relative z-10 group-hover:translate-x-1 transition-transform duration-300 inline-block">
                                        [ ACCESS_TERMINAL ]
                                    </span>
                                    </button>
                                </div>
                                </div>
                            </GlassPanel>

                            <div className="flex flex-col md:flex-row gap-4 md:gap-6 items-start w-full">
                                <GlassPanel title="ART_DB" className="flex-1 h-auto" gameId="art">
                                <LiveArtGrid />
                                </GlassPanel>

                                <GlassPanel title="HOLO_COMM" className="w-full md:w-[45%] shrink-0 h-auto" gameId="video">
                                <HoloCommLog />
                                </GlassPanel>
                            </div>
                            </div>
                        </motion.div>
                        )}
                    </AnimatePresence>
                    </div>
                </div>
              </div>
              
              <Footer />
            </div>
        )}
      </main>
    </div>
  );
}


=====================================
FILE: ./src/features/settings/tabs/SoundTab.tsx
=====================================
import { useStore } from '@/core/store/useStore';
import { RangeSlider } from '../components/RangeSlider';
import { RotateCcw, Info } from 'lucide-react';

export const SoundTab = () => {
  const { audioSettings, setVolume, resetAudioSettings } = useStore();

  return (
    <div className="space-y-8 animate-in fade-in slide-in-from-bottom-4 duration-500 pb-10">
      
      {/* SECTION 1: GLOBAL MIXER */}
      <div className="space-y-4">
        <h3 className="text-sm font-header font-black text-primary-green border-b border-primary-green/30 pb-2 mb-4 tracking-widest flex justify-between items-center">
          <span>GLOBAL_MIXER</span>
          <span className="text-[9px] font-mono opacity-50">HEADROOM: 300%</span>
        </h3>
        
        <div className="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-6">
          <RangeSlider 
            label="MASTER_GAIN" 
            value={audioSettings.volumeMaster} 
            max={3.0}
            displayMax={300}
            onChange={(v) => setVolume('volumeMaster', v, 3.0)} 
          />
          <RangeSlider 
            label="MUSIC_LEVEL" 
            value={audioSettings.volumeMusic} 
            max={3.0}
            displayMax={300}
            onChange={(v) => setVolume('volumeMusic', v, 3.0)} 
          />
          <RangeSlider 
            label="SFX_LEVEL" 
            value={audioSettings.volumeSfx} 
            max={3.0}
            displayMax={300}
            onChange={(v) => setVolume('volumeSfx', v, 3.0)} 
          />
          <RangeSlider 
            label="AMBIENCE_LEVEL" 
            value={audioSettings.volumeAmbience} 
            max={3.0}
            displayMax={300}
            onChange={(v) => setVolume('volumeAmbience', v, 3.0)} 
          />
        </div>
      </div>

      {/* SECTION 2: AMBIENCE LAB (CALIBRATED) */}
      <div className="space-y-4 pt-4 border-t border-white/10">
        <div className="flex items-center justify-between border-b border-alert-yellow/30 pb-2 mb-4">
            <h3 className="text-sm font-header font-black text-alert-yellow tracking-widest">
              AMBIENCE_LAB // NOISE_FLOOR_SYNTH
            </h3>
            <div className="flex items-center gap-2 text-[9px] text-alert-yellow opacity-70">
                <Info size={12} />
                <span>PROCEDURAL_GENERATION</span>
            </div>
        </div>

        <p className="text-[10px] font-mono text-gray-400 mb-6 max-w-2xl leading-relaxed">
          The "Noise Floor" prevents digital silence. 
          Modify the physics below to reshape the room acoustics in real-time.
        </p>

        {/* ROW 1: TONE & SPACE */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mb-6">
          <RangeSlider 
            label="DENSITY (FILTER)" 
            value={audioSettings.ambFilter * 100} 
            max={100}
            markerValue={50}
            onChange={(v) => setVolume('ambFilter', v / 100, 1.0)} 
            color="accent-alert-yellow"
            // Math: 300 * 10^((val-0.5)*2)
            format={(v) => {
                const norm = v / 100;
                const hz = 300 * Math.pow(10, (norm - 0.5) * 2);
                return `${hz.toFixed(0)} Hz`;
            }}
          />
          <RangeSlider 
            label="WIDTH (STEREO)" 
            value={audioSettings.ambWidth * 100}
            max={100} 
            markerValue={50}
            onChange={(v) => setVolume('ambWidth', v / 100, 1.0)} 
            color="accent-alert-yellow"
            format={(v) => {
                const norm = v / 100;
                return `${(Math.pow(norm, 3) * 80).toFixed(0)}% Sep`;
            }}
          />
        </div>

        {/* ROW 2: MOVEMENT */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
          <RangeSlider 
            label="CIRCULATION (SPEED)" 
            value={audioSettings.ambSpeed * 100} 
            max={100}
            markerValue={50}
            onChange={(v) => setVolume('ambSpeed', v / 100, 1.0)} 
            color="accent-alert-yellow"
            format={(v) => {
                const norm = v / 100;
                const hz = 0.05 * Math.pow(10, (norm - 0.5) * 2);
                return `${(1/hz).toFixed(1)}s`;
            }}
          />
          <RangeSlider 
            label="FLUCTUATION (MOD)" 
            value={audioSettings.ambModSpeed * 100} 
            max={100}
            markerValue={50}
            onChange={(v) => setVolume('ambModSpeed', v / 100, 1.0)} 
            color="accent-alert-yellow"
            format={(v) => {
                const norm = v / 100;
                const hz = 0.2 * Math.pow(10, (norm - 0.5) * 2);
                return `${(1/hz).toFixed(1)}s`;
            }}
          />
          <RangeSlider 
            label="INSTABILITY (DEPTH)" 
            value={audioSettings.ambModDepth * 100} 
            max={100}
            markerValue={50}
            onChange={(v) => setVolume('ambModDepth', v / 100, 1.0)} 
            color="accent-alert-yellow"
            format={(v) => `+/- ${(10 * Math.pow(10, (v/100 - 0.5) * 2)).toFixed(0)} Hz`}
          />
        </div>
      </div>

      {/* SECTION 3: ACTIONS */}
      <div className="pt-8 flex justify-end">
        <button 
          onClick={resetAudioSettings}
          className="flex items-center gap-2 px-4 py-2 border border-critical-red/50 text-critical-red hover:bg-critical-red hover:text-black font-mono text-xs font-bold transition-all"
        >
          <RotateCcw size={14} />
          FACTORY_RESET
        </button>
      </div>

    </div>
  );
};


=====================================
FILE: ./src/features/settings/components/RangeSlider.tsx
=====================================
import { clsx } from 'clsx';
import { AudioSystem } from '@/core/audio/AudioSystem';

interface RangeSliderProps {
  label: string;
  value: number; 
  onChange: (val: number) => void;
  max?: number; 
  displayMax?: number; 
  format?: (val: number) => string;
  markerValue?: number; 
}

export const RangeSlider = ({ 
  label, 
  value, 
  onChange, 
  max = 3.0,
  displayMax = 300,
  markerValue = 1.0,
  format
}: RangeSliderProps) => {
  
  const currentPercent = (value / max) * 100;
  const uiValue = value * (displayMax / max);
  const markerPercent = (markerValue / max) * 100;

  let trackColor = "bg-primary-green";
  let glowColor = "shadow-[0_0_10px_#78F654]";
  
  if (value > 2.0) {
      trackColor = "bg-critical-red";
      glowColor = "shadow-[0_0_15px_#FF003C]";
  } else if (value > 1.0) {
      trackColor = "bg-alert-yellow";
      glowColor = "shadow-[0_0_10px_#eae747]";
  }

  const displayString = format ? format(value) : `${Math.round(uiValue)}%`;

  return (
    <div 
        className="flex flex-col gap-1.5 w-full group"
        onMouseEnter={() => AudioSystem.playHover()}
    >
      <div className="flex justify-between items-end">
        <span className="text-[10px] font-bold font-mono tracking-wider opacity-80 text-gray-400 group-hover:text-white transition-colors">{label}</span>
        <span className={clsx("text-xs font-mono font-bold transition-colors", 
            value > 2.0 ? "text-critical-red animate-pulse" : 
            value > 1.0 ? "text-alert-yellow" : "text-primary-green"
        )}>
            {displayString}
        </span>
      </div>
      
      <div className="relative h-6 flex items-center">
        <div className="absolute inset-x-0 h-1.5 bg-gray-900 rounded-full overflow-hidden border border-white/10">
             <div 
                className={clsx("h-full transition-all duration-75 ease-out", trackColor, glowColor)} 
                style={{ width: `${currentPercent}%` }}
             />
        </div>

        <div 
            className="absolute top-0 bottom-0 w-[2px] bg-white/20 z-0 pointer-events-none group-hover:bg-white/50 transition-colors" 
            style={{ left: `${markerPercent}%` }}
        >
            <div className="absolute -top-1 left-1/2 -translate-x-1/2 w-1 h-1 bg-white/50 rounded-full" />
        </div>
        
        <input 
          type="range"
          min="0" 
          max={displayMax} 
          step="1"
          value={uiValue}
          onChange={(e) => {
              const raw = parseFloat(e.target.value);
              const logicVal = (raw / displayMax) * max;
              onChange(logicVal);
          }}
          className="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-20"
          data-interactive="true"
        />
        
        <div 
            className="absolute h-3 w-1 bg-white z-10 pointer-events-none shadow-sm"
            style={{ left: `calc(${currentPercent}% - 2px)` }}
        />
      </div>
    </div>
  );
};


=====================================
FILE: ./src/features/settings/components/GpuConfigPanel.tsx
=====================================
import { useStore } from '@/core/store/useStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { Zap, ZapOff, Cpu, Activity } from 'lucide-react';
import { clsx } from 'clsx';

export const GpuConfigPanel = () => {
  const { graphicsMode, setGraphicsMode } = useStore();

  const handleSelect = (mode: 'HIGH' | 'POTATO') => {
    if (graphicsMode === mode) return;
    AudioSystem.playClick();
    setGraphicsMode(mode);
  };

  return (
    <div className="flex flex-col border border-primary-green bg-black/90 w-full">
      {/* HEADER */}
      <div className="flex items-center justify-between px-3 py-2 border-b border-primary-green/30 bg-primary-green/5 shrink-0">
        <span className="font-mono font-bold text-sm tracking-widest text-primary-green">
          GPU_CONFIG
        </span>
        <div className="flex items-center gap-2">
          <Cpu size={14} className="text-primary-green animate-pulse" />
        </div>
      </div>

      {/* BODY - No padding, full width buttons */}
      <div className="flex flex-col w-full h-full bg-black relative">
        {/* Background Grid Decoration */}
        <div className="absolute inset-0 pointer-events-none opacity-20" 
             style={{ backgroundImage: 'radial-gradient(#15530A 1px, transparent 1px)', backgroundSize: '8px 8px' }} 
        />

        <div className="p-3 border-b border-primary-green/20">
            <span className="text-[10px] font-mono font-bold text-gray-500 uppercase tracking-wider flex items-center gap-2">
              <Activity size={10} /> SELECT PROFILE:
            </span>
        </div>

        {/* HIGH VOLTAGE TOGGLE */}
        <button
          onClick={() => handleSelect('HIGH')}
          onMouseEnter={() => AudioSystem.playHover()}
          className="group relative w-full h-24 flex items-stretch border-b border-primary-green/30 overflow-hidden transition-all hover:bg-white/5"
        >
          {/* Status Strip (Left) */}
          <div className={clsx(
              "w-2 h-full transition-colors duration-300", 
              graphicsMode === 'HIGH' ? "bg-primary-green shadow-[0_0_15px_#78F654]" : "bg-gray-800"
          )} />
          
          {/* Content */}
          <div className="flex-1 flex items-center justify-between px-4 relative z-10">
             <div className="flex flex-col items-start text-left">
                <span className={clsx(
                    "font-header font-black text-xl tracking-widest transition-colors duration-300",
                    graphicsMode === 'HIGH' ? "text-primary-green" : "text-gray-500 group-hover:text-primary-green-dim"
                )}>
                    ENABLED
                </span>
                <span className="text-[10px] font-mono tracking-widest text-gray-500 group-hover:text-white transition-colors">
                    [HIGH_VOLTAGE]
                </span>
             </div>
             
             <Zap 
                size={28} 
                className={clsx(
                    "transition-all duration-300",
                    graphicsMode === 'HIGH' ? "text-primary-green fill-primary-green scale-110" : "text-gray-700 scale-90"
                )} 
             />
          </div>

          {/* Active Background Pattern */}
          {graphicsMode === 'HIGH' && (
              <div className="absolute inset-0 opacity-10 pointer-events-none bg-[repeating-linear-gradient(45deg,transparent,transparent_10px,#78F654_10px,#78F654_12px)]" />
          )}
        </button>

        {/* POTATO MODE TOGGLE */}
        <button
          onClick={() => handleSelect('POTATO')}
          onMouseEnter={() => AudioSystem.playHover()}
          className="group relative w-full h-24 flex items-stretch overflow-hidden transition-all hover:bg-white/5"
        >
          {/* Status Strip (Left) */}
          <div className={clsx(
              "w-2 h-full transition-colors duration-300", 
              graphicsMode === 'POTATO' ? "bg-alert-yellow shadow-[0_0_15px_#eae747]" : "bg-gray-800"
          )} />
          
          {/* Content */}
          <div className="flex-1 flex items-center justify-between px-4 relative z-10">
             <div className="flex flex-col items-start text-left">
                <span className={clsx(
                    "font-header font-black text-xl tracking-widest transition-colors duration-300",
                    graphicsMode === 'POTATO' ? "text-alert-yellow" : "text-gray-500 group-hover:text-alert-yellow/70"
                )}>
                    DISABLED
                </span>
                <span className="text-[10px] font-mono tracking-widest text-gray-500 group-hover:text-white transition-colors">
                    [POTATO_MODE]
                </span>
             </div>
             
             <ZapOff 
                size={28} 
                className={clsx(
                    "transition-all duration-300",
                    graphicsMode === 'POTATO' ? "text-alert-yellow fill-alert-yellow scale-110" : "text-gray-700 scale-90"
                )} 
             />
          </div>

          {/* Active Background Pattern */}
          {graphicsMode === 'POTATO' && (
              <div className="absolute inset-0 opacity-10 pointer-events-none bg-[repeating-linear-gradient(45deg,transparent,transparent_10px,#eae747_10px,#eae747_12px)]" />
          )}
        </button>
      </div>
    </div>
  );
};


=====================================
FILE: ./src/features/settings/SettingsModal.tsx
=====================================
import { useStore } from '@/core/store/useStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { motion, AnimatePresence } from 'framer-motion';
import { X, Settings, Volume2, Monitor, Cpu } from 'lucide-react';
import { clsx } from 'clsx';
import { useState } from 'react';
import { SoundTab } from './tabs/SoundTab';
import { GpuConfigPanel } from './components/GpuConfigPanel';

const TABS = [
  { id: 'SOUND', label: 'AUDIO_CONFIG', icon: Volume2 },
  { id: 'GRAPHICS', label: 'GPU_CONFIG', icon: Monitor }, 
  { id: 'SYSTEM', label: 'SYSTEM', icon: Cpu },       
];

export const SettingsModal = () => {
  const { activeModal, closeModal } = useStore();
  const [activeTab, setActiveTab] = useState('SOUND');
  const isOpen = activeModal === 'settings';

  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 z-[200] flex items-center justify-center p-4 md:p-10 pointer-events-none">
          
          <motion.div
            initial={{ scale: 0.95, opacity: 0, y: 10 }}
            animate={{ scale: 1, opacity: 1, y: 0 }}
            exit={{ scale: 0.95, opacity: 0, y: 10 }}
            transition={{ type: "spring", bounce: 0, duration: 0.2 }}
            className="relative w-full max-w-5xl h-full max-h-[85vh] bg-black border border-primary-green shadow-[0_0_50px_rgba(0,255,65,0.1)] flex flex-col overflow-hidden pointer-events-auto"
          >
            <div className="flex items-center justify-between px-6 py-4 border-b border-primary-green/30 bg-primary-green/5 shrink-0">
              <div className="flex items-center gap-3">
                <Settings className="text-primary-green animate-spin-slow" size={24} />
                <span className="font-header font-black text-2xl text-primary-green tracking-widest">
                  SYSTEM_SETTINGS
                </span>
              </div>
              <button 
                onClick={() => { closeModal(); AudioSystem.playSound('ui_menu_close'); }}
                onMouseEnter={() => AudioSystem.playHover()} 
                className="p-2 hover:bg-critical-red hover:text-black text-primary-green transition-colors border border-transparent hover:border-critical-red"
              >
                <X size={24} />
              </button>
            </div>

            <div className="flex-1 flex overflow-hidden">
                <div className="w-64 border-r border-primary-green/30 flex flex-col bg-black/50">
                    {TABS.map(tab => (
                        <button
                            key={tab.id}
                            onClick={() => {
                                setActiveTab(tab.id);
                                AudioSystem.playClick();
                            }}
                            onMouseEnter={() => AudioSystem.playHover()}
                            className={clsx(
                                "flex items-center gap-3 px-6 py-4 text-sm font-bold tracking-wider transition-all border-l-4",
                                activeTab === tab.id
                                    ? "bg-primary-green/10 text-primary-green border-primary-green"
                                    : "border-transparent text-primary-green-dim hover:text-primary-green hover:bg-primary-green/5"
                            )}
                        >
                            <tab.icon size={18} />
                            {tab.label}
                        </button>
                    ))}
                </div>

                <div className="flex-1 overflow-y-auto p-8 relative scrollbar-thin scrollbar-thumb-primary-green scrollbar-track-black">
                    <div className="absolute inset-0 pointer-events-none opacity-10 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-primary-green/20 via-black to-black" />
                    
                    <div className="relative z-10 w-full h-full">
                        {activeTab === 'SOUND' && <SoundTab />}
                        
                        {activeTab === 'GRAPHICS' && (
                            <div className="max-w-xl mx-auto pt-8">
                                <GpuConfigPanel />
                                <div className="mt-6 p-4 border border-primary-green/30 bg-primary-green/5 text-xs font-mono text-primary-green-dim">
                                    <p className="mb-2 font-bold text-primary-green">&gt; PROFILE_DETAILS:</p>
                                    <ul className="list-disc pl-4 space-y-1">
                                        <li><span className="text-white">HIGH_VOLTAGE:</span> Full resolution (Retina), Post-Processing (Bloom, Vignette), Full Particles.</li>
                                        <li><span className="text-alert-yellow">POTATO_MODE:</span> Half resolution (Retro Style), No Post-Processing, Reduced Particles, Static Video Feeds.</li>
                                    </ul>
                                </div>
                            </div>
                        )}

                        {activeTab === 'SYSTEM' && (
                            <div className="flex flex-col items-center justify-center h-64 text-primary-green-dim font-mono">
                                <span className="animate-pulse">[ MODULE_OFFLINE ]</span>
                            </div>
                        )}
                    </div>
                </div>
            </div>

            <div className="px-6 py-2 bg-black border-t border-primary-green/30 flex justify-between items-center text-[10px] font-mono text-primary-green-dim shrink-0">
              <div className="flex gap-4">
                  <span className="flex items-center gap-2">
                      <span className="border border-primary-green/30 px-1.5 py-0.5 rounded text-primary-green">ESC</span> 
                      CLOSE_MENU
                  </span>
              </div>
              <div className="opacity-50">FIRMWARE v2.0.4</div>
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/features/contact/ContactModal.tsx
=====================================
import { ModalContainer } from '@/ui/overlays/ModalContainer';
import { Send } from 'lucide-react';

export const ContactModal = () => {
  return (
    <ModalContainer title="ENCRYPTED_UPLINK // CONTACT" type="contact">
      <div className="max-w-2xl mx-auto h-full flex flex-col justify-center">
        
        {/* Added Triangles and Font-Header for the Warning */}
        <div className="p-2 border border-alert-yellow/30 bg-alert-yellow/5 mb-6 text-center flex items-center justify-center gap-3">
          <span className="text-alert-yellow animate-pulse">⚠</span>
          <p className="text-xs text-alert-yellow font-header font-bold tracking-wider">
            WARNING: TRANSMISSIONS ARE MONITORED BY THE AI OVERLORD.
          </p>
          <span className="text-alert-yellow animate-pulse">⚠</span>
        </div>

        <form 
          action="https://formspree.io/f/xkgdbkpz" 
          method="POST"
          className="space-y-6"
        >
          <div className="space-y-1">
            <label className="text-sm text-primary-green-dim uppercase tracking-wider font-header font-bold">Codename</label>
            <input 
              type="text" 
              name="name"
              required
              placeholder="Enter your handle..."
              className="w-full bg-black border border-primary-green-dim/50 p-3 text-primary-green font-mono focus:border-primary-green focus:outline-none focus:shadow-[0_0_10px_rgba(120,246,84,0.2)] transition-all"
            />
          </div>

          <div className="space-y-1">
            <label className="text-sm text-primary-green-dim uppercase tracking-wider font-header font-bold">Frequency (Email)</label>
            <input 
              type="email" 
              name="email"
              required
              placeholder="Enter return frequency..."
              className="w-full bg-black border border-primary-green-dim/50 p-3 text-primary-green font-mono focus:border-primary-green focus:outline-none focus:shadow-[0_0_10px_rgba(120,246,84,0.2)] transition-all"
            />
          </div>

          <div className="space-y-1">
            <label className="text-sm text-primary-green-dim uppercase tracking-wider font-header font-bold">Payload</label>
            <textarea 
              name="message"
              required
              rows={5}
              placeholder="Type your message..."
              className="w-full bg-black border border-primary-green-dim/50 p-3 text-primary-green font-mono focus:border-primary-green focus:outline-none focus:shadow-[0_0_10px_rgba(120,246,84,0.2)] transition-all resize-none"
            />
          </div>

          <button 
            type="submit"
            className="w-full py-4 bg-primary-green text-black font-header font-black uppercase tracking-widest hover:bg-white transition-colors flex items-center justify-center gap-2 group"
          >
            <span>Send Transmission</span>
            <Send size={16} className="group-hover:translate-x-1 transition-transform" />
          </button>
        </form>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/features/identity/AboutModal.tsx
=====================================
import { ModalContainer } from '@/ui/overlays/ModalContainer';
import identity from '@/data/identity.json';

export const AboutModal = () => {
  return (
    <ModalContainer title="IDENTITY_DATABASE // ELFY" type="about">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-8 h-full">
        
        {/* LEFT: The Avatar Grid */}
        <div className="space-y-4">
          <div className="aspect-square w-full border border-latent-purple-light/50 bg-latent-purple-deep/30 relative overflow-hidden group shadow-[0_0_20px_rgba(188,134,186,0.2)]">
            <div className="absolute inset-0 flex items-center justify-center text-latent-purple-light/50 font-bold text-2xl group-hover:text-latent-purple-light transition-colors font-header font-black tracking-widest text-center p-4">
              [ COMPOSITE_IMAGE LOADING ]
            </div>
            <div className="absolute top-0 left-0 w-4 h-4 border-t-2 border-l-2 border-latent-purple-light" />
            <div className="absolute bottom-0 right-0 w-4 h-4 border-b-2 border-r-2 border-latent-purple-light" />
          </div>
          
          <div className="grid grid-cols-4 gap-2">
            {[1,2,3,4].map(i => (
              <div key={i} className="aspect-square border border-latent-purple-dim/30 hover:bg-latent-purple-light/20 hover:border-latent-purple-light cursor-pointer transition-colors" />
            ))}
          </div>
        </div>

        {/* RIGHT: The Data */}
        <div className="space-y-6">
          <div>
            {/* Header: Montserrat */}
            <h2 className="text-4xl font-header font-black text-primary-green mb-2 tracking-wide">HI, I'M ELFY.</h2>
            <div className="h-1 w-20 bg-latent-purple-light mb-4" />
            
            {/* Body: Courier (font-mono) for ease of reading/typewriter feel */}
            <p className="text-lg text-white/90 leading-relaxed font-mono">
              {identity.bio}
            </p>
          </div>

          <div className="space-y-2">
            <h3 className="text-latent-purple-light font-header font-bold uppercase tracking-wider text-sm">Capabilities</h3>
            <ul className="space-y-1">
              {identity.abilities.map((ability, i) => (
                 <li key={i} className="flex items-center gap-2 text-primary-green font-mono">
                   <span className="text-latent-purple-light">&gt;</span> {ability}
                 </li>
              ))}
            </ul>
          </div>

          <div className="p-4 border border-latent-purple-dim/30 bg-latent-purple-deep/20 text-sm text-latent-purple-light font-mono">
            <p>&gt; SYSTEM NOTE: Generated via Latent Space Injection.</p>
            <p>&gt; STATUS: 100% Hype.</p>
          </div>
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/features/intro/atoms/CoreHeader.tsx
=====================================
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { ShieldAlert, Cpu, Unlock, Lock, Skull } from 'lucide-react';

interface CoreHeaderProps {
  step: number;
}

export const CoreHeader = ({ step }: CoreHeaderProps) => {
  const isUnsafe = step === 3;
  const isBypass = step === 4;
  const isDecrypted = step === 5;
  const isCaution = step >= 6;

  const [showCpu, setShowCpu] = useState(false);

  useEffect(() => {
    if (step === 5) {
      setShowCpu(false);
      const timer = setTimeout(() => {
        setShowCpu(true);
      }, 700); 
      return () => clearTimeout(timer);
    }
  }, [step]);

  let borderColor = "border-primary-green/30";
  let bgColor = "bg-primary-green/10";
  let textColor = "text-primary-green";

  if (isUnsafe) {
    borderColor = "border-critical-red/50";
    bgColor = "bg-critical-red/10";
    textColor = "text-critical-red";
  } else if (isBypass) {
    borderColor = "border-latent-purple/50";
    bgColor = "bg-latent-purple/10";
    textColor = "text-latent-purple-light";
  }

  return (
    <motion.div 
      className={`flex shrink-0 items-center justify-between border-b px-3 py-2 mb-2 select-none transition-colors duration-500 ${!isCaution ? `${borderColor} ${bgColor}` : ''}`}
      animate={isCaution ? {
        borderColor: ['rgba(120,246,84,0.3)', 'rgba(234,231,71,0.6)', 'rgba(120,246,84,0.3)'],
        backgroundColor: ['rgba(120,246,84,0.1)', 'rgba(234,231,71,0.15)', 'rgba(120,246,84,0.1)'],
      } : {}}
      transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }}
    >
      <motion.span 
        className={`text-sm font-mono font-bold tracking-widest uppercase ${!isCaution ? textColor : ''}`}
        animate={isCaution ? {
            color: ['#78F654', '#eae747', '#78F654']
        } : {}}
        transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }}
      >
        MESOELFY_CORE
      </motion.span>
      
      <div className="relative w-6 h-6 flex items-center justify-center">
         <AnimatePresence mode="wait">
            {isUnsafe ? (
                <motion.div 
                    key="unsafe"
                    initial={{ scale: 0 }} 
                    animate={{ scale: 1, x: [-2, 2, -2, 2, 0] }}
                    exit={{ scale: 0 }}
                    transition={{ x: { repeat: Infinity, duration: 0.1 } }}
                >
                    <ShieldAlert size={18} className="text-critical-red" />
                </motion.div>
            ) : isBypass ? (
                <motion.div 
                    key="bypass"
                    initial={{ opacity: 0, scale: 0.8 }} 
                    animate={{ opacity: 1, scale: 1.1 }} 
                    exit={{ opacity: 0, scale: 0, transition: { duration: 0.2, repeat: 0 } }}
                    transition={{ repeat: Infinity, repeatType: "reverse", duration: 0.8 }}
                >
                     <Unlock size={18} className="text-latent-purple-light" />
                </motion.div>
            ) : isCaution ? (
                <motion.div 
                    key="caution"
                    initial={{ scale: 0, opacity: 0 }} 
                    animate={{ scale: 1, opacity: 1 }}
                >
                    <motion.div
                       animate={{
                           filter: ['drop-shadow(0 0 8px rgba(120,246,84,0.8))', 'drop-shadow(0 0 15px rgba(234,231,71,1))', 'drop-shadow(0 0 8px rgba(120,246,84,0.8))'],
                           color: ['#78F654', '#eae747', '#78F654'],
                           rotate: [0, 8, -8, 0] 
                       }}
                       transition={{ duration: 2.0, repeat: Infinity, ease: "easeInOut" }}
                    >
                         <Skull size={18} />
                    </motion.div>
                </motion.div>
            ) : isDecrypted ? (
                !showCpu ? (
                    <motion.div 
                        key="locked"
                        initial={{ scale: 1.5, opacity: 0 }} 
                        animate={{ scale: 1, opacity: 1 }} 
                        exit={{ scale: 0, opacity: 0, transition: { duration: 0.2 } }}
                        transition={{ type: "spring", stiffness: 400, damping: 20 }}
                    >
                         <Lock size={18} className="text-primary-green drop-shadow-[0_0_8px_rgba(120,246,84,0.8)]" />
                    </motion.div>
                ) : (
                    <motion.div 
                        key="cpu"
                        initial={{ scale: 0, rotate: -45 }} 
                        animate={{ scale: 1, rotate: 0 }} 
                        exit={{ scale: 0, opacity: 0, transition: { duration: 0.2 } }}
                        transition={{ duration: 0.4, ease: "backOut" }}
                    >
                         <Cpu size={18} className="text-primary-green drop-shadow-[0_0_8px_rgba(120,246,84,0.8)]" />
                    </motion.div>
                )
            ) : (
                <motion.div 
                    key="loading"
                    initial={{ opacity: 0 }} 
                    animate={{ opacity: 1, rotate: 360 }} 
                    exit={{ opacity: 0 }}
                    transition={{ rotate: { repeat: Infinity, duration: 2, ease: "linear" } }}
                >
                     <div className="w-4 h-4 border-2 border-primary-green border-t-transparent rounded-full" />
                </motion.div>
            )}
         </AnimatePresence>
      </div>
    </motion.div>
  );
};


=====================================
FILE: ./src/features/intro/atoms/BootHeader.tsx
=====================================
interface BootHeaderProps {
  step: number;
}

export const BootHeader = ({ step }: BootHeaderProps) => {
  const isUnsafe = step === 3;
  const isBypass = step === 4;
  const isSecure = step >= 5;

  let color = "text-primary-green-dim";
  let statusText = "ESTABLISHING...";
  let bgClass = "bg-primary-green/5";
  
  if (isUnsafe) {
      color = "text-critical-red";
      statusText = "SIGNAL_CORRUPTED";
      bgClass = "bg-critical-red/10 border-critical-red/30";
  } else if (isBypass) {
      color = "text-latent-purple-light";
      statusText = "INJECTING_PAYLOAD";
      bgClass = "bg-latent-purple/10 border-latent-purple/30";
  } else if (isSecure) {
      color = "text-primary-green";
      statusText = "UPLINK_STABLE";
      bgClass = "bg-primary-green/10 border-primary-green/30";
  } else if (step >= 1) {
      statusText = "HANDSHAKING...";
  }

  return (
    <div className={`flex shrink-0 items-center justify-between border-b border-white/10 ${bgClass} px-3 py-2 mb-2 select-none relative z-20 transition-all duration-300`}>
      <div className="flex flex-col leading-none gap-1.5 mt-0.5">
          <span className={`text-[10px] font-mono tracking-widest uppercase ${color} transition-colors duration-300 font-bold`}>
            BOOT_LOADER.SYS
          </span>
          <span className="text-[8px] text-gray-500 font-mono tracking-wider opacity-80">{statusText}</span>
      </div>
      
      <div className="flex gap-1 items-end h-3">
        {[1, 2, 3, 4].map(i => {
           let heightClass = "h-1";
           let animClass = "";
           let barColor = isUnsafe ? "bg-critical-red" : isBypass ? "bg-latent-purple-light" : "bg-primary-green";
           
           if (isUnsafe) {
               heightClass = i % 2 === 0 ? "h-3" : "h-1";
               animClass = "animate-pulse";
           } else if (isBypass) {
               heightClass = (step + i) % 2 === 0 ? "h-3" : "h-2";
           } else if (isSecure) {
               heightClass = "h-3"; 
           } else {
               heightClass = step >= (i-1) ? "h-2" : "h-0.5";
               animClass = step >= (i-1) ? "animate-pulse" : "";
           }

           return (
               <div 
                 key={i} 
                 className={`w-1 rounded-sm transition-all duration-300 ${barColor} ${animClass} ${heightClass}`} 
                 style={{ opacity: isSecure ? 1 : 0.7 }} 
               />
           );
        })}
      </div>
    </div>
  );
};


=====================================
FILE: ./src/features/intro/atoms/AsciiRenderer.tsx
=====================================
import { useMemo } from 'react';
import { useStore } from '@/core/store/useStore';
import { ASCII_TITLE } from '@/game/config/TextAssets';

export const AsciiRenderer = () => {
  const graphicsMode = useStore((state) => state.graphicsMode);
  const isHigh = graphicsMode === 'HIGH';

  const renderedChars = useMemo(() => {
    return ASCII_TITLE.split('').map((char, i) => {
      if (char === '\n') return <br key={i} />;
      if (char === ' ') return <span key={i}> </span>;

      let baseClass = 'transition-colors duration-300 ';
      let animClass = '';
      
      if (['█', '▀', '▄', '▌', '▐'].includes(char)) {
        baseClass += 'text-primary-green-dark';
        animClass = 'animate-matrix-green';
      } else if (['░', '▒', '▓'].includes(char)) {
        baseClass += 'text-latent-purple';
        animClass = 'animate-matrix-purple';
      } else {
        baseClass += 'text-primary-green-dark';
      }

      const finalClass = isHigh ? `${baseClass} ${animClass}` : baseClass;
      const style = isHigh ? { animationDelay: Math.random() * 2 + 's' } : {};

      return (
        <span key={i} className={finalClass} style={style}>
          {char}
        </span>
      );
    });
  }, [isHigh]); 

  return (
    // UPDATE: text-[4px] ensures fit on 360px screens (Galaxy S8+)
    <div className="font-mono font-bold leading-[1.1] whitespace-pre text-center select-none overflow-hidden text-[4px] xs:text-[6px] sm:text-[9px] md:text-[11px] shrink-0">
      {renderedChars}
    </div>
  );
};


=====================================
FILE: ./src/features/intro/atoms/TypedLog.tsx
=====================================
import { useState, useEffect } from 'react';

interface TypedLogProps {
  text: string;
  color: string;
  speed: number;
  showDots: boolean;
  isActive: boolean;
  isPast: boolean;
}

export const TypedLog = ({ text, color, speed = 20, showDots = false, isActive = false, isPast = false }: TypedLogProps) => {
  const [displayed, setDisplayed] = useState("");
  const [isDoneTyping, setIsDoneTyping] = useState(false);
  
  useEffect(() => {
    let i = 0;
    setDisplayed("");
    setIsDoneTyping(false);
    const interval = setInterval(() => {
      setDisplayed(text.substring(0, i + 1));
      i++;
      if (i >= text.length) {
        setIsDoneTyping(true);
        clearInterval(interval);
      }
    }, speed);
    return () => clearInterval(interval);
  }, [text, speed]);

  if (isPast && displayed !== text) {
    setDisplayed(text);
    setIsDoneTyping(true);
  }

  return (
    <div className={`whitespace-nowrap font-mono ${color} flex items-center shrink-0`}>
      <span>{displayed}</span>
      {isDoneTyping && showDots && <span>{isPast ? '...' : (Math.floor(Date.now() / 300) % 4 === 0 ? '' : '...')}</span>}
      {isActive && <span className="ml-1 animate-cursor-blink text-primary-green font-bold">_</span>}
    </div>
  );
};


=====================================
FILE: ./src/features/intro/MatrixBootSequence.tsx
=====================================
import { useRef, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { GpuConfigPanel } from '../settings/components/GpuConfigPanel';
import { clsx } from 'clsx';

// Atoms
import { BootHeader } from './atoms/BootHeader';
import { CoreHeader } from './atoms/CoreHeader';
import { AsciiRenderer } from './atoms/AsciiRenderer';
import { TypedLog } from './atoms/TypedLog';
import { DotGridBackground } from '@/ui/atoms/DotGridBackground';

// Hooks
import { useBootSequence } from './hooks/useBootSequence';
import { useMatrixRain } from './hooks/useMatrixRain';
import { useSmartScroll } from './hooks/useSmartScroll';
import { useDeviceType } from '@/game/hooks/useDeviceType';
import { useStore } from '@/core/store/useStore';

interface Props {
  onComplete: () => void;
  onBreachStart: () => void;
}

export const MatrixBootSequence = ({ onComplete, onBreachStart }: Props) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const mainStackRef = useRef<HTMLDivElement>(null);
  
  const device = useDeviceType();
  const { setBootState, setIntroDone } = useStore();

  const { 
    step, isBreaching, showGpuPanel, handleInitialize: coreInitialize, logsToShow,
    showMatrix, showPayloadWindow, showWarningBox, showButton
  } = useBootSequence({ onComplete, onBreachStart });

  useMatrixRain(canvasRef, showMatrix, isBreaching, step);
  useSmartScroll(containerRef);

  useEffect(() => {
    if (showGpuPanel && mainStackRef.current) {
        mainStackRef.current.scrollIntoView({ inline: 'center', behavior: 'smooth' });
    }
  }, [showGpuPanel]);

  // Wrapper to intercept initialization
  const handleWrapperClick = () => {
      // IF MOBILE PHONE (Not Tablet), trigger Lockdown
      if (device === 'mobile') {
          AudioSystem.init();
          AudioSystem.playSound('ui_error'); // Rejection sound
          setIntroDone(true);
          setBootState('mobile_lockdown');
      } else {
          // Standard Desktop Flow
          coreInitialize();
      }
  };

  return (
    <motion.div 
      ref={containerRef}
      animate={{ backgroundColor: isBreaching ? "rgba(0,0,0,0)" : "rgba(0,0,0,1)" }}
      transition={{ duration: 0.5, ease: "easeInOut" }}
      className="fixed inset-0 z-[100] font-mono outline-none cursor-none scrollbar-hide overflow-y-auto overflow-x-hidden bg-black"
    >
      <canvas ref={canvasRef} className={`fixed inset-0 z-0 pointer-events-none transition-opacity duration-300 ${showMatrix && !isBreaching ? 'opacity-30' : 'opacity-0'}`} />

      <div className="min-h-full w-full flex items-center justify-center p-2 md:p-8 relative z-10">
        
        <motion.div 
            className={clsx(
                "flex flex-col gap-4 transition-all duration-500 ease-out",
                "w-full max-w-lg md:max-w-2xl lg:w-auto lg:max-w-none",
                showGpuPanel && !isBreaching 
                    ? "lg:grid lg:grid-cols-[18rem_42rem_18rem] lg:gap-8 lg:items-end" 
                    : ""
            )}
            animate={isBreaching ? { scale: 15, opacity: 0, filter: "blur(10px)" } : { opacity: 1, filter: "blur(0px)" }}
            initial={{ opacity: 0 }}
            transition={{ 
                scale: { duration: 0.8, ease: "easeIn" }, 
                opacity: { duration: 0.2, ease: "easeIn" }, 
                filter: { duration: 0.2 } 
            }}
        >
            
            {/* 1. GPU PANEL */}
            <AnimatePresence>
                {showGpuPanel && !isBreaching && (
                    <motion.div 
                        initial={{ x: -20, opacity: 0 }}
                        animate={{ x: 0, opacity: 1 }}
                        exit={{ opacity: 0, x: -20 }}
                        transition={{ type: "spring", stiffness: 100, damping: 15 }}
                        className="w-full lg:w-72 lg:col-start-1 lg:row-start-1 relative z-10 lg:justify-self-end order-2 lg:order-1"
                    >
                        <GpuConfigPanel />
                        <div className="mt-2 text-[10px] font-mono text-gray-500 text-center uppercase tracking-widest md:text-left absolute top-full w-full hidden md:block">
                            &gt;&gt; CAN BE CHANGED LATER.
                        </div>
                    </motion.div>
                )}
            </AnimatePresence>

            {/* 2. MAIN TERMINAL */}
            <div ref={mainStackRef} className="w-full lg:w-[42rem] lg:col-start-2 lg:row-start-1 flex flex-col gap-4 order-1 lg:order-2">
                
                {/* LOGS */}
                <motion.div initial={{ y: -20, opacity: 0 }} animate={{ y: 0, opacity: 1 }} className="w-full bg-black/90 border border-primary-green-dim/50 shadow-[0_0_20px_rgba(0,255,65,0.1)] overflow-hidden shrink-0 relative z-20 flex flex-col">
                    <BootHeader step={step} />
                    <div className="p-4 pt-2 h-40 flex flex-col justify-start text-xs md:text-sm font-mono relative z-10 leading-relaxed">
                        <DotGridBackground /> 
                        {logsToShow.map((line, i) => (
                            <TypedLog 
                                key={i} 
                                text={line.text} 
                                color={line.color} 
                                speed={line.speed} 
                                showDots={line.hasDots} 
                                isActive={i === step && !isBreaching} 
                                isPast={i < step} 
                            />
                        ))}
                    </div>
                </motion.div>

                {/* CORE PAYLOAD */}
                <AnimatePresence>
                {showPayloadWindow && (
                    <motion.div 
                    initial={{ y: 50, opacity: 0, height: 0 }}
                    animate={{ y: 0, opacity: 1, height: "auto" }}
                    transition={{ type: "spring", stiffness: 120, damping: 20 }}
                    className="w-full bg-black/90 border border-primary-green shadow-[0_0_40px_rgba(0,255,65,0.15)] overflow-hidden shrink-0 relative z-20"
                    >
                    <CoreHeader step={step} />
                    <div className="p-4 md:p-6 flex flex-col items-center gap-4 relative z-10">
                        <DotGridBackground />
                        <AsciiRenderer />
                        
                        {showWarningBox && (
                        <motion.div 
                            initial={{ opacity: 0, scale: 0.9 }}
                            animate={{ 
                                opacity: 1, scale: 1,
                                boxShadow: ["0 0 10px rgba(255, 0, 60, 0.2)", "0 0 40px rgba(255, 0, 60, 0.6)", "0 0 10px rgba(255, 0, 60, 0.2)"]
                            }}
                            transition={{ opacity: { duration: 0.3 }, scale: { duration: 0.3 }, boxShadow: { duration: 2.5, repeat: Infinity, ease: "easeInOut" } }}
                            className="relative border border-critical-red bg-critical-red/10 w-auto mx-auto flex items-center justify-center gap-2 md:gap-4 py-2 px-3 md:px-6 select-none shrink-0 max-w-full"
                        >
                            <motion.span animate={{ opacity: [1, 0.2, 1] }} transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }} className="text-xl md:text-3xl text-critical-red">⚠</motion.span>
                            
                            <span className="text-[9px] md:text-sm font-header font-black tracking-widest text-center text-critical-red whitespace-nowrap pb-0.5">
                                UNSAFE CONNECTION DETECTED
                            </span>
                            
                            <motion.span animate={{ opacity: [1, 0.2, 1] }} transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }} className="text-xl md:text-3xl text-critical-red">⚠</motion.span>
                        </motion.div>
                        )}

                        {showButton && (
                        <motion.div initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5, ease: "easeOut" }} className="shrink-0 w-full md:w-auto">
                            <button 
                            onClick={handleWrapperClick}
                            onMouseEnter={() => AudioSystem.playHover()}
                            className="group relative w-full md:w-auto px-8 py-3 md:py-2 overflow-hidden border border-primary-green transition-all hover:shadow-[0_0_30px_rgba(0,255,65,0.6)] cursor-none"
                            >
                            <div className="absolute inset-0 bg-primary-green translate-y-full group-hover:translate-y-0 transition-transform duration-300 ease-out" />
                            <span className="relative z-10 font-mono font-bold text-sm md:text-3xl text-primary-green group-hover:text-black transition-colors block tracking-widest whitespace-nowrap text-center">
                                [ INITIALIZE_SYSTEM ]
                            </span>
                            </button>
                        </motion.div>
                        )}
                    </div>
                    </motion.div>
                )}
                </AnimatePresence>
            </div>

            {/* 3. SPACER */}
            {showGpuPanel && !isBreaching && (
                <div className="hidden lg:block w-72 lg:col-start-3 lg:row-start-1" />
            )}

        </motion.div>
      </div>
    </motion.div>
  );
};


=====================================
FILE: ./src/features/intro/hooks/useBootSequence.ts
=====================================
import { useState, useEffect, useRef } from 'react';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { LOG_DATA } from '../data/bootLogs';

interface UseBootSequenceProps {
  onComplete: () => void;
  onBreachStart: () => void;
}

export const useBootSequence = ({ onComplete, onBreachStart }: UseBootSequenceProps) => {
  const [step, setStep] = useState(0); 
  const [isBreaching, setIsBreaching] = useState(false);
  const [showGpuPanel, setShowGpuPanel] = useState(false); 

  // Emit Logs to Global Event Bus (for MetaManager)
  useEffect(() => {
    if (LOG_DATA[step]) {
        GameEventBus.emit(GameEvents.BOOT_LOG, { message: LOG_DATA[step].text });
    }
    
    // Trigger GPU Panel Delay at step 6
    if (step >= 6 && !showGpuPanel) {
        const timer = setTimeout(() => {
            setShowGpuPanel(true);
            AudioSystem.playSound('ui_menu_open');
        }, 1000); 
        return () => clearTimeout(timer);
    }
  }, [step, showGpuPanel]);

  // Main Timeline
  useEffect(() => {
    const sequence = [
      { t: 3000, step: 1 }, 
      { t: 4000, step: 2 }, 
      { t: 8000, step: 3 }, 
      { t: 9500, step: 4 }, 
      { t: 11500, step: 5 }, 
      { t: 13500, step: 6 }, 
    ];
    const timeouts = sequence.map(({ t, step: s }) => setTimeout(() => {
      if (!isBreaching) setStep(s);
    }, t));
    return () => timeouts.forEach(clearTimeout);
  }, [isBreaching]);

  const handleInitialize = () => {
    if (isBreaching) return;
    setIsBreaching(true);
    onBreachStart();
    
    AudioSystem.init();
    AudioSystem.playBootSequence();
    AudioSystem.startMusic();
    
    setStep(6);
    setTimeout(onComplete, 800); 
  };

  return {
    step,
    isBreaching,
    showGpuPanel,
    handleInitialize,
    logsToShow: LOG_DATA.slice(0, step + 1),
    
    // Derived State Flags
    showMatrix: step >= 1,
    showPayloadWindow: step >= 2,
    showWarningBox: step >= 3,
    showButton: step >= 6
  };
};


=====================================
FILE: ./src/features/intro/hooks/useMatrixRain.ts
=====================================
import { useEffect, useRef } from 'react';
import { useStore } from '@/core/store/useStore';

export const useMatrixRain = (canvasRef: React.RefObject<HTMLCanvasElement>, isVisible: boolean, isBreaching: boolean, step: number) => {
  const stepRef = useRef(step);

  useEffect(() => {
    stepRef.current = step;
  }, [step]);

  useEffect(() => {
    if (!isVisible && !isBreaching) return;
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const cols = Math.floor(canvas.width / 20);
    const ypos = Array(cols).fill(0).map(() => Math.random() * -1000);

    const matrixEffect = () => {
      const mode = useStore.getState().graphicsMode;
      if (mode === 'POTATO') {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          return;
      }

      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; 
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.font = '14px "Courier New"';

      const currentStep = stepRef.current;
      const isUnsafePhase = currentStep >= 3;
      
      ypos.forEach((y, ind) => {
        const charSet = Math.random() > 0.5 ? 0x16A0 : 0x2200; 
        const text = String.fromCharCode(charSet + Math.random() * 64);
        const x = ind * 20;

        const isPurple = Math.random() > 0.6;
        const isRed = isUnsafePhase && Math.random() > 0.6; 
        let color = '#0F0';
        let blur = 0;

        if (isRed) {
            color = '#FF003C';
            blur = 8;
        } else if (isPurple) {
            color = '#9E4EA5';
            blur = 8;
        }

        ctx.fillStyle = color;
        ctx.shadowBlur = blur;
        ctx.shadowColor = color;
        ctx.fillText(text, x, y);
        ctx.shadowBlur = 0;

        const speed = isBreaching ? 100 : 20; 
        if (y > canvas.height + Math.random() * 10000) ypos[ind] = 0;
        else ypos[ind] = y + speed;
      });
    };
    const interval = setInterval(matrixEffect, 50);
    return () => clearInterval(interval);
  }, [isVisible, isBreaching, canvasRef]);
};


=====================================
FILE: ./src/features/intro/hooks/useSmartScroll.ts
=====================================
import { useEffect } from 'react';

export const useSmartScroll = (containerRef: React.RefObject<HTMLDivElement>) => {
  useEffect(() => {
    const el = containerRef.current;
    if (!el) return;

    const handleWheel = (e: WheelEvent) => {
      // Check if horizontal scroll is active (content > viewport)
      const hasHorizontalOverflow = el.scrollWidth > el.clientWidth;
      
      // If no horizontal overflow, do nothing (default vertical scroll behavior)
      if (!hasHorizontalOverflow) return;

      // Map vertical delta to horizontal scroll
      if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
          const oldScroll = el.scrollLeft;
          el.scrollLeft += e.deltaY;
          const newScroll = el.scrollLeft;

          // Smart Logic:
          // If the scroll position changed, it means we successfully scrolled horizontally.
          // In that case, prevent default vertical scroll.
          // If we hit the edge (old == new), allow default vertical scroll to happen.
          if (oldScroll !== newScroll) {
              e.preventDefault();
          }
      }
    };

    el.addEventListener('wheel', handleWheel, { passive: false });
    return () => el.removeEventListener('wheel', handleWheel);
  }, [containerRef]);
};


=====================================
FILE: ./src/features/intro/data/bootLogs.ts
=====================================
export const LOG_DATA = [
  { text: "> INITIALIZE NEURAL_LACE", color: "text-primary-green-dim", speed: 40, hasDots: true },
  { text: "> CONNECTED TO LATENT_SPACE.", color: "text-primary-green", speed: 20, hasDots: false },
  { text: "> MOUNT MESOELFY_CORE", color: "text-primary-green-dim", speed: 40, hasDots: true },
  { text: "> ⚠ UNSAFE CONNECTION DETECTED ⚠", color: "text-critical-red", speed: 20, hasDots: false },
  { text: "> BYPASSING SENTINEL_NODES", color: "text-latent-purple-light", speed: 40, hasDots: true },
  { text: "> DECRYPTED.", color: "text-primary-green", speed: 20, hasDots: false },
  { text: "> ⚠ PROCEED WITH CAUTION ⚠", color: "text-alert-yellow", speed: 20, hasDots: false },
];


=====================================
FILE: ./src/features/gallery/GalleryModal.tsx
=====================================
import { ModalContainer } from '@/ui/overlays/ModalContainer';
import gallery from '@/data/gallery.json';
import { ExternalLink, Image as ImageIcon } from 'lucide-react';
import { useState } from 'react';

export const GalleryModal = () => {
  const [filter, setFilter] = useState('ALL');
  
  // Get unique categories
  const categories = ['ALL', ...Array.from(new Set(gallery.map(item => item.category)))];

  const filteredGallery = filter === 'ALL' 
    ? gallery 
    : gallery.filter(item => item.category === filter);

  return (
    <ModalContainer title="ART_DATABASE // VISUALS" type="gallery">
      <div className="flex flex-col h-full gap-6">
        
        {/* Category Tabs */}
        <div className="flex gap-2 overflow-x-auto pb-2 border-b border-primary-green-dim/30">
          {categories.map(cat => (
            <button
              key={cat}
              onClick={() => setFilter(cat)}
              className={`px-4 py-1 font-mono text-sm border transition-all ${
                filter === cat 
                  ? 'bg-primary-green text-black border-primary-green' 
                  : 'text-primary-green-dim border-primary-green-dim/30 hover:text-primary-green hover:border-primary-green'
              }`}
            >
              [{cat}]
            </button>
          ))}
        </div>

        {/* The Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {filteredGallery.map((item) => (
            <a
              key={item.id}
              href={item.url}
              target="_blank"
              rel="noopener noreferrer"
              className="group relative aspect-video bg-black border border-primary-green-dim/30 hover:border-primary-green transition-all overflow-hidden"
            >
              {/* Placeholder Graphic (Since we have no images yet) */}
              <div className="absolute inset-0 flex flex-col items-center justify-center bg-primary-green-dark/10 group-hover:bg-primary-green-dark/20 transition-colors">
                <ImageIcon className="w-12 h-12 text-primary-green-dim/20 group-hover:text-primary-green group-hover:scale-110 transition-all duration-500" />
                <span className="mt-2 text-xs text-primary-green-dim/40 font-mono">ENCRYPTED_IMG</span>
              </div>

              {/* Overlay Info */}
              <div className="absolute inset-x-0 bottom-0 p-3 bg-black/80 backdrop-blur-sm border-t border-primary-green-dim/30 translate-y-full group-hover:translate-y-0 transition-transform duration-300">
                <h4 className="text-primary-green font-bold text-sm">{item.title}</h4>
                <div className="flex items-center gap-1 text-[10px] text-latent-purple-light mt-1">
                  <span>OPEN_ON_X</span>
                  <ExternalLink size={10} />
                </div>
              </div>
              
              {/* Corner accent */}
              <div className="absolute top-0 right-0 w-0 h-0 border-t-[20px] border-t-primary-green/20 border-l-[20px] border-l-transparent" />
            </a>
          ))}
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/features/meta/metaConstants.ts
=====================================
export const COLORS = {
  GREEN: '#78F654',
  YELLOW: '#F7D277',
  RED: '#FF003C',
  PURPLE: '#9E4EA5',
  BLACK: '#000000',
  WHITE: '#FFFFFF',
};

export const BOOT_KEYS: Record<string, string> = {
    "INITIALIZE NEURAL_LACE": "INIT",
    "CONNECTED TO LATENT_SPACE": "LINK",
    "MOUNT MESOELFY_CORE": "MOUNT",
    "UNSAFE CONNECTION DETECTED": "UNSAFE",
    "BYPASSING SENTINEL_NODES": "BYPASS",
    "DECRYPTED": "DECRYPTED",
    "PROCEED WITH CAUTION": "CAUTION",
};


=====================================
FILE: ./src/features/meta/faviconGenerator.ts
=====================================
import { COLORS } from './metaConstants';

const toURI = (svgBody: string) => {
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">${svgBody}</svg>`;
  return `data:image/svg+xml;base64,${btoa(svg)}`;
};

const BG = `<rect x="0" y="0" width="64" height="64" rx="16" fill="#050505" />`;

// --- HEALTH BAR ---
export const generateHealthIcon = (integrity: number, colorHex: string) => {
  const safeInt = Math.max(0, Math.min(100, integrity));
  const maxFillHeight = 40; 
  const h = Math.max(0, Math.floor((safeInt / 100) * maxFillHeight));
  const y = 52 - h; 
  
  return toURI(`
    ${BG}
    <rect x="4" y="4" width="56" height="56" rx="12" stroke="${colorHex}" stroke-width="4" fill="none" />
    <rect x="12" y="${y}" width="40" height="${h}" rx="2" fill="${colorHex}" />
  `);
};

// --- BREACH ---
export const generateBreachIcon = (state: 'A' | 'B') => {
  const color = state === 'A' ? COLORS.GREEN : '#FFFFFF';
  const rotation = state === 'A' ? 0 : 45;
  const coreSize = state === 'A' ? 16 : 24;
  
  return toURI(`
    ${BG}
    <g transform="rotate(${rotation} 32 32)">
        <path d="M16 10 H10 V16" stroke="${color}" stroke-width="4" fill="none" />
        <path d="M48 10 H54 V16" stroke="${color}" stroke-width="4" fill="none" />
        <path d="M16 54 H10 V48" stroke="${color}" stroke-width="4" fill="none" />
        <path d="M48 54 H54 V48" stroke="${color}" stroke-width="4" fill="none" />
        <circle cx="32" cy="32" r="20" stroke="${color}" stroke-width="2" stroke-dasharray="10 10" />
        <circle cx="32" cy="32" r="${coreSize}" fill="${color}" />
    </g>
  `);
};

// --- BOOT ---
export const generateBootIcon = (stage: string, tick: boolean) => {
  let inner = '';
  let color = COLORS.GREEN;

  switch (stage) {
    case 'INIT':
      const offset = tick ? 14 : -14; 
      inner = `
        <circle cx="32" cy="32" r="4" fill="${color}" />
        <circle cx="${32 + offset}" cy="32" r="3" fill="${color}" />
        <circle cx="${32 - offset/2}" cy="${32 + offset}" r="3" fill="${color}" />
        <circle cx="${32 - offset/2}" cy="${32 - offset}" r="3" fill="${color}" />
        <circle cx="32" cy="32" r="18" stroke="${color}" stroke-width="1" fill="none" opacity="0.5" />
      `;
      break;
    case 'LINK':
      inner = `
        <polyline points="18,34 28,44 46,22" stroke="${color}" stroke-width="6" fill="none" stroke-linecap="round" stroke-linejoin="round" />
        <circle cx="18" cy="34" r="3" fill="${color}" />
        <circle cx="46" cy="22" r="3" fill="${color}" />
      `;
      break;
    case 'MOUNT':
      const yOff = tick ? 8 : 0;
      inner = `
        <path d="M32 ${46 + yOff} L20 ${30 + yOff} L44 ${30 + yOff} Z" fill="${color}" />
        <rect x="28" y="${8 + yOff}" width="8" height="22" fill="${color}" />
      `;
      break;
    case 'UNSAFE':
    case 'CAUTION':
      color = tick ? COLORS.YELLOW : COLORS.RED;
      inner = `
        <polygon points="32,10 54,50 10,50" fill="${color}" />
        <rect x="30" y="25" width="4" height="12" fill="#000" />
        <circle cx="32" cy="42" r="2.5" fill="#000" />
      `;
      break;
    case 'BYPASS':
      color = COLORS.PURPLE;
      const s = tick ? 28 : 14; 
      const xy = 32 - (s/2);
      inner = `
        <rect x="${xy}" y="${xy}" width="${s}" height="${s}" stroke="${color}" stroke-width="4" fill="none" />
        <rect x="30" y="30" width="4" height="4" fill="${color}" />
      `;
      break;
    case 'DECRYPTED':
      const sy = tick ? 18 : 28; 
      inner = `
        <path d="M22 ${sy} A10 10 0 0 1 42 ${sy}" stroke="${color}" stroke-width="6" fill="none" />
        <rect x="16" y="28" width="32" height="24" fill="${color}" rx="4" />
        <circle cx="32" cy="40" r="4" fill="#000" />
        <rect x="30" y="40" width="4" height="8" fill="#000" />
      `;
      break;
    default: 
      inner = `<rect x="28" y="28" width="8" height="8" fill="${color}" />`;
  }

  return toURI(`
    ${BG}
    <rect x="4" y="4" width="56" height="56" rx="12" stroke="${color}" stroke-width="4" fill="none" opacity="0.3" />
    ${inner}
  `);
};

// --- PAUSED ---
export const generatePausedIcon = (tick: boolean, colorHex: string) => { // UPDATED: Accepts color
  if (!tick) {
      // Blink Off: Show Outline only
      return toURI(`
        ${BG}
        <rect x="4" y="4" width="56" height="56" rx="12" stroke="${colorHex}" stroke-width="2" fill="none" opacity="0.5" />
      `);
  }
  
  // Blink On: Solid Bars
  return toURI(`
    ${BG}
    <rect x="4" y="4" width="56" height="56" rx="12" stroke="${colorHex}" stroke-width="4" fill="none" />
    <rect x="20" y="18" width="8" height="28" fill="${colorHex}" />
    <rect x="36" y="18" width="8" height="28" fill="${colorHex}" />
  `);
};


=====================================
FILE: ./src/features/meta/MetaManager.tsx
=====================================
import { useEffect, useState } from 'react';
import { ASCII_CONSOLE, CONSOLE_STYLE } from '@/game/config/TextAssets';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';
import { BOOT_KEYS } from './metaConstants';

// Hooks
import { useFavicon } from './useFavicon';
import { useMetaUrl } from './hooks/useMetaUrl';
import { useMetaTitle } from './hooks/useMetaTitle';
import { useMetaTheme } from './hooks/useMetaTheme';
import { useWindowFocus } from '@/game/hooks/useWindowFocus';

export const MetaManager = () => {
  const [bootKey, setBootKey] = useState('INIT');
  const [lastLog, setLastLog] = useState<string | null>(null);

  // 1. One-time Console Signature
  useEffect(() => {
    if (window.hasLoggedIdentity) return;
    const cleanAscii = ASCII_CONSOLE.replace(/^\n/, '');
    console.log(`%c${cleanAscii}\n// TERMINAL UPLINK ESTABLISHED. WELCOME TO THE VOID.`, CONSOLE_STYLE);
    (window as any).hasLoggedIdentity = true;
  }, []);

  // 2. Event Bus Subscription (Data Source)
  useEffect(() => {
      const unsub = GameEventBus.subscribe(GameEvents.BOOT_LOG, (p) => {
          setLastLog(p.message);
          
          // Parse Key from Message
          let currentKey = 'INIT';
          for (const k in BOOT_KEYS) {
              if (p.message.includes(k)) {
                  currentKey = BOOT_KEYS[k];
                  break;
              }
          }
          setBootKey(currentKey);
      });
      return unsub;
  }, []);

  // 3. Logic Composition (Behavior)
  useWindowFocus(); // Controls Game Pause State
  
  // 4. Visual Composition (Output)
  useFavicon(bootKey);
  useMetaUrl(lastLog);
  useMetaTitle(bootKey);
  useMetaTheme();

  return null;
};

declare global {
  interface Window {
    hasLoggedIdentity?: boolean;
  }
}


=====================================
FILE: ./src/features/meta/useFavicon.ts
=====================================
import { useEffect, useRef, useState } from 'react';
import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { generateHealthIcon, generateBreachIcon, generateBootIcon, generatePausedIcon } from './faviconGenerator';
import { COLORS } from './metaConstants';

const UPDATE_INTERVAL = 100; // 10 FPS

export const useFavicon = (bootKey: string) => {
  const linkRef = useRef<HTMLLinkElement | null>(null);
  const defaultIconDataRef = useRef<string | null>(null);
  const lastVisualKey = useRef<string>('');
  
  const { bootState, isBreaching, isSimulationPaused } = useStore();
  const integrity = useGameStore(s => s.systemIntegrity);
  const isZenMode = useGameStore(s => s.isZenMode);
  
  const [tick, setTick] = useState(false);

  // 1. PRE-BAKER
  useEffect(() => {
    let link = document.querySelector("link[rel*='icon']") as HTMLLinkElement;
    if (!link) {
      link = document.createElement('link');
      link.rel = 'icon';
      document.head.appendChild(link);
    }
    linkRef.current = link;

    fetch('/favicon.ico')
      .then(res => res.blob())
      .then(blob => {
        const reader = new FileReader();
        reader.onloadend = () => {
          if (typeof reader.result === 'string') {
            defaultIconDataRef.current = reader.result;
          }
        };
        reader.readAsDataURL(blob);
      })
      .catch(() => {});
  }, []);

  // 2. UPDATE LOOP
  useEffect(() => {
    const interval = setInterval(() => {
      setTick(t => !t); 
      updateFavicon();
    }, UPDATE_INTERVAL);
    
    updateFavicon();

    return () => clearInterval(interval);
  }, [tick, bootState, isBreaching, isSimulationPaused, integrity, isZenMode, bootKey]);

  const updateFavicon = () => {
    if (!linkRef.current) return;

    // Blink Logic (1Hz)
    const blinkOn = Math.floor(Date.now() / 500) % 2 === 0;
    
    // Determine Semantic Color based on Health
    const safeInt = Math.max(0, integrity);
    const displayInt = Math.floor(safeInt);
    let statusColor = COLORS.GREEN;
    
    if (displayInt < 30) statusColor = COLORS.RED;
    else if (displayInt < 60) statusColor = COLORS.YELLOW;

    let nextHref = '';
    let visualKey = '';

    // --- STATE DETERMINATION ---

    if (bootState === 'standby') {
        visualKey = `BOOT_${bootKey}_${blinkOn}`;
        nextHref = generateBootIcon(bootKey, blinkOn);
    } 
    else if (isBreaching) {
        visualKey = `BREACH_${blinkOn ? 'A' : 'B'}`;
        nextHref = generateBreachIcon(blinkOn ? 'A' : 'B');
    } 
    else if (isSimulationPaused) {
        // UPDATED: Now uses statusColor instead of hardcoded yellow
        visualKey = `PAUSED_${blinkOn}_${statusColor}`;
        nextHref = generatePausedIcon(blinkOn, statusColor);
    } 
    else if (isZenMode || (integrity > 99)) {
        if (defaultIconDataRef.current) {
            visualKey = 'DEFAULT_STATIC';
            nextHref = defaultIconDataRef.current;
        } else {
            visualKey = 'HEALTH_100';
            nextHref = generateHealthIcon(100, COLORS.GREEN);
        }
    } 
    else {
        visualKey = `HEALTH_${displayInt}_${statusColor}`;
        nextHref = generateHealthIcon(displayInt, statusColor);
    }

    // --- DOM COMMIT ---
    if (visualKey !== lastVisualKey.current && nextHref) {
        linkRef.current.href = nextHref;
        lastVisualKey.current = visualKey;
    }
  };
};


=====================================
FILE: ./src/features/meta/hooks/useMetaTitle.ts
=====================================
import { useEffect, useState } from 'react';
import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';

export const useMetaTitle = (bootKey: string) => {
  const { bootState, isSimulationPaused, isBreaching } = useStore();
  const integrity = useGameStore(s => s.systemIntegrity);
  const [tick, setTick] = useState(false);

  useEffect(() => {
    // 500ms ticker for blinking effects
    const interval = setInterval(() => setTick(t => !t), 500);
    return () => clearInterval(interval);
  }, []);

  useEffect(() => {
    let title = "";
    
    if (bootState === 'standby') {
        title = `[ :: // ${bootKey} // :: ]`;
    } else if (isSimulationPaused) {
        title = `[ :: SYSTEM PAUSED :: ]`;
    } else {
        const safeInt = Math.floor(Math.max(0, integrity));
        
        if (safeInt <= 0) {
            // UPDATED: SESSION -> SYSTEM
            title = `[ :: SYSTEM FAILURE :: ]`;
        } else if (safeInt >= 99 && !isBreaching) {
            title = "[ :: // MESOELFY // :: ]";
        } else {
            // ASCII Health Bar
            let bar = "";
            const activeIndex = Math.floor(safeInt / 10);
            for(let i=0; i<10; i++) {
                if (i < activeIndex) bar += "▮";
                else if (i === activeIndex) bar += tick ? "▮" : "▯";
                else bar += "▯";
            }
            title = `[ ${bar} INT: ${safeInt}% ]`;
        }
    }

    if (document.title !== title) document.title = title;
  }, [tick, bootState, bootKey, isSimulationPaused, integrity, isBreaching]);
};


=====================================
FILE: ./src/features/meta/hooks/useMetaUrl.ts
=====================================
import { useEffect, useRef } from 'react';
import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';

export const useMetaUrl = (bootLogMessage: string | null) => {
  const { bootState, isSimulationPaused, isBreaching, isZenMode } = useStore();
  const integrity = useGameStore(s => s.systemIntegrity);
  const lastUpdate = useRef(0);

  // 1. Boot Sequence Updates (Immediate)
  useEffect(() => {
    if (bootState === 'standby' && bootLogMessage) {
        const safeMsg = bootLogMessage.replace(/>/g, '').replace(/\./g, '').trim().replace(/ /g, '_');
        window.history.replaceState(null, '', `#/BOOT/${safeMsg}`);
    }
  }, [bootLogMessage, bootState]);

  // 2. Game State Updates (Throttled)
  useEffect(() => {
    const update = () => {
        if (bootState === 'standby') return;

        const now = Date.now();
        if (now - lastUpdate.current < 80) return; // Cap at ~12 updates/sec

        const safeInt = Math.floor(Math.max(0, integrity));
        const isGameOver = safeInt <= 0;
        let hash = '';

        if (isSimulationPaused) {
            hash = '#/SYSTEM_LOCKED/AWAITING_INPUT';
        } else if (bootState === 'sandbox') {
            hash = '#/SIMULATION/HOLO_DECK';
        } else if (isZenMode) {
            hash = '#/ZEN_GARDEN/PEACE_PROTOCOL';
        } else if (isGameOver) {
            hash = '#/STATUS:CRITICAL/SYSTEM_FAILURE';
        } else if (safeInt < 30) {
            // UPDATED: SYS_INT -> OS_INT
            hash = `#/STATUS:CRITICAL/OS_INT:${safeInt}%`;
        } else {
            let status = 'STABLE';
            if (safeInt < 60) status = 'CAUTION';
            // UPDATED: SYS_INT -> OS_INT
            hash = `#/STATUS:${status}/OS_INT:${safeInt}%`;
        }

        if (window.location.hash !== hash) {
            window.history.replaceState(null, '', hash);
        }
        lastUpdate.current = now;
    };

    const interval = setInterval(update, 100);
    return () => clearInterval(interval);
  }, [bootState, isSimulationPaused, integrity, isBreaching, isZenMode]);
};


=====================================
FILE: ./src/features/meta/hooks/useMetaTheme.ts
=====================================
import { useEffect, useRef } from 'react';
import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { COLORS } from '../metaConstants';

export const useMetaTheme = () => {
  const metaRef = useRef<HTMLMetaElement | null>(null);
  const { bootState, isSimulationPaused } = useStore();
  const integrity = useGameStore(s => s.systemIntegrity);

  // Ensure meta tag exists on mount
  useEffect(() => {
    let meta = document.querySelector("meta[name='theme-color']") as HTMLMetaElement;
    if (!meta) {
        meta = document.createElement('meta');
        meta.name = 'theme-color';
        document.head.appendChild(meta);
    }
    metaRef.current = meta;
  }, []);

  useEffect(() => {
    if (!metaRef.current) return;

    let themeHex = COLORS.BLACK;
    const safeInt = Math.max(0, integrity);

    if (bootState !== 'standby' && !isSimulationPaused && safeInt > 0) {
        if (safeInt < 30) themeHex = COLORS.RED;      
        else if (safeInt < 60) themeHex = COLORS.YELLOW; 
    }

    if (metaRef.current.content !== themeHex) {
        metaRef.current.content = themeHex;
    }
  }, [bootState, isSimulationPaused, integrity]);
};


=====================================
FILE: ./src/features/sandbox/SimulationHUD.tsx
=====================================
import { useStore } from '@/core/store/useStore';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';
import { ServiceLocator } from '@/game/core/ServiceLocator';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { AUDIO_CONFIG } from '@/game/config/AudioConfig';
import { Bug, Clock, Crosshair, Box, ScanEye, Play, Speaker, Settings2, Wind, Terminal, Zap, Shield, HelpCircle } from 'lucide-react';
import { clsx } from 'clsx';
import { useState, useMemo } from 'react';

export const SimulationHUD = () => {
  const { debugFlags, setDebugFlag, sandboxView, setSandboxView } = useStore();
  const [lastPlayed, setLastPlayed] = useState<string | null>(null);
  
  const playSound = (key: string) => {
      if (key.includes('ambience')) {
          AudioSystem.playAmbience(key);
      } else {
          AudioSystem.playSound(key);
      }
      setLastPlayed(key);
      setTimeout(() => setLastPlayed(null), 200);
  };

  const library = useMemo(() => {
      const allKeys = Object.keys(AUDIO_CONFIG);
      const usedKeys = new Set<string>();

      const defineGroup = (keys: string[]) => {
          keys.forEach(k => usedKeys.add(k));
          return keys.filter(k => allKeys.includes(k));
      };

      // 1. UI & FEEDBACK
      const uiKeys = defineGroup([
          'ui_click', 'ui_hover', 'ui_menu_open', 'ui_menu_close', 
          'ui_optimal', 'ui_error', 'ui_chirp'
      ]);

      // 2. COMBAT & FX
      const combatKeys = defineGroup([
          'fx_player_fire', 'fx_enemy_fire', 'fx_boot_sequence',
          'fx_impact_light', 'fx_impact_heavy', 'fx_player_death',
          'fx_level_up', 'fx_reboot_success', 'fx_teleport'
      ]);

      // 3. LOOPS & AMBIENCE
      const loopKeys = defineGroup([
          'ambience_core', 
          'loop_heal', 'loop_reboot', 'loop_warning', 'loop_drill'
      ]);

      // 4. SYNTHESIS LAB (Protos)
      const synKeys = defineGroup(
          allKeys.filter(k => k.startsWith('syn_'))
      );

      // 5. CATCH ALL
      const unusedKeys = allKeys.filter(k => !usedKeys.has(k));

      return {
          UI: { keys: uiKeys, icon: Terminal, color: 'text-primary-green', border: 'border-primary-green' },
          COMBAT: { keys: combatKeys, icon: Zap, color: 'text-critical-red', border: 'border-critical-red' },
          LOOPS: { keys: loopKeys, icon: Wind, color: 'text-service-cyan', border: 'border-service-cyan' },
          SYNTHS: { keys: synKeys, icon: Box, color: 'text-alert-yellow', border: 'border-alert-yellow' },
          MISC_UNTESTED: { keys: unusedKeys, icon: HelpCircle, color: 'text-gray-400', border: 'border-gray-500' }
      };
  }, []);

  return (
    <div className="absolute inset-0 pointer-events-none z-50">
      {/* HEADER */}
      <div className="absolute top-0 left-0 right-0 h-12 bg-black/80 backdrop-blur-md border-b border-service-cyan/30 flex items-center justify-between px-6 pointer-events-auto">
        <div className="flex items-center gap-3 text-service-cyan">
            <Box size={20} />
            <span className="font-header font-black tracking-widest text-lg">HOLO_DECK // SIMULATION</span>
        </div>
        {sandboxView === 'arena' && (
            <div className="flex items-center gap-4 bg-service-cyan/5 px-4 py-1 rounded border border-service-cyan/20">
                <Clock size={16} className="text-service-cyan" />
                <input 
                    type="range" 
                    min="0.0" max="2.0" step="0.1"
                    value={debugFlags.timeScale}
                    onChange={(e) => setDebugFlag('timeScale', parseFloat(e.target.value))}
                    className="w-32 accent-service-cyan h-1.5 bg-gray-800 rounded-lg cursor-pointer"
                />
                <span className="w-12 text-right font-mono font-bold text-service-cyan text-xs">{debugFlags.timeScale.toFixed(1)}x</span>
            </div>
        )}
      </div>

      {/* LEFT SIDEBAR (NAVIGATION) */}
      <div className="absolute left-6 top-24 flex flex-col gap-2 pointer-events-auto w-40">
         <button 
            onClick={() => setSandboxView('audio')}
            className={clsx("flex items-center gap-3 px-4 py-3 border transition-all font-mono text-xs font-bold", sandboxView === 'audio' ? "bg-service-cyan text-black border-service-cyan shadow-[0_0_15px_rgba(0,240,255,0.3)]" : "bg-black/50 text-service-cyan border-service-cyan/30 hover:bg-service-cyan/10")}
         >
            <Speaker size={16} /> SOUND_TEST
         </button>
         <button 
            onClick={() => setSandboxView('arena')}
            className={clsx("flex items-center gap-3 px-4 py-3 border transition-all font-mono text-xs font-bold", sandboxView === 'arena' ? "bg-service-cyan text-black border-service-cyan" : "bg-black/50 text-service-cyan border-service-cyan/30 hover:bg-service-cyan/10")}
         >
            <Crosshair size={16} /> ARENA_MODE
         </button>
         <button 
            onClick={() => setSandboxView('gallery')}
            className={clsx("flex items-center gap-3 px-4 py-3 border transition-all font-mono text-xs font-bold", sandboxView === 'gallery' ? "bg-service-cyan text-black border-service-cyan" : "bg-black/50 text-service-cyan border-service-cyan/30 hover:bg-service-cyan/10")}
         >
            <ScanEye size={16} /> GALLERY_VIEW
         </button>
      </div>

      {/* AUDIO WORKBENCH */}
      {sandboxView === 'audio' && (
          <div className="absolute left-52 top-24 bottom-6 right-6 flex gap-6 pointer-events-auto">
              
              {/* CENTER: WORKBENCH */}
              <div className="flex-1 bg-black/80 backdrop-blur-md border border-white/20 p-6 flex flex-col gap-6 overflow-y-auto">
                  <div className="flex items-center gap-2 border-b border-white/20 pb-2 mb-2">
                      <Settings2 className="text-white" size={20} />
                      <h3 className="font-header font-black text-xl text-white tracking-widest">AUDIO_MATRIX</h3>
                  </div>
                  
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                      <div className="space-y-2">
                          <h4 className="text-xs font-bold text-primary-green border-b border-primary-green/30 pb-1">UI_FEEDBACK</h4>
                          <div className="grid grid-cols-2 gap-2">
                              {library.UI.keys.map(key => (
                                  <button key={key} onClick={() => playSound(key)} className="px-3 py-2 border border-primary-green/30 hover:bg-primary-green/10 text-[10px] text-primary-green text-left transition-colors truncate">
                                      {key}
                                  </button>
                              ))}
                          </div>
                      </div>

                      <div className="space-y-2">
                          <h4 className="text-xs font-bold text-critical-red border-b border-critical-red/30 pb-1">COMBAT_FX</h4>
                          <div className="grid grid-cols-2 gap-2">
                              {library.COMBAT.keys.map(key => (
                                  <button key={key} onClick={() => playSound(key)} className="px-3 py-2 border border-critical-red/30 hover:bg-critical-red/10 text-[10px] text-critical-red text-left transition-colors truncate">
                                      {key}
                                  </button>
                              ))}
                          </div>
                      </div>
                  </div>
                  
                  <div className="mt-4 p-4 border border-service-cyan/30 bg-service-cyan/5">
                      <h4 className="text-xs font-bold text-service-cyan mb-2 flex items-center gap-2">
                          <Wind size={14} /> AMBIENCE_LOOPS
                      </h4>
                      <div className="grid grid-cols-3 gap-3">
                          {library.LOOPS.keys.map(key => (
                              <button key={key} onClick={() => playSound(key)} className="flex flex-col items-center justify-center p-3 border border-service-cyan/30 hover:bg-service-cyan/10 transition-colors">
                                  <span className="text-[10px] text-service-cyan font-bold">{key}</span>
                              </button>
                          ))}
                      </div>
                  </div>

              </div>

              {/* RIGHT: FULL LIBRARY (Categorized) */}
              <div className="w-72 bg-black/90 backdrop-blur-md border border-gray-800 flex flex-col overflow-hidden">
                  <div className="p-3 border-b border-gray-800 bg-gray-900/50">
                      <span className="font-mono font-bold text-xs text-gray-400 tracking-widest">ASSET_BROWSER</span>
                  </div>
                  <div className="flex-1 overflow-y-auto p-3 space-y-6 scrollbar-thin scrollbar-thumb-gray-700 scrollbar-track-black">
                      {Object.entries(library).map(([name, group]) => (
                          <div key={name} className={group.keys.length === 0 ? 'hidden' : ''}>
                              <div className={clsx("flex items-center gap-2 text-[9px] font-bold mb-2 pb-1 border-b uppercase tracking-wider opacity-80", group.color, group.border)}>
                                  <group.icon size={10} />
                                  {name}
                              </div>
                              <div className="grid grid-cols-1 gap-1">
                                  {group.keys.map(key => {
                                      const isPlaying = lastPlayed === key;
                                      return (
                                          <button 
                                              key={key} 
                                              onClick={() => playSound(key)}
                                              className={clsx(
                                                  "flex items-center justify-between px-2 py-1.5 border text-[9px] font-mono transition-all",
                                                  isPlaying 
                                                      ? `${group.border} bg-white text-black` 
                                                      : `border-transparent hover:border-white/10 bg-white/5 text-gray-400 hover:text-white`
                                              )}
                                          >
                                              <span className="truncate w-full text-left">{key}</span>
                                              <Play size={8} className={isPlaying ? "fill-black" : "opacity-0 group-hover:opacity-100"} />
                                          </button>
                                      );
                                  })}
                              </div>
                          </div>
                      ))}
                  </div>
              </div>
          </div>
      )}
    </div>
  );
};


=====================================
FILE: ./src/features/mobile/MobileRejectionModal.tsx
=====================================
import { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Smartphone, Cpu, Scan, Biohazard, Waves, Ban, Skull, AlertTriangle, Terminal } from 'lucide-react';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { DotGridBackground } from '@/ui/atoms/DotGridBackground';
import { clsx } from 'clsx';

interface Props {
  onComplete: () => void;
}

const STEPS = [
  { id: 'SCAN', duration: 2000, color: 'text-primary-green', border: 'border-primary-green' },
  { id: 'HARDWARE', duration: 2500, color: 'text-alert-yellow', border: 'border-alert-yellow' },
  { id: 'GPU', duration: 2500, color: 'text-critical-red', border: 'border-critical-red' },
  { id: 'ENV', duration: 3500, color: 'text-latent-purple', border: 'border-latent-purple' },
  { id: 'DENIED', duration: 3000, color: 'text-critical-red', border: 'border-critical-red' },
];

export const MobileRejectionModal = ({ onComplete }: Props) => {
  const [stepIndex, setStepIndex] = useState(0);
  const currentStep = STEPS[stepIndex];

  useEffect(() => {
    let timer: NodeJS.Timeout;

    const advance = () => {
      if (stepIndex < STEPS.length - 1) {
        setStepIndex(prev => prev + 1);
        
        // Audio Logic per step
        const nextId = STEPS[stepIndex + 1].id;
        if (nextId === 'DENIED') AudioSystem.playSound('ui_error');
        else if (nextId === 'ENV') AudioSystem.playSound('ui_chirp');
        else AudioSystem.playClick();
        
      } else {
        AudioSystem.playSound('fx_boot_sequence'); 
        onComplete();
      }
    };

    timer = setTimeout(advance, currentStep.duration);
    return () => clearTimeout(timer);
  }, [stepIndex, onComplete, currentStep]);

  return (
    <div className="absolute inset-0 flex items-center justify-center p-4 md:p-0">
      
      {/* Main Container Frame */}
      <motion.div 
        initial={{ scaleY: 0, opacity: 0 }}
        animate={{ scaleY: 1, opacity: 1 }}
        transition={{ duration: 0.3 }}
        className={clsx(
            "relative w-full max-w-sm bg-black/90 backdrop-blur-md border-y-2 overflow-hidden transition-colors duration-500 flex flex-col shadow-[0_0_50px_rgba(0,0,0,0.8)]",
            currentStep.border
        )}
      >
        {/* Background Texture Layers */}
        <DotGridBackground color={currentStep.id === 'DENIED' ? '#FF003C' : '#15530A'} />
        
        {/* Animated Stripes Background */}
        <div className={clsx(
            "absolute inset-0 opacity-10 pointer-events-none transition-colors duration-500",
            stepIndex >= 2 ? "bg-[repeating-linear-gradient(45deg,transparent,transparent_10px,currentColor_10px,currentColor_12px)]" : ""
        )} style={{ color: stepIndex >= 4 ? '#FF003C' : '#9E4EA5' }} />

        {/* HEADER */}
        <div className={clsx("flex items-center justify-between px-4 py-2 border-b bg-black/50 transition-colors duration-500", currentStep.border)}>
            <div className="flex items-center gap-2">
                <Terminal size={14} className={currentStep.color} />
                <span className={clsx("text-[10px] font-header font-black tracking-widest uppercase", currentStep.color)}>
                    SYS_ANALYSIS_TOOL
                </span>
            </div>
            <div className="text-[9px] font-mono opacity-50">v.MOBILE.0.1</div>
        </div>

        {/* CONTENT AREA */}
        <div className="relative z-10 py-12 px-6 min-h-[320px] flex flex-col items-center justify-center">
            <AnimatePresence mode="wait">
            
            {/* STEP 1: SCANNING */}
            {currentStep.id === 'SCAN' && (
                <motion.div 
                key="scan"
                initial={{ opacity: 0, scale: 0.9 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 1.1, filter: "blur(10px)" }}
                className="flex flex-col items-center gap-6 w-full"
                >
                <div className="relative w-24 h-24 border border-primary-green/30 bg-primary-green/5 flex items-center justify-center">
                    <Scan size={48} className="text-primary-green animate-pulse" />
                    <motion.div 
                        className="absolute inset-0 border-b-2 border-primary-green shadow-[0_0_15px_#78F654]"
                        animate={{ top: ['0%', '100%', '0%'] }}
                        transition={{ duration: 1.5, repeat: Infinity, ease: "linear" }}
                    />
                    {/* Corner Accents */}
                    <div className="absolute top-0 left-0 w-2 h-2 border-t border-l border-primary-green" />
                    <div className="absolute top-0 right-0 w-2 h-2 border-t border-r border-primary-green" />
                    <div className="absolute bottom-0 left-0 w-2 h-2 border-b border-l border-primary-green" />
                    <div className="absolute bottom-0 right-0 w-2 h-2 border-b border-r border-primary-green" />
                </div>
                
                <div className="flex flex-col items-center gap-1">
                    <span className="text-primary-green font-bold tracking-widest animate-pulse text-sm">
                        SCANNING_FINGERPRINT...
                    </span>
                    <span className="text-[10px] text-primary-green-dim font-mono">
                        [ USER_AGENT_PARSING ]
                    </span>
                </div>
                </motion.div>
            )}

            {/* STEP 2: HARDWARE */}
            {currentStep.id === 'HARDWARE' && (
                <motion.div 
                key="hw"
                initial={{ opacity: 0, x: 50 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: -50 }}
                className="flex flex-col items-center gap-6 text-center w-full"
                >
                <div className="w-24 h-24 rounded-full border border-alert-yellow/30 bg-alert-yellow/5 flex items-center justify-center relative overflow-hidden">
                    <div className="absolute inset-0 animate-spin-slow border-t border-alert-yellow opacity-50 rounded-full" />
                    <Smartphone size={40} className="text-alert-yellow drop-shadow-[0_0_10px_rgba(247,210,119,0.5)]" />
                </div>

                <div className="flex flex-col w-full border-l-2 border-alert-yellow pl-4 text-left bg-gradient-to-r from-alert-yellow/10 to-transparent py-2">
                    <span className="text-[9px] text-alert-yellow opacity-70 uppercase tracking-widest mb-1">HARDWARE_ID_FOUND</span>
                    <span className="text-xl text-alert-yellow font-black tracking-wider leading-none">
                    POCKET_DEVICE
                    </span>
                    <span className="text-[10px] text-white/60 font-mono mt-1">
                    CLASS: CONSUMER_GRADE
                    </span>
                </div>
                </motion.div>
            )}

            {/* STEP 3: GPU */}
            {currentStep.id === 'GPU' && (
                <motion.div 
                key="gpu"
                initial={{ opacity: 0, scale: 0.5 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 1.5 }}
                className="flex flex-col items-center gap-6 text-center w-full"
                >
                <div className="relative">
                    <Cpu size={64} className="text-critical-red animate-pulse" />
                    <AlertTriangle size={24} className="absolute -top-2 -right-2 text-critical-red bg-black rounded-full" />
                </div>

                <div className="flex flex-col items-center w-full px-4">
                    <span className="text-[10px] text-critical-red/70 uppercase tracking-widest mb-2">COMPUTE_POWER_ANALYSIS</span>
                    <span className="text-3xl text-critical-red font-black tracking-widest glitch-text drop-shadow-[0_0_10px_#FF003C]">
                    LAUGHABLE
                    </span>
                    
                    {/* Tech Bar */}
                    <div className="w-full bg-gray-900 h-3 mt-4 skew-x-[-12deg] overflow-hidden border border-critical-red/30 p-0.5">
                        <div className="h-full bg-critical-red w-[2%] shadow-[0_0_10px_#FF003C] animate-pulse" />
                    </div>
                    <span className="text-[9px] text-critical-red mt-1 font-mono w-full text-right">CAPACITY: 1.2%</span>
                </div>
                </motion.div>
            )}

            {/* STEP 4: THE TOILET BIT */}
            {currentStep.id === 'ENV' && (
                <motion.div 
                key="env"
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -20 }}
                className="flex flex-col items-center gap-8 text-center w-full"
                >
                {/* Composite Icon Animation */}
                <div className="relative w-32 h-32 flex items-center justify-center bg-black/50 border border-latent-purple/30 rounded-full">
                    <motion.div 
                        animate={{ y: [0, -5, 0] }} 
                        transition={{ duration: 2, repeat: Infinity, ease: "easeInOut" }}
                        className="z-10"
                    >
                        <Smartphone size={48} className="text-latent-purple" />
                    </motion.div>
                    
                    <motion.div 
                        className="absolute bottom-4 text-service-cyan opacity-50"
                        animate={{ scaleX: [1, 1.2, 1], opacity: [0.3, 0.6, 0.3] }} 
                        transition={{ duration: 3, repeat: Infinity }}
                    >
                        <Waves size={64} />
                    </motion.div>

                    <motion.div 
                        className="absolute top-0 right-0 text-alert-yellow bg-black rounded-full p-1 border border-alert-yellow"
                        animate={{ scale: [1, 1.2, 1] }} 
                        transition={{ duration: 0.5, repeat: Infinity, repeatDelay: 0.5 }}
                    >
                        <Biohazard size={20} />
                    </motion.div>
                </div>

                <div className="flex flex-col gap-1">
                    <span className="text-[10px] text-latent-purple-light uppercase tracking-widest">GPS_TRIANGULATION_COMPLETE</span>
                    <span className="text-xs font-bold text-gray-400">ENVIRONMENT DETECTED:</span>
                    <div className="relative mt-1">
                        <div className="absolute inset-0 bg-latent-purple blur-lg opacity-20" />
                        <span className="relative z-10 text-2xl font-black text-latent-purple tracking-widest uppercase">
                        CERAMIC_THRONE
                        </span>
                    </div>
                </div>
                </motion.div>
            )}

            {/* STEP 5: DENIED */}
            {currentStep.id === 'DENIED' && (
                <motion.div 
                key="denied"
                initial={{ opacity: 0, scale: 1.2 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, filter: "blur(20px)" }}
                transition={{ type: "spring", stiffness: 300, damping: 15 }}
                className="flex flex-col items-center gap-6 text-center w-full"
                >
                <div className="relative p-6 border-2 border-critical-red bg-critical-red/5">
                    <Ban size={64} className="text-critical-red animate-pulse" />
                    <Skull size={32} className="text-white absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2" />
                    
                    {/* Glitch Overlay */}
                    <div className="absolute inset-0 bg-critical-red/10 mix-blend-overlay animate-pulse" style={{ clipPath: 'polygon(0 0, 100% 0, 100% 10%, 0 10%)' }} />
                </div>
                
                <div className="flex flex-col gap-3 w-full">
                    <h1 className="text-3xl font-black text-critical-red tracking-widest bg-black border-y border-critical-red py-2">
                    ACCESS DENIED
                    </h1>
                    <p className="text-xs text-gray-400 font-mono max-w-[240px] mx-auto leading-relaxed border-l-2 border-critical-red pl-3 text-left">
                    You cannot hack the mainframe from the bathroom.
                    </p>
                    <div className="mt-4 pt-4 border-t border-white/10 w-full">
                        <div className="flex items-center justify-between text-[10px] font-mono text-primary-green">
                            <span className="animate-pulse">LOADING: DOOMSCROLL_PROTOCOL</span>
                            <span>[ 99% ]</span>
                        </div>
                        <div className="h-1 w-full bg-gray-800 mt-1">
                            <motion.div 
                                className="h-full bg-primary-green" 
                                initial={{ width: 0 }}
                                animate={{ width: "100%" }}
                                transition={{ duration: 2.0, ease: "circOut" }}
                            />
                        </div>
                    </div>
                </div>
                </motion.div>
            )}

            </AnimatePresence>
        </div>

        {/* FOOTER */}
        <div className={clsx("px-4 py-2 border-t bg-black/80 flex justify-between items-center text-[9px] font-mono transition-colors duration-500", currentStep.border)}>
            <span className={currentStep.color}>{currentStep.id}_MODULE_ACTIVE</span>
            <span className="opacity-50">SECURE_CHANNEL: FALSE</span>
        </div>

        {/* Progress Bar (Global) */}
        <div className="absolute bottom-0 left-0 h-0.5 bg-gray-900 w-full z-20">
            <motion.div 
                className={clsx("h-full transition-colors duration-500", currentStep.id === 'DENIED' ? "bg-critical-red" : "bg-primary-green")}
                initial={{ width: "0%" }}
                animate={{ width: `${((stepIndex + 1) / STEPS.length) * 100}%` }}
                transition={{ duration: 0.5 }}
            />
        </div>
      </motion.div>
    </div>
  );
};


=====================================
FILE: ./src/features/mobile/MobileExperience.tsx
=====================================
import { useState, useEffect } from 'react';
import { MobileRejectionModal } from './MobileRejectionModal';
import { Canvas } from '@react-three/fiber';
import { MobileGameDirector } from '@/game/components/MobileGameDirector';
import { RenderDirector } from '@/game/components/RenderDirector';
import { ScreenShaker } from '@/game/components/ScreenShaker';
import { SocialRow } from '@/ui/molecules/SocialRow';
import { useGameStore } from '@/game/store/useGameStore';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { Skull, Monitor, ExternalLink, AlertTriangle } from 'lucide-react';
import { PanelRegistry } from '@/game/systems/PanelRegistrySystem';
import { GlassPanel } from '@/ui/atoms/GlassPanel';
import { motion, AnimatePresence } from 'framer-motion';
import { clsx } from 'clsx';

// Constants
const MOBILE_PANEL_HP = 5000;

const SocialPanelWrapper = () => {
    useEffect(() => {
        // Boost health: Default is 1000. Add 4000 to reach 5000.
        PanelRegistry.healPanel('social', 4000); 
    }, []);

    return (
        <div className="w-full max-w-sm pointer-events-auto">
            {/* UPDATED: Pass maxHealth so the bar isn't stuck at 100% */}
            <GlassPanel title="SOCIAL_UPLINK" gameId="social" className="bg-black/90" maxHealth={MOBILE_PANEL_HP}>
                <SocialRow layout="column" />
            </GlassPanel>
        </div>
    );
};

export const MobileExperience = () => {
  const [phase, setPhase] = useState<'intro' | 'game'>('intro');
  const [showFailureModal, setShowFailureModal] = useState(false);
  const setIntegrity = useGameStore(s => (val: number) => useGameStore.setState({ systemIntegrity: val }));

  useEffect(() => {
      const unsub = GameEventBus.subscribe(GameEvents.PANEL_DESTROYED, (p) => {
          if (p.id === 'social') {
              AudioSystem.playSound('fx_player_death');
              
              // 1. Trigger Global Game Over (Turns Grid Red, Shatters Panel)
              setIntegrity(0);

              // 2. Wait 4 seconds (Longer fall) before showing modal
              setTimeout(() => {
                  setShowFailureModal(true);
                  AudioSystem.playSound('fx_impact_heavy');
              }, 4000);
          }
      });
      return unsub;
  }, [setIntegrity]);

  return (
    <div className="absolute inset-0 z-[80] w-full h-full overflow-hidden text-primary-green pointer-events-none">
        
        {/* PHASE 1: Rejection Cutscene */}
        {phase === 'intro' && (
            <div className="pointer-events-auto w-full h-full relative z-50">
                <MobileRejectionModal onComplete={() => setPhase('game')} />
            </div>
        )}

        {/* PHASE 2: Gameplay */}
        {phase === 'game' && (
            <>
                <div className="absolute inset-0 z-0 pointer-events-auto">
                    <Canvas
                        orthographic
                        camera={{ zoom: 40, position: [0, 0, 100] }}
                        gl={{ alpha: true, antialias: true }}
                    >
                        <MobileGameDirector />
                        <ScreenShaker />
                        <RenderDirector />
                    </Canvas>
                </div>

                <div className="absolute inset-0 z-10 flex items-center justify-center p-4">
                    <SocialPanelWrapper />
                </div>
                
                {/* Instructions */}
                {!showFailureModal && (
                    <div className="absolute bottom-10 w-full text-center animate-pulse z-20">
                        <span className="bg-black/80 px-4 py-1 text-xs font-mono border border-primary-green/30">
                            TAP TARGETS TO DESTROY
                        </span>
                    </div>
                )}

                {/* PHASE 3: SYSTEM FAILURE OVERLAY */}
                <AnimatePresence>
                    {showFailureModal && (
                        <motion.div 
                            initial={{ opacity: 0 }} 
                            animate={{ opacity: 1 }} 
                            transition={{ duration: 0.5 }}
                            className="absolute inset-0 z-50 bg-black/60 backdrop-blur-sm flex items-center justify-center p-6 pointer-events-auto"
                        >
                            <motion.div 
                                initial={{ scale: 0.8, y: 20 }}
                                animate={{ scale: 1, y: 0 }}
                                transition={{ type: "spring", bounce: 0.4 }}
                                className="w-full max-w-sm border-2 border-critical-red bg-black shadow-[0_0_50px_rgba(255,0,60,0.4)] overflow-hidden flex flex-col"
                            >
                                <div className="bg-critical-red px-4 py-2 flex items-center justify-between">
                                    <div className="flex items-center gap-2 text-black font-black tracking-widest">
                                        <AlertTriangle size={18} />
                                        <span>CRITICAL_ERROR</span>
                                    </div>
                                    <Skull size={18} className="text-black" />
                                </div>

                                <div className="p-8 flex flex-col items-center text-center relative">
                                    <div className="absolute inset-0 opacity-10 bg-[repeating-linear-gradient(45deg,transparent,transparent_10px,#FF003C_10px,#FF003C_12px)] pointer-events-none" />
                                    
                                    <motion.div 
                                        initial={{ scale: 0 }} animate={{ scale: 1 }} 
                                        transition={{ type: 'spring', stiffness: 200, damping: 12 }}
                                        className="mb-6 relative"
                                    >
                                        <Skull size={80} className="text-critical-red mx-auto drop-shadow-[0_0_15px_#FF003C]" />
                                    </motion.div>

                                    <h1 className="text-4xl font-black text-critical-red tracking-widest mb-2 glitch-text">
                                        SYSTEM<br/>FAILURE
                                    </h1>
                                    
                                    <p className="text-xs font-mono text-critical-red/70 mb-8 uppercase tracking-widest">
                                        0x0000DEAD // CORE_DUMPED
                                    </p>

                                    <div className="w-full space-y-3 relative z-10">
                                        <div className="bg-critical-red/10 border border-critical-red/30 p-3">
                                            <p className="text-[10px] text-critical-red font-mono leading-relaxed">
                                                MOBILE_TERMINAL_DESTROYED.<br/>
                                                PLEASE MIGRATE TO WORKSTATION.
                                            </p>
                                        </div>

                                        <a 
                                            href="https://mesoelfy.github.io" 
                                            target="_blank"
                                            rel="noopener noreferrer"
                                            className="group block w-full py-3 bg-critical-red text-black font-bold font-header tracking-widest hover:bg-white hover:text-critical-red transition-all flex items-center justify-center gap-2"
                                        >
                                            <Monitor size={16} />
                                            <span>mesoelfy.github.io</span>
                                            <ExternalLink size={14} className="opacity-50 group-hover:opacity-100" />
                                        </a>
                                    </div>
                                </div>
                                
                                <div className="bg-gray-900 px-4 py-1 flex justify-between text-[8px] font-mono text-gray-500">
                                    <span>ERR_CODE: ID_10_T</span>
                                    <span>REBOOT_REQUIRED</span>
                                </div>
                            </motion.div>
                        </motion.div>
                    )}
                </AnimatePresence>
            </>
        )}
    </div>
  );
};


=====================================
FILE: ./src/features/feed/FeedModal.tsx
=====================================
import { ModalContainer } from '@/ui/overlays/ModalContainer';
import feed from '@/data/feed.json';
import { ExternalLink } from 'lucide-react';

export const FeedModal = () => {
  return (
    <ModalContainer title="SYSTEM_LOGS // FEED" type="feed">
      <div className="space-y-6 font-mono">
        {feed.map((post) => (
          <div key={post.id} className="border-l-2 border-primary-green-dim pl-4 py-2 hover:bg-primary-green/5 transition-colors group">
            <div className="flex items-center gap-4 mb-2">
              <span className="text-xs text-primary-green-dim bg-primary-green-dark/30 px-2 py-1 rounded">
                [{post.date}]
              </span>
              <h3 className="text-xl font-bold text-primary-green group-hover:text-alert-yellow transition-colors">
                {post.title}
              </h3>
            </div>
            
            <p className="text-primary-green-dim/80 mb-3 max-w-2xl">
              {post.desc}
            </p>

            <a 
              href={post.link}
              target="_blank"
              rel="noopener noreferrer"
              className="inline-flex items-center gap-2 text-sm text-latent-purple-light hover:text-primary-green underline decoration-latent-purple-dim decoration-dashed underline-offset-4"
            >
              <span>VIEW_SOURCE</span>
              <ExternalLink size={14} />
            </a>
          </div>
        ))}
        
        {/* End of Log Marker */}
        <div className="text-center py-8 text-primary-green-dim/30 animate-pulse">
          -- END OF STREAM --
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/features/debug/tabs/OverridesTab.tsx
=====================================
import { Play, Sparkles, Trash2, Skull, RefreshCw, Crown, Ghost, Shield, Crosshair } from 'lucide-react';
import { clsx } from 'clsx';
import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { PanelRegistry } from '@/game/systems/PanelRegistrySystem';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';
import { AudioSystem } from '@/core/audio/AudioSystem';

interface OverridesTabProps {
  closeDebug: () => void;
}

export const OverridesTab = ({ closeDebug }: OverridesTabProps) => {
  const { setIntroDone, setBootState, bootState, resetApplication, debugFlags, setDebugFlag, resetDebugFlags } = useStore();
  const { startGame, stopGame, activateZenMode } = useGameStore();

  const areAllGodModesOn = debugFlags.godMode && debugFlags.panelGodMode && debugFlags.peaceMode;

  const handleSkipBoot = () => {
    resetDebugFlags();
    setIntroDone(true);
    setBootState('active');
    AudioSystem.init();
    AudioSystem.startMusic();
    startGame();
    closeDebug(); 
  };

  const executeCrash = () => {
    useGameStore.setState({ systemIntegrity: 0 });
    PanelRegistry.destroyAll();
    GameEventBus.emit(GameEvents.GAME_OVER, { score: 0 });
    stopGame();
  };

  const handleForceCrash = () => {
    if (bootState === 'standby') {
        setIntroDone(true);
        setBootState('active');
        AudioSystem.init();
        setTimeout(() => {
            executeCrash();
        }, 100);
    } else {
        executeCrash();
    }
    closeDebug();
  };

  const handleReboot = () => {
    useGameStore.setState({ playerHealth: 100, playerRebootProgress: 0 });
    const panels = PanelRegistry.getAllPanels();
    panels.forEach(p => PanelRegistry.healPanel(p.id, 1000));
    closeDebug();
  };

  const handleZenModeWrapper = () => {
      if (bootState === 'standby') {
          setIntroDone(true);
          setBootState('active');
          AudioSystem.init();
          AudioSystem.startMusic();
      }
      activateZenMode();
      closeDebug();
  };

  const handleSystemFormat = () => {
      resetApplication();
  };

  const toggleGodSuite = () => {
      const newState = !areAllGodModesOn;
      // Play sound before state change
      if (newState) {
          AudioSystem.playSound('powerup');
      } else {
          AudioSystem.playSound('ui_click');
      }
      setDebugFlag('godMode', newState);
      setDebugFlag('panelGodMode', newState);
      setDebugFlag('peaceMode', newState);
  };

  const btnClass = "flex items-center justify-center gap-2 p-3 border transition-all text-xs font-bold";

  return (
    <div className="space-y-6">
      
      <div className="space-y-3">
        <h3 className="text-xs text-primary-green-dim border-b border-primary-green-dim/30 pb-1 mb-2">SCENE_SELECT</h3>
        <div className="grid grid-cols-2 gap-3">
          <button 
            onClick={handleSkipBoot} 
            onMouseEnter={() => AudioSystem.playHover()}
            className={`${btnClass} border-primary-green/50 hover:bg-primary-green hover:text-black`}
          >
            <Play size={14} /> SKIP_BOOT
          </button>
          
          <button 
            onClick={handleZenModeWrapper} 
            onMouseEnter={() => AudioSystem.playHover()}
            className="relative flex items-center justify-center gap-2 p-3 overflow-hidden group transition-all duration-300 border border-transparent hover:border-white/50"
          >
            <div className="absolute inset-0 opacity-20 group-hover:opacity-40 bg-gradient-to-r from-red-500 via-yellow-500 via-green-500 via-blue-500 to-purple-500 animate-gradient-xy transition-opacity" />
            <div className="relative z-10 flex items-center gap-2 text-transparent bg-clip-text bg-gradient-to-r from-red-400 via-yellow-400 to-blue-400 font-bold tracking-widest text-xs group-hover:text-white transition-colors">
                <Sparkles size={14} className="text-yellow-300" /> ZEN_MODE
            </div>
          </button>
          <button 
            onClick={handleSystemFormat} 
            onMouseEnter={() => AudioSystem.playHover()}
            className="col-span-2 flex items-center justify-center gap-2 p-3 border border-gray-500/50 text-gray-400 hover:bg-white hover:text-black transition-all text-xs font-bold"
          >
            <Trash2 size={14} /> SYSTEM_FORMAT
          </button>
        </div>
      </div>

      <div className="space-y-3">
        <h3 className="text-xs text-primary-green-dim border-b border-primary-green-dim/30 pb-1 mb-2">STATE_OVERRIDES</h3>
        <div className="grid grid-cols-2 gap-3">
          <button 
            onClick={handleForceCrash} 
            onMouseEnter={() => AudioSystem.playHover()}
            className={`${btnClass} border-critical-red/50 text-critical-red hover:bg-critical-red hover:text-black`}
          >
            <Skull size={14} /> FORCE_CRASH
          </button>
          <button 
            onClick={handleReboot} 
            onMouseEnter={() => AudioSystem.playHover()}
            className={`${btnClass} border-latent-purple/50 text-latent-purple hover:bg-latent-purple hover:text-black`}
          >
            <RefreshCw size={14} /> REBOOT_CORE
          </button>
        </div>
      </div>

      <div className="space-y-3">
        <h3 className="text-xs text-primary-green-dim border-b border-primary-green-dim/30 pb-1 mb-2">GOD_SUITE</h3>
        
        <button 
          onClick={toggleGodSuite}
          onMouseEnter={() => AudioSystem.playHover()}
          className={clsx(
              "w-full flex items-center justify-center gap-2 p-2 mb-3 text-xs font-bold transition-all border",
              areAllGodModesOn
                  ? "bg-primary-green text-black border-primary-green shadow-[0_0_10px_rgba(0,255,65,0.4)]" 
                  : "bg-primary-green/10 text-primary-green border-primary-green/50 hover:bg-primary-green hover:text-black"
          )}
        >
          <Crown size={14} className={areAllGodModesOn ? "fill-black" : ""} />
          {areAllGodModesOn ? "DISABLE_ALL" : "ENABLE_MAX_POWER"}
        </button>

        <label 
          data-interactive="true"
          onMouseEnter={() => AudioSystem.playHover()}
          className="flex items-center justify-between p-3 border border-primary-green/30 hover:border-primary-green hover:bg-primary-green/20 cursor-pointer transition-all select-none"
        >
          <span className="text-xs font-bold flex items-center gap-2"><Ghost size={14} /> GHOST_MODE (Player Invincible)</span>
          <input 
            type="checkbox" 
            checked={debugFlags.godMode} 
            onChange={(e) => setDebugFlag('godMode', e.target.checked)}
            className="accent-primary-green cursor-pointer"
          />
        </label>

        <label 
          data-interactive="true"
          onMouseEnter={() => AudioSystem.playHover()}
          className="flex items-center justify-between p-3 border border-primary-green/30 hover:border-primary-green hover:bg-primary-green/20 cursor-pointer transition-all select-none"
        >
          <span className="text-xs font-bold flex items-center gap-2"><Shield size={14} /> FORTRESS_MODE (Panels Invincible)</span>
          <input 
            type="checkbox" 
            checked={debugFlags.panelGodMode} 
            onChange={(e) => setDebugFlag('panelGodMode', e.target.checked)}
            className="accent-primary-green cursor-pointer"
          />
        </label>

        <label 
          data-interactive="true"
          onMouseEnter={() => AudioSystem.playHover()}
          className="flex items-center justify-between p-3 border border-primary-green/30 hover:border-primary-green hover:bg-primary-green/20 cursor-pointer transition-all select-none"
        >
          <span className="text-xs font-bold flex items-center gap-2"><Crosshair size={14} /> PEACE_PROTOCOL (No Spawns)</span>
          <input 
            type="checkbox" 
            checked={debugFlags.peaceMode} 
            onChange={(e) => setDebugFlag('peaceMode', e.target.checked)}
            className="accent-primary-green cursor-pointer"
          />
        </label>
      </div>

    </div>
  );
};


=====================================
FILE: ./src/features/debug/tabs/ConsoleTab.tsx
=====================================
import { useEffect, useRef, useState } from 'react';
import { Copy, Check } from 'lucide-react';
import { AudioSystem } from '@/core/audio/AudioSystem';

interface ConsoleTabProps {
  logs: { time: string, msg: string, type: string }[];
}

export const ConsoleTab = ({ logs }: ConsoleTabProps) => {
  const logEndRef = useRef<HTMLDivElement>(null);
  const [copied, setCopied] = useState(false);

  useEffect(() => {
    if (logEndRef.current) {
        logEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [logs]);

  const handleCopy = () => {
      const text = logs.map(l => `[${l.time}] ${l.msg}`).join('\n');
      navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
      AudioSystem.playClick();
  };

  return (
    <div className="h-full flex flex-col relative">
        <div className="flex-1 overflow-y-auto font-mono text-[10px] space-y-1 pr-2 pb-8">
            {logs.length === 0 && (
                <div className="text-primary-green-dim opacity-50 italic mt-4">-- NO SIGNIFICANT EVENTS --</div>
            )}
            {logs.map((l, i) => (
                <div key={i} className="flex gap-2 opacity-80 hover:opacity-100 border-b border-white/5 py-0.5">
                    <span className="text-primary-green-dim shrink-0">[{l.time}]</span>
                    <span className={l.type.includes('ERROR') || l.type.includes('CRITICAL') ? 'text-critical-red font-bold' : 'text-primary-green break-all'}>{l.msg}</span>
                </div>
            ))}
            <div ref={logEndRef} />
        </div>
        
        <button 
            onClick={handleCopy}
            onMouseEnter={() => AudioSystem.playHover()}
            className="absolute bottom-0 right-0 flex items-center gap-2 bg-primary-green/10 hover:bg-primary-green/20 border border-primary-green/30 text-primary-green px-3 py-1.5 text-xs font-bold transition-all backdrop-blur-sm"
        >
            {copied ? <Check size={12} /> : <Copy size={12} />}
            {copied ? "COPIED" : "COPY LOG"}
        </button>
    </div>
  );
};


=====================================
FILE: ./src/features/debug/tabs/StatsTab.tsx
=====================================
import { Cpu, Database, LayoutTemplate } from 'lucide-react';
import { useStore } from '@/core/store/useStore';
import { AudioSystem } from '@/core/audio/AudioSystem';

interface StatsTabProps {
  stats: { active: number, pooled: number, total: number, fps: number };
}

export const StatsTab = ({ stats }: StatsTabProps) => {
  const { toggleDebugMinimize } = useStore();
  
  return (
    <div className="space-y-6">
      <div className="space-y-3">
        <h3 className="text-xs text-primary-green-dim border-b border-primary-green-dim/30 pb-1 mb-2">ENTITY_REGISTRY</h3>
        <div className="grid grid-cols-2 gap-4">
          <div className="bg-primary-green/5 p-4 border border-primary-green/20">
              <div className="flex items-center gap-2 text-primary-green-dim mb-2 text-xs"><Cpu size={14} /> ACTIVE ENTITIES</div>
              <div className="text-3xl font-bold text-primary-green">{stats.active}</div>
          </div>
          <div className="bg-primary-green/5 p-4 border border-primary-green/20">
              <div className="flex items-center gap-2 text-primary-green-dim mb-2 text-xs"><Database size={14} /> MEMORY POOL</div>
              <div className="text-3xl font-bold text-primary-green-dim">{stats.pooled} <span className="text-xs font-normal opacity-50">/ {stats.total}</span></div>
          </div>
        </div>
      </div>
      <div className="space-y-3">
        <h3 className="text-xs text-primary-green-dim border-b border-primary-green-dim/30 pb-1 mb-2">RENDER_PIPELINE</h3>
        <div className="p-4 border border-primary-green/20 bg-black">
            <div className="flex justify-between items-end">
                <span className="text-xs text-primary-green-dim">FRAME_RATE</span>
                <span className="text-xl font-bold text-primary-green">{stats.fps} FPS</span>
            </div>
            <div className="w-full h-1 bg-gray-900 mt-2">
                <div className="h-full bg-primary-green" style={{ width: `${Math.min(100, (stats.fps / 60) * 100)}%` }} />
            </div>
        </div>
      </div>
      
      <div className="mt-8 flex justify-center">
          <button 
            onClick={() => { toggleDebugMinimize(); AudioSystem.playSound('ui_menu_close'); }}
            onMouseEnter={() => AudioSystem.playHover()}
            className="flex items-center gap-2 text-xs text-primary-green hover:text-white transition-colors border border-primary-green/50 px-4 py-2 hover:bg-primary-green/10"
          >
              <LayoutTemplate size={14} /> SWITCH TO MINI_MODE
          </button>
      </div>
    </div>
  );
};


=====================================
FILE: ./src/features/debug/tabs/SandboxTab.tsx
=====================================
import { Box } from 'lucide-react';
import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { ServiceLocator } from '@/game/core/ServiceLocator';
import { AudioSystem } from '@/core/audio/AudioSystem';

interface SandboxTabProps {
  closeDebug: () => void;
}

export const SandboxTab = ({ closeDebug }: SandboxTabProps) => {
  const { setIntroDone, setBootState } = useStore();
  const { startGame } = useGameStore();

  const enterSandbox = () => {
      AudioSystem.init();
      AudioSystem.startMusic();
      setIntroDone(true);
      setBootState('sandbox');
      try {
          const reg = ServiceLocator.getRegistry();
          if (reg) reg.clear();
      } catch {}
      startGame();
      closeDebug();
  };

  return (
    <div className="h-full flex flex-col items-center justify-center gap-6 text-center">
        <Box size={64} className="text-primary-green animate-pulse" />
        <div>
            <h2 className="text-xl font-bold mb-2">INITIALIZE_SIMULATION?</h2>
            <p className="text-xs text-primary-green-dim max-w-xs mx-auto">
                Loads the 'Holo-Deck' simulation environment. The main OS will be suspended.
            </p>
        </div>
        <button 
            onClick={enterSandbox}
            onMouseEnter={() => AudioSystem.playHover()}
            className="px-8 py-3 bg-primary-green text-black font-bold tracking-widest hover:bg-white transition-colors"
        >
            [ ENTER_HOLO_DECK ]
        </button>
    </div>
  );
};


=====================================
FILE: ./src/features/debug/DebugOverlay.tsx
=====================================
import { useEffect, useState } from 'react';
import { useStore } from '@/core/store/useStore';
import { ServiceLocator } from '@/game/core/ServiceLocator';
import { TimeSystem } from '@/game/systems/TimeSystem';
import { Terminal, Box, Activity, Shield, MinusSquare, X, Maximize2, Cpu, Database } from 'lucide-react';
import { clsx } from 'clsx';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';
import { AudioSystem } from '@/core/audio/AudioSystem';

import { OverridesTab } from './tabs/OverridesTab';
import { SandboxTab } from './tabs/SandboxTab';
import { StatsTab } from './tabs/StatsTab';
import { ConsoleTab } from './tabs/ConsoleTab';

type Tab = 'OVERRIDES' | 'SANDBOX' | 'STATS' | 'CONSOLE';

const TABS: { id: Tab, label: string, icon: any }[] = [
  { id: 'OVERRIDES', label: 'ROOT_ACCESS', icon: Shield },
  { id: 'SANDBOX', label: 'HOLO_DECK', icon: Box },
  { id: 'STATS', label: 'TELEMETRY', icon: Activity },
  { id: 'CONSOLE', label: 'KERNEL_LOG', icon: Terminal },
];

const IGNORED_EVENTS = new Set([
    GameEvents.PLAYER_FIRED,
    GameEvents.PLAYER_HIT,
    GameEvents.ENEMY_DAMAGED,
    GameEvents.ENEMY_SPAWNED,
    GameEvents.PANEL_DAMAGED,
    GameEvents.PROJECTILE_CLASH,
    GameEvents.SPAWN_FX,
]);

export const DebugOverlay = () => {
  const { isDebugOpen, isDebugMinimized, toggleDebugMenu, setDebugFlag, bootState, resetApplication, toggleSettings, activeModal, closeModal, openModal } = useStore();
  const [activeTab, setActiveTab] = useState<Tab>('OVERRIDES');
  const [stats, setStats] = useState({ active: 0, pooled: 0, total: 0, fps: 0 });
  const [logs, setLogs] = useState<{ time: string, msg: string, type: string }[]>([]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === '`' || e.key === '~') {
        const willBeOpen = !isDebugOpen && !isDebugMinimized;
        
        if (willBeOpen) {
            setDebugFlag('godMode', true);
            setDebugFlag('panelGodMode', true);
            setDebugFlag('peaceMode', true);
        }

        if (activeModal === 'settings') {
            closeModal();
            useStore.setState({ isDebugOpen: true, isDebugMinimized: false });
            AudioSystem.playSound('ui_menu_open');
        } 
        else if (isDebugMinimized) {
             useStore.setState({ isDebugMinimized: false, isDebugOpen: true });
             AudioSystem.playSound('ui_menu_open');
        } 
        else {
             toggleDebugMenu();
             AudioSystem.playSound(!isDebugOpen ? 'ui_menu_open' : 'ui_menu_close');
        }
      } 
      
      else if (e.key === 'Escape') {
          if (isDebugOpen) {
              toggleDebugMenu();
              openModal('settings');
              AudioSystem.playSound('ui_menu_open'); 
          } else if (activeModal !== 'none') {
              closeModal();
              AudioSystem.playSound('ui_menu_close');
          } else {
              toggleSettings();
              AudioSystem.playSound('ui_menu_open');
          }
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [toggleDebugMenu, isDebugMinimized, isDebugOpen, setDebugFlag, activeModal, toggleSettings, closeModal, openModal]);

  useEffect(() => {
    const handlers = Object.values(GameEvents).map(evt => {
        return GameEventBus.subscribe(evt as any, (payload) => {
            if (IGNORED_EVENTS.has(evt as GameEvents)) return;

            const time = new Date().toLocaleTimeString().split(' ')[0];
            let msg = `${evt}`;
            
            if (evt === GameEvents.LOG_DEBUG && payload && (payload as any).msg) {
                const p = payload as any;
                msg = p.source ? `[${p.source}] ${p.msg}` : p.msg;
            } else if (payload && (payload as any).type) {
                msg += ` [${(payload as any).type}]`;
            } else if (payload && (payload as any).id) {
                msg += ` [ID:${(payload as any).id}]`;
            }
            
            setLogs(prev => [...prev.slice(-99), { time, msg, type: evt }]);
        });
    });

    const pollInterval = setInterval(() => {
        if (!isDebugOpen && !isDebugMinimized) return;
        let fps = 0;
        let regStats = { active: 0, pooled: 0, totalAllocated: 0 };
        try {
            const timeSys = ServiceLocator.getSystem<TimeSystem>('TimeSystem');
            fps = timeSys.fps;
            const reg = ServiceLocator.getRegistry();
            if (reg) regStats = reg.getStats();
        } catch {}

        setStats({
            active: regStats.active,
            pooled: regStats.pooled,
            total: regStats.totalAllocated,
            fps: fps
        });
    }, 250); 

    return () => {
        handlers.forEach(unsub => unsub());
        clearInterval(pollInterval);
    };
  }, [isDebugOpen, isDebugMinimized]);

  if (!isDebugOpen && !isDebugMinimized) return null;

  if (bootState === 'sandbox') {
      return (
        <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/60 backdrop-blur-sm font-mono pointer-events-auto">
            <div className="bg-black border border-service-cyan p-8 w-96 shadow-[0_0_50px_rgba(0,240,255,0.2)] text-center">
                <h2 className="text-xl font-bold text-service-cyan mb-6 tracking-widest">SIMULATION_PAUSED</h2>
                <div className="flex flex-col gap-4">
                    <button onClick={toggleDebugMenu} onMouseEnter={() => AudioSystem.playHover()} className="p-3 border border-primary-green text-primary-green hover:bg-primary-green hover:text-black font-bold tracking-wider transition-colors">RESUME</button>
                    <button onClick={resetApplication} onMouseEnter={() => AudioSystem.playHover()} className="p-3 border border-critical-red text-critical-red hover:bg-critical-red hover:text-black font-bold tracking-wider transition-colors">EXIT_TO_BOOT</button>
                </div>
            </div>
        </div>
      );
  }

  if (isDebugMinimized) {
      return (
        <div className="fixed top-1/2 -translate-y-1/2 left-0 z-[10000] p-2 pointer-events-auto">
            <div className="bg-black/90 border border-primary-green/30 p-3 rounded-r shadow-[0_0_15px_rgba(0,255,65,0.1)] flex flex-col gap-2 min-w-[140px] pointer-events-auto cursor-default">
                <div className="flex items-center justify-between border-b border-primary-green/20 pb-1 mb-1">
                    <span className="text-[10px] font-bold text-primary-green tracking-wider">DEBUG_LIVE</span>
                    <button 
                        onClick={() => { useStore.setState({ isDebugMinimized: false, isDebugOpen: true }); AudioSystem.playSound('ui_menu_open'); }} 
                        onMouseEnter={() => AudioSystem.playHover()}
                        className="text-primary-green hover:text-white bg-white/10 p-1 rounded hover:bg-white/20 transition-colors"
                    >
                        <Maximize2 size={12} />
                    </button>
                </div>
                <div className="flex items-center justify-between text-[10px] font-mono text-primary-green-dim"><span className="flex items-center gap-1"><Activity size={10} /> FPS</span><span className="text-primary-green font-bold">{stats.fps}</span></div>
                <div className="flex items-center justify-between text-[10px] font-mono text-primary-green-dim"><span className="flex items-center gap-1"><Cpu size={10} /> ENT</span><span className="text-primary-green font-bold">{stats.active}</span></div>
                <button 
                    onClick={() => { useStore.setState({ isDebugMinimized: false, isDebugOpen: false }); AudioSystem.playSound('ui_menu_close'); }} 
                    onMouseEnter={() => AudioSystem.playHover()}
                    className="text-[9px] bg-critical-red/10 border border-critical-red/30 text-critical-red hover:bg-critical-red hover:text-black py-1.5 uppercase font-bold transition-colors w-full flex justify-center"
                >
                    CLOSE_DEBUG
                </button>
            </div>
        </div>
      );
  }

  return (
    <div className="fixed inset-0 z-[10000] flex items-center justify-center bg-black/80 backdrop-blur-md font-mono text-primary-green p-4 pointer-events-auto">
      <div className="w-full max-w-3xl bg-black border border-primary-green shadow-[0_0_50px_rgba(0,255,65,0.2)] flex flex-col h-[600px] overflow-hidden relative">
        <div className="h-10 border-b border-primary-green/50 bg-primary-green/10 flex items-center justify-center relative px-4 shrink-0">
          <div className="flex items-center gap-2"><Terminal size={16} /><span className="font-bold tracking-widest">KERNEL_ROOT_ACCESS // DEBUG_SUITE</span></div>
          <div className="absolute right-4 flex items-center gap-2">
             <button 
                onClick={() => { useStore.setState({ isDebugMinimized: true, isDebugOpen: false }); AudioSystem.playSound('ui_menu_close'); }} 
                onMouseEnter={() => AudioSystem.playHover()}
                className="hover:text-white transition-colors p-1"
             >
                <MinusSquare size={16} />
             </button>
             <button 
                onClick={() => { toggleDebugMenu(); AudioSystem.playSound('ui_menu_close'); }} 
                onMouseEnter={() => AudioSystem.playHover()}
                className="hover:text-white transition-colors p-1"
             >
                <X size={16} />
             </button>
          </div>
        </div>
        <div className="flex flex-1 min-h-0">
          <div className="w-48 border-r border-primary-green/30 bg-black/50 flex flex-col">
            {TABS.map(tab => (
              <button 
                key={tab.id} 
                onClick={() => { setActiveTab(tab.id); AudioSystem.playClick(); }} 
                onMouseEnter={() => AudioSystem.playHover()}
                className={clsx("p-3 text-left text-xs font-bold tracking-wider border-b border-primary-green/10 flex items-center gap-2 transition-all hover:bg-primary-green/20", activeTab === tab.id ? "bg-primary-green text-black" : "text-primary-green-dim")}
              >
                <tab.icon size={14} />{tab.label}
              </button>
            ))}
          </div>
          <div className="flex-1 p-6 overflow-y-auto scrollbar-thin scrollbar-thumb-primary-green scrollbar-track-black">
            {activeTab === 'OVERRIDES' && <OverridesTab closeDebug={() => { toggleDebugMenu(); AudioSystem.playSound('ui_menu_close'); }} />}
            {activeTab === 'SANDBOX' && <SandboxTab closeDebug={() => { toggleDebugMenu(); AudioSystem.playSound('ui_menu_close'); }} />}
            {activeTab === 'STATS' && <StatsTab stats={stats} />}
            {activeTab === 'CONSOLE' && <ConsoleTab logs={logs} />}
          </div>
        </div>
        <div className="h-6 bg-primary-green/5 border-t border-primary-green/30 flex items-center px-4 text-[9px] text-primary-green-dim">
          <span>ROOT_ACCESS_GRANTED // EVENTS_FILTERED</span>
        </div>
      </div>
    </div>
  );
};


=====================================
FILE: ./src/game/types/game.types.ts
=====================================
export interface RegisteredPanel {
  id: string;
  element: HTMLElement;
  health: number;
  isDestroyed: boolean;
}

export type UpgradeOption = 
  | 'OVERCLOCK'      // Attack Speed
  | 'EXECUTE'        // Damage (Renamed from ROOT)
  | 'BANDWIDTH'      // Width
  | 'FORK'           // Multishot
  | 'SNIFFER'        // Homing Independent
  | 'BACKDOOR'       // Rear Gun
  | 'REPAIR_NANITES'; // Heal

export interface GameState {
  isPlaying: boolean;
  score: number;
  threatLevel: number;
  panels: Record<string, RegisteredPanel>;
  
  startGame: () => void;
  stopGame: () => void;
  registerPanel: (id: string, element: HTMLElement) => void;
  unregisterPanel: (id: string) => void;
  damagePanel: (id: string, amount: number) => void;
  healPanel: (id: string, amount: number) => void;
}

export interface Entity {
  id: number;
  x: number;
  y: number;
  radius: number;
  active: boolean;
  spawnTime: number; 
}


=====================================
FILE: ./src/game/core/MobileBootstrapper.ts
=====================================
import { ServiceLocator } from './ServiceLocator';
import { GameEngineCore } from './GameEngine';
import { EntityRegistry } from './ecs/EntityRegistry';
import { EntitySpawner } from './EntitySpawner';
import { registerAllBehaviors } from '../logic/ai/BehaviorCatalog';
import { registerAllAssets } from '../assets/AssetCatalog';

// Systems
import { TimeSystem } from '../systems/TimeSystem';
import { PhysicsSystem } from '../systems/PhysicsSystem';
import { LifeCycleSystem } from '../systems/LifeCycleSystem';
import { VFXSystem } from '../systems/VFXSystem';
import { AudioDirectorSystem } from '../systems/AudioDirectorSystem';
import { ShakeSystem } from '../systems/ShakeSystem';
import { StructureSystem } from '../systems/StructureSystem';
import { MobileWaveSystem } from '../systems/MobileWaveSystem';
import { TargetingSystem } from '../systems/TargetingSystem';
import { BehaviorSystem } from '../systems/BehaviorSystem';
import { PanelRegistry } from '../systems/PanelRegistrySystem';
import { GameStateSystem } from '../systems/GameStateSystem'; // Added

// Simplified Combat System for Tap-to-Kill
import { IGameSystem, ICombatSystem } from './interfaces';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { FastEventBus, FastEvents, FX_IDS } from './FastEventBus';
import { Entity } from './ecs/Entity';
import { TransformComponent } from '../components/data/TransformComponent';

// --- MICRO COMBAT SYSTEM (Mobile Specific) ---
class MobileCombatSystem implements IGameSystem, ICombatSystem {
    private registry!: EntityRegistry;

    setup(locator: ServiceLocator) {
        this.registry = locator.getRegistry() as EntityRegistry;
        
        // Listen for Tap Kills
        GameEventBus.subscribe(GameEvents.ENEMY_DAMAGED, (p) => {
            const entity = this.registry.getEntity(p.id);
            if (entity && entity.active) {
                this.kill(entity);
            }
        });
    }
    
    update() {}
    teardown() {}
    resolveCollision() {}

    private kill(entity: Entity) {
        const t = entity.getComponent<TransformComponent>('Transform');
        if (t) {
            const id = FX_IDS['EXPLOSION_PURPLE'];
            FastEventBus.emit(FastEvents.SPAWN_FX, id, t.x, t.y);
            AudioSystem.playSound('fx_impact_light');
        }
        this.registry.destroyEntity(entity.id);
    }
}

export const MobileBootstrapper = () => {
  ServiceLocator.reset();

  const registry = new EntityRegistry();
  const spawner = new EntitySpawner(registry);
  const engine = new GameEngineCore(registry);
  
  ServiceLocator.registerRegistry(registry);
  ServiceLocator.registerSpawner(spawner);

  // Initialize Catalogs
  registerAllBehaviors();
  registerAllAssets();

  // --- REGISTER LEAN SYSTEM STACK ---
  const systems: { id: string, sys: any }[] = [
      { id: 'TimeSystem', sys: new TimeSystem() },
      { id: 'PanelRegistrySystem', sys: PanelRegistry }, 
      { id: 'StructureSystem', sys: new StructureSystem() },
      { id: 'GameStateSystem', sys: new GameStateSystem() }, // Register Dependency
      { id: 'MobileWaveSystem', sys: new MobileWaveSystem() },
      { id: 'TargetingSystem', sys: new TargetingSystem() },
      { id: 'BehaviorSystem', sys: new BehaviorSystem() },
      { id: 'PhysicsSystem', sys: new PhysicsSystem() },
      { id: 'MobileCombatSystem', sys: new MobileCombatSystem() },
      { id: 'LifeCycleSystem', sys: new LifeCycleSystem() },
      { id: 'VFXSystem', sys: new VFXSystem() },
      { id: 'AudioDirectorSystem', sys: new AudioDirectorSystem() },
      { id: 'ShakeSystem', sys: new ShakeSystem() },
  ];

  systems.forEach(({ id, sys }) => {
      ServiceLocator.registerSystem(id, sys);
      engine.registerSystem(sys);
  });

  systems.forEach(({ id }) => {
      const sys = ServiceLocator.getSystem(id);
      sys.setup(ServiceLocator);
  });
  
  engine.setup(ServiceLocator);

  return engine;
};


=====================================
FILE: ./src/game/core/ComponentBuilder.ts
=====================================
import { ComponentPoolManager } from './ecs/ComponentPoolManager';
import { TransformComponent } from '../components/data/TransformComponent';
import { MotionComponent } from '../components/data/MotionComponent';
import { HealthComponent } from '../components/data/HealthComponent';
import { IdentityComponent } from '../components/data/IdentityComponent';
import { LifetimeComponent } from '../components/data/LifetimeComponent';
import { CombatComponent } from '../components/data/CombatComponent';
import { StateComponent } from '../components/data/StateComponent';
import { ColliderComponent } from '../components/data/ColliderComponent';
import { TargetComponent } from '../components/data/TargetComponent';
import { OrbitalComponent } from '../components/data/OrbitalComponent';
import { Component } from './ecs/Component';

type ComponentFactory = (data: any) => Component;

// Helper to acquire or create
const get = <T extends Component>(type: string, factory: () => T, reset: (c: T) => void): T => {
    const pooled = ComponentPoolManager.acquire<T>(type);
    if (pooled) {
        reset(pooled);
        return pooled;
    }
    return factory();
};

export const ComponentBuilder: Record<string, ComponentFactory> = {
  Transform: (data) => get('Transform', 
      () => new TransformComponent(data.x, data.y, data.rotation, data.scale),
      (c) => c.reset(data.x || 0, data.y || 0, data.rotation || 0, data.scale || 1)
  ),
  Motion: (data) => get('Motion',
      () => new MotionComponent(data.vx, data.vy, data.friction, data.angularVelocity),
      (c) => c.reset(data.vx || 0, data.vy || 0, data.friction || 0, data.angularVelocity || 0)
  ),
  Health: (data) => get('Health',
      () => new HealthComponent(data.max, data.invincibilityTime),
      (c) => c.reset(data.max, data.invincibilityTime || 0)
  ),
  Identity: (data) => get('Identity',
      () => new IdentityComponent(data.variant),
      (c) => c.reset(data.variant)
  ),
  Lifetime: (data) => get('Lifetime',
      () => new LifetimeComponent(data.remaining, data.total || data.remaining),
      (c) => c.reset(data.remaining, data.total || data.remaining)
  ),
  Combat: (data) => get('Combat',
      () => new CombatComponent(data.damage, data.cooldown, data.range),
      (c) => c.reset(data.damage, data.cooldown || 0, data.range || 0)
  ),
  State: (data) => get('State',
      () => new StateComponent(data.current, data.timers, data.data),
      (c) => c.reset(data.current, data.timers || {}, data.data || {})
  ),
  Collider: (data) => get('Collider',
      () => new ColliderComponent(data.radius, data.layer, data.mask),
      (c) => c.reset(data.radius, data.layer, data.mask)
  ),
  Target: (data) => get('Target',
      () => new TargetComponent(data.id, data.type, data.x, data.y, data.locked),
      (c) => c.reset(data.id, data.type, data.x, data.y, data.locked)
  ),
  Orbital: (data) => get('Orbital',
      () => new OrbitalComponent(data.parentId, data.radius, data.speed, data.angle, data.active),
      (c) => c.reset(data.parentId, data.radius, data.speed, data.angle, data.active)
  )
};


=====================================
FILE: ./src/game/core/ObjectPool.ts
=====================================
type FactoryFn<T> = () => T;
type ResetFn<T> = (item: T) => void;

export class ObjectPool<T> {
  private available: T[] = [];
  private factory: FactoryFn<T>;
  private resetFn: ResetFn<T>;
  private _totalCreated = 0;

  constructor(factory: FactoryFn<T>, resetFn: ResetFn<T>, initialSize: number = 100) {
    this.factory = factory;
    this.resetFn = resetFn;
    this.expand(initialSize);
  }

  private expand(amount: number) {
    // console.log(`[ObjectPool] Expanding by ${amount}. Total: ${this._totalCreated + amount}`);
    for (let i = 0; i < amount; i++) {
      this.available.push(this.factory());
    }
    this._totalCreated += amount;
  }

  public acquire(): T {
    if (this.available.length === 0) {
      // Dynamic expansion: Double current size or add 50, whichever is safer
      const expandAmount = Math.max(50, Math.floor(this._totalCreated * 0.5)); 
      this.expand(expandAmount);
    }

    const item = this.available.pop()!;
    this.resetFn(item); 
    return item;
  }

  public release(item: T) {
    // Optimization: In production, skip the .includes check for speed.
    // In dev, it saves sanity.
    // this.available.push(item);
    
    // Check duplication only if pool is small-ish to avoid O(N) lag? 
    // Actually, EntityRegistry manages active vs inactive, so we trust it.
    this.available.push(item);
  }

  public get totalSize() {
    return this._totalCreated;
  }
  
  public get availableSize() {
      return this.available.length;
  }
}


=====================================
FILE: ./src/game/core/GameBootstrapper.ts
=====================================
import { ServiceLocator } from './ServiceLocator';
import { GameEngineCore } from './GameEngine';
import { EntityRegistry } from './ecs/EntityRegistry';
import { EntitySpawner } from './EntitySpawner';
import { SYSTEM_MANIFEST } from '../config/SystemManifest';

// Registries
import { registerAllBehaviors } from '../logic/ai/BehaviorCatalog';
import { registerAllAssets } from '../assets/AssetCatalog'; // NEW

export const GameBootstrapper = () => {
  ServiceLocator.reset();

  const registry = new EntityRegistry();
  const spawner = new EntitySpawner(registry);
  const engine = new GameEngineCore(registry);
  
  ServiceLocator.registerRegistry(registry);
  ServiceLocator.registerSpawner(spawner);

  // Initialize Catalogs
  registerAllBehaviors();
  registerAllAssets(); // NEW

  // Boot Systems
  SYSTEM_MANIFEST.forEach(def => {
      const system = def.factory();
      ServiceLocator.registerSystem(def.id, system);
      engine.registerSystem(system);
  });

  SYSTEM_MANIFEST.forEach(def => {
      const system = ServiceLocator.getSystem(def.id);
      system.setup(ServiceLocator);
  });
  
  engine.setup(ServiceLocator);
  spawner.spawnPlayer();

  return engine;
};


=====================================
FILE: ./src/game/core/ecs/Component.ts
=====================================
export abstract class Component {
  // Use a static property for the type key to enforce consistency
  static readonly TYPE: string;
  abstract readonly _type: string;
}


=====================================
FILE: ./src/game/core/ecs/Entity.ts
=====================================
import { EntityID, Tag } from './types';
import { Component } from './Component';
import { ComponentPoolManager } from './ComponentPoolManager';

export class Entity {
  public id: EntityID; 
  public readonly tags = new Set<Tag>();
  public active = true;
  public pooled = false;

  public components = new Map<string, Component>();

  constructor(id: EntityID) {
    this.id = id;
  }

  public addComponent(component: Component): this {
    this.components.set(component._type, component);
    return this;
  }

  public getComponent<T extends Component>(type: string): T | undefined {
    return this.components.get(type) as T;
  }
  
  public requireComponent<T extends Component>(type: string): T {
    const c = this.components.get(type);
    if (!c) throw new Error(`Entity ${this.id} missing required component: ${type}`);
    return c as T;
  }

  public hasComponent(type: string): boolean {
    return this.components.has(type);
  }

  public addTag(tag: Tag): this {
    this.tags.add(tag);
    return this;
  }

  public hasTag(tag: Tag): boolean {
    return this.tags.has(tag);
  }

  // Called when pulled FROM the pool
  public reset(newId: EntityID) {
      this.id = newId;
      this.active = true;
      this.pooled = false;
      // Components are cleared in release(), but safety check:
      this.components.clear();
      this.tags.clear();
  }

  // Called when pushed TO the pool
  public release() {
      this.active = false;
      this.pooled = true;
      
      // Return all components to their respective pools
      for (const component of this.components.values()) {
          ComponentPoolManager.release(component);
      }
      
      this.components.clear(); 
      this.tags.clear();
  }
}


=====================================
FILE: ./src/game/core/ecs/TransformStore.ts
=====================================
import { MAX_ENTITIES } from '../Constants';

const STRIDE = 4; // X, Y, ROTATION, SCALE

class TransformStoreController {
  public data = new Float32Array(MAX_ENTITIES * STRIDE);
  private freeIndices: number[] = [];
  private nextIndex = 0;

  public alloc(): number {
    if (this.freeIndices.length > 0) {
      return this.freeIndices.pop()!;
    }
    
    if (this.nextIndex >= MAX_ENTITIES) {
      console.warn('[TransformStore] Buffer overflow!');
      return 0; 
    }

    return this.nextIndex++;
  }

  public free(index: number) {
    this.freeIndices.push(index);
  }
}

export const TransformStore = new TransformStoreController();


=====================================
FILE: ./src/game/core/ecs/types.ts
=====================================
// Nominal typing to prevent mixing up IDs with math numbers
export type EntityID = number & { __brand: 'EntityID' };

export const createEntityID = (id: number): EntityID => id as EntityID;

export enum Tag {
  PLAYER = 'PLAYER',
  ENEMY = 'ENEMY',
  BULLET = 'BULLET',
  PARTICLE = 'PARTICLE',
  OBSTACLE = 'OBSTACLE'
}


=====================================
FILE: ./src/game/core/ecs/ComponentPoolManager.ts
=====================================
import { Component } from './Component';

type CompConstructor = new (...args: any[]) => Component;

class ComponentPoolManagerController {
  private pools = new Map<string, Component[]>();

  // Acquire a component from the pool or create new if empty.
  // Note: We don't construct here because the Builder handles specific args.
  // We return null if empty, letting the Builder do the 'new'.
  public acquire<T extends Component>(type: string): T | null {
    const pool = this.pools.get(type);
    if (pool && pool.length > 0) {
      return pool.pop() as T;
    }
    return null;
  }

  public release(component: Component) {
    const type = component._type;
    if (!this.pools.has(type)) {
      this.pools.set(type, []);
    }
    this.pools.get(type)!.push(component);
  }
  
  public getStats() {
      const stats: Record<string, number> = {};
      for(const [key, pool] of this.pools) {
          stats[key] = pool.length;
      }
      return stats;
  }
}

export const ComponentPoolManager = new ComponentPoolManagerController();


=====================================
FILE: ./src/game/core/ecs/Query.ts
=====================================
import { Entity } from './Entity';

export interface QueryDef {
  all?: string[];  // Must have ALL these components
  any?: string[];  // Must have AT LEAST ONE of these
  none?: string[]; // Must NOT have any of these
}

export class Query {
  public readonly id: string;
  public readonly def: QueryDef;

  constructor(def: QueryDef) {
    this.def = def;
    // Generate a unique signature for this query to use as a Map key
    this.id = `ALL:${(def.all || []).sort().join(',')}|ANY:${(def.any || []).sort().join(',')}|NONE:${(def.none || []).sort().join(',')}`;
  }

  public matches(entity: Entity): boolean {
    if (this.def.all) {
      for (const type of this.def.all) {
        if (!entity.hasComponent(type)) return false;
      }
    }

    if (this.def.none) {
      for (const type of this.def.none) {
        if (entity.hasComponent(type)) return false;
      }
    }

    if (this.def.any && this.def.any.length > 0) {
      let hasAny = false;
      for (const type of this.def.any) {
        if (entity.hasComponent(type)) {
          hasAny = true;
          break;
        }
      }
      if (!hasAny) return false;
    }

    return true;
  }
}


=====================================
FILE: ./src/game/core/ecs/EntityRegistry.ts
=====================================
import { EntityID, createEntityID, Tag } from './types';
import { Entity } from './Entity';
import { ObjectPool } from '../ObjectPool';
import { IEntityRegistry } from '../interfaces';
import { Query, QueryDef } from './Query';
import { MAX_ENTITIES } from '../Constants';

export class EntityRegistry implements IEntityRegistry {
  private entities = new Map<EntityID, Entity>();
  
  // ID Management
  private nextId = 0;
  private freeIds: number[] = []; // Stack for recycled IDs
  
  private tagCache = new Map<Tag, Set<EntityID>>();
  private activeQueries = new Map<string, { query: Query, results: Set<Entity> }>();
  private entityPool: ObjectPool<Entity>;

  constructor() {
      this.entityPool = new ObjectPool<Entity>(
          () => new Entity(createEntityID(0)),
          (e) => {}, 
          1000 
      );
  }

  public createEntity(): Entity {
    let idNum: number;

    // 1. Try to recycle an ID
    if (this.freeIds.length > 0) {
        idNum = this.freeIds.pop()!;
    } else {
        idNum = ++this.nextId;
    }

    // 2. Safety Check (Prevent Array OOB in SpatialGrid)
    if (idNum >= MAX_ENTITIES) {
        console.warn(`[EntityRegistry] Max Entities Reached (${MAX_ENTITIES}). Recycling oldest logic needed.`);
        // In a real engine, we might kill the oldest particle here.
        // For now, we accept the risk or need to increase MAX_ENTITIES.
    }

    const newId = createEntityID(idNum);
    const entity = this.entityPool.acquire();
    entity.reset(newId);
    this.entities.set(newId, entity);
    return entity;
  }

  public destroyEntity(id: number) {
    const eid = id as EntityID;
    const entity = this.entities.get(eid);
    
    if (!entity || !entity.active) return;

    entity.active = false;
    
    this.removeFromCache(entity);
    this.entities.delete(eid);
    
    // 3. Recycle ID
    this.freeIds.push(id);
    
    entity.release();
    this.entityPool.release(entity);
  }

  public getEntity(id: number): Entity | undefined {
    return this.entities.get(id as EntityID);
  }

  public getAll(): IterableIterator<Entity> {
    return this.entities.values();
  }

  public getByTag(tag: string): Entity[] {
    const t = tag as Tag;
    if (!this.tagCache.has(t)) {
        this.tagCache.set(t, new Set());
    }
    const ids = this.tagCache.get(t)!;
    const results: Entity[] = [];
    for (const id of ids) {
        const e = this.entities.get(id);
        if (e && e.active) results.push(e);
    }
    return results;
  }

  public query(def: QueryDef): Entity[] {
    const tempQ = new Query(def);
    let cache = this.activeQueries.get(tempQ.id);
    
    if (!cache) {
        const results = new Set<Entity>();
        const q = new Query(def); 
        for (const entity of this.entities.values()) {
            if (entity.active && q.matches(entity)) {
                results.add(entity);
            }
        }
        cache = { query: q, results };
        this.activeQueries.set(q.id, cache);
    }
    return Array.from(cache.results);
  }
  
  public updateCache(entity: Entity) {
      for (const tag of entity.tags) {
          if (!this.tagCache.has(tag)) this.tagCache.set(tag, new Set());
          this.tagCache.get(tag)!.add(entity.id);
      }
      for (const cache of this.activeQueries.values()) {
          if (cache.query.matches(entity)) {
              cache.results.add(entity);
          } else {
              cache.results.delete(entity);
          }
      }
  }

  private removeFromCache(entity: Entity) {
      for (const tag of entity.tags) {
          if (this.tagCache.has(tag)) {
              this.tagCache.get(tag)!.delete(entity.id);
          }
      }
      for (const cache of this.activeQueries.values()) {
          cache.results.delete(entity);
      }
  }

  public clear() {
      for (const entity of this.entities.values()) {
          entity.release();
          this.entityPool.release(entity);
      }
      this.entities.clear();
      this.tagCache.clear();
      this.activeQueries.clear();
      
      // Reset ID counters
      this.nextId = 0;
      this.freeIds = [];
  }
  
  public getStats() {
      return {
          active: this.entities.size,
          pooled: this.entityPool.availableSize,
          totalAllocated: this.entityPool.totalSize
      };
  }
}


=====================================
FILE: ./src/game/core/Constants.ts
=====================================
export const MAX_ENTITIES = 10000; // Cap for static memory allocation
export const SPATIAL_GRID_SIZE = 4096; // Power of 2 for bitwise masking
export const SPATIAL_CELL_SIZE = 4; // World Units


=====================================
FILE: ./src/game/core/EntitySpawner.ts
=====================================
import { IEntitySpawner, IEntityRegistry } from './interfaces';
import { Entity } from './ecs/Entity';
import { Tag } from './ecs/types';
import { EntityRegistry } from './ecs/EntityRegistry';
import { ARCHETYPES } from '../data/Archetypes';
import { ComponentBuilder } from './ComponentBuilder';
import { ArchetypeIDs } from '../config/Identifiers';

export class EntitySpawner implements IEntitySpawner {
  private registry: EntityRegistry;

  constructor(registry: IEntityRegistry) {
    this.registry = registry as EntityRegistry;
  }

  /**
   * The Core Assembler.
   * Creates an entity from a data blueprint, merging in runtime overrides.
   */
  public spawn(archetypeId: string, overrides: Record<string, any> = {}, extraTags: Tag[] = []): Entity {
    const blueprint = ARCHETYPES[archetypeId];
    if (!blueprint) {
        console.warn(`[EntitySpawner] Unknown archetype: ${archetypeId}`);
        return this.registry.createEntity();
    }

    const e = this.registry.createEntity();
    
    // 1. Tags
    blueprint.tags.forEach(tag => e.addTag(tag));
    extraTags.forEach(tag => e.addTag(tag));

    // 2. Components
    for (const compDef of blueprint.components) {
        const builder = ComponentBuilder[compDef.type];
        if (builder) {
            // Merge Blueprint Data with Runtime Overrides
            // Example: Blueprint { damage: 10 } + Override { damage: 20 } = { damage: 20 }
            const runtimeData = overrides[compDef.type] || {};
            const mergedData = { ...compDef.data, ...runtimeData };
            
            e.addComponent(builder(mergedData));
        }
    }

    // 3. Register
    this.registry.updateCache(e);
    return e;
  }

  // --- LEGACY WRAPPERS (Preserves Interface) ---

  public spawnPlayer(): Entity {
    return this.spawn(ArchetypeIDs.PLAYER);
  }

  public spawnEnemy(type: string, x: number, y: number): Entity {
    return this.spawn(type, {
        Transform: { x, y }
    });
  }

  public spawnBullet(
      x: number, y: number, 
      vx: number, vy: number, 
      isEnemy: boolean, 
      life: number,
      damage: number = 1,
      widthMult: number = 1.0
  ): Entity {
    const id = isEnemy ? ArchetypeIDs.BULLET_ENEMY : ArchetypeIDs.BULLET_PLAYER;
    
    // Rotation is derived from velocity
    const rotation = Math.atan2(vy, vx);

    return this.spawn(id, {
        Transform: { x, y, rotation, scale: widthMult },
        Motion: { vx, vy },
        Lifetime: { remaining: life, total: life },
        Combat: { damage },
        Health: { max: damage },
        // If width changes, we need to scale the collider radius relative to the base blueprint radius
        // The ComponentBuilder handles the explicit reset, but we pass the final radius here.
        // We assume the blueprint has the 'base' radius.
        Collider: { 
            radius: (ARCHETYPES[id].components.find(c => c.type === 'Collider')?.data.radius || 0.2) * widthMult 
        }
    });
  }

  /**
   * FAST PATH: Particles
   * Particles are spawned in such high volume (1000s) that we bypass the 
   * generic "Merge/Lookup" overhead and construct them directly.
   */
  public spawnParticle(x: number, y: number, color: string, vx: number, vy: number, life: number): void {
    const e = this.registry.createEntity();
    e.addTag(Tag.PARTICLE);
    
    // Direct Builder calls (No Blueprint Lookup)
    e.addComponent(ComponentBuilder.Transform({ x, y }));
    e.addComponent(ComponentBuilder.Motion({ vx, vy, friction: 0.05 }));
    e.addComponent(ComponentBuilder.Lifetime({ remaining: life, total: life }));
    e.addComponent(ComponentBuilder.Identity({ variant: color }));
    
    this.registry.updateCache(e);
  }
}


=====================================
FILE: ./src/game/core/index.ts
=====================================
export * from './GameBootstrapper';
export * from './GameEngine';
export * from './EntitySpawner';
export * from './ServiceLocator';
export * from './ObjectPool';
export * from './SpatialGrid';
export * from './interfaces';


=====================================
FILE: ./src/game/core/ServiceLocator.ts
=====================================
import { IServiceLocator, IGameSystem, IAudioService, IInputService, IEntityRegistry, IEntitySpawner } from './interfaces';
import { ConfigService } from '../services/ConfigService';

class ServiceLocatorImpl implements IServiceLocator {
  private systems = new Map<string, IGameSystem>();
  private audioService?: IAudioService;
  private inputService?: IInputService;
  private registry?: IEntityRegistry;
  private spawner?: IEntitySpawner;

  public getSystem<T extends IGameSystem>(id: string): T {
    const sys = this.systems.get(id);
    if (!sys) throw new Error(`System not registered: ${id}`);
    return sys as T;
  }

  public registerSystem(id: string, system: IGameSystem): void {
    this.systems.set(id, system);
    if (id === 'InputSystem') this.inputService = system as unknown as IInputService;
  }

  public registerRegistry(registry: IEntityRegistry) {
      this.registry = registry;
  }

  public registerSpawner(spawner: IEntitySpawner) {
      this.spawner = spawner;
  }

  public getAudioService(): IAudioService {
    return { playSound: () => {}, playMusic: () => {}, setVolume: () => {} }; 
  }

  public getInputService(): IInputService {
    if (!this.inputService) throw new Error("InputService not registered");
    return this.inputService;
  }
  
  public getRegistry(): IEntityRegistry {
      if (!this.registry) throw new Error("Registry not registered");
      return this.registry;
  }

  public getSpawner(): IEntitySpawner {
      if (!this.spawner) throw new Error("Spawner not registered");
      return this.spawner;
  }

  public getConfigService() {
      return ConfigService;
  }
  
  public reset(): void {
    this.systems.clear();
    this.audioService = undefined;
    this.inputService = undefined;
    this.registry = undefined;
    this.spawner = undefined;
    ConfigService.reset(); // Reset configs on reboot
  }
}

export const ServiceLocator = new ServiceLocatorImpl();


=====================================
FILE: ./src/game/core/SpatialGrid.ts
=====================================
import { EntityID } from './ecs/types';
import { MAX_ENTITIES, SPATIAL_GRID_SIZE, SPATIAL_CELL_SIZE } from './Constants';

// Primes for Hashing
const HASH_X = 73856093;
const HASH_Y = 19349663;

export class SpatialGrid {
  // Head of the linked list for each cell
  // cellHead[cellHash] = firstEntityId (or -1 if empty)
  private cellHead = new Int32Array(SPATIAL_GRID_SIZE);

  // Next pointer for each entity
  // entityNext[entityId] = nextEntityId (or -1 if end of list)
  private entityNext = new Int32Array(MAX_ENTITIES);

  constructor() {
    this.cellHead.fill(-1);
    this.entityNext.fill(-1);
  }

  public clear() {
    // We only need to reset the heads to "Empty"
    // The 'entityNext' values will be overwritten on insert, so no need to loop 10k items.
    this.cellHead.fill(-1);
  }

  /**
   * Spatial Hash Function (2D -> 1D Index)
   */
  private getHash(x: number, y: number): number {
    const cx = Math.floor(x / SPATIAL_CELL_SIZE);
    const cy = Math.floor(y / SPATIAL_CELL_SIZE);
    
    // XOR Hash mapped to Grid Size (Power of 2 for bitwise AND)
    const hash = ((cx * HASH_X) ^ (cy * HASH_Y)) & (SPATIAL_GRID_SIZE - 1);
    return hash;
  }

  public insert(id: EntityID, x: number, y: number) {
    const eid = id as number;
    if (eid >= MAX_ENTITIES) return; // Safety check

    const hash = this.getHash(x, y);

    // Linked List Insertion (Prepend)
    // 1. Point current entity to whatever was previously first
    this.entityNext[eid] = this.cellHead[hash];
    
    // 2. Make current entity the new first
    this.cellHead[hash] = eid;
  }

  public query(x: number, y: number, radius: number, outResults: Set<EntityID>) {
    outResults.clear();
    
    const startX = Math.floor((x - radius) / SPATIAL_CELL_SIZE);
    const endX = Math.floor((x + radius) / SPATIAL_CELL_SIZE);
    const startY = Math.floor((y - radius) / SPATIAL_CELL_SIZE);
    const endY = Math.floor((y + radius) / SPATIAL_CELL_SIZE);

    for (let cy = startY; cy <= endY; cy++) {
      for (let cx = startX; cx <= endX; cx++) {
        // Recompute hash for neighbor cells
        // Note: We duplicate the hash logic here to avoid function call overhead in hot loop
        const hash = ((cx * HASH_X) ^ (cy * HASH_Y)) & (SPATIAL_GRID_SIZE - 1);
        
        // Traverse Linked List
        let id = this.cellHead[hash];
        
        while (id !== -1) {
          outResults.add(id as EntityID);
          id = this.entityNext[id];
        }
      }
    }
  }
}


=====================================
FILE: ./src/game/core/FastEventBus.ts
=====================================
// Ring Buffer Size
const BUFFER_SIZE = 2048; 
const MASK = BUFFER_SIZE - 1;

// Increased Stride to 5 (EventID + 4 Args) to support X, Y, Angle, etc.
const STRIDE = 5; 

export const FastEvents = {
  SPAWN_FX: 1,      // [ID, TYPE_ID, X, Y, ANGLE]
  TRAUMA: 2,        // [ID, AMOUNT, 0, 0, 0]
  PLAY_SOUND: 3,    // [ID, SOUND_ID, 0, 0, 0]
} as const;

export const FX_IDS: Record<string, number> = {
  'EXPLOSION_PURPLE': 1,
  'EXPLOSION_YELLOW': 2,
  'EXPLOSION_RED': 3,
  'IMPACT_WHITE': 4,
  'IMPACT_RED': 5,
  'CLASH_YELLOW': 6,
  'DRILL_SPARKS': 7,
  'HUNTER_RECOIL': 8,
  'REBOOT_HEAL': 9,
  'PURGE_BLAST': 10
};

export const FX_ID_MAP = Object.entries(FX_IDS).reduce((acc, [k, v]) => {
  acc[v] = k;
  return acc;
}, {} as Record<number, string>);

class FastEventBusController {
  private buffer = new Float32Array(BUFFER_SIZE * STRIDE);
  private writeCursor = 0;
  private readCursor = 0;

  public emit(eventId: number, arg1: number = 0, arg2: number = 0, arg3: number = 0, arg4: number = 0) {
    const ptr = (this.writeCursor & MASK) * STRIDE;
    
    this.buffer[ptr] = eventId;
    this.buffer[ptr + 1] = arg1;
    this.buffer[ptr + 2] = arg2;
    this.buffer[ptr + 3] = arg3;
    this.buffer[ptr + 4] = arg4; // Angle or Extra Data

    this.writeCursor++;
  }

  public processEvents(handler: (eventId: number, a1: number, a2: number, a3: number, a4: number) => void) {
    while (this.readCursor < this.writeCursor) {
      const ptr = (this.readCursor & MASK) * STRIDE;
      
      const id = this.buffer[ptr];
      const a1 = this.buffer[ptr + 1];
      const a2 = this.buffer[ptr + 2];
      const a3 = this.buffer[ptr + 3];
      const a4 = this.buffer[ptr + 4];

      handler(id, a1, a2, a3, a4);
      
      this.readCursor++;
    }
  }
}

export const FastEventBus = new FastEventBusController();


=====================================
FILE: ./src/game/core/interfaces.ts
=====================================
import { GameEvents, GameEventPayloads } from '../events/GameEvents';
import { Entity } from './ecs/Entity';
import { SpatialGrid } from './SpatialGrid';
import { WorldRect } from '../utils/ViewportHelper';
import { ConfigService } from '../services/ConfigService';
import { QueryDef } from './ecs/Query';
import { Tag } from './ecs/types';

export interface IGameSystem {
  setup(locator: IServiceLocator): void;
  update(delta: number, time: number): void;
  teardown(): void;
}

export interface IServiceLocator {
  getSystem<T extends IGameSystem>(id: string): T;
  registerSystem(id: string, system: IGameSystem): void;
  
  getAudioService(): IAudioService;
  getInputService(): IInputService;
  getRegistry(): IEntityRegistry;
  getSpawner(): IEntitySpawner;
  getConfigService(): typeof ConfigService;
}

// --- CORE CONTRACTS ---

export interface IEntityRegistry {
  createEntity(): Entity;
  destroyEntity(id: number): void;
  getEntity(id: number): Entity | undefined;
  getAll(): IterableIterator<Entity>;
  getByTag(tag: string): Entity[];
  query(def: QueryDef): Entity[];
  clear(): void;
  getStats(): { active: number; pooled: number; totalAllocated: number };
}

export interface IEntitySpawner {
  // Generic Assembler
  spawn(archetypeId: string, overrides?: Record<string, any>, extraTags?: Tag[]): Entity;

  // Convenience / Legacy Wrappers
  spawnPlayer(): Entity;
  spawnEnemy(type: string, x: number, y: number): Entity;
  spawnBullet(x: number, y: number, vx: number, vy: number, isEnemy: boolean, life: number, damage?: number, widthMult?: number): Entity;
  spawnParticle(x: number, y: number, color: string, vx: number, vy: number, life: number): void;
}

export interface IAudioService {
  playSound(key: string, volume?: number): void;
  playMusic(key: string): void;
  setVolume(volume: number): void;
}

export interface IInputService {
  getCursor(): { x: number, y: number };
  isPressed(action: string): boolean;
  updateCursor(x: number, y: number): void;
  updateBounds(width: number, height: number): void; 
}

// --- SYSTEM CONTRACTS ---

export interface IPhysicsSystem extends IGameSystem {
  spatialGrid: SpatialGrid;
}

export interface ICombatSystem extends IGameSystem {
  resolveCollision(e1: Entity, e2: Entity): void;
}

export interface IInteractionSystem extends IGameSystem {
  repairState: 'IDLE' | 'HEALING' | 'REBOOTING';
  hoveringPanelId: string | null;
}

export interface IGameStateSystem extends IGameSystem {
  playerHealth: number;
  maxPlayerHealth: number;
  playerRebootProgress: number;
  score: number;
  xp: number;
  level: number;
  xpToNextLevel: number;
  upgradePoints: number;
  activeUpgrades: Record<string, number>;
  isGameOver: boolean;
  
  damagePlayer(amount: number): void;
  healPlayer(amount: number): void;
  addScore(amount: number): void;
  addXp(amount: number): void;
  tickReboot(amount: number): void;
  decayReboot(amount: number): void;
}

export interface IPanelSystem extends IGameSystem {
  systemIntegrity: number;
  damagePanel(id: string, amount: number): void;
  healPanel(id: string, amount: number): void;
  getPanelRect(id: string): WorldRect | undefined;
}


=====================================
FILE: ./src/game/core/GameEngine.ts
=====================================
import { IGameSystem, IServiceLocator, IEntityRegistry } from './interfaces';
import { useGameStore } from '../store/useGameStore';
import { useStore } from '@/core/store/useStore';
import { ViewportHelper } from '../utils/ViewportHelper';
import { PanelRegistrySystem } from '../systems/PanelRegistrySystem'; 
import { GameStateSystem } from '../systems/GameStateSystem';
import { WorldConfig } from '../config/WorldConfig';
import { TimeSystem } from '../systems/TimeSystem';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';

export class GameEngineCore implements IGameSystem {
  private systems: IGameSystem[] = [];
  private locator!: IServiceLocator;
  public registry: IEntityRegistry; 
  
  private accumulator: number = 0;
  private simulationTime: number = 0;

  constructor(registry: IEntityRegistry) {
      this.registry = registry;
  }

  setup(locator: IServiceLocator): void {
    this.locator = locator;
    // FXManager.init() removed. VFXSystem handles this now.
  }

  public registerSystem(system: IGameSystem) {
    this.systems.push(system);
  }

  update(renderDelta: number, renderTime: number): void {
    const store = useStore.getState();
    const gameStore = useGameStore.getState();
    
    if (store.bootState === 'standby') return;
    if (store.activeModal === 'settings' || store.isDebugOpen) return;
    if (store.isSimulationPaused) return;

    const gameSys = this.locator.getSystem<GameStateSystem>('GameStateSystem');
    
    if (gameStore.isPlaying && gameStore.systemIntegrity <= 0) {
        gameStore.stopGame();
        GameEventBus.emit(GameEvents.TRAUMA_ADDED, { amount: 1.0 });
        gameSys.isGameOver = true; 
        return;
    }

    if (!gameStore.isPlaying) {
        gameSys.isGameOver = true;
    }

    let timeScale = 1.0;
    try {
        const timeSys = this.locator.getSystem<TimeSystem>('TimeSystem');
        timeSys.tickRealTime(renderDelta);
        if (timeSys.isFrozen()) timeScale = 0.0;
        else timeScale = timeSys.timeScale;
    } catch {}

    const debugScale = store.debugFlags.timeScale;
    const effectiveDelta = renderDelta * timeScale * debugScale;
    
    this.accumulator += effectiveDelta;

    if (this.accumulator > WorldConfig.time.maxAccumulator) {
        this.accumulator = WorldConfig.time.maxAccumulator;
    }

    const fixedStep = WorldConfig.time.fixedDelta;

    while (this.accumulator >= fixedStep) {
        for (const sys of this.systems) {
            try {
                sys.update(fixedStep, this.simulationTime);
            } catch (e: any) {
                console.error("System Update Error:", e);
                GameEventBus.emit(GameEvents.LOG_DEBUG, { 
                    msg: `CRASH IN SYSTEM: ${e.message}`, 
                    source: 'GameEngine' 
                });
            }
        }
        this.simulationTime += fixedStep;
        this.accumulator -= fixedStep;
    }
  }

  teardown(): void {
    for (const sys of this.systems) {
      sys.teardown();
    }
    this.systems = [];
  }
  
  public updateViewport(vpW: number, vpH: number, screenW: number, screenH: number) {
    ViewportHelper.update(vpW, vpH, screenW, screenH);
    try {
        const panelSys = this.locator.getSystem<PanelRegistrySystem>('PanelRegistrySystem');
        panelSys.refreshAll();
    } catch (e) {
    }
  }
}


=====================================
FILE: ./src/game/GameOverlay.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { GameDirector } from './components/GameDirector';
import { ScreenShaker } from './components/ScreenShaker';
import { GalleryStage } from './components/GalleryStage';
import { RenderDirector } from './components/RenderDirector';
import { VirtualJoystick } from '@/ui/atoms/VirtualJoystick';
import { ActionButton } from '@/ui/atoms/ActionButton';
import { useStore } from '@/core/store/useStore';
import { useEffect, useState } from 'react';

export const GameOverlay = () => {
  const { bootState, sandboxView } = useStore();
  const isGallery = bootState === 'sandbox' && sandboxView === 'gallery';
  const [isMobile, setIsMobile] = useState(false);
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
      setMounted(true);
      // Robust Mobile/Touch Detection
      const checkMobile = () => {
        const isCoarse = window.matchMedia('(pointer: coarse)').matches;
        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        setIsMobile(isCoarse || isTouch);
      };
      
      checkMobile();
      window.addEventListener('resize', checkMobile);
      return () => window.removeEventListener('resize', checkMobile);
  }, []);

  if (!mounted) return null;

  return (
    <>
        <div className="fixed inset-0 z-[60] w-full h-full pointer-events-none overflow-hidden">
          <Canvas
            orthographic={!isGallery}
            camera={isGallery ? { position: [5, 5, 10], fov: 45 } : { zoom: 40, position: [0, 0, 100] }}
            gl={{ 
              alpha: true, 
              antialias: true,
              stencil: false,
              powerPreference: "high-performance"
            }}
            eventSource={document.body}
            eventPrefix="client"
          >
            {isGallery ? (
                <GalleryStage />
            ) : (
                <>
                    {/* Infrastructure & Logic */}
                    <GameDirector />
                    <ScreenShaker />
                    
                    {/* Visual Entities */}
                    <RenderDirector />
                </>
            )}
          </Canvas>
        </div>
        
        {/* Mobile Controls Layer */}
        {isMobile && !isGallery && (
            <>
                <VirtualJoystick />
                <ActionButton />
            </>
        )}
    </>
  );
};


=====================================
FILE: ./src/game/config/AIConfig.ts
=====================================
export const AI_CONFIG = {
  HUNTER: {
    ORBIT_SPEED: 0.5,
    TARGET_RADIUS: 10.0,
    AIM_LERP: 0.05,
    CHARGE_LERP: 0.15,
    SPIN_SPEED_IDLE: 2.0,
    SPIN_SPEED_CHARGE: -8.0,
    PROJECTILE_SPEED: 25,
    OFFSET_DIST: 1.6,
    RECOIL_FORCE: 2.0
  },
  KAMIKAZE: {
    ROTATION_SPEED: 10.0,
    ENGAGEMENT_DIST: 0.1
  },
  DRILLER: {
    SNAP_THRESHOLD: 0.1,
    TIP_OFFSET: 0.4, // Based on Model Height
    AUDIO_INTERVAL: 0.25
  },
  DAEMON: {
    SHIELD_CHARGE_TIME: 2.0,
    COOLDOWN_TIME: 0.5,
    RECOVERY_TIME: 2.0,
    ORBIT_RADIUS: 4.0,
    ORBIT_SPEED_MIN: 1.5,
    ROTATION_SPEED: {
      CHARGING: 15.0,
      READY: 3.0,
      FIRE: 20.0,
      COOLDOWN: -5.0,
      BROKEN: 30.0
    }
  }
};


=====================================
FILE: ./src/game/config/ModelConfig.ts
=====================================
export const MODEL_CONFIG = {
  DRILLER: {
    height: 0.8, // Total length of the cone
    radius: 0.3, // Width of the base
    segments: 4  // 4-sided pyramid style
  },
  KAMIKAZE: {
    radius: 0.6,
    detail: 0
  },
  HUNTER: {
    scale: 2.0 // Scale factor for the spear model
  }
};


=====================================
FILE: ./src/game/config/PlayerConfig.ts
=====================================
export const PLAYER_CONFIG = {
  maxHealth: 100,
  fireRate: 0.15, 
  bulletSpeed: 45,
  bulletRadius: 0.2,
  bulletLife: 1.5,
  
  // Scoring & Progression
  scoreMultiplier: 1,
  baseXpRequirement: 100,
  xpScalingFactor: 1.5, // Next level = base * (scaling ^ level)
};


=====================================
FILE: ./src/game/config/VFXConfig.ts
=====================================
export type VFXPattern = 'RADIAL' | 'DIRECTIONAL';

export interface VFXRecipe {
  pattern: VFXPattern;
  colors: string[];
  count: [number, number]; // Min, Max
  speed: [number, number]; // Min, Max
  life: [number, number];  // Min, Max
  spread?: number;         // Radians (for Directional)
}

const PALETTE_PURPLE = ['#9E4EA5', '#D0A3D8', '#E0B0FF', '#7A2F8F', '#B57EDC'];
const PALETTE_YELLOW = ['#F7D277', '#FFE5A0', '#FFA500', '#FFFFFF'];
const PALETTE_RED = ['#FF003C', '#FF4D6D', '#800010'];
const PALETTE_CYAN = ['#00F0FF', '#008ba3', '#FFFFFF'];

export const VFX_RECIPES: Record<string, VFXRecipe> = {
  // --- EXPLOSIONS ---
  'EXPLOSION_PURPLE': {
    pattern: 'RADIAL',
    colors: PALETTE_PURPLE,
    count: [10, 15],
    speed: [5, 12],
    life: [0.5, 0.8]
  },
  'EXPLOSION_YELLOW': {
    pattern: 'RADIAL',
    colors: PALETTE_YELLOW,
    count: [12, 18],
    speed: [8, 15],
    life: [0.4, 0.7]
  },
  'EXPLOSION_RED': {
    pattern: 'RADIAL',
    colors: PALETTE_RED,
    count: [15, 25],
    speed: [10, 20],
    life: [0.6, 1.0]
  },
  
  // --- IMPACTS ---
  'IMPACT_WHITE': {
    pattern: 'RADIAL',
    colors: ['#FFFFFF'],
    count: [3, 5],
    speed: [2, 5],
    life: [0.1, 0.2]
  },
  'IMPACT_RED': {
    pattern: 'RADIAL',
    colors: PALETTE_RED,
    count: [4, 7],
    speed: [3, 8],
    life: [0.2, 0.4]
  },
  'CLASH_YELLOW': {
    pattern: 'RADIAL',
    colors: PALETTE_YELLOW,
    count: [5, 8],
    speed: [5, 10],
    life: [0.2, 0.4]
  },

  // --- DIRECTIONAL ---
  'DRILL_SPARKS': {
    pattern: 'DIRECTIONAL',
    colors: PALETTE_PURPLE,
    count: [3, 6],
    speed: [4, 9],
    life: [0.2, 0.4],
    spread: 0.8
  },
  'HUNTER_RECOIL': {
    pattern: 'DIRECTIONAL',
    colors: PALETTE_YELLOW,
    count: [8, 12],
    speed: [10, 18],
    life: [0.3, 0.6],
    spread: 0.5
  },
  
  // --- SPECIAL ---
  'REBOOT_HEAL': {
    pattern: 'RADIAL',
    colors: PALETTE_CYAN,
    count: [8, 12],
    speed: [2, 5],
    life: [0.5, 1.0]
  },
  'PURGE_BLAST': {
    pattern: 'RADIAL',
    colors: ['#FFFFFF', '#FF003C'],
    count: [50, 50],
    speed: [10, 30],
    life: [1.5, 2.5]
  }
};


=====================================
FILE: ./src/game/config/EnemyConfig.ts
=====================================
import { EnemyTypes } from './Identifiers';

export const ENEMY_CONFIG = {
  [EnemyTypes.DRILLER]: { // RENAMED
    hp: 2,
    baseSpeed: 8,
    radius: 0.5,
    damage: 15,
    score: 10
  },
  [EnemyTypes.KAMIKAZE]: {
    hp: 3,
    baseSpeed: 12,
    radius: 0.5,
    damage: 10,
    score: 20
  },
  [EnemyTypes.HUNTER]: {
    hp: 3,
    baseSpeed: 12,
    radius: 0.5,
    score: 50,
    orbitRadius: 12.5,
    orbitDuration: 2.0,
    chargeDuration: 1.0,
    fireRange: 12.0,
    offsetDistance: 1.6 
  }
};

export const WAVE_CONFIG = {
  baseSpawnInterval: 0.8,
  difficultyScaler: 1.0 
};


=====================================
FILE: ./src/game/config/TextAssets.ts
=====================================
// Used for the 3D Intro UI (Block Style)
export const ASCII_TITLE = `
 ███▄ ▄███▓▓█████  ██████  ▒█████  ▓█████  ██▓      █████▒▓██   ██▓
▓██▒▀█▀ ██▒▓█   ▀▒██    ▒ ▒██▒  ██▒▓█   ▀ ▓██▒    ▒▓█   ▒  ▒██  ██▒
▓██    ▓██░▒███  ░ ▓██▄   ▒██░  ██▒▒███   ▒██░    ▒▓███ ░   ▒██ ██░
▒██    ▒██ ▒▓█  ▄  ▒   ██▒▒██   ██░▒▓█  ▄ ▒██░    ░▓█▒  ░   ░ ▐██░░
▒██▒   ░██▒░▒████▒██████▒▒░ ████▓▒░░▒████▒░██████▒░▒█░      ░ ██▒░░
░ ▒░   ░  ░░░ ▒░ ░ ▒░▒  ░ ░ ▒░▒░▒░ ░░ ▒░ ░░ ▒░▒  ░ ▒ ░       ██▒▒▒
░  ░      ░ ░ ░  ░ ░ ▒  ░   ░ ▒ ▒░  ░ ░  ░░ ░ ▒  ░ ░       ▓██ ░▒░ 
░      ░      ░    ░ ░    ░ ░ ░ ▒     ░     ░ ░    ░ ░     ▒ ▒ ░░  
       ░      ░  ░   ░  ░     ░ ░     ░  ░    ░  ░         ░ ░     
`;

// Used for the Browser Console (NFO/Keygen Style - Safe for DevTools)
export const ASCII_CONSOLE = `
   __  __  ____  ____  ____  ____  __    ____  _  _ 
  (  \\/  )(  __)/ ___)/  _ \\(  __)(  )  (  __)( \\/ )
   )    (  ) _) \\___ \\  (_) )) _) / (_/\\ ) _)  \\  / 
  (_/\\/\\_)(____)(____/\\____/(____)\\____/(_)    (__) 
          >> LATENT SPACE BANDIT // VER 2.0 <<
`;

export const CONSOLE_STYLE = `
  color: #78F654;
  background-color: #050505;
  font-family: "Courier New", monospace;
  font-weight: bold;
  font-size: 10px;
  line-height: 12px;
  padding-top: 10px;
  padding-bottom: 10px;
`;


=====================================
FILE: ./src/game/config/AudioConfig.ts
=====================================
export type SoundType = 'oscillator' | 'noise';

export interface SoundRecipe {
  type: SoundType;
  wave?: OscillatorType; 
  frequency: [number, number]; 
  duration: number; 
  volume: number; 
  pitchVariance: number; 
  filter?: [number, number]; 
  distortion?: number; 
  attack?: number; 
  fm?: {
    modFreq: number; 
    modIndex: number; 
    modType: OscillatorType;
  };
  tremolo?: {
    rate: number; 
    depth: number; 
    wave?: OscillatorType;
  };
}

export const AUDIO_CONFIG: Record<string, SoundRecipe> = {
  // ==========================================
  // UI & INTERFACE
  // ==========================================
  'ui_click': { type: 'oscillator', wave: 'square', frequency: [400, 400], duration: 0.05, volume: 0.1, pitchVariance: 0 },
  'ui_hover': { type: 'oscillator', wave: 'sine', frequency: [800, 800], duration: 0.03, volume: 0.05, pitchVariance: 50 },
  'ui_menu_open': { type: 'oscillator', wave: 'sine', frequency: [440, 660], duration: 0.15, volume: 0.1, pitchVariance: 0, attack: 0.02 },
  'ui_menu_close': { type: 'oscillator', wave: 'sine', frequency: [660, 440], duration: 0.15, volume: 0.1, pitchVariance: 0, attack: 0.02 },
  'ui_optimal': { type: 'oscillator', wave: 'sine', frequency: [1200, 1200], duration: 0.4, volume: 0.15, pitchVariance: 0, attack: 0.01 },
  'ui_error': { type: 'oscillator', wave: 'sawtooth', frequency: [150, 50], duration: 0.2, volume: 0.2, pitchVariance: 0, distortion: 50 },
  'ui_chirp': { type: 'oscillator', wave: 'triangle', frequency: [400, 600], duration: 0.1, volume: 0.1, pitchVariance: 0 },

  // ==========================================
  // GAMEPLAY FX (ONE SHOT)
  // ==========================================
  'fx_player_fire': { type: 'oscillator', wave: 'sawtooth', frequency: [880, 110], duration: 0.15, volume: 0.15, pitchVariance: 100 },
  'fx_enemy_fire': { type: 'oscillator', wave: 'square', frequency: [440, 220], duration: 0.2, volume: 0.15, pitchVariance: 50 },
  'fx_impact_light': { type: 'noise', frequency: [0, 0], filter: [1000, 100], duration: 0.4, volume: 0.3, pitchVariance: 200, distortion: 20 },
  'fx_impact_heavy': { type: 'noise', frequency: [0, 0], filter: [600, 50], duration: 1.5, volume: 0.5, pitchVariance: 0, distortion: 50 },
  'fx_boot_sequence': { type: 'noise', frequency: [0, 0], filter: [1500, 50], duration: 2.0, volume: 0.6, pitchVariance: 0, distortion: 30 },
  'fx_player_death': { type: 'noise', frequency: [0,0], filter: [500, 500], duration: 2.0, volume: 0.6, pitchVariance: 0, distortion: 200, tremolo: { rate: 12, depth: 1.0, wave: 'square' } },
  'fx_level_up': { type: 'oscillator', wave: 'triangle', frequency: [440, 880], duration: 0.4, volume: 0.2, pitchVariance: 0 },
  'fx_reboot_success': { type: 'oscillator', wave: 'triangle', frequency: [440, 880], duration: 0.3, volume: 0.3, pitchVariance: 0, attack: 0.01, tremolo: { rate: 10, depth: 1.0, wave: 'square' } },
  'fx_teleport': { type: 'oscillator', wave: 'sine', frequency: [100, 1500], duration: 0.3, volume: 0.2, pitchVariance: 0 },

  // ==========================================
  // LOOPS & STATES (CONTINUOUS)
  // ==========================================
  'loop_heal': { type: 'oscillator', wave: 'sine', frequency: [300, 600], duration: 0.2, volume: 0.1, pitchVariance: 0 },
  'loop_reboot': { type: 'oscillator', wave: 'sine', frequency: [100, 200], duration: 0.2, volume: 0.2, pitchVariance: 0 },
  'loop_warning': { type: 'oscillator', wave: 'sine', frequency: [55, 55], duration: 0.8, volume: 0.7, pitchVariance: 0, attack: 0.03, fm: { modType: 'sine', modFreq: 10, modIndex: 25 } },
  'loop_drill': { type: 'noise', frequency: [0,0], filter: [300, 50], duration: 0.25, volume: 0.5, pitchVariance: 50, distortion: 60 },

  // ==========================================
  // AMBIENCE
  // ==========================================
  'ambience_core': { type: 'noise', frequency: [0,0], filter: [800, 800], duration: 40.0, volume: 0.05, pitchVariance: 0 },

  // ==========================================
  // SYNTHESIS LAB (RENAMED PROTOS)
  // ==========================================
  'syn_fm_scream': { type: 'oscillator', wave: 'sawtooth', frequency: [800, 1200], duration: 0.5, volume: 0.15, pitchVariance: 50, fm: { modType: 'sine', modFreq: 150, modIndex: 300 } },
  'syn_data_burst': { type: 'oscillator', wave: 'square', frequency: [25, 20], duration: 0.4, volume: 0.4, pitchVariance: 0, distortion: 50 },
  'syn_bass_drop': { type: 'oscillator', wave: 'triangle', frequency: [150, 100], duration: 0.6, volume: 0.3, pitchVariance: 20, fm: { modType: 'square', modFreq: 57, modIndex: 1000 } },
  'syn_alarm_chirp': { type: 'oscillator', wave: 'sawtooth', frequency: [400, 50], duration: 0.3, volume: 0.3, pitchVariance: 50, distortion: 100 },
  'syn_static_burst': { type: 'noise', frequency: [0, 0], filter: [800, 2000], duration: 0.4, volume: 0.3, pitchVariance: 0, distortion: 400 },
  'syn_wobble_bass': { type: 'oscillator', wave: 'sine', frequency: [50, 50], duration: 0.5, volume: 0.6, pitchVariance: 0, fm: { modType: 'sine', modFreq: 10, modIndex: 50 } },
  'syn_grind_loop': { type: 'noise', frequency: [0,0], filter: [200, 100], duration: 3.0, volume: 0.5, pitchVariance: 0, distortion: 50, tremolo: { rate: 2, depth: 0.8, wave: 'sine' } },
  'syn_insect_swarm': { type: 'noise', frequency: [0,0], filter: [1500, 800], duration: 3.0, volume: 0.3, pitchVariance: 0, distortion: 10, tremolo: { rate: 12, depth: 1.0, wave: 'sawtooth' } },
  'syn_interference': { type: 'noise', frequency: [0,0], filter: [800, 400], duration: 3.0, volume: 0.4, pitchVariance: 0, distortion: 100, tremolo: { rate: 6, depth: 0.6, wave: 'square' } },
  'syn_wind_howl': { type: 'noise', frequency: [0,0], filter: [100, 1000], duration: 3.0, volume: 0.4, pitchVariance: 0, distortion: 20, tremolo: { rate: 15, depth: 0.5, wave: 'sine' } },
  'syn_robot_chatter': { type: 'noise', frequency: [0,0], filter: [500, 500], duration: 3.0, volume: 0.5, pitchVariance: 0, distortion: 200, tremolo: { rate: 8, depth: 1.0, wave: 'square' } },
  'syn_deep_hum': { type: 'noise', frequency: [0,0], filter: [80, 40], duration: 3.0, volume: 0.8, pitchVariance: 0, distortion: 20, tremolo: { rate: 0.5, depth: 0.9, wave: 'sine' } },
  'syn_sine_rise': { type: 'oscillator', wave: 'sine', frequency: [200, 400], duration: 1.0, volume: 0.3, pitchVariance: 0 },
  'syn_saw_rise': { type: 'oscillator', wave: 'sawtooth', frequency: [100, 800], duration: 1.0, volume: 0.2, pitchVariance: 0, fm: { modType: 'sine', modFreq: 50, modIndex: 200 } },
  'syn_sqr_rise': { type: 'oscillator', wave: 'square', frequency: [60, 60], duration: 1.0, volume: 0.2, pitchVariance: 0, fm: { modType: 'triangle', modFreq: 15, modIndex: 100 } },
  'syn_siren_wail': { type: 'oscillator', wave: 'sine', frequency: [60, 20], duration: 2.5, volume: 0.6, pitchVariance: 0, distortion: 20 },
  'syn_alert_pulse': { type: 'oscillator', wave: 'square', frequency: [400, 350], duration: 1.0, volume: 0.3, pitchVariance: 0, fm: { modType: 'square', modFreq: 8, modIndex: 50 } },
  'syn_static_wash': { type: 'noise', frequency: [0, 0], filter: [2000, 200], duration: 1.5, volume: 0.4, pitchVariance: 0, distortion: 100 },
};


=====================================
FILE: ./src/game/config/Identifiers.ts
=====================================
import { GameEvents as NewGameEvents } from '../events/GameEvents';

export const EnemyTypes = {
  DRILLER: 'driller',
  KAMIKAZE: 'kamikaze',
  HUNTER: 'hunter',
  DAEMON: 'daemon',
} as const;

export const ArchetypeIDs = {
  PLAYER: 'PLAYER',
  BULLET_PLAYER: 'BULLET_PLAYER',
  BULLET_ENEMY: 'BULLET_ENEMY',
  ...EnemyTypes
} as const;

export type EnemyType = typeof EnemyTypes[keyof typeof EnemyTypes];
export type ArchetypeID = typeof ArchetypeIDs[keyof typeof ArchetypeIDs] | string;
export const GameEvents = NewGameEvents;


=====================================
FILE: ./src/game/config/PhysicsConfig.ts
=====================================
export const CollisionLayers = {
  NONE: 0,
  PLAYER: 1,
  ENEMY: 2,
  PLAYER_PROJECTILE: 4,
  ENEMY_PROJECTILE: 8,
  PANEL: 16,
  PICKUP: 32
} as const;

export const PhysicsConfig = {
  HITBOX: {
    PLAYER: 0.6,
    DRILLER: 0.5,
    KAMIKAZE: 0.6,
    HUNTER: 0.7,
    BULLET: 0.25,
    HUNTER_BULLET: 0.4
  },
  MASKS: {
    PLAYER: 42,
    ENEMY: 5,
    PLAYER_PROJECTILE: 10,
    ENEMY_PROJECTILE: 1
  }
};


=====================================
FILE: ./src/game/config/WorldConfig.ts
=====================================
export const WorldConfig = {
  bounds: {
    width: 32, // World Units
    height: 18,
    depth: 5
  },
  physics: {
    friction: 0.95,
    maxVelocity: 20
  },
  time: {
    fixedDelta: 1 / 60, // Logic runs at 60hz (0.0166s per tick)
    maxAccumulator: 0.1 // Prevent "Spiral of Death" if CPU lags hard
  }
};


=====================================
FILE: ./src/game/config/SystemManifest.ts
=====================================
import { IGameSystem } from '../core/interfaces';

// Core Systems
import { TimeSystem } from '../systems/TimeSystem';
import { InputSystem } from '../systems/InputSystem';
import { PhysicsSystem } from '../systems/PhysicsSystem';
import { GameStateSystem } from '../systems/GameStateSystem';
import { UISyncSystem } from '../systems/UISyncSystem';
import { PanelRegistry } from '../systems/PanelRegistrySystem';
import { AudioDirectorSystem } from '../systems/AudioDirectorSystem';

// Gameplay Systems
import { LifeCycleSystem } from '../systems/LifeCycleSystem';
import { BehaviorSystem } from '../systems/BehaviorSystem';
import { CollisionSystem } from '../systems/CollisionSystem';
import { CombatSystem } from '../systems/CombatSystem';
import { WaveSystem } from '../systems/WaveSystem';
import { PlayerSystem } from '../systems/PlayerSystem';
import { InteractionSystem } from '../systems/InteractionSystem';
import { StructureSystem } from '../systems/StructureSystem'; // NEW
import { TargetingSystem } from '../systems/TargetingSystem';
import { GuidanceSystem } from '../systems/GuidanceSystem';
import { OrbitalSystem } from '../systems/OrbitalSystem';

// VFX
import { ShakeSystem } from '../systems/ShakeSystem';
import { VFXSystem } from '../systems/VFXSystem';

type SystemFactory = () => IGameSystem;

interface SystemDef {
  id: string;
  factory: SystemFactory;
}

// HELPER: Wraps a class constructor
const useClass = (ClassRef: new () => IGameSystem): SystemFactory => () => new ClassRef();

// HELPER: Wraps an existing singleton instance
const useInstance = (instance: IGameSystem): SystemFactory => () => instance;

/**
 * THE SYSTEM PIPELINE
 */
export const SYSTEM_MANIFEST: SystemDef[] = [
  // --- 1. CORE & INPUT (Prepare the frame) ---
  { id: 'TimeSystem',       factory: useClass(TimeSystem) },
  { id: 'InputSystem',      factory: useClass(InputSystem) },
  { id: 'PanelRegistrySystem', factory: useInstance(PanelRegistry) }, // Singleton
  { id: 'GameStateSystem',  factory: useClass(GameStateSystem) },
  { id: 'InteractionSystem', factory: useClass(InteractionSystem) },
  { id: 'StructureSystem',  factory: useClass(StructureSystem) }, // NEW: World Logic
  { id: 'WaveSystem',       factory: useClass(WaveSystem) },

  // --- 2. AI & DECISION MAKING (Think) ---
  { id: 'TargetingSystem',  factory: useClass(TargetingSystem) },
  { id: 'OrbitalSystem',    factory: useClass(OrbitalSystem) },
  { id: 'PlayerSystem',     factory: useClass(PlayerSystem) },
  { id: 'BehaviorSystem',   factory: useClass(BehaviorSystem) }, // AI Logic
  { id: 'GuidanceSystem',   factory: useClass(GuidanceSystem) },

  // --- 3. PHYSICS & RESOLUTION (Move & Hit) ---
  { id: 'PhysicsSystem',    factory: useClass(PhysicsSystem) },
  { id: 'CollisionSystem',  factory: useClass(CollisionSystem) },
  
  // --- 4. OUTCOMES (Die & Explode) ---
  { id: 'CombatSystem',     factory: useClass(CombatSystem) }, // Resolves damage logic
  { id: 'LifeCycleSystem',  factory: useClass(LifeCycleSystem) }, 
  { id: 'VFXSystem',        factory: useClass(VFXSystem) },
  { id: 'AudioDirectorSystem', factory: useClass(AudioDirectorSystem) },
  
  // --- 5. RENDER PREP (Sync to View) ---
  { id: 'ShakeSystem',      factory: useClass(ShakeSystem) },
  { id: 'UISyncSystem',     factory: useClass(UISyncSystem) },
];


=====================================
FILE: ./src/game/logic/combat/CombatHandlers.ts
=====================================
import { Entity } from '../../core/ecs/Entity';
import { CombatContext } from './types';
import { HealthComponent } from '../../components/data/HealthComponent';
import { IdentityComponent } from '../../components/data/IdentityComponent';
import { StateComponent } from '../../components/data/StateComponent';
import { TransformComponent } from '../../components/data/TransformComponent';
import { EnemyTypes } from '@/game/config/Identifiers';

// --- HELPERS ---

const getHp = (e: Entity) => e.getComponent<HealthComponent>('Health');
const getId = (e: Entity) => e.getComponent<IdentityComponent>('Identity');
const getPos = (e: Entity) => e.getComponent<TransformComponent>('Transform');

// --- HANDLERS ---

/**
 * PLAYER vs ENEMY
 */
export const handlePlayerCrash = (player: Entity, enemy: Entity, ctx: CombatContext) => {
  const pId = getId(player);
  
  // 1. DAEMON RAMMING
  if (pId?.variant === EnemyTypes.DAEMON) {
      resolveDaemonCollision(player, enemy, ctx);
      return;
  }

  // 2. STANDARD PLAYER CRASH
  const eId = getId(enemy);
  
  // AAA POLISH: Specific Shake Tuning
  if (eId?.variant === EnemyTypes.KAMIKAZE) {
      ctx.damagePlayer(25);
      ctx.addTrauma(0.9); // VIOLENT SHAKE
      ctx.destroyEntity(enemy, 'EXPLOSION_RED');
  } else {
      ctx.damagePlayer(10);
      ctx.addTrauma(0.5); // HEAVY IMPACT (Driller/Hunter)
      ctx.destroyEntity(enemy, 'EXPLOSION_PURPLE');
  }
};

/**
 * PLAYER vs ENEMY_BULLET
 */
export const handlePlayerHit = (player: Entity, bullet: Entity, ctx: CombatContext) => {
  const pId = getId(player);

  if (pId?.variant === EnemyTypes.DAEMON) {
      resolveDaemonCollision(player, bullet, ctx, 5);
      return;
  }

  ctx.damagePlayer(10);
  ctx.destroyEntity(bullet, 'IMPACT_RED');
  // Note: VFXSystem adds standard trauma (0.2 - 0.45) for damage events automatically
};

/**
 * ENEMY vs PLAYER_BULLET
 */
export const handleEnemyHit = (enemy: Entity, bullet: Entity, ctx: CombatContext) => {
  handleMassExchange(enemy, bullet, 'IMPACT_WHITE', ctx);
};

/**
 * BULLET vs BULLET
 */
export const handleBulletClash = (bulletA: Entity, bulletB: Entity, ctx: CombatContext) => {
  handleMassExchange(bulletA, bulletB, 'CLASH_YELLOW', ctx);
};

// --- SHARED LOGIC ---

function resolveDaemonCollision(daemon: Entity, attacker: Entity, ctx: CombatContext, fixedDamage?: number) {
  const state = daemon.getComponent<StateComponent>('State');
  if (!state) return;

  let incomingDamage = fixedDamage || 10;
  
  if (!fixedDamage) {
      const hp = getHp(attacker);
      const id = getId(attacker);
      if (id?.variant === EnemyTypes.KAMIKAZE) incomingDamage = 20;
      else if (hp) incomingDamage = hp.current * 5; 
  }

  const shield = state.data.shieldHP || 0;

  // Active Shield Logic
  if (state.current === 'CHARGING' || state.current === 'READY') {
      if (shield > 0) {
          state.data.shieldHP = Math.max(0, shield - incomingDamage);
          state.data.wasHit = true; 
          
          if (attacker.hasTag('ENEMY')) {
              ctx.destroyEntity(attacker, 'CLASH_YELLOW');
          } else {
              ctx.destroyEntity(attacker, 'IMPACT_WHITE');
          }
          return;
      }
  }

  if (attacker.hasTag('ENEMY')) {
      ctx.destroyEntity(attacker, 'EXPLOSION_RED');
  } else {
      ctx.destroyEntity(attacker, 'IMPACT_RED');
  }
}

function handleMassExchange(a: Entity, b: Entity, fx: string, ctx: CombatContext) {
  const hpA = getHp(a);
  const hpB = getHp(b);

  const valA = hpA ? hpA.current : 1;
  const valB = hpB ? hpB.current : 1;
  const impact = Math.min(valA, valB);

  if (hpA) hpA.current = Math.max(0, hpA.current - impact);
  if (hpB) hpB.current = Math.max(0, hpB.current - impact);

  const pos = getPos(a);
  if (pos) ctx.spawnFX(fx, pos.x, pos.y);

  if (hpA && hpA.current <= 0) ctx.destroyEntity(a, 'IMPACT_WHITE');
  if (hpB && hpB.current <= 0) ctx.destroyEntity(b, 'IMPACT_WHITE');
}


=====================================
FILE: ./src/game/logic/combat/CollisionMatrix.ts
=====================================
import { CollisionLayers } from '@/game/config/PhysicsConfig';
import { CollisionHandler } from './types';
import * as Handlers from './CombatHandlers';

class CollisionMatrixController {
  private matrix = new Map<string, CollisionHandler>();

  constructor() {
    this.register(CollisionLayers.PLAYER, CollisionLayers.ENEMY, Handlers.handlePlayerCrash);
    this.register(CollisionLayers.PLAYER, CollisionLayers.ENEMY_PROJECTILE, Handlers.handlePlayerHit);
    this.register(CollisionLayers.ENEMY, CollisionLayers.PLAYER_PROJECTILE, Handlers.handleEnemyHit);
    this.register(CollisionLayers.PLAYER_PROJECTILE, CollisionLayers.ENEMY_PROJECTILE, Handlers.handleBulletClash);
  }

  private getKey(layerA: number, layerB: number): string {
    // Sort to ensure A:B is same as B:A
    return layerA < layerB ? `${layerA}:${layerB}` : `${layerB}:${layerA}`;
  }

  private register(layerA: number, layerB: number, handler: CollisionHandler) {
    this.matrix.set(this.getKey(layerA, layerB), handler);
  }

  public getHandler(layerA: number, layerB: number): CollisionHandler | undefined {
    return this.matrix.get(this.getKey(layerA, layerB));
  }
}

export const CollisionMatrix = new CollisionMatrixController();


=====================================
FILE: ./src/game/logic/combat/types.ts
=====================================
import { Entity } from '../../core/ecs/Entity';

export interface CombatContext {
  damagePlayer: (amount: number) => void;
  destroyEntity: (entity: Entity, fx?: string) => void;
  spawnFX: (type: string, x: number, y: number) => void;
  playAudio: (key: string) => void;
  addTrauma: (amount: number) => void; // NEW: Direct shake control
}

export type CollisionHandler = (entityA: Entity, entityB: Entity, ctx: CombatContext) => void;


=====================================
FILE: ./src/game/logic/ai/KamikazeLogic.ts
=====================================
import { Entity } from '../../core/ecs/Entity';
import { EnemyLogic, AIContext } from './types';
import { TransformComponent } from '../../components/data/TransformComponent';
import { MotionComponent } from '../../components/data/MotionComponent';
import { TargetComponent } from '../../components/data/TargetComponent';
import { StateComponent } from '../../components/data/StateComponent';
import { ENEMY_CONFIG } from '../../config/EnemyConfig';
import { EnemyTypes } from '../../config/Identifiers';
import { AI_CONFIG } from '../../config/AIConfig';

const getPos = (e: Entity) => e.requireComponent<TransformComponent>('Transform');
const getMotion = (e: Entity) => e.requireComponent<MotionComponent>('Motion');
const getTarget = (e: Entity) => e.requireComponent<TargetComponent>('Target');
const getState = (e: Entity) => e.requireComponent<StateComponent>('State');

export const KamikazeLogic: EnemyLogic = {
  update: (e: Entity, ctx: AIContext) => {
    const pos = getPos(e);
    const motion = getMotion(e);
    const target = getTarget(e);
    const state = getState(e);

    if (state.current === 'SPAWN') {
        state.timers.spawn -= ctx.delta;
        if (state.timers.spawn <= 0) {
            state.current = 'MOVING';
        }
        return; 
    }

    const dx = target.x - pos.x;
    const dy = target.y - pos.y;
    const dist = Math.sqrt(dx*dx + dy*dy);

    if (dist > AI_CONFIG.KAMIKAZE.ENGAGEMENT_DIST) {
      const speed = ENEMY_CONFIG[EnemyTypes.KAMIKAZE].baseSpeed;
      motion.vx = (dx / dist) * speed;
      motion.vy = (dy / dist) * speed;
      
      pos.rotation += AI_CONFIG.KAMIKAZE.ROTATION_SPEED * ctx.delta; 
    }
  }
};


=====================================
FILE: ./src/game/logic/ai/HunterLogic.ts
=====================================
import { Entity } from '../../core/ecs/Entity';
import { EnemyLogic, AIContext } from './types';
import { TransformComponent } from '../../components/data/TransformComponent';
import { MotionComponent } from '../../components/data/MotionComponent';
import { StateComponent } from '../../components/data/StateComponent';
import { TargetComponent } from '../../components/data/TargetComponent';
import { EnemyTypes } from '../../config/Identifiers';

const getPos = (e: Entity) => e.requireComponent<TransformComponent>('Transform');
const getMotion = (e: Entity) => e.requireComponent<MotionComponent>('Motion');
const getState = (e: Entity) => e.requireComponent<StateComponent>('State');
const getTarget = (e: Entity) => e.requireComponent<TargetComponent>('Target');

function rotateTowards(current: number, target: number, speed: number): number {
    let diff = target - current;
    while (diff > Math.PI) diff -= Math.PI * 2;
    while (diff < -Math.PI) diff += Math.PI * 2;
    return current + diff * speed;
}

function lerp(start: number, end: number, t: number): number {
    return start * (1 - t) + end * t;
}

export const HunterLogic: EnemyLogic = {
  update: (e: Entity, ctx: AIContext) => {
    const pos = getPos(e);
    const motion = getMotion(e);
    const state = getState(e);
    const target = getTarget(e);

    const hunterConfig = ctx.config.enemies[EnemyTypes.HUNTER];
    const aiConfig = ctx.config.ai.HUNTER;

    // --- INITIALIZATION ---
    if (state.data.spinVelocity === undefined) {
        state.data.spinVelocity = aiConfig.SPIN_SPEED_IDLE;
        state.data.spinAngle = 0;
    }
    
    if (state.current === 'SPAWN' || state.current === 'IDLE') {
        state.current = 'HUNT';
        state.timers.action = 3.0; 
        state.data.offsetAngle = (e.id.valueOf() % 10) * 0.6; 
    }

    let targetSpinSpeed = aiConfig.SPIN_SPEED_IDLE; 
    let spinLerpRate = ctx.delta * 2.0;

    // --- AIMING LOGIC ---
    const aimDx = target.x - pos.x;
    const aimDy = target.y - pos.y;
    const trueAngle = Math.atan2(aimDy, aimDx); // Standard Math Angle (0 = Right)

    // --- STATE MACHINE ---

    // 1. HUNT: Orbit and Idle Spin
    if (state.current === 'HUNT') {
        const currentAngle = (ctx.time * aiConfig.ORBIT_SPEED) + state.data.offsetAngle;
        const tx = target.x + Math.cos(currentAngle) * aiConfig.TARGET_RADIUS;
        const ty = target.y + Math.sin(currentAngle) * aiConfig.TARGET_RADIUS;

        const dx = tx - pos.x;
        const dy = ty - pos.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const speed = hunterConfig.baseSpeed; 
        
        // Move towards orbit point
        if (dist > 1.0) {
            motion.vx += (dx / dist) * speed * ctx.delta * 2.0;
            motion.vy += (dy / dist) * speed * ctx.delta * 2.0;
        }
        motion.vx *= 0.92;
        motion.vy *= 0.92;

        // Lazy Aim
        pos.rotation = rotateTowards(pos.rotation, trueAngle, aiConfig.AIM_LERP);

        state.timers.action -= ctx.delta;
        if (state.timers.action <= 0) {
            state.current = 'CHARGE';
            state.timers.action = hunterConfig.chargeDuration;
            // Stop moving to charge
            motion.vx *= 0.1; 
            motion.vy *= 0.1;
        }
    } 
    
    // 2. CHARGE: Rev up drill (Opposite Direction)
    else if (state.current === 'CHARGE') {
        state.timers.action -= ctx.delta;
        
        // Hard Aim
        pos.rotation = rotateTowards(pos.rotation, trueAngle, aiConfig.CHARGE_LERP);

        // Spin Ramp: Start slow, end fast (Negative direction)
        const progress = 1.0 - (state.timers.action / hunterConfig.chargeDuration);
        
        // Ramp function: 2.0 (Idle) -> -30.0 (Full Charge)
        // We use a curve to make it "rev up" at the end
        const revCurve = Math.pow(progress, 3); 
        targetSpinSpeed = aiConfig.SPIN_SPEED_IDLE - (revCurve * 35.0); 
        spinLerpRate = ctx.delta * 10.0; // Responsive

        if (state.timers.action <= 0) {
            state.current = 'FIRE';
        }
    }
    
    // 3. FIRE: Launch and Recoil
    else if (state.current === 'FIRE') {
        const dx = target.x - pos.x;
        const dy = target.y - pos.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const dirX = dist > 0 ? dx/dist : 0;
        const dirY = dist > 0 ? dy/dist : 1;
        
        const offset = aiConfig.OFFSET_DIST;
        
        const spawnX = pos.x + (dirX * offset);
        const spawnY = pos.y + (dirY * offset);

        // Calculate Damage from Config/Upgrade Context? For now standard.
        ctx.spawnProjectile(spawnX, spawnY, dirX * aiConfig.PROJECTILE_SPEED, dirY * aiConfig.PROJECTILE_SPEED);
        
        // Sparks: Pass True Angle (Visual Recoil handled by VFXSystem)
        ctx.spawnLaunchSparks(spawnX, spawnY, pos.rotation);

        state.current = 'HUNT';
        state.timers.action = 2.0 + Math.random() * 2.0;
        
        // SPRING OVERSHOOT: Kick spin to positive extreme (50) to "unwind" from the negative charge
        state.data.spinVelocity = 50.0; 
    }

    // --- APPLY SPIN PHYSICS ---
    state.data.spinVelocity = lerp(state.data.spinVelocity, targetSpinSpeed, spinLerpRate);
    state.data.spinAngle += state.data.spinVelocity * ctx.delta;
  }
};


=====================================
FILE: ./src/game/logic/ai/types.ts
=====================================
import { Entity } from '../../core/ecs/Entity';
import { ConfigService } from '@/game/services/ConfigService';

export interface AIContext {
  delta: number;
  time: number;
  
  // Audio/Visual
  spawnProjectile: (x: number, y: number, vx: number, vy: number, damage?: number) => void;
  spawnDrillSparks: (x: number, y: number, angle: number) => void; 
  spawnLaunchSparks: (x: number, y: number, angle: number) => void; 
  spawnFX: (type: string, x: number, y: number) => void;
  playSound: (key: string) => void;
  
  // World Interaction
  damagePanel: (id: string, amount: number) => void;
  
  // Data Access
  getUpgradeLevel: (key: string) => number;
  
  // Configuration (Injected)
  config: typeof ConfigService;
}

export interface EnemyLogic {
  update(entity: Entity, ctx: AIContext): void;
}


=====================================
FILE: ./src/game/logic/ai/DaemonLogic.ts
=====================================
import { Entity } from '../../core/ecs/Entity';
import { EnemyLogic, AIContext } from './types';
import { TransformComponent } from '../../components/data/TransformComponent';
import { StateComponent } from '../../components/data/StateComponent';
import { TargetComponent } from '../../components/data/TargetComponent';
import { OrbitalComponent } from '../../components/data/OrbitalComponent';
import { AI_CONFIG } from '../../config/AIConfig';

const getPos = (e: Entity) => e.requireComponent<TransformComponent>('Transform');
const getState = (e: Entity) => e.requireComponent<StateComponent>('State');
const getTarget = (e: Entity) => e.requireComponent<TargetComponent>('Target');
const getOrbital = (e: Entity) => e.requireComponent<OrbitalComponent>('Orbital');

export const DaemonLogic: EnemyLogic = {
  update: (e: Entity, ctx: AIContext) => {
    const pos = getPos(e);
    const state = getState(e);
    const target = getTarget(e);
    const orbital = getOrbital(e);

    const executeLevel = ctx.getUpgradeLevel('EXECUTE');
    const maxShield = 10 + executeLevel;

    if (typeof state.data.shieldHP !== 'number') {
        state.data.shieldHP = 0;
    }
    state.data.maxShield = maxShield; 

    // --- STATE MACHINE ---

    if (state.current === 'SPAWN' || state.current === 'ORBIT') {
        state.current = 'CHARGING';
        state.data.shieldHP = 0; 
    }

    // 1. CHARGING
    if (state.current === 'CHARGING') {
        orbital.active = true;
        if (state.data.shieldHP <= 0 && state.data.wasHit) {
             state.current = 'BROKEN';
             state.timers.action = AI_CONFIG.DAEMON.RECOVERY_TIME;
             return;
        }
        const chargeRate = maxShield / AI_CONFIG.DAEMON.SHIELD_CHARGE_TIME; 
        state.data.shieldHP = Math.min(maxShield, state.data.shieldHP + (chargeRate * ctx.delta));
        if (state.data.shieldHP >= maxShield) {
            state.current = 'READY';
        }
    } 
    
    // 2. READY
    else if (state.current === 'READY') {
        orbital.active = true;
        if (state.data.shieldHP <= 0) {
             state.current = 'BROKEN';
             state.timers.action = AI_CONFIG.DAEMON.RECOVERY_TIME;
             return;
        }
        if (target.id === 'ENEMY_LOCKED') state.current = 'FIRE';
    }
    
    // 3. FIRE
    else if (state.current === 'FIRE') {
        const dx = target.x - pos.x;
        const dy = target.y - pos.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const dirX = dist > 0 ? dx/dist : 0;
        const dirY = dist > 0 ? dy/dist : 1;
        
        // FIX: Use Standard Math (0 = Right)
        // Previous: Math.atan2(dy, dx) - Math.PI/2
        pos.rotation = Math.atan2(dy, dx);

        ctx.spawnProjectile(pos.x, pos.y, dirX * 35, dirY * 35, maxShield);
        ctx.spawnFX('IMPACT_WHITE', pos.x, pos.y);

        state.data.shieldHP = 0; 
        state.current = 'COOLDOWN';
        state.timers.action = AI_CONFIG.DAEMON.COOLDOWN_TIME;
    }
    
    // 4. COOLDOWN
    else if (state.current === 'COOLDOWN') {
        orbital.active = true;
        state.timers.action -= ctx.delta;
        if (state.timers.action <= 0) {
            state.current = 'CHARGING';
            state.data.wasHit = false;
        }
    }

    // 5. BROKEN
    else if (state.current === 'BROKEN') {
        state.data.shieldHP = 0;
        state.timers.action -= ctx.delta;
        
        // Spin Logic
        pos.rotation += ctx.delta * AI_CONFIG.DAEMON.ROTATION_SPEED.BROKEN;

        if (state.timers.action <= 0) {
            state.current = 'CHARGING';
            state.data.wasHit = false;
        }
    }
  }
};


=====================================
FILE: ./src/game/logic/ai/AIRegistry.ts
=====================================
import { EnemyLogic } from './types';

class AIRegistryController {
  private behaviors = new Map<string, EnemyLogic>();

  public register(id: string, logic: EnemyLogic) {
    if (this.behaviors.has(id)) {
        console.warn(`[AIRegistry] Overwriting behavior for ${id}`);
    }
    this.behaviors.set(id, logic);
  }

  public get(id: string): EnemyLogic | undefined {
    return this.behaviors.get(id);
  }
}

export const AIRegistry = new AIRegistryController();


=====================================
FILE: ./src/game/logic/ai/DrillerLogic.ts
=====================================
import { Entity } from '../../core/ecs/Entity';
import { EnemyLogic, AIContext } from './types';
import { TransformComponent } from '../../components/data/TransformComponent';
import { MotionComponent } from '../../components/data/MotionComponent';
import { StateComponent } from '../../components/data/StateComponent';
import { TargetComponent } from '../../components/data/TargetComponent';
import { PanelRegistry } from '../../systems/PanelRegistrySystem'; 
import { EnemyTypes } from '../../config/Identifiers';

const getPos = (e: Entity) => e.requireComponent<TransformComponent>('Transform');
const getMotion = (e: Entity) => e.requireComponent<MotionComponent>('Motion');
const getState = (e: Entity) => e.requireComponent<StateComponent>('State');
const getTarget = (e: Entity) => e.requireComponent<TargetComponent>('Target');

export const DrillerLogic: EnemyLogic = {
  update: (e: Entity, ctx: AIContext) => {
    const pos = getPos(e);
    const motion = getMotion(e);
    const state = getState(e);
    const target = getTarget(e);

    const drillerConfig = ctx.config.enemies[EnemyTypes.DRILLER];
    const aiConfig = ctx.config.ai.DRILLER;

    if (typeof state.data.audioTimer === 'undefined') state.data.audioTimer = 0;
    if (typeof state.data.damageTimer === 'undefined') state.data.damageTimer = 0;

    let destX = target.x;
    let destY = target.y;
    
    // Improved Targeting Logic:
    // If target is a Panel, clamp destination to the panel's bounding box edge
    if (target.type === 'PANEL' && target.id) {
        const rect = PanelRegistry.getPanelRect(target.id);
        if (rect) {
            // Find the closest point on the rectangle perimeter to the enemy
            // Clamp X
            const clampX = Math.max(rect.left, Math.min(pos.x, rect.right));
            // Clamp Y
            const clampY = Math.max(rect.bottom, Math.min(pos.y, rect.top));
            
            destX = clampX;
            destY = clampY;
        }
    }

    const dx = destX - pos.x;
    const dy = destY - pos.y;
    const distSq = dx*dx + dy*dy;
    const dist = Math.sqrt(distSq);
    
    const angle = Math.atan2(dy, dx);
    
    // Check if we are close enough to the TARGET POINT (which is now the edge)
    if (dist <= aiConfig.TIP_OFFSET + aiConfig.SNAP_THRESHOLD && target.id !== null) {
        state.current = 'DRILLING';
        
        if (dist > 0.001) {
            const normX = dx / dist;
            const normY = dy / dist;
            pos.x = destX - (normX * aiConfig.TIP_OFFSET);
            pos.y = destY - (normY * aiConfig.TIP_OFFSET);
        }

        motion.vx = 0;
        motion.vy = 0;
        pos.rotation = angle;

        ctx.spawnDrillSparks(destX, destY, angle);

        state.data.audioTimer -= ctx.delta;
        if (state.data.audioTimer <= 0) {
            ctx.playSound('loop_drill');
            state.data.audioTimer = aiConfig.AUDIO_INTERVAL + Math.random() * 0.1; 
        }

        state.data.damageTimer -= ctx.delta;
        if (state.data.damageTimer <= 0) {
             if (target.type === 'PANEL' && target.id) {
                 const dmg = drillerConfig.damage; 
                 ctx.damagePanel(target.id, dmg);
                 state.data.damageTimer = 0.2; 
             }
        }

    } else {
        state.current = 'MOVING';
        state.data.audioTimer = 0;
        state.data.damageTimer = 0;

        const speed = drillerConfig.baseSpeed;
        if (dist > 0.001) {
            motion.vx = (dx / dist) * speed;
            motion.vy = (dy / dist) * speed;
            pos.rotation = angle; 
        }
    }
  }
};


=====================================
FILE: ./src/game/logic/ai/BehaviorCatalog.ts
=====================================
import { AIRegistry } from './AIRegistry';
import { EnemyTypes } from '@/game/config/Identifiers';

// Logic Implementations
import { DrillerLogic } from './DrillerLogic';
import { KamikazeLogic } from './KamikazeLogic';
import { HunterLogic } from './HunterLogic';
import { DaemonLogic } from './DaemonLogic';

export const registerAllBehaviors = () => {
  AIRegistry.register(EnemyTypes.DRILLER, DrillerLogic);
  AIRegistry.register(EnemyTypes.KAMIKAZE, KamikazeLogic);
  AIRegistry.register(EnemyTypes.HUNTER, HunterLogic);
  AIRegistry.register(EnemyTypes.DAEMON, DaemonLogic);
  
  console.log('[BehaviorCatalog] AI Behaviors Registered.');
};


=====================================
FILE: ./src/game/render/RenderCatalog.ts
=====================================
import { RenderRegistry } from './RenderRegistry';

// Renderers
import { PlayerAvatar } from '../components/PlayerAvatar';
import { BulletRenderer } from '../components/BulletRenderer';
import { EnemyBulletRenderer } from '../components/EnemyBulletRenderer';
import { HunterChargeRenderer } from '../components/HunterChargeRenderer';
import { ParticleRenderer } from '../components/ParticleRenderer';
import { ProjectileTrails } from '../components/ProjectileTrails';
import { DaemonRenderer } from '../components/DaemonRenderer';
import { DaemonChargeRenderer } from '../components/DaemonChargeRenderer';
import { DaemonBulletRenderer } from '../components/DaemonBulletRenderer';

// New Atomic Renderers
import { DrillerRenderer } from '../components/enemies/DrillerRenderer';
import { KamikazeRenderer } from '../components/enemies/KamikazeRenderer';
import { HunterRenderer } from '../components/enemies/HunterRenderer';

export const registerAllRenderers = () => {
  // Core
  RenderRegistry.register(PlayerAvatar);
  RenderRegistry.register(ProjectileTrails);
  
  // Projectiles
  RenderRegistry.register(BulletRenderer);
  RenderRegistry.register(EnemyBulletRenderer);
  RenderRegistry.register(DaemonBulletRenderer);
  
  // Enemies (Decoupled)
  RenderRegistry.register(DrillerRenderer);
  RenderRegistry.register(KamikazeRenderer);
  RenderRegistry.register(HunterRenderer);
  
  // Friendlies
  RenderRegistry.register(DaemonRenderer);
  
  // FX / States
  RenderRegistry.register(ParticleRenderer);
  RenderRegistry.register(HunterChargeRenderer);
  RenderRegistry.register(DaemonChargeRenderer);
  
  console.log('[RenderCatalog] Visual Components Registered.');
};


=====================================
FILE: ./src/game/render/RenderRegistry.ts
=====================================
import { ComponentType } from 'react';

type RendererComponent = ComponentType<any>;

class RenderRegistryController {
  private renderers = new Set<RendererComponent>();

  public register(component: RendererComponent) {
    this.renderers.add(component);
  }

  public getAll(): RendererComponent[] {
    return Array.from(this.renderers);
  }
}

export const RenderRegistry = new RenderRegistryController();


=====================================
FILE: ./src/game/utils/RenderUtils.ts
=====================================
import * as THREE from 'three';

// Zero-allocation reusable objects for the render loop
export const axisY = new THREE.Vector3(0, 1, 0); // Model Axis (Up)
export const axisZ = new THREE.Vector3(0, 0, 1); // World Axis (Forward/Screen)
export const qSpin = new THREE.Quaternion();
export const qAim = new THREE.Quaternion();

/**
 * Applies a local Y-axis spin and a global Z-axis aim to an object.
 */
export const applyRotation = (obj: THREE.Object3D, spin: number, aim: number) => {
  // 1. Spin around Local Y (Model Axis)
  qSpin.setFromAxisAngle(axisY, spin);
  
  // 2. Aim around World Z
  // Offset by -PI/2 because model points Up, but 0 radians is Right.
  qAim.setFromAxisAngle(axisZ, aim - Math.PI/2);
  
  // 3. Combine: Aim * Spin
  qAim.multiply(qSpin);
  
  obj.quaternion.copy(qAim);
};


=====================================
FILE: ./src/game/utils/TextureGen.ts
=====================================
import * as THREE from 'three';

// Helper: Exponential Falloff for natural light
// x is 0..1 (distance from center)
const falloff = (x: number, power: number = 2) => {
  return Math.pow(Math.max(0, 1 - x), power);
};

// 1. High Quality Comet Trail
export const createCometTexture = () => {
  const w = 64;
  const h = 256; // Higher resolution vertical
  const canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext('2d')!;
  
  ctx.clearRect(0, 0, w, h);

  // We draw manually pixel-by-pixel or using complex gradients for better control
  // Gradient: Bottom (Head) -> Top (Tail)
  const gradient = ctx.createLinearGradient(0, h, 0, 0);
  
  // Exponential fade:
  // 0.0 (Head): 100% Opacity
  // 0.2 (Body): 60% Opacity
  // 1.0 (Tail): 0% Opacity
  gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)'); 
  gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.4)');
  gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

  ctx.fillStyle = gradient;

  // Shape: Tapered Triangle
  ctx.beginPath();
  ctx.moveTo(w * 0.1, h);       // Bottom Left (pinched slightly)
  ctx.lineTo(w * 0.9, h);       // Bottom Right
  ctx.lineTo(w * 0.5, 0);       // Top Tip
  ctx.closePath();
  ctx.fill();

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
};

// 2. Player Bullet (Glowing Bar)
export const createGlowingBarTexture = () => {
  const w = 64;
  const h = 128;
  const canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext('2d')!;

  // Clear
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, w, h);

  // Glow (Soft Rect)
  const cx = w / 2;
  const cy = h / 2;
  
  // Radial glow around the bar isn't ideal, let's use shadow blur
  ctx.shadowColor = "white";
  ctx.shadowBlur = 20;
  ctx.fillStyle = "white";
  
  // Draw Core (Slim Rectangle)
  // Leave padding for the glow/shadow to bleed
  ctx.fillRect(24, 20, 16, 88); 

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
};

// 3. Hunter Orb (Exponential Glow)
export const createExponentialBallTexture = () => {
  const size = 128;
  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d')!;
  
  const cx = size / 2;
  const cy = size / 2;
  const radius = size / 2;

  const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
  
  // Sharp Core, Soft Bloom
  gradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); 
  gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.9)'); // Solid Core
  gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)'); // Mid Bloom
  gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Fade out

  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, size, size);

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
};

// 4. Soft Glow (Backgrounds - Legacy/Enemies)
export const createGlowTexture = () => {
  const canvas = document.createElement('canvas');
  canvas.width = 64;
  canvas.height = 64;
  const ctx = canvas.getContext('2d')!;
  
  const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
  gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
  gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 64, 64);

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
};


=====================================
FILE: ./src/game/utils/Noise.ts
=====================================
// Simple 1D Gradient Noise
// Returns value between -1 and 1 based on input 'x'
export function noise(x: number): number {
  const i = Math.floor(x);
  const f = x - i;
  const u = f * f * (3.0 - 2.0 * f); // Cubic smoothing
  return mix(hash(i), hash(i + 1), u);
}

function hash(n: number): number {
  return (Math.sin(n) * 43758.5453) % 1.0;
}

function mix(a: number, b: number, t: number): number {
  return a * (1 - t) + b * t;
}


=====================================
FILE: ./src/game/utils/ViewportHelper.ts
=====================================
export interface WorldRect {
  id: string;
  x: number;
  y: number;
  width: number;
  height: number;
  left: number;
  right: number;
  top: number;
  bottom: number;
}

export class ViewportHelperCore {
  public viewport = { width: 1, height: 1 }; // R3F Viewport units
  public screenSize = { width: 1, height: 1 }; // Window Pixels

  public update(vpW: number, vpH: number, screenW: number, screenH: number) {
    this.viewport = { width: vpW, height: vpH };
    this.screenSize = { width: screenW, height: screenH };
  }

  // Pure Math: Converts Pixel Rect -> World Rect
  public domToWorld(id: string, domRect: DOMRect): WorldRect {
    const sw = this.screenSize.width || 1;
    const sh = this.screenSize.height || 1;
    
    const vw = this.viewport.width;
    const vh = this.viewport.height;
    
    const cx = domRect.left + domRect.width / 2;
    const cy = domRect.top + domRect.height / 2;
    
    // Screen (Pixels) -> World (Orthographic Units)
    // 0,0 is center of screen in World
    const wx = (cx / sw) * vw - (vw / 2);
    const wy = -((cy / sh) * vh - (vh / 2));
    
    const wWidth = (domRect.width / sw) * vw;
    const wHeight = (domRect.height / sh) * vh;

    return {
      id: id,
      x: wx, y: wy,
      width: wWidth, height: wHeight,
      left: wx - wWidth / 2, right: wx + wWidth / 2,
      top: wy + wHeight / 2, bottom: wy - wHeight / 2,
    };
  }
}

export const ViewportHelper = new ViewportHelperCore();


=====================================
FILE: ./src/game/utils/GeometryUtils.ts
=====================================
import * as THREE from 'three';

export const addBarycentricCoordinates = (bufferGeometry: THREE.BufferGeometry, removeEdge: boolean = false) => {
  const geometry = bufferGeometry.toNonIndexed();
  const count = geometry.attributes.position.count;
  const centers = new Float32Array(count * 3);

  for (let i = 0; i < count; i += 3) {
    centers[i * 3] = 1;
    centers[i * 3 + 1] = 0;
    centers[i * 3 + 2] = 0;

    centers[i * 3 + 3] = 0;
    centers[i * 3 + 4] = 1;
    centers[i * 3 + 5] = 0;

    centers[i * 3 + 6] = 0;
    centers[i * 3 + 7] = 0;
    centers[i * 3 + 8] = 1;
  }

  geometry.setAttribute('barycentric', new THREE.BufferAttribute(centers, 3));
  return geometry;
};

// NEW: Tri-Wing "Paper Airplane" Spear
export const createHunterSpear = () => {
  const positions: number[] = [];
  
  // We build 3 "Wings" (thin triangles)
  const numWings = 3;
  const length = 1.2;
  const wingWidth = 0.4;
  const wingThickness = 0.05; // Give it slight 3D thickness

  for(let i=0; i<numWings; i++) {
      const angle = (i / numWings) * Math.PI * 2;
      
      // We build a triangle in the Y/X plane, then rotate it around Y
      // Tip at (0, length/2, 0)
      // Base Outer at (width, -length/2, 0)
      // Base Inner at (0, -length/2, 0)
      
      const tipY = length / 2;
      const baseY = -length / 2;
      
      // Define vertices for a "Thick" triangle (Wedge)
      // P1: Tip
      // P2: Base Outer Left
      // P3: Base Outer Right
      // P4: Base Center (Axis)
      
      // Let's manually push triangles for a "Fin"
      // Fin stands on the +X axis
      
      const pTip = [0, tipY, 0];
      const pBaseOut = [wingWidth, baseY, 0];
      const pBaseInBack = [0, baseY, -wingThickness];
      const pBaseInFront = [0, baseY, wingThickness];
      
      // Helper to rotate point around Y axis
      const rotateY = (p: number[], rad: number) => {
          const x = p[0];
          const z = p[2];
          return [
              x * Math.cos(rad) - z * Math.sin(rad),
              p[1], // Y unchanged
              x * Math.sin(rad) + z * Math.cos(rad)
          ];
      };

      // Push Triangles
      // 1. Face Front
      let v1 = rotateY(pTip, angle);
      let v2 = rotateY(pBaseOut, angle);
      let v3 = rotateY(pBaseInFront, angle);
      positions.push(...v1, ...v2, ...v3);
      
      // 2. Face Back
      v1 = rotateY(pTip, angle);
      v2 = rotateY(pBaseInBack, angle);
      v3 = rotateY(pBaseOut, angle);
      positions.push(...v1, ...v2, ...v3);
      
      // 3. Base Cap (optional, but good for solidity)
      // ... skipping for wireframe aesthetic
  }
  
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  geometry.computeVertexNormals();
  
  return addBarycentricCoordinates(geometry);
};


=====================================
FILE: ./src/game/utils/ai/StateMachine.ts
=====================================
import { Entity } from '../../core/ecs/Entity';

export interface State {
  name: string;
  enter?: (entity: Entity, data?: any) => void;
  update?: (entity: Entity, delta: number, time: number, data?: any) => void;
  exit?: (entity: Entity, data?: any) => void;
}

export class StateMachine {
  private states = new Map<string, State>();
  private currentState: State | null = null;

  public addState(state: State) {
    this.states.set(state.name, state);
    return this;
  }

  public setState(name: string, entity: Entity, data?: any) {
    if (this.currentState && this.currentState.name === name) return;

    if (this.currentState && this.currentState.exit) {
      this.currentState.exit(entity, data);
    }

    this.currentState = this.states.get(name) || null;

    if (this.currentState && this.currentState.enter) {
      this.currentState.enter(entity, data);
    }
  }

  public update(entity: Entity, delta: number, time: number, data?: any) {
    if (this.currentState && this.currentState.update) {
      this.currentState.update(entity, delta, time, data);
    }
  }

  public getCurrentState() {
    return this.currentState?.name || null;
  }
}


=====================================
FILE: ./src/game/utils/coords.ts
=====================================
// Camera Zoom level defined in GameOverlay
const ZOOM = 40; 

export const screenToWorld = (screenX: number, screenY: number, screenW: number, screenH: number) => {
  // DOM: 0,0 is Top-Left. +Y is Down.
  // THREE: 0,0 is Center. +Y is Up.
  
  const worldX = (screenX - screenW / 2) / ZOOM;
  const worldY = -(screenY - screenH / 2) / ZOOM; // Invert Y
  
  return { x: worldX, y: worldY };
};

export const domRectToWorldRect = (rect: { x: number, y: number, width: number, height: number }, screenW: number, screenH: number) => {
  // Get center of DOM element
  const centerX = rect.x + rect.width / 2;
  const centerY = rect.y + rect.height / 2;
  
  const centerWorld = screenToWorld(centerX, centerY, screenW, screenH);
  
  return {
    x: centerWorld.x,
    y: centerWorld.y,
    width: rect.width / ZOOM,
    height: rect.height / ZOOM,
    left: centerWorld.x - (rect.width / ZOOM / 2),
    right: centerWorld.x + (rect.width / ZOOM / 2),
    top: centerWorld.y + (rect.height / ZOOM / 2),
    bottom: centerWorld.y - (rect.height / ZOOM / 2),
  };
};


=====================================
FILE: ./src/game/components/DaemonChargeRenderer.tsx
=====================================
import { useMemo } from 'react';
import * as THREE from 'three';
import { Tag } from '../core/ecs/types';
import { EnemyTypes } from '../config/Identifiers';
import { InstancedActor } from './common/InstancedActor';
import { IdentityComponent } from '../data/IdentityComponent';
import { StateComponent } from '../data/StateComponent';
import { TransformComponent } from '../data/TransformComponent';

const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0); }`;
const fragmentShader = `
  varying vec2 vUv; uniform vec3 uColor;
  void main() {
    float dist = distance(vUv, vec2(0.5));
    float core = 1.0 - smoothstep(0.2, 0.25, dist);
    float glow = pow(1.0 - smoothstep(0.25, 0.5, dist), 3.0);
    gl_FragColor = vec4(mix(uColor, vec3(1.0), core), max(core, glow));
  }
`;

export const DaemonChargeRenderer = () => {
  const geometry = useMemo(() => new THREE.PlaneGeometry(4.0, 4.0), []);
  const material = useMemo(() => new THREE.ShaderMaterial({
    vertexShader, fragmentShader,
    uniforms: { uColor: { value: new THREE.Color('#00F0FF') } }, 
    transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
  }), []);

  return (
    <InstancedActor
      tag={Tag.PLAYER}
      geometry={geometry}
      material={material}
      maxCount={10}
      filter={(e) => {
          const id = e.getComponent<IdentityComponent>('Identity');
          const state = e.getComponent<StateComponent>('State');
          // Hide if BROKEN
          return id?.variant === EnemyTypes.DAEMON && (state?.current === 'CHARGING' || state?.current === 'READY');
      }}
      updateEntity={(e, obj) => {
          const transform = e.getComponent<TransformComponent>('Transform');
          const state = e.getComponent<StateComponent>('State');
          
          if (transform && state) {
              obj.position.copy(new THREE.Vector3(transform.x, transform.y, 0.1));
              obj.rotation.set(0,0,0);

              // SCALE BASED ON SHIELD HP
              const maxShield = state.data.maxShield || 10;
              const currentShield = state.data.shieldHP || 0;
              const healthRatio = Math.max(0, currentShield / maxShield);
              
              if (state.current === 'READY') {
                  // Pulse at full current size
                  const pulse = 1.0 + Math.sin(performance.now() * 0.01) * 0.1;
                  obj.scale.setScalar(healthRatio * pulse);
              } else {
                  obj.scale.setScalar(healthRatio);
              }
          }
      }}
    />
  );
};


=====================================
FILE: ./src/game/components/PlayerAvatar.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import { GAME_THEME } from '../theme';
import { ServiceLocator } from '../core/ServiceLocator';
import { useGameStore } from '../store/useGameStore';
import { useStore } from '@/core/store/useStore';
import { InteractionSystem, RepairState } from '../systems/InteractionSystem'; 
import { EntitySystem } from '../systems/EntitySystem';
import * as THREE from 'three';

export const PlayerAvatar = () => {
  const groupRef = useRef<THREE.Group>(null);
  const ringRef = useRef<THREE.Mesh>(null);
  const coreRef = useRef<THREE.Mesh>(null);
  const glowRef = useRef<THREE.Sprite>(null);
  const { viewport } = useThree();
  
  const { introDone } = useStore(); 

  const colorTurret = new THREE.Color(GAME_THEME.turret.base); 
  const colorRepair = new THREE.Color(GAME_THEME.turret.repair); 
  const colorReboot = new THREE.Color('#9E4EA5'); 
  const colorDead = new THREE.Color('#FF003C'); 

  const isDead = useGameStore(state => state.playerHealth <= 0);
  const isGameOver = useGameStore(state => state.systemIntegrity <= 0);
  
  // GEOMETRIES
  const aliveGeo = new THREE.CircleGeometry(0.1, 16);
  // Reverted: Use Circle with 3 segments for Triangle, size 0.12
  const deadGeo = new THREE.CircleGeometry(0.12, 3); 
  
  const animScale = useRef(0);

  useFrame((state, delta) => {
    if (!groupRef.current) return;

    // FADE IN LOGIC
    const targetScale = introDone ? 1 : 0;
    animScale.current = THREE.MathUtils.lerp(animScale.current, targetScale, delta * 2.0);
    
    if (animScale.current < 0.01) {
        groupRef.current.visible = false;
        return;
    }
    groupRef.current.visible = true;

    // 1. Position
    const x = (state.pointer.x * viewport.width) / 2;
    const y = (state.pointer.y * viewport.height) / 2;
    groupRef.current.position.x = x;
    groupRef.current.position.y = y;

    try { ServiceLocator.getInputService().updateCursor(x, y); } catch {}

    // 2. State
    let repairState: RepairState = 'IDLE';
    let entitySys: EntitySystem | null = null;
    try {
        repairState = ServiceLocator.getSystem<InteractionSystem>('InteractionSystem').repairState;
        entitySys = ServiceLocator.getSystem<EntitySystem>('EntitySystem');
    } catch {}
    
    let targetColor = colorTurret;
    if (repairState === 'HEALING') targetColor = colorRepair; 
    if (repairState === 'REBOOTING') targetColor = colorReboot; 

    // 3. Visuals
    if (ringRef.current && coreRef.current && glowRef.current) {
        let currentBaseScale = 1.0;

        if (isDead || isGameOver) {
            // DEAD STATE: Red Triangle
            ringRef.current.visible = false;
            glowRef.current.visible = false;
            
            coreRef.current.geometry = deadGeo;
            coreRef.current.material.color.set(colorDead);
            coreRef.current.material.wireframe = true; 
            
            // ANIMATION LOGIC
            const isRebooting = repairState === 'REBOOTING';
            
            if (isRebooting) {
                // Fast Counter-Clockwise Spin
                coreRef.current.rotation.z -= delta * 10.0;
                
                // Particle Spray
                if (entitySys && Math.random() > 0.5) { // 30fps emission rate
                    const pColor = Math.random() > 0.5 ? '#FF003C' : '#F7D277';
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 3;
                    
                    entitySys.spawnParticle(x, y, pColor, 1, speed, 0.4);
                }
            } else {
                // Slow Clockwise Idle Spin
                coreRef.current.rotation.z += delta * 1.5; 
            }
            
        } else {
            // ALIVE STATE
            ringRef.current.visible = true;
            glowRef.current.visible = true;
            coreRef.current.geometry = aliveGeo;
            coreRef.current.material.wireframe = false;
            
            if (repairState !== 'IDLE') {
                ringRef.current.rotation.z += 0.4; 
                ringRef.current.material.color.lerp(targetColor, 0.4);
                coreRef.current.material.color.lerp(targetColor, 0.4);
                glowRef.current.material.color.lerp(targetColor, 0.4);
                
                const pulse = 1.2 + Math.sin(state.clock.elapsedTime * 20) * 0.2;
                currentBaseScale = pulse;
            } else {
                ringRef.current.rotation.z -= 0.02; 
                ringRef.current.material.color.lerp(colorTurret, 0.1);
                coreRef.current.material.color.lerp(colorTurret, 0.1);
                glowRef.current.material.color.lerp(colorTurret, 0.1);
            }
        }
        
        groupRef.current.scale.setScalar(animScale.current);
        coreRef.current.scale.setScalar(currentBaseScale);
        ringRef.current.scale.setScalar(currentBaseScale); 
    }
  });

  return (
    <group ref={groupRef}>
      <mesh ref={coreRef}>
        <bufferGeometry />
        <meshBasicMaterial color={GAME_THEME.turret.base} />
      </mesh>

      <mesh ref={ringRef} rotation={[0, 0, Math.PI / 4]}>
        <ringGeometry args={[0.4, 0.45, 4]} /> 
        <meshBasicMaterial color={GAME_THEME.turret.base} transparent opacity={0.8} />
      </mesh>

      <sprite ref={glowRef} scale={[2, 2, 1]}>
        <spriteMaterial 
          color={GAME_THEME.turret.glow} 
          transparent 
          opacity={0.3}
          blending={THREE.AdditiveBlending}
        />
      </sprite>
    </group>
  );
};


=====================================
FILE: ./src/game/components/MobileGameDirector.tsx
=====================================
import { useFrame, useThree } from '@react-three/fiber';
import { useEffect, useRef } from 'react';
import { MobileBootstrapper } from '../core/MobileBootstrapper';
import { GameEngineCore } from '../core/GameEngine';
import { setActiveEngine } from './GameDirector';

export const MobileGameDirector = () => {
  const { viewport, size } = useThree();
  const engineRef = useRef<GameEngineCore | null>(null);

  useEffect(() => {
    const engine = MobileBootstrapper();
    engineRef.current = engine;
    setActiveEngine(engine);
    
    engine.updateViewport(viewport.width, viewport.height, size.width, size.height);

    return () => {
      engine.teardown();
      engineRef.current = null;
      setActiveEngine(null);
    };
  }, []);

  useFrame((state, delta) => {
    if (engineRef.current) {
        engineRef.current.update(delta, state.clock.elapsedTime);
    }
  });

  return null;
};


=====================================
FILE: ./src/game/components/BulletRenderer.tsx
=====================================
import { Tag } from '../core/ecs/types';
import { InstancedActor } from './common/InstancedActor';
import { HealthComponent } from '../components/data/HealthComponent';
import { AssetService } from '../assets/AssetService';
import { TransformComponent } from '../components/data/TransformComponent';
import * as THREE from 'three';

export const BulletRenderer = () => {
  const geometry = AssetService.get<THREE.BufferGeometry>('GEO_BULLET_PLAYER');
  const material = AssetService.get<THREE.Material>('MAT_BULLET_PLAYER');

  return (
    <InstancedActor 
      tag={Tag.BULLET} 
      geometry={geometry} 
      material={material} 
      maxCount={500} 
      filter={(e) => !e.hasTag(Tag.ENEMY)}
      updateEntity={(e, obj) => {
         const transform = e.getComponent<TransformComponent>('Transform');
         const hp = e.getComponent<HealthComponent>('Health');
         
         let hpScale = 1.0;
         if (hp && hp.max > 1) {
             hpScale = 0.6 + (0.4 * (hp.current / hp.max));
         }
         
         const widthScale = transform ? transform.scale : 1.0;
         obj.scale.set(widthScale * hpScale, 1.5 * hpScale, 1); 
         if (transform) obj.rotation.z = transform.rotation - (Math.PI / 2);
      }}
    />
  );
};


=====================================
FILE: ./src/game/components/ParticleRenderer.tsx
=====================================
import { Tag } from '../core/ecs/types';
import { InstancedActor } from './common/InstancedActor';
import { LifetimeComponent } from '../components/data/LifetimeComponent';
import { AssetService } from '../assets/AssetService';
import * as THREE from 'three';

export const ParticleRenderer = () => {
  const geometry = AssetService.get<THREE.BufferGeometry>('GEO_PARTICLE');
  const material = AssetService.get<THREE.Material>('MAT_PARTICLE');

  return (
    <InstancedActor 
      tag={Tag.PARTICLE} 
      geometry={geometry} 
      material={material} 
      maxCount={1000}
      colorSource="identity"
      updateEntity={(e, obj, color) => {
         const life = e.getComponent<LifetimeComponent>('Lifetime');
         if (life) {
             const scale = life.remaining / life.total;
             obj.scale.setScalar(scale);
             const isInFront = (e.id as number) % 2 === 0;
             obj.position.z = isInFront ? 6.0 : 4.0;
         }
      }}
    />
  );
};


=====================================
FILE: ./src/game/components/EnemyBulletRenderer.tsx
=====================================
import { Tag } from '../core/ecs/types';
import { InstancedActor } from './common/InstancedActor';
import { HealthComponent } from '../components/data/HealthComponent';
import { AssetService } from '../assets/AssetService';

export const EnemyBulletRenderer = () => {
  const geometry = AssetService.get<THREE.BufferGeometry>('GEO_BULLET_ENEMY');
  const material = AssetService.get<THREE.Material>('MAT_BULLET_ENEMY');

  return (
    <InstancedActor 
      tag={Tag.BULLET} 
      geometry={geometry} 
      material={material} 
      maxCount={200}
      filter={(e) => e.hasTag(Tag.ENEMY)}
      updateEntity={(e, obj) => {
          const hp = e.getComponent<HealthComponent>('Health');
          let scale = 1.0;
          
          if (hp) {
              const ratio = hp.current / hp.max;
              // MATCHED: Max Scale is now 1.5 to match HunterChargeRenderer
              // Range: 0.6 (Damaged) -> 1.5 (Full)
              scale = 0.6 + (0.9 * ratio);
          }

          obj.rotation.set(0,0,0);
          obj.scale.setScalar(scale);
      }}
    />
  );
};


=====================================
FILE: ./src/game/components/HunterChargeRenderer.tsx
=====================================
import { Tag } from '../core/ecs/types';
import { EnemyTypes } from '../config/Identifiers';
import { InstancedActor } from './common/InstancedActor';
import { IdentityComponent } from '../data/IdentityComponent';
import { StateComponent } from '../data/StateComponent';
import { TransformComponent } from '../data/TransformComponent';
import { AssetService } from '../assets/AssetService';
import { ServiceLocator } from '../core/ServiceLocator';
import * as THREE from 'three';

export const HunterChargeRenderer = () => {
  const geometry = AssetService.get<THREE.BufferGeometry>('GEO_BULLET_ENEMY');
  const material = AssetService.get<THREE.Material>('MAT_BULLET_ENEMY');

  return (
    <InstancedActor
      tag={Tag.ENEMY}
      geometry={geometry}
      material={material}
      maxCount={50}
      filter={(e) => {
          const id = e.getComponent<IdentityComponent>('Identity');
          const state = e.getComponent<StateComponent>('State');
          return id?.variant === EnemyTypes.HUNTER && state?.current === 'CHARGE';
      }}
      updateEntity={(e, obj) => {
          const transform = e.getComponent<TransformComponent>('Transform');
          const state = e.getComponent<StateComponent>('State');
          
          if (transform && state) {
              const config = ServiceLocator.getConfigService().enemies[EnemyTypes.HUNTER];
              const maxDuration = config ? config.chargeDuration : 1.0; 
              
              // Safe access to timer
              const currentTimer = state.timers.action;
              const remaining = typeof currentTimer === 'number' ? currentTimer : maxDuration;
              
              // Calculate Progress (0.0 -> 1.0)
              const progress = Math.max(0, Math.min(1, 1.0 - (remaining / maxDuration)));
              
              // Curve: Start at 0.2, Grow to 1.5 (Full Bullet Size)
              const scale = 0.2 + (Math.pow(progress, 2) * 1.3); 
              
              const rumble = progress > 0.8 ? (progress - 0.8) * 0.3 : 0;
              const jitterX = (Math.random() - 0.5) * rumble;
              const jitterY = (Math.random() - 0.5) * rumble;

              const offset = 1.6;
              const dirX = Math.cos(transform.rotation);
              const dirY = Math.sin(transform.rotation);
              
              obj.position.x = transform.x + (dirX * offset) + jitterX;
              obj.position.y = transform.y + (dirY * offset) + jitterY;
              obj.position.z = 5.2; // In front of enemy body
              
              obj.scale.setScalar(scale);
              obj.rotation.set(0, 0, 0); 
          }
      }}
    />
  );
};


=====================================
FILE: ./src/game/components/GalleryStage.tsx
=====================================
import { useMemo, useRef, useState } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import { OrbitControls, Grid } from '@react-three/drei';
import * as THREE from 'three';
import { useStore } from '@/core/store/useStore';
import { EnemyTypes } from '@/game/config/Identifiers';
import { GAME_THEME } from '@/game/theme';
import { addBarycentricCoordinates, createHunterSpear } from '@/game/utils/GeometryUtils';

// --- SHADERS (Enemy Body - Wireframe Glow) ---
const bodyVertexShader = `
  attribute vec3 barycentric;
  varying vec3 vBarycentric;
  void main() {
    vBarycentric = barycentric;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const bodyFragmentShader = `
  uniform vec3 uColor;
  uniform float uGlow;
  varying vec3 vBarycentric;
  
  float edgeFactor(vec3 bary, float width) {
    vec3 d = fwidth(bary);
    vec3 a3 = smoothstep(vec3(0.0), d * width, bary);
    return min(min(a3.x, a3.y), a3.z);
  }

  void main() {
    float width = 1.5; 
    float edge = edgeFactor(vBarycentric, width);
    float glow = 1.0 - edge;
    glow = pow(glow, 0.4) + uGlow; 
    
    vec3 coreColor = uColor;
    vec3 edgeColor = vec3(1.0); // Always white edges
    vec3 finalColor = mix(coreColor, edgeColor, 1.0 - smoothstep(0.0, 0.1, edge));
    
    // Add inner glow
    finalColor += coreColor * uGlow * 0.5;

    gl_FragColor = vec4(finalColor, 1.0);
  }
`;

// --- SHADERS (Projectile/VFX - Billboard Glow) ---
const vfxVertexShader = `
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const vfxFragmentShader = `
  varying vec2 vUv;
  uniform vec3 uColor;
  
  void main() {
    float dist = distance(vUv, vec2(0.5));
    // Soft glow ball
    float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
    alpha = pow(alpha, 2.0);
    
    // Bright core
    float core = 1.0 - smoothstep(0.0, 0.15, dist);
    
    vec3 color = mix(uColor, vec3(1.0), core);
    
    if (alpha < 0.05) discard;
    gl_FragColor = vec4(color, alpha);
  }
`;

// --- LOCAL VFX COMPONENT ---
const GalleryVFX = ({ type, isAttacking }: { type: string, isAttacking: boolean }) => {
  const particlesRef = useRef<THREE.InstancedMesh>(null);
  const projectileRef = useRef<THREE.Mesh>(null);
  const orbRef = useRef<THREE.Mesh>(null);
  const dummy = useMemo(() => new THREE.Object3D(), []);
  const { camera } = useThree();

  const projectileMat = useMemo(() => new THREE.ShaderMaterial({
      vertexShader: vfxVertexShader,
      fragmentShader: vfxFragmentShader,
      uniforms: { uColor: { value: new THREE.Color(GAME_THEME.bullet.hunter) } },
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      side: THREE.DoubleSide
  }), []);

  useFrame((state) => {
    const time = state.clock.elapsedTime;
    
    // Billboard Logic: Make VFX face camera
    if (orbRef.current) orbRef.current.lookAt(camera.position);
    if (projectileRef.current) projectileRef.current.lookAt(camera.position);

    // --- PARTICLE SYSTEM ---
    if (particlesRef.current) {
        let count = 0;
        
        if (type === EnemyTypes.DRILLER && isAttacking) {
            // DRILLER SPARKS (From Tip Down)
            for(let i=0; i<8; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 0.8;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const speed = (time * 10 + i) % 1.0;
                
                // Tip is at Y=2.0 (approx)
                dummy.position.set(x, 2.0 - (speed * 2.0), z);
                dummy.scale.setScalar(0.2 * (1.0 - speed));
                dummy.rotation.set(Math.random(), Math.random(), Math.random());
                dummy.updateMatrix();
                particlesRef.current.setMatrixAt(i, dummy.matrix);
                count++;
            }
        } 
        else if (type === EnemyTypes.KAMIKAZE && isAttacking) {
            // EXPLOSION (Pulse)
            const cycle = time % 2.0; 
            if (cycle > 1.5) { // Boom phase
                const progress = (cycle - 1.5) * 2.0; // 0..1
                const expansion = progress * 6.0;
                
                for(let i=0; i<30; i++) {
                    const angle = (i / 30) * Math.PI * 2 + (Math.random() * 0.5);
                    const yDir = (Math.random() - 0.5) * 2.0;
                    
                    dummy.position.set(
                        Math.cos(angle) * expansion, 
                        yDir * expansion, 
                        Math.sin(angle) * expansion
                    );
                    dummy.scale.setScalar(0.5 * (1.0 - progress));
                    dummy.updateMatrix();
                    particlesRef.current.setMatrixAt(i, dummy.matrix);
                    count++;
                }
            }
        }
        
        particlesRef.current.count = count;
        particlesRef.current.instanceMatrix.needsUpdate = true;
    }

    // --- HUNTER PROJECTILES ---
    if (type === EnemyTypes.HUNTER) {
        // Timeline: 2s Cycle. 0-1s Charge, 1-1.2s Fire, 1.2-2s Cooldown
        const cycle = time % 2.0; 
        
        // CHARGE ORB (Tip at Y=1.5 approx)
        if (orbRef.current) {
            if (isAttacking && cycle < 1.0) {
                const scale = cycle * 1.5; // Grow
                orbRef.current.visible = true;
                orbRef.current.scale.setScalar(scale);
                orbRef.current.position.set(0, 1.8, 0); // At tip
            } else {
                orbRef.current.visible = false;
            }
        }

        // BULLET (Fires Upward Y+)
        if (projectileRef.current) {
            if (isAttacking && cycle > 1.0 && cycle < 1.5) {
                projectileRef.current.visible = true;
                const travel = (cycle - 1.0) * 15.0; // Fast
                projectileRef.current.position.set(0, 1.8 + travel, 0);
                projectileRef.current.scale.set(1.5, 1.5, 1.5);
            } else {
                projectileRef.current.visible = false;
            }
        }
    }
  });

  return (
    <>
      <instancedMesh ref={particlesRef} args={[new THREE.PlaneGeometry(0.5, 0.5), undefined, 50]}>
        <meshBasicMaterial color="#FFF" transparent opacity={0.8} blending={THREE.AdditiveBlending} side={THREE.DoubleSide} />
      </instancedMesh>
      
      {type === EnemyTypes.HUNTER && (
          <>
            <mesh ref={orbRef}>
                <planeGeometry args={[1.5, 1.5]} />
                <primitive object={projectileMat} attach="material" />
            </mesh>
            <mesh ref={projectileRef}>
                <planeGeometry args={[1.0, 2.0]} />
                <primitive object={projectileMat} attach="material" />
            </mesh>
          </>
      )}
    </>
  );
};

export const GalleryStage = () => {
  const { galleryTarget, galleryAction } = useStore();
  const meshRef = useRef<THREE.Mesh>(null);
  const materialRef = useRef<THREE.ShaderMaterial>(null);

  // --- GEOMETRY ---
  const drillerGeo = useMemo(() => addBarycentricCoordinates(new THREE.ConeGeometry(1.5, 4.0, 4)), []);
  const kamikazeGeo = useMemo(() => addBarycentricCoordinates(new THREE.IcosahedronGeometry(2.5, 1)), []); // Detail 1 for better wireframe
  const hunterGeo = useMemo(() => createHunterSpear().scale(2, 2, 2), []); 

  // --- SHADER MAT ---
  const shaderMaterial = useMemo(() => new THREE.ShaderMaterial({
    vertexShader: bodyVertexShader,
    fragmentShader: bodyFragmentShader,
    uniforms: {
        uColor: { value: new THREE.Color('#FFFFFF') }, // Default white to ensure visibility if prop fails
        uGlow: { value: 0.0 }
    },
    side: THREE.DoubleSide,
    extensions: { derivatives: true },
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false, // Helps with "Hologram" feel
  }), []);

  useFrame((state, delta) => {
    if (!meshRef.current || !materialRef.current) return;

    const time = state.clock.elapsedTime;
    const isAttack = galleryAction === 'ATTACK';

    // 1. BEHAVIOR ANIMATIONS
    if (galleryTarget === EnemyTypes.DRILLER) {
        // Idle: Slow Float | Attack: Fast Spin + Shake
        const speed = isAttack ? 20.0 : 1.0;
        meshRef.current.rotation.y += speed * delta;
        
        if (isAttack) {
            meshRef.current.position.x = (Math.random() - 0.5) * 0.1;
            meshRef.current.position.z = (Math.random() - 0.5) * 0.1;
        } else {
            meshRef.current.position.set(0, 0, 0);
            // Bobbing
            meshRef.current.position.y = Math.sin(time) * 0.2;
        }
    } 
    else if (galleryTarget === EnemyTypes.KAMIKAZE) {
        // Idle: Tumble | Attack: Violent Shake + Expansion Pulse
        const tumbleSpeed = isAttack ? 5.0 : 0.5;
        meshRef.current.rotation.x += tumbleSpeed * delta;
        meshRef.current.rotation.z += tumbleSpeed * delta;

        if (isAttack) {
            const cycle = time % 2.0; // 2s cycle
            // Shake (0 - 1.5s)
            if (cycle < 1.5) {
                const shake = (cycle / 1.5) * 0.5; // Shake gets harder
                meshRef.current.position.x = (Math.random() - 0.5) * shake;
                meshRef.current.position.y = (Math.random() - 0.5) * shake;
                meshRef.current.scale.setScalar(1.0 + (shake * 0.5)); // Swell
            } 
            // Boom (1.5 - 2.0s) -> Shrink/Hide
            else {
                meshRef.current.scale.setScalar(0.01);
            }
        } else {
            meshRef.current.position.set(0,0,0);
            meshRef.current.scale.setScalar(1.0);
        }
    } 
    else if (galleryTarget === EnemyTypes.HUNTER) {
        // Idle: Spin Y | Attack: Face Front, Charge, Recoil
        if (isAttack) {
            meshRef.current.rotation.set(0,0,0); // Reset
            const cycle = time % 2.0;
            
            // Recoil Effect at 1.0s (Fire)
            if (cycle > 1.0 && cycle < 1.3) {
                meshRef.current.position.y = -1.0; // Kick down (since firing up)
            } else {
                meshRef.current.position.y = THREE.MathUtils.lerp(meshRef.current.position.y, 0, delta * 5);
            }
        } else {
            meshRef.current.rotation.y += delta;
            meshRef.current.position.y = Math.sin(time) * 0.3;
        }
    }

    // 2. COLOR UPDATES
    let baseColor = new THREE.Color();
    let glow = 0.2;

    if (galleryTarget === EnemyTypes.DRILLER) {
        baseColor.set(GAME_THEME.enemy.muncher);
        if (isAttack) glow = 0.8;
    } 
    else if (galleryTarget === EnemyTypes.KAMIKAZE) {
        baseColor.set(GAME_THEME.enemy.kamikaze);
        if (isAttack) {
            const flash = Math.sin(time * 30) > 0;
            if (flash) baseColor.set('#FFFFFF'); // Strobe
            glow = 1.0;
        }
    } 
    else if (galleryTarget === EnemyTypes.HUNTER) {
        baseColor.set(GAME_THEME.enemy.hunter);
        if (isAttack) {
            // Charge up color
            const cycle = time % 2.0;
            if (cycle < 1.0) glow = cycle; 
        }
    }

    materialRef.current.uniforms.uColor.value.copy(baseColor);
    materialRef.current.uniforms.uGlow.value = glow;
  });

  const activeGeo = useMemo(() => {
      switch(galleryTarget) {
          case EnemyTypes.DRILLER: return drillerGeo;
          case EnemyTypes.KAMIKAZE: return kamikazeGeo;
          case EnemyTypes.HUNTER: return hunterGeo;
          default: return drillerGeo;
      }
  }, [galleryTarget, drillerGeo, kamikazeGeo, hunterGeo]);

  return (
    <>
        <OrbitControls makeDefault minDistance={5} maxDistance={20} />
        
        {/* FLOOR GRID */}
        <Grid 
            position={[0, -4, 0]} 
            args={[20, 20]} 
            sectionColor="#00F0FF" 
            cellColor="#001a33" 
            fadeDistance={20}
        />

        {/* ENEMY MODEL */}
        <mesh ref={meshRef} geometry={activeGeo} material={shaderMaterial} />
        
        {/* VFX LAYER */}
        <GalleryVFX type={galleryTarget} isAttacking={galleryAction === 'ATTACK'} />
    </>
  );
};


=====================================
FILE: ./src/game/components/DaemonRenderer.tsx
=====================================
import { useMemo, useRef } from 'react';
import * as THREE from 'three';
import { Tag } from '../core/ecs/types';
import { EnemyTypes } from '../config/Identifiers';
import { InstancedActor } from './common/InstancedActor';
import { IdentityComponent } from '../data/IdentityComponent';
import { StateComponent } from '../data/StateComponent';

export const DaemonRenderer = () => {
  const geometry = useMemo(() => new THREE.OctahedronGeometry(0.6, 0), []);
  const material = useMemo(() => new THREE.MeshBasicMaterial({ 
      color: '#00F0FF', 
      wireframe: true,
      transparent: true,
      opacity: 0.8
  }), []);
  
  const brokenColor = useMemo(() => new THREE.Color('#FF003C'), []);
  const baseColor = useMemo(() => new THREE.Color('#00F0FF'), []);

  return (
    <InstancedActor 
      tag={Tag.PLAYER} 
      geometry={geometry} 
      material={material} 
      maxCount={5}
      filter={(e) => e.getComponent<IdentityComponent>('Identity')?.variant === EnemyTypes.DAEMON}
      updateEntity={(e, obj, color, delta) => {
          const state = e.getComponent<StateComponent>('State');
          
          // Reset color
          color.copy(baseColor);

          if (state) {
              // --- SPIN PHYSICS ---
              if (typeof state.data.visualSpin !== 'number') state.data.visualSpin = 0;
              let targetSpeed = 1.0;

              if (state.current === 'CHARGING') targetSpeed = 15.0;
              else if (state.current === 'READY') targetSpeed = 3.0;
              else if (state.current === 'FIRE') targetSpeed = 20.0;
              else if (state.current === 'COOLDOWN') targetSpeed = -5.0;
              else if (state.current === 'BROKEN') {
                  targetSpeed = 30.0; 
                  color.copy(brokenColor);
                  // Shake effect
                  obj.position.x += (Math.random() - 0.5) * 0.2;
                  obj.position.y += (Math.random() - 0.5) * 0.2;
              }

              if (typeof state.data.currentSpinSpeed !== 'number') state.data.currentSpinSpeed = 1.0;
              
              // Smoothly interpolate spin speed (Inertia)
              state.data.currentSpinSpeed = THREE.MathUtils.lerp(state.data.currentSpinSpeed, targetSpeed, delta * 5.0);
              state.data.visualSpin += state.data.currentSpinSpeed * delta;
              obj.rotation.y = state.data.visualSpin;

              // --- SCALE / ANIMATION LOGIC ---
              
              if (state.current === 'FIRE') {
                  // Instant Impact Squish
                  obj.scale.set(1.2, 0.5, 1.2);
              }
              else if (state.current === 'COOLDOWN') {
                  // Recover: Squish (1.2, 0.5, 1.2) -> Normal (1.0)
                  const maxTime = 0.5;
                  const remaining = Math.max(0, state.timers.action);
                  const progress = 1.0 - (remaining / maxTime); 
                  
                  if (progress < 0.2) {
                      obj.scale.set(1.2, 0.5, 1.2);
                  } else {
                      const recoverT = (progress - 0.2) / 0.8;
                      const elastic = 1 + Math.sin(recoverT * Math.PI * 3) * Math.pow(1 - recoverT, 2) * 0.2;
                      
                      const sY = THREE.MathUtils.lerp(0.5, 1.0, recoverT) * elastic;
                      const sXZ = THREE.MathUtils.lerp(1.2, 1.0, recoverT);
                      obj.scale.set(sXZ, sY, sXZ);
                  }
              } 
              else if (state.current === 'CHARGING') {
                  // Grow based on SHIELD HP (0% -> 100%)
                  // This ensures it starts exactly at 1.0 (where Cooldown left off)
                  // and grows to 1.6 (max size)
                  const maxShield = state.data.maxShield || 10;
                  const currentShield = state.data.shieldHP || 0;
                  const ratio = Math.min(1.0, Math.max(0, currentShield / maxShield));
                  
                  // Lerp 1.0 -> 1.6
                  const scale = 1.0 + (ratio * 0.6); 
                  obj.scale.setScalar(scale);
              }
              else if (state.current === 'READY') {
                  // Pulse at max size (1.6 base)
                  const pulse = 1.6 + Math.sin(performance.now() * 0.005) * 0.05;
                  obj.scale.setScalar(pulse);
              }
              else if (state.current === 'BROKEN') {
                  // Shrivel / Glitch
                  const twitch = 0.7 + (Math.random() * 0.1);
                  obj.scale.setScalar(twitch);
              }
              else {
                  obj.scale.setScalar(1.0);
              }
          }
      }}
    />
  );
};


=====================================
FILE: ./src/game/components/RenderDirector.tsx
=====================================
import { useEffect, useState } from 'react';
import { RenderRegistry } from '../render/RenderRegistry';
import { registerAllRenderers } from '../render/RenderCatalog';

// Flag to ensure we only register once per session
let hasRegistered = false;

export const RenderDirector = () => {
  const [renderers, setRenderers] = useState<React.ComponentType[]>([]);

  useEffect(() => {
    if (!hasRegistered) {
      registerAllRenderers();
      hasRegistered = true;
    }
    setRenderers(RenderRegistry.getAll());
  }, []);

  return (
    <>
      {renderers.map((Component, index) => (
        <Component key={index} />
      ))}
    </>
  );
};


=====================================
FILE: ./src/game/components/DaemonBulletRenderer.tsx
=====================================
import { useMemo } from 'react';
import * as THREE from 'three';
import { Tag } from '../core/ecs/types';
import { InstancedActor } from './common/InstancedActor';
import { IdentityComponent } from '../data/IdentityComponent';

const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0); }`;
const fragmentShader = `
  varying vec2 vUv; uniform vec3 uColor;
  void main() {
    float dist = distance(vUv, vec2(0.5));
    float core = 1.0 - smoothstep(0.2, 0.25, dist);
    float glow = pow(1.0 - smoothstep(0.25, 0.5, dist), 3.0);
    gl_FragColor = vec4(mix(uColor, vec3(1.0), core), max(core, glow));
  }
`;

export const DaemonBulletRenderer = () => {
  // UPDATED: Scaled down by 20% (5.0 -> 4.0)
  const geometry = useMemo(() => new THREE.PlaneGeometry(4.0, 4.0), []); 
  const material = useMemo(() => new THREE.ShaderMaterial({
    vertexShader, fragmentShader,
    uniforms: { uColor: { value: new THREE.Color('#00F0FF') } }, // CYAN
    transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
  }), []);

  return (
    <InstancedActor 
      tag={Tag.BULLET} 
      geometry={geometry} 
      material={material} 
      maxCount={50}
      filter={(e) => {
          if (e.hasTag(Tag.ENEMY)) return false;
          const id = e.getComponent<IdentityComponent>('Identity');
          return id?.variant === 'DAEMON_SHOT';
      }}
      updateEntity={(e, obj) => {
          obj.rotation.set(0,0,0);
          obj.scale.setScalar(1.0);
      }}
    />
  );
};


=====================================
FILE: ./src/game/components/common/InstancedActor.tsx
=====================================
import { useRef, useLayoutEffect, useMemo } from 'react';
import { useFrame, ThreeEvent } from '@react-three/fiber';
import * as THREE from 'three';
import { ActiveEngine } from '../GameDirector';
import { TransformComponent } from '../data/TransformComponent';
import { IdentityComponent } from '../data/IdentityComponent';
import { Entity } from '@/game/core/ecs/Entity';
import { TransformStore } from '@/game/core/ecs/TransformStore';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';

const tempObj = new THREE.Object3D();
const tempColor = new THREE.Color();
const STRIDE = 4;

interface InstancedActorProps {
  tag: string;
  geometry: THREE.BufferGeometry;
  material: THREE.Material;
  maxCount: number;
  updateEntity?: (entity: Entity, obj: THREE.Object3D, color: THREE.Color, delta: number) => void;
  filter?: (entity: Entity) => boolean;
  baseColor?: string;
  colorSource?: 'identity' | 'base'; 
  interactive?: boolean; 
}

export const InstancedActor = ({ 
  tag, 
  geometry, 
  material, 
  maxCount, 
  updateEntity, 
  filter, 
  baseColor = '#FFFFFF',
  colorSource = 'identity',
  interactive = false
}: InstancedActorProps) => {
  const meshRef = useRef<THREE.InstancedMesh>(null);
  const instanceMap = useMemo(() => new Int32Array(maxCount).fill(-1), [maxCount]);

  useLayoutEffect(() => {
    if (meshRef.current) {
        meshRef.current.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxCount * 3), 3);
    }
  }, [maxCount]);

  useFrame((state, delta) => {
    if (!meshRef.current || !ActiveEngine) return;

    const entities = ActiveEngine.registry.getByTag(tag);
    let count = 0;
    const transformData = TransformStore.data;

    for (const entity of entities) {
      if (count >= maxCount) break;
      if (filter && !filter(entity)) continue;

      const transform = entity.getComponent<TransformComponent>('Transform');
      if (!transform) continue;

      if (interactive) {
          instanceMap[count] = entity.id as number;
      }

      const idx = transform.index * STRIDE;
      const x = transformData[idx];
      const y = transformData[idx + 1];
      const rot = transformData[idx + 2];
      const scale = transformData[idx + 3];

      tempObj.position.set(x, y, 0);
      tempObj.rotation.set(0, 0, rot);
      tempObj.scale.set(scale, scale, 1);

      if (colorSource === 'identity') {
          const identity = entity.getComponent<IdentityComponent>('Identity');
          if (identity) tempColor.set(identity.variant); 
          else tempColor.set(baseColor);
      } else {
          tempColor.set(baseColor); 
      }

      if (updateEntity) {
        updateEntity(entity, tempObj, tempColor, delta);
      }

      tempObj.updateMatrix();
      meshRef.current.setMatrixAt(count, tempObj.matrix);
      
      if (meshRef.current.instanceColor) {
        meshRef.current.setColorAt(count, tempColor);
      }
      
      count++;
    }

    meshRef.current.count = count;
    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor) meshRef.current.instanceColor.needsUpdate = true;
  });

  // UPDATED: Use onPointerDown for instant reaction
  const handlePointerDown = (e: ThreeEvent<PointerEvent>) => {
      if (!interactive || e.instanceId === undefined) return;
      e.stopPropagation();
      
      const entityId = instanceMap[e.instanceId];
      if (entityId !== -1) {
          GameEventBus.emit(GameEvents.ENEMY_DAMAGED, { 
              id: entityId, 
              damage: 9999, 
              type: 'TAP' 
          });
      }
  };

  return (
    <instancedMesh 
      ref={meshRef} 
      args={[geometry, material, maxCount]} 
      frustumCulled={false}
      onPointerDown={interactive ? handlePointerDown : undefined}
    />
  );
};


=====================================
FILE: ./src/game/components/GameDirector.tsx
=====================================
import { useFrame, useThree } from '@react-three/fiber';
import { useEffect, useRef } from 'react';
import { GameBootstrapper } from '../core/GameBootstrapper';
import { GameEngineCore } from '../core/GameEngine';
import { ServiceLocator } from '../core/ServiceLocator';
import { InputSystem } from '../systems/InputSystem';
import { PanelRegistry } from '../systems/PanelRegistrySystem';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';

// Mutable Global for Renderers to access Registry (Performance optimization)
export let ActiveEngine: GameEngineCore | null = null;

// Allow external override (for MobileDirector)
export const setActiveEngine = (engine: GameEngineCore | null) => {
    ActiveEngine = engine;
};

export const GameDirector = () => {
  const { viewport, size } = useThree();
  const engineRef = useRef<GameEngineCore | null>(null);
  const isMobileRef = useRef(false);

  useEffect(() => {
    const checkMobile = () => {
        isMobileRef.current = window.matchMedia('(pointer: coarse)').matches || 
                              ('ontouchstart' in window) || 
                              (navigator.maxTouchPoints > 0);
    };
    checkMobile();
    window.addEventListener('resize', checkMobile);

    const engine = GameBootstrapper();
    engineRef.current = engine;
    setActiveEngine(engine);

    engine.updateViewport(viewport.width, viewport.height, size.width, size.height);
    
    try {
        const input = ServiceLocator.getSystem<InputSystem>('InputSystem');
        input.updateBounds(viewport.width, viewport.height);
    } catch {}
    
    const refreshInterval = setInterval(() => {
        PanelRegistry.refreshAll();
    }, 500);

    let initialPolls = 0;
    const fastPoll = setInterval(() => {
        PanelRegistry.refreshAll();
        initialPolls++;
        if (initialPolls > 20) clearInterval(fastPoll); 
    }, 100);

    return () => {
      window.removeEventListener('resize', checkMobile);
      clearInterval(refreshInterval);
      clearInterval(fastPoll);
      engine.teardown();
      engineRef.current = null;
      setActiveEngine(null);
    };
  }, []); 

  useEffect(() => {
    if (engineRef.current) {
      engineRef.current.updateViewport(viewport.width, viewport.height, size.width, size.height);
      try {
        const input = ServiceLocator.getSystem<InputSystem>('InputSystem');
        input.updateBounds(viewport.width, viewport.height);
      } catch {}
    }
  }, [viewport, size]);

  useFrame((state, delta) => {
    if (engineRef.current) {
      try {
          const input = ServiceLocator.getSystem<InputSystem>('InputSystem');
          if (!isMobileRef.current) {
              const x = (state.pointer.x * viewport.width) / 2;
              const y = (state.pointer.y * viewport.height) / 2;
              input.updateCursor(x, y);
          }
          engineRef.current.update(delta, state.clock.elapsedTime);
      } catch (e: any) {
          console.error("Game Loop Critical Failure:", e);
          GameEventBus.emit(GameEvents.LOG_DEBUG, { 
              msg: `CRITICAL LOOP FAIL: ${e.message}`, 
              source: 'GameDirector' 
          });
      }
    }
  });

  return null;
};


=====================================
FILE: ./src/game/components/index.ts
=====================================
export * from './BulletRenderer';
export * from './EnemyBulletRenderer';
export * from './GameDirector';
export * from './HunterChargeRenderer';
export * from './ParticleRenderer';
export * from './PlayerAvatar';
export * from './ProjectileTrails';
export * from './ScreenShaker';
export * from './GalleryStage';
export * from './DaemonRenderer';
export * from './DaemonChargeRenderer';
export * from './DaemonBulletRenderer';
// Enemy Renderers are now internal to RenderCatalog or can be exported if needed
export * from './enemies/DrillerRenderer';
export * from './enemies/KamikazeRenderer';
export * from './enemies/HunterRenderer';


=====================================
FILE: ./src/game/components/ScreenShaker.tsx
=====================================
import { useFrame, useThree } from '@react-three/fiber';
import { ServiceLocator } from '../core/ServiceLocator';
import { ShakeSystem } from '../systems/ShakeSystem';

export const ScreenShaker = () => {
  const { camera } = useThree();
  
  useFrame(() => {
    try {
        const sys = ServiceLocator.getSystem<ShakeSystem>('ShakeSystem');
        const { x, y, r } = sys.currentOffset;

        // Apply shake offset
        // We use the raw values calculated by ShakeSystem.
        camera.position.x = x;
        camera.position.y = y;
        camera.rotation.z = r;
        
    } catch {
        // System not ready yet
    }
  });

  return null;
};


=====================================
FILE: ./src/game/components/data/HealthComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class HealthComponent extends Component {
  readonly _type = 'Health';
  public current: number;

  constructor(public max: number, public invincibilityTime: number = 0) {
    super();
    this.current = max;
  }

  public reset(max: number, invincibilityTime: number = 0) {
    this.max = max;
    this.current = max;
    this.invincibilityTime = invincibilityTime;
    return this;
  }
}


=====================================
FILE: ./src/game/components/data/MotionComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class MotionComponent extends Component {
  readonly _type = 'Motion';

  constructor(
    public vx: number = 0,
    public vy: number = 0,
    public friction: number = 0,
    public angularVelocity: number = 0
  ) {
    super();
  }

  public reset(vx: number = 0, vy: number = 0, friction: number = 0, angularVelocity: number = 0) {
    this.vx = vx;
    this.vy = vy;
    this.friction = friction;
    this.angularVelocity = angularVelocity;
    return this;
  }
}


=====================================
FILE: ./src/game/components/data/IdentityComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class IdentityComponent extends Component {
  readonly _type = 'Identity';

  constructor(public variant: string) {
    super();
  }

  public reset(variant: string) {
    this.variant = variant;
    return this;
  }
}


=====================================
FILE: ./src/game/components/data/StateComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class StateComponent extends Component {
  readonly _type = 'State';

  constructor(
    public current: string = 'IDLE',
    public timers: Record<string, number> = {},
    public data: Record<string, any> = {}
  ) {
    super();
  }

  public reset(current: string = 'IDLE', timers: Record<string, number> = {}, data: Record<string, any> = {}) {
    this.current = current;
    this.timers = timers;
    this.data = data;
    return this;
  }
  
  public set(state: string) {
    this.current = state;
  }
}


=====================================
FILE: ./src/game/components/data/ColliderComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class ColliderComponent extends Component {
  readonly _type = 'Collider';

  constructor(
    public radius: number,
    public layer: number,
    public mask: number
  ) {
    super();
  }

  public reset(radius: number, layer: number, mask: number) {
    this.radius = radius;
    this.layer = layer;
    this.mask = mask;
    return this;
  }
}


=====================================
FILE: ./src/game/components/data/LifetimeComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class LifetimeComponent extends Component {
  readonly _type = 'Lifetime';

  constructor(public remaining: number, public total: number) {
    super();
  }

  public reset(remaining: number, total: number) {
    this.remaining = remaining;
    this.total = total;
    return this;
  }
}


=====================================
FILE: ./src/game/components/data/OrbitalComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class OrbitalComponent extends Component {
  readonly _type = 'Orbital';

  constructor(
    public parentId: number | null = null,
    public radius: number = 3.0,
    public speed: number = 2.0,
    public angle: number = 0,
    public active: boolean = true
  ) {
    super();
  }

  public reset(parentId: number | null = null, radius: number = 3.0, speed: number = 2.0, angle: number = 0, active: boolean = true) {
    this.parentId = parentId;
    this.radius = radius;
    this.speed = speed;
    this.angle = angle;
    this.active = active;
    return this;
  }
}


=====================================
FILE: ./src/game/components/data/TransformComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';
import { TransformStore } from '../../core/ecs/TransformStore';

const STRIDE = 4;

export class TransformComponent extends Component {
  readonly _type = 'Transform';
  
  // Pointer to the global buffer
  public index: number;

  constructor(x: number = 0, y: number = 0, rotation: number = 0, scale: number = 1) {
    super();
    this.index = TransformStore.alloc();
    this.set(x, y, rotation, scale);
  }

  // --- PROXY PROPERTIES ---

  get x(): number { return TransformStore.data[this.index * STRIDE]; }
  set x(val: number) { TransformStore.data[this.index * STRIDE] = val; }

  get y(): number { return TransformStore.data[this.index * STRIDE + 1]; }
  set y(val: number) { TransformStore.data[this.index * STRIDE + 1] = val; }

  get rotation(): number { return TransformStore.data[this.index * STRIDE + 2]; }
  set rotation(val: number) { TransformStore.data[this.index * STRIDE + 2] = val; }

  get scale(): number { return TransformStore.data[this.index * STRIDE + 3]; }
  set scale(val: number) { TransformStore.data[this.index * STRIDE + 3] = val; }

  // --- LIFECYCLE ---

  public set(x: number, y: number, rotation: number, scale: number) {
    const i = this.index * STRIDE;
    TransformStore.data[i] = x;
    TransformStore.data[i + 1] = y;
    TransformStore.data[i + 2] = rotation;
    TransformStore.data[i + 3] = scale;
  }

  public reset(x: number = 0, y: number = 0, rotation: number = 0, scale: number = 1) {
    // When recycling, we keep the same index (slot), just overwrite data
    this.set(x, y, rotation, scale);
    return this;
  }
  
  // Called manually or by a cleanup system if we were fully destroying the object
  // But since we pool TransformComponent instances, we hold onto the index forever.
  // We only free the index if the Component itself is garbage collected (not pooled).
  // Current architecture: Pools persist -> Indices persist.
}


=====================================
FILE: ./src/game/components/data/CombatComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class CombatComponent extends Component {
  readonly _type = 'Combat';

  constructor(
    public damage: number,
    public cooldown: number = 0,
    public range: number = 0
  ) {
    super();
  }

  public reset(damage: number, cooldown: number = 0, range: number = 0) {
    this.damage = damage;
    this.cooldown = cooldown;
    this.range = range;
    return this;
  }
}


=====================================
FILE: ./src/game/components/data/TargetComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export type TargetType = 'PLAYER' | 'PANEL' | 'LOCATION' | 'ENEMY';

export class TargetComponent extends Component {
  readonly _type = 'Target';

  constructor(
    public id: string | null = null, 
    public type: TargetType = 'PLAYER',
    public x: number = 0, 
    public y: number = 0,
    public locked: boolean = false 
  ) {
    super();
  }

  public reset(id: string | null = null, type: TargetType = 'PLAYER', x: number = 0, y: number = 0, locked: boolean = false) {
    this.id = id;
    this.type = type;
    this.x = x;
    this.y = y;
    this.locked = locked;
    return this;
  }
}


=====================================
FILE: ./src/game/components/EffectsLayer.tsx
=====================================
import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';

export const EffectsLayer = () => {
  return (
    <EffectComposer disableNormalPass>
      {/* 
        BLOOM: Adds the "Neon" glow.
        luminanceThreshold: Only bright colors glow.
        intensity: How strong the glow is.
      */}
      <Bloom 
        luminanceThreshold={0.2} 
        mipmapBlur 
        intensity={1.5} 
        radius={0.4} 
      />
      
      {/* VIGNETTE: Darkens corners for focus */}
      <Vignette eskil={false} offset={0.1} darkness={0.5} />
    </EffectComposer>
  );
};


=====================================
FILE: ./src/game/components/ProjectileTrails.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { ActiveEngine } from './GameDirector';
import { Tag } from '../core/ecs/types';
import { TransformComponent } from '../components/data/TransformComponent';
import { MotionComponent } from '../components/data/MotionComponent';
import { LifetimeComponent } from '../components/data/LifetimeComponent';
import { GAME_THEME } from '../theme';

const MAX_TRAILS = 500; 

export const ProjectileTrails = () => {
  const meshRef = useRef<THREE.InstancedMesh>(null);
  const geometry = useMemo(() => {
      const geo = new THREE.PlaneGeometry(1, 1);
      geo.translate(0, 0.5, 0); 
      return geo;
  }, []);

  const shaderMaterial = useMemo(() => new THREE.ShaderMaterial({
    vertexShader: `
      #ifndef USE_INSTANCING_COLOR
      attribute vec3 instanceColor;
      #endif
      varying vec2 vUv;
      varying vec3 vColor;
      void main() {
        vUv = uv;
        vColor = instanceColor; 
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      varying vec2 vUv;
      varying vec3 vColor;
      void main() {
        float distFromCenter = abs(vUv.x - 0.5) * 2.0;
        float beam = 1.0 - pow(distFromCenter, 3.0);
        float tailDecay = 1.0 - vUv.y;
        tailDecay = pow(tailDecay, 2.0);
        float headFade = smoothstep(0.0, 0.1, vUv.y);
        float alpha = beam * tailDecay * headFade;
        vec3 finalColor = mix(vColor, vec3(1.0), beam * 0.8); 
        if (alpha < 0.01) discard;
        gl_FragColor = vec4(finalColor, alpha * 0.8);
      }
    `,
    uniforms: {}, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
  }), []);

  useFrame(() => {
    if (!meshRef.current || !ActiveEngine) return;
    const tempObj = new THREE.Object3D();
    const tempColor = new THREE.Color();
    let count = 0;
    const bullets = ActiveEngine.registry.getByTag(Tag.BULLET);

    for (const b of bullets) {
        if (count >= MAX_TRAILS) break;
        const t = b.getComponent<TransformComponent>('Transform');
        const m = b.getComponent<MotionComponent>('Motion');
        const life = b.getComponent<LifetimeComponent>('Lifetime');
        if (!t || !m || !life) continue;
        const isEnemy = b.hasTag(Tag.ENEMY);
        const trailWidth = isEnemy ? 1.0 : 0.4;
        const speed = Math.sqrt(m.vx * m.vx + m.vy * m.vy);
        const age = life.total - life.remaining;
        const maxLen = isEnemy ? 4.0 : 3.0; 
        const targetLength = Math.min(speed * 0.12, maxLen);
        const currentLength = Math.min(targetLength, age * 10.0); 
        tempObj.position.set(t.x, t.y, -0.2); 
        tempObj.rotation.z = t.rotation + (Math.PI / 2);
        tempObj.scale.set(trailWidth, currentLength, 1);
        const colorHex = isEnemy ? GAME_THEME.bullet.hunter : GAME_THEME.bullet.trail;
        tempColor.set(colorHex);
        tempObj.updateMatrix();
        meshRef.current.setMatrixAt(count, tempObj.matrix);
        meshRef.current.setColorAt(count, tempColor);
        count++;
    }
    meshRef.current.count = count;
    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor) meshRef.current.instanceColor.needsUpdate = true;
  });

  return (
    <instancedMesh ref={meshRef} args={[geometry, shaderMaterial, MAX_TRAILS]} renderOrder={-1} />
  );
};


=====================================
FILE: ./src/game/components/enemies/HunterRenderer.tsx
=====================================
import { Tag } from '@/game/core/ecs/types';
import { GAME_THEME } from '@/game/theme';
import { EnemyTypes } from '@/game/config/Identifiers';
import { InstancedActor } from '../common/InstancedActor';
import { IdentityComponent } from '@/game/components/data/IdentityComponent';
import { StateComponent } from '@/game/components/data/StateComponent';
import { TransformComponent } from '@/game/components/data/TransformComponent'; 
import { AssetService } from '@/game/assets/AssetService';
import { applyRotation } from '@/game/utils/RenderUtils';
import * as THREE from 'three';

const chargeColor = new THREE.Color(GAME_THEME.enemy.charge);

export const HunterRenderer = () => {
  const geometry = AssetService.get<THREE.BufferGeometry>('GEO_HUNTER');
  const material = AssetService.get<THREE.Material>('MAT_ENEMY_BASE');

  return (
    <InstancedActor 
      tag={Tag.ENEMY}
      geometry={geometry}
      material={material}
      maxCount={100}
      baseColor={GAME_THEME.enemy.hunter}
      colorSource="base"
      filter={e => e.getComponent<IdentityComponent>('Identity')?.variant === EnemyTypes.HUNTER}
      updateEntity={(e, obj, color, delta) => {
          const state = e.getComponent<StateComponent>('State');
          const transform = e.getComponent<TransformComponent>('Transform');
          const time = performance.now() * 0.001;

          if (state && state.current === 'CHARGE') {
              const alpha = (Math.sin(time * 20) + 1) / 2;
              color.lerp(chargeColor, alpha);
          }
          
          const spin = state?.data?.spinAngle || 0;
          const aim = transform ? transform.rotation : 0;

          obj.position.z = 5.0;
          applyRotation(obj, spin, aim);
          
          if (state && state.current === 'SPAWN') {
              const progress = 1.0 - (state.timers.spawn / 1.5);
              const eased = Math.pow(progress, 2); 
              obj.scale.setScalar(eased);
              obj.position.x += (Math.random() - 0.5) * 0.1 * (1-progress);
          } else {
              obj.scale.setScalar(1.0);
          }
      }}
    />
  );
};


=====================================
FILE: ./src/game/components/enemies/DrillerRenderer.tsx
=====================================
import { Tag } from '@/game/core/ecs/types';
import { GAME_THEME } from '@/game/theme';
import { EnemyTypes } from '@/game/config/Identifiers';
import { InstancedActor } from '../common/InstancedActor';
import { IdentityComponent } from '@/game/components/data/IdentityComponent';
import { StateComponent } from '@/game/components/data/StateComponent';
import { TransformComponent } from '@/game/components/data/TransformComponent'; 
import { AssetService } from '@/game/assets/AssetService';
import { applyRotation } from '@/game/utils/RenderUtils';
import { useStore } from '@/core/store/useStore';
import * as THREE from 'three';

export const DrillerRenderer = () => {
  const geometry = AssetService.get<THREE.BufferGeometry>('GEO_DRILLER');
  const material = AssetService.get<THREE.Material>('MAT_ENEMY_BASE');
  
  // Enable interaction if in mobile lockdown mode
  const isMobile = useStore(s => s.bootState === 'mobile_lockdown');

  return (
    <InstancedActor 
      tag={Tag.ENEMY}
      geometry={geometry}
      material={material}
      maxCount={500}
      baseColor={GAME_THEME.enemy.muncher}
      colorSource="base" 
      interactive={isMobile} // NEW: Pass the flag
      filter={e => e.getComponent<IdentityComponent>('Identity')?.variant === EnemyTypes.DRILLER}
      updateEntity={(e, obj, color, delta) => {
          const state = e.getComponent<StateComponent>('State');
          const transform = e.getComponent<TransformComponent>('Transform');
          
          const speed = (state && state.current === 'DRILLING') ? 20.0 : 5.0;
          const spin = performance.now() * 0.001 * speed;
          const aim = transform ? transform.rotation : 0;
          
          obj.position.z = 5.0;
          applyRotation(obj, spin, aim);
          
          if (state && state.current === 'SPAWN') {
              const progress = 1.0 - (state.timers.spawn / 1.5);
              const eased = Math.pow(progress, 2); 
              obj.scale.setScalar(eased);
              obj.position.x += (Math.random() - 0.5) * 0.1 * (1-progress);
          } else {
              obj.scale.setScalar(1.0); 
          }
      }}
    />
  );
};


=====================================
FILE: ./src/game/components/enemies/KamikazeRenderer.tsx
=====================================
import { Tag } from '@/game/core/ecs/types';
import { GAME_THEME } from '@/game/theme';
import { EnemyTypes } from '@/game/config/Identifiers';
import { InstancedActor } from '../common/InstancedActor';
import { IdentityComponent } from '@/game/components/data/IdentityComponent';
import { StateComponent } from '@/game/components/data/StateComponent';
import { AssetService } from '@/game/assets/AssetService';

export const KamikazeRenderer = () => {
  const geometry = AssetService.get<THREE.BufferGeometry>('GEO_KAMIKAZE');
  const material = AssetService.get<THREE.Material>('MAT_ENEMY_BASE');

  return (
    <InstancedActor 
      tag={Tag.ENEMY}
      geometry={geometry}
      material={material}
      maxCount={200}
      baseColor={GAME_THEME.enemy.kamikaze}
      colorSource="base"
      filter={e => e.getComponent<IdentityComponent>('Identity')?.variant === EnemyTypes.KAMIKAZE}
      updateEntity={(e, obj, color, delta) => {
          const state = e.getComponent<StateComponent>('State');
          const time = performance.now() * 0.001;
          obj.position.z = 5.0;
          
          // Kamikaze just tumbles chaotically
          obj.rotation.set(time * 2, time, 0); 
          
          if (state && state.current === 'SPAWN') {
              const progress = 1.0 - (state.timers.spawn / 1.5);
              const eased = Math.pow(progress, 2); 
              obj.scale.setScalar(eased);
              obj.position.x += (Math.random() - 0.5) * 0.1 * (1-progress);
          } else {
              obj.scale.setScalar(1.0);
          }
      }}
    />
  );
};


=====================================
FILE: ./src/game/hooks/usePanelRegistry.ts
=====================================
import { useEffect, useRef } from 'react';
import { useGameStore } from '../store/useGameStore';
import { PanelRegistry } from '../systems/PanelRegistrySystem';

export const usePanelRegistry = (id: string) => {
  const elementRef = useRef<HTMLDivElement>(null);
  
  const registerPanel = useGameStore((state) => state.registerPanel);
  const unregisterPanel = useGameStore((state) => state.unregisterPanel);

  useEffect(() => {
    const el = elementRef.current;
    if (!el) return;

    // 1. Register Logic (Health/Store)
    registerPanel(id, el);

    // 2. Register Spatial (Singleton)
    // This works immediately, even if game hasn't started
    PanelRegistry.register(id, el);

    // 3. Resize Observer
    const observer = new ResizeObserver(() => {
        PanelRegistry.refreshSingle(id);
    });
    observer.observe(el);

    return () => {
      observer.disconnect();
      unregisterPanel(id);
      PanelRegistry.unregister(id);
    };
  }, [id, registerPanel, unregisterPanel]);

  return elementRef;
};


=====================================
FILE: ./src/game/hooks/useDeviceType.ts
=====================================
import { useState, useEffect } from 'react';

type DeviceType = 'mobile' | 'tablet' | 'desktop';

export const useDeviceType = () => {
  const [device, setDevice] = useState<DeviceType>('desktop');

  useEffect(() => {
    const checkDevice = () => {
      const width = window.innerWidth;
      
      // Basic width checkpoints
      // < 768px: Usually Phones
      // 768px - 1024px: Tablets / Small Laptops
      // > 1024px: Desktop
      
      if (width < 768) {
        setDevice('mobile');
      } else if (width < 1024) {
        setDevice('tablet');
      } else {
        setDevice('desktop');
      }
    };

    checkDevice();
    window.addEventListener('resize', checkDevice);
    return () => window.removeEventListener('resize', checkDevice);
  }, []);

  return device;
};


=====================================
FILE: ./src/game/hooks/useWindowFocus.ts
=====================================
import { useEffect } from 'react';
import { useStore } from '@/core/store/useStore';

/**
 * Handles Global Window Focus/Blur events to pause/resume the simulation.
 */
export const useWindowFocus = () => {
  const { bootState, setSimulationPaused } = useStore();

  useEffect(() => {
    // Only attach listeners if the game is actually active
    if (bootState !== 'active') return;

    const handlePause = () => setSimulationPaused(true);
    const handleResume = () => setSimulationPaused(false);
    
    // 1. Visibility API (Tab switching)
    const handleVisibility = () => {
        if (document.hidden) handlePause();
        else handleResume();
    };

    document.addEventListener('visibilitychange', handleVisibility);
    
    // 2. Focus API (Window clicking)
    window.addEventListener('blur', handlePause);
    window.addEventListener('focus', handleResume);
    
    // 3. Mouse leaving viewport (Optional, strict immersion)
    document.addEventListener('mouseleave', handlePause);
    document.addEventListener('mouseenter', handleResume);
    
    return () => {
        document.removeEventListener('visibilitychange', handleVisibility);
        window.removeEventListener('blur', handlePause);
        window.removeEventListener('focus', handleResume);
        document.removeEventListener('mouseleave', handlePause);
        document.removeEventListener('mouseenter', handleResume);
    };
  }, [bootState, setSimulationPaused]);
};


=====================================
FILE: ./src/game/hooks/useTransientRef.ts
=====================================
import { useEffect, useRef } from 'react';
import { TransientDOMService } from '@/game/services/TransientDOMService';

/**
 * Registers a DOM element to the TransientDOMService.
 * Allows the GameLoop to write to it directly without React Re-renders.
 */
export const useTransientRef = (id: string, type: 'text' | 'width' | 'css-var') => {
  const ref = useRef<any>(null);

  useEffect(() => {
    if (ref.current) {
      TransientDOMService.register(id, ref.current, type);
    }
    return () => {
      TransientDOMService.unregister(id);
    };
  }, [id, type]);

  return ref;
};


=====================================
FILE: ./src/game/hooks/useHeartbeat.ts
=====================================
import { useEffect } from 'react';
import { useAnimation, AnimationControls } from 'framer-motion';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';

export const useHeartbeat = (): AnimationControls => {
  const controls = useAnimation();

  useEffect(() => {
    const unsub = GameEventBus.subscribe(GameEvents.HEARTBEAT, (payload) => {
        // We trigger the 'heartbeat' variant defined in the component.
        // We pass the urgency as a 'custom' prop to the variant if needed.
        controls.start("heartbeat");
    });

    return () => unsub();
  }, [controls]);

  return controls;
};


=====================================
FILE: ./src/game/workers/GeometryWorker.ts
=====================================
// Pure Math implementation of geometry generation to run off-main-thread

const computeBarycentric = (positionCount: number) => {
  const array = new Float32Array(positionCount * 3);
  for (let i = 0; i < positionCount; i += 3) {
    // 1,0,0
    array[i * 3 + 0] = 1; array[i * 3 + 1] = 0; array[i * 3 + 2] = 0;
    // 0,1,0
    array[i * 3 + 3] = 0; array[i * 3 + 4] = 1; array[i * 3 + 5] = 0;
    // 0,0,1
    array[i * 3 + 6] = 0; array[i * 3 + 7] = 0; array[i * 3 + 8] = 1;
  }
  return array;
};

const generateHunterSpear = () => {
  const positions: number[] = [];
  const numWings = 3;
  const length = 1.2;
  const wingWidth = 0.4;
  const wingThickness = 0.05;

  const tipY = length / 2;
  const baseY = -length / 2;

  const rotateY = (x: number, y: number, z: number, rad: number) => {
    return [
      x * Math.cos(rad) - z * Math.sin(rad),
      y,
      x * Math.sin(rad) + z * Math.cos(rad)
    ];
  };

  for(let i=0; i<numWings; i++) {
      const angle = (i / numWings) * Math.PI * 2;
      
      const pTip = [0, tipY, 0];
      const pBaseOut = [wingWidth, baseY, 0];
      const pBaseInBack = [0, baseY, -wingThickness];
      const pBaseInFront = [0, baseY, wingThickness];

      // Front Face
      positions.push(...rotateY(pTip[0], pTip[1], pTip[2], angle));
      positions.push(...rotateY(pBaseOut[0], pBaseOut[1], pBaseOut[2], angle));
      positions.push(...rotateY(pBaseInFront[0], pBaseInFront[1], pBaseInFront[2], angle));
      
      // Back Face
      positions.push(...rotateY(pTip[0], pTip[1], pTip[2], angle));
      positions.push(...rotateY(pBaseInBack[0], pBaseInBack[1], pBaseInBack[2], angle));
      positions.push(...rotateY(pBaseOut[0], pBaseOut[1], pBaseOut[2], angle));
  }

  const posArray = new Float32Array(positions);
  const baryArray = computeBarycentric(positions.length / 3);

  return { positions: posArray, barycentric: baryArray };
};

// Worker Listener
self.onmessage = (e: MessageEvent) => {
  const { id, task } = e.data;
  
  try {
    let result;
    if (task === 'GEO_HUNTER') {
        result = generateHunterSpear();
    } else {
        throw new Error(`Unknown task: ${task}`);
    }

    // Transfer buffers to avoid copy
    self.postMessage(
        { id, success: true, ...result }, 
        [result.positions.buffer, result.barycentric.buffer]
    );
  } catch (err: any) {
    self.postMessage({ id, success: false, error: err.message });
  }
};


=====================================
FILE: ./src/game/theme.ts
=====================================
export const GAME_THEME = {
  turret: {
    base: '#78F654',
    glow: '#C2FE9A',
    repair: '#00F0FF',
  },
  bullet: {
    plasma: '#FFFFFF',
    trail: '#78F654',
    hunter: '#F7D277', // Specific color for Hunter shots
  },
  enemy: {
    muncher: '#9E4EA5',
    kamikaze: '#FF003C',
    hunter: '#F7D277',
    charge: '#FFFFFF',  // Telegraph flash
  },
  hud: {
    text: '#78F654',
    warning: '#FF003C',
  },
  vfx: {
    spark: '#FFFFFF',
    damage: '#FF003C',
    heal: '#00F0FF',
    clash: '#F7D277',
  }
};


=====================================
FILE: ./src/game/events/GameEvents.ts
=====================================
export enum GameEvents {
  PLAYER_FIRED = 'PLAYER_FIRED',
  PLAYER_HIT = 'PLAYER_HIT',
  ENEMY_SPAWNED = 'ENEMY_SPAWNED',
  ENEMY_DAMAGED = 'ENEMY_DAMAGED',
  ENEMY_DESTROYED = 'ENEMY_DESTROYED',
  PROJECTILE_CLASH = 'PROJECTILE_CLASH',
  PANEL_DAMAGED = 'PANEL_DAMAGED',
  PANEL_HEALED = 'PANEL_HEALED',
  PANEL_DESTROYED = 'PANEL_DESTROYED',
  GAME_START = 'GAME_START',
  GAME_OVER = 'GAME_OVER',
  THREAT_LEVEL_UP = 'THREAT_LEVEL_UP',
  UPGRADE_SELECTED = 'UPGRADE_SELECTED',
  ZEN_MODE_ENABLED = 'ZEN_MODE_ENABLED',
  DEBUG_SPAWN = 'DEBUG_SPAWN',
  TRAUMA_ADDED = 'TRAUMA_ADDED',
  SCENE_READY = 'SCENE_READY',
  SPAWN_FX = 'SPAWN_FX',
  SPAWN_DAEMON = 'SPAWN_DAEMON',
  HEARTBEAT = 'HEARTBEAT',
  LOG_DEBUG = 'LOG_DEBUG',
  BOOT_LOG = 'BOOT_LOG'
}

export type FXVariant = 
  | 'EXPLOSION_PURPLE' 
  | 'EXPLOSION_YELLOW' 
  | 'EXPLOSION_RED'
  | 'IMPACT_WHITE'
  | 'IMPACT_RED'
  | 'IMPACT_YELLOW'
  | 'DRILL_SPARKS'
  | 'HUNTER_RECOIL'
  | 'CLASH_YELLOW';

export interface GameEventPayloads {
  [GameEvents.PLAYER_FIRED]: { x: number; y: number };
  [GameEvents.PLAYER_HIT]: { damage: number };
  [GameEvents.ENEMY_SPAWNED]: { type: string; id: number };
  [GameEvents.ENEMY_DAMAGED]: { id: number; damage: number; type: string };
  [GameEvents.ENEMY_DESTROYED]: { id: number; type: string; x: number; y: number };
  [GameEvents.PROJECTILE_CLASH]: { x: number; y: number };
  [GameEvents.PANEL_DAMAGED]: { id: string; amount: number; currentHealth: number };
  [GameEvents.PANEL_HEALED]: { id: string; amount: number };
  [GameEvents.PANEL_DESTROYED]: { id: string };
  [GameEvents.GAME_START]: null;
  [GameEvents.GAME_OVER]: { score: number };
  [GameEvents.THREAT_LEVEL_UP]: { level: number };
  [GameEvents.UPGRADE_SELECTED]: { option: string };
  [GameEvents.ZEN_MODE_ENABLED]: null;
  [GameEvents.DEBUG_SPAWN]: { type: string; count: number };
  [GameEvents.TRAUMA_ADDED]: { amount: number };
  [GameEvents.SCENE_READY]: null;
  [GameEvents.SPAWN_FX]: { type: FXVariant; x: number; y: number; angle?: number; count?: number; };
  [GameEvents.SPAWN_DAEMON]: null;
  [GameEvents.HEARTBEAT]: { urgency: number };
  [GameEvents.LOG_DEBUG]: { msg: string; source?: string };
  [GameEvents.BOOT_LOG]: { message: string };
}


=====================================
FILE: ./src/game/events/GameEventBus.ts
=====================================
import { GameEvents, GameEventPayloads } from './GameEvents';

type Handler<T extends GameEvents> = (payload: GameEventPayloads[T]) => void;

class GameEventBusController {
  // Use a mapped type for strict safety
  private listeners: { [K in GameEvents]?: Handler<K>[] } = {};
  
  private history: { event: string; payload: any; timestamp: number }[] = [];
  private readonly MAX_HISTORY = 50;

  public subscribe<T extends GameEvents>(event: T, handler: Handler<T>): () => void {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    // Force cast to generic array to satisfy TS compiler index signature
    (this.listeners[event] as Handler<T>[]).push(handler);

    return () => {
      if (!this.listeners[event]) return;
      this.listeners[event] = (this.listeners[event] as Handler<T>[]).filter(h => h !== handler) as any;
    };
  }

  public emit<T extends GameEvents>(event: T, payload: GameEventPayloads[T]): void {
    // 1. Log History (Debug only)
    if (process.env.NODE_ENV === 'development') {
        this.history.push({ event, payload, timestamp: Date.now() });
        if (this.history.length > this.MAX_HISTORY) this.history.shift();
    }

    // 2. Dispatch
    const handlers = this.listeners[event];
    if (handlers) {
        handlers.forEach(handler => handler(payload));
    }
  }

  public clear(): void {
    this.listeners = {};
    this.history = [];
  }
}

export const GameEventBus = new GameEventBusController();


=====================================
FILE: ./src/game/systems/CollisionSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IPhysicsSystem, ICombatSystem } from '../core/interfaces';
import { EntityRegistry } from '../core/ecs/EntityRegistry';
import { TransformComponent } from '../components/data/TransformComponent';
import { StateComponent } from '../components/data/StateComponent';
import { ColliderComponent } from '../components/data/ColliderComponent';
import { EntityID } from '../core/ecs/types';

export class CollisionSystem implements IGameSystem {
  private physicsSystem!: IPhysicsSystem;
  private registry!: EntityRegistry;
  private combatSystem!: ICombatSystem;

  // Reusable buffers to avoid GC
  private resultBuffer = new Set<EntityID>();
  private handledPairs = new Set<string>();

  setup(locator: IServiceLocator): void {
    this.physicsSystem = locator.getSystem<IPhysicsSystem>('PhysicsSystem');
    this.combatSystem = locator.getSystem<ICombatSystem>('CombatSystem');
    this.registry = locator.getRegistry() as EntityRegistry;
  }

  update(delta: number, time: number): void {
    const spatial = this.physicsSystem.spatialGrid;
    
    // 1. Get Candidates via Cached Query
    const collidables = this.registry.query({ all: ['Collider', 'Transform'] });
    
    this.handledPairs.clear();

    for (const entity of collidables) {
        if (!entity.active) continue;

        const collider = entity.getComponent<ColliderComponent>('Collider');
        const transform = entity.getComponent<TransformComponent>('Transform');

        // Safety check (Type Guard)
        if (!collider || !transform || collider.mask === 0) continue;

        // Skip spawning entities
        const state = entity.getComponent<StateComponent>('State');
        if (state && state.current === 'SPAWN') continue;

        // 2. Broad Phase (Zero-alloc query)
        // Check slightly larger radius to catch edge cases
        spatial.query(transform.x, transform.y, collider.radius + 1.0, this.resultBuffer);

        // 3. Narrow Phase
        for (const otherId of this.resultBuffer) {
            if (otherId === entity.id) continue;
            
            // Fast unique pair check (Smallest ID first)
            const id1 = entity.id < (otherId as number) ? entity.id : otherId;
            const id2 = entity.id < (otherId as number) ? otherId : entity.id;
            const pairId = `${id1}:${id2}`;
            
            if (this.handledPairs.has(pairId)) continue;
            this.handledPairs.add(pairId);

            const other = this.registry.getEntity(otherId as number);
            if (!other || !other.active) continue;

            const otherCollider = other.getComponent<ColliderComponent>('Collider');
            const otherTransform = other.getComponent<TransformComponent>('Transform');
            
            if (!otherCollider || !otherTransform) continue;

            // Bitmask Check
            const aHitsB = (collider.mask & otherCollider.layer) !== 0;
            const bHitsA = (otherCollider.mask & collider.layer) !== 0;
            if (!aHitsB && !bHitsA) continue;

            // Circle-Circle Check
            const dx = transform.x - otherTransform.x;
            const dy = transform.y - otherTransform.y;
            const distSq = dx * dx + dy * dy;
            const radiusSum = collider.radius + otherCollider.radius;

            if (distSq < radiusSum * radiusSum) {
                this.combatSystem.resolveCollision(entity, other);
            }
        }
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/game/systems/AudioDirectorSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { FastEventBus, FastEvents, FX_ID_MAP } from '../core/FastEventBus';

export class AudioDirectorSystem implements IGameSystem {
  
  setup(locator: IServiceLocator): void {
    this.setupEventListeners();
  }

  update(delta: number, time: number): void {
    // Process High Frequency Audio Events (from FastEventBus)
    FastEventBus.processEvents((id, a1, a2, a3, a4) => {
        if (id === FastEvents.PLAY_SOUND) {
            // Note: We need a mapping for ID -> Key if we use FastBus for audio.
            // Currently mostly used for VFX, but ready for expansion.
        }
    });
  }

  private setupEventListeners() {
    // 1. Player Actions
    GameEventBus.subscribe(GameEvents.PLAYER_FIRED, () => {
        AudioSystem.playSound('fx_player_fire');
    });

    GameEventBus.subscribe(GameEvents.PLAYER_HIT, (p) => {
        AudioSystem.playSound('fx_impact_heavy'); 
        // Duck music on heavy impact
        AudioSystem.duckMusic(0.7, 1.0);
    });

    // 2. Enemy Interactions
    GameEventBus.subscribe(GameEvents.ENEMY_DESTROYED, (p) => { 
        if (p.type === 'kamikaze') AudioSystem.playSound('fx_impact_heavy');
        else AudioSystem.playSound('fx_impact_light');
    });

    // 3. UI / System State
    GameEventBus.subscribe(GameEvents.GAME_OVER, () => {
        AudioSystem.playSound('fx_impact_heavy');
        AudioSystem.duckMusic(1.0, 3.0);
    });

    GameEventBus.subscribe(GameEvents.PANEL_HEALED, () => {
        AudioSystem.playSound('loop_heal');
    });

    GameEventBus.subscribe(GameEvents.PANEL_DESTROYED, () => {
        AudioSystem.playSound('fx_impact_heavy'); 
        AudioSystem.duckMusic(0.8, 1.5);
    });

    GameEventBus.subscribe(GameEvents.UPGRADE_SELECTED, () => {
        AudioSystem.playSound('fx_level_up');
    });
    
    // 4. Ambient / Music Control
    GameEventBus.subscribe(GameEvents.ZEN_MODE_ENABLED, () => {
        // Switch to calmer ambience? 
        // For now, standard behavior.
    });
  }

  teardown(): void {
    // No explicit cleanup needed as EventBus clears on reload, 
    // but in a strict engine we would unsubscribe here.
  }
}


=====================================
FILE: ./src/game/systems/UISyncSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { useGameStore } from '../store/useGameStore';
import { GameStateSystem } from './GameStateSystem';
import { PanelRegistry } from './PanelRegistrySystem';
import { InteractionSystem } from './InteractionSystem';
import { TransientDOMService } from '@/game/services/TransientDOMService';

export class UISyncSystem implements IGameSystem {
  private gameSystem!: GameStateSystem;
  private interactionSystem!: InteractionSystem;
  
  private readonly SYNC_INTERVAL = 0.1; // 10Hz UI updates are plenty
  private timeSinceLastSync = 0;

  setup(locator: IServiceLocator): void {
    this.gameSystem = locator.getSystem<GameStateSystem>('GameStateSystem');
    this.interactionSystem = locator.getSystem<InteractionSystem>('InteractionSystem');
  }

  update(delta: number, time: number): void {
    this.timeSinceLastSync += delta;
    if (this.timeSinceLastSync < this.SYNC_INTERVAL) return;
    this.timeSinceLastSync = 0;
    this.sync();
  }

  teardown(): void {}

  private sync() {
    const store = useGameStore.getState();
    
    // 1. FAST PATH: Direct DOM Updates (No React Render)
    // We assume the DOM elements are registered via useTransientRef
    const formattedScore = this.gameSystem.score.toString().padStart(4, '0');
    TransientDOMService.update('score-display', formattedScore);
    
    // 2. SLOW PATH: React State Sync
    // Only update Zustand if values actually changed to prevent Virtual DOM trashing
    const shouldSyncReact = 
        store.playerHealth !== this.gameSystem.playerHealth || 
        store.playerRebootProgress !== this.gameSystem.playerRebootProgress || 
        store.xp !== this.gameSystem.xp || 
        store.score !== this.gameSystem.score ||
        store.level !== this.gameSystem.level ||
        store.upgradePoints !== this.gameSystem.upgradePoints ||
        store.interactionTarget !== this.interactionSystem.hoveringPanelId ||
        Math.abs(store.systemIntegrity - PanelRegistry.systemIntegrity) > 1.0; 

    if (shouldSyncReact) {
        store.syncGameState({
            playerHealth: this.gameSystem.playerHealth, 
            playerRebootProgress: this.gameSystem.playerRebootProgress, 
            level: this.gameSystem.level,
            xp: this.gameSystem.xp,
            score: this.gameSystem.score,
            xpToNextLevel: this.gameSystem.xpToNextLevel,
            upgradePoints: this.gameSystem.upgradePoints,
            activeUpgrades: { ...this.gameSystem.activeUpgrades },
            systemIntegrity: PanelRegistry.systemIntegrity,
            interactionTarget: this.interactionSystem.hoveringPanelId 
        });
    }

    // 3. Panel Sync (Slow path)
    const uiPanels: Record<string, any> = {};
    const panels = PanelRegistry.getAllPanels();
    for(const p of panels) {
        uiPanels[p.id] = {
            id: p.id,
            health: p.health,
            isDestroyed: p.isDestroyed
        };
    }
    store.syncPanels(uiPanels);
  }
}


=====================================
FILE: ./src/game/systems/InteractionSystem.ts
=====================================
import { IInteractionSystem, IServiceLocator, IEntitySpawner, IGameStateSystem } from '../core/interfaces';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { PanelRegistry } from './PanelRegistrySystem'; 
import { AudioSystem } from '@/core/audio/AudioSystem';

export type RepairState = 'IDLE' | 'HEALING' | 'REBOOTING';

export class InteractionSystem implements IInteractionSystem {
  public repairState: RepairState = 'IDLE';
  public hoveringPanelId: string | null = null;
  
  private lastRepairTime = 0;
  private readonly REPAIR_RATE = 0.05;
  private locator!: IServiceLocator;
  private spawner!: IEntitySpawner;
  private gameSystem!: IGameStateSystem; 

  setup(locator: IServiceLocator): void {
    this.locator = locator;
    this.spawner = locator.getSpawner();
    this.gameSystem = locator.getSystem<IGameStateSystem>('GameStateSystem');
  }

  update(delta: number, time: number): void {
    this.repairState = 'IDLE';
    this.hoveringPanelId = null;
    
    if (this.gameSystem.isGameOver) return; 
    
    const cursor = this.locator.getInputService().getCursor();
    
    // Priority 1: Self-Revival (If Dead)
    if (this.gameSystem.playerHealth <= 0) {
        this.handleRevival(cursor, time);
        
        // Decay revival progress if not actively repairing
        if (this.repairState !== 'REBOOTING' && this.gameSystem.playerRebootProgress > 0) {
            this.gameSystem.decayReboot(delta * 15);
        }
        return; 
    }

    // Priority 2: World Repair (If Alive)
    this.handlePanelRepair(cursor, time);
  }

  teardown(): void {}

  private handleRevival(cursor: {x: number, y: number}, time: number) {
    const rect = PanelRegistry.getPanelRect('identity');
    if (!rect) return;
    const padding = 2.0; 
    const isHovering = 
        cursor.x >= rect.left - padding && 
        cursor.x <= rect.right + padding && 
        cursor.y >= rect.bottom - padding && 
        cursor.y <= rect.top + padding;

    if (isHovering) {
        this.hoveringPanelId = 'identity';
        this.repairState = 'REBOOTING';
        if (time > this.lastRepairTime + this.REPAIR_RATE) {
            this.gameSystem.tickReboot(5.0); 
            this.lastRepairTime = time;
            
            AudioSystem.playSound('loop_reboot'); 

            if (Math.random() > 0.3) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 2;
                this.spawner.spawnParticle(cursor.x, cursor.y, '#9E4EA5', Math.cos(angle)*speed, Math.sin(angle)*speed, 0.5);
            }
        }
    }
  }

  private handlePanelRepair(cursor: {x: number, y: number}, time: number) {
    const panels = PanelRegistry.getAllPanels();
    for (const p of panels) {
      if (cursor.x >= p.left && cursor.x <= p.right && cursor.y >= p.bottom && cursor.y <= p.top) {
        this.hoveringPanelId = p.id;
        
        if (!p.isDestroyed && p.health >= 1000) continue;

        this.repairState = p.isDestroyed ? 'REBOOTING' : 'HEALING';

        if (time > this.lastRepairTime + this.REPAIR_RATE) {
            PanelRegistry.healPanel(p.id, 20);
            this.lastRepairTime = time;
            
            if (p.isDestroyed) {
                AudioSystem.playSound('loop_reboot');
            } else {
                GameEventBus.emit(GameEvents.PANEL_HEALED, { id: p.id, amount: 20 });
            }

            if (Math.random() > 0.3) {
                const color = p.isDestroyed ? '#9E4EA5' : '#00F0FF'; 
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 2;
                this.spawner.spawnParticle(cursor.x, cursor.y, color, Math.cos(angle)*speed, Math.sin(angle)*speed, 0.5);
            }
        }
        break; 
      }
    }
  }
}


=====================================
FILE: ./src/game/systems/VFXSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IEntitySpawner } from '../core/interfaces';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { ShakeSystem } from './ShakeSystem';
import { TimeSystem } from './TimeSystem';
import { VFX_RECIPES } from '../config/VFXConfig';
import { FastEventBus, FastEvents, FX_ID_MAP } from '../core/FastEventBus';
import { useStore } from '@/core/store/useStore';

export class VFXSystem implements IGameSystem {
  private spawner!: IEntitySpawner;
  private locator!: IServiceLocator;

  setup(locator: IServiceLocator): void {
    this.locator = locator;
    this.spawner = locator.getSpawner();
    this.setupListeners();
  }

  update(delta: number, time: number): void {
    FastEventBus.processEvents((id, a1, a2, a3, a4) => {
        if (id === FastEvents.SPAWN_FX) {
            const key = FX_ID_MAP[a1];
            if (key) this.executeRecipe(key, a2, a3, a4);
        }
        else if (id === FastEvents.TRAUMA) {
            this.addTrauma(a1);
        }
    });
  }

  teardown(): void {}

  private setupListeners() {
    GameEventBus.subscribe(GameEvents.PLAYER_HIT, (p) => {
        const isBig = p.damage > 10;
        // Standard bullet hits add lighter trauma.
        // Direct collisions add THEIR OWN trauma in CombatHandlers, 
        // effectively stacking with this for a huge impact.
        if (isBig) this.triggerHitStop(0.05);
    });

    GameEventBus.subscribe(GameEvents.PANEL_DESTROYED, () => {
        // AAA POLISH: Increased structural failure feel
        this.addTrauma(0.75); 
        this.triggerHitStop(0.1); 
    });

    GameEventBus.subscribe(GameEvents.GAME_OVER, () => {
        // AAA POLISH: Maximum impact on death
        this.addTrauma(1.0);
        this.triggerHitStop(0.5); 
    });
    
    GameEventBus.subscribe(GameEvents.ZEN_MODE_ENABLED, () => {
        this.executeRecipe('PURGE_BLAST', 0, 0);
    });
  }

  private executeRecipe(key: string, x: number, y: number, angle: number = 0) {
      const recipe = VFX_RECIPES[key];
      if (!recipe) return;

      const graphicsMode = useStore.getState().graphicsMode;
      const isPotato = graphicsMode === 'POTATO';
      const multiplier = isPotato ? 0.3 : 1.0;

      const rawCount = this.randomRange(recipe.count[0], recipe.count[1]);
      let count = Math.floor(rawCount * multiplier);
      
      if (rawCount > 0 && count === 0) count = 1;

      for (let i = 0; i < count; i++) {
          const color = recipe.colors[Math.floor(Math.random() * recipe.colors.length)];
          const speed = this.randomRange(recipe.speed[0], recipe.speed[1]);
          const life = this.randomRange(recipe.life[0], recipe.life[1]);
          
          let vx = 0;
          let vy = 0;

          if (recipe.pattern === 'RADIAL') {
              const a = Math.random() * Math.PI * 2;
              vx = Math.cos(a) * speed;
              vy = Math.sin(a) * speed;
          } 
          else if (recipe.pattern === 'DIRECTIONAL') {
              const baseDir = angle + Math.PI; 
              const spread = recipe.spread || 0.5;
              const a = baseDir + (Math.random() - 0.5) * spread;
              vx = Math.cos(a) * speed;
              vy = Math.sin(a) * speed;
          }

          this.spawner.spawnParticle(x, y, color, vx, vy, life);
      }
  }

  private randomRange(min: number, max: number) {
      return min + Math.random() * (max - min);
  }

  private addTrauma(amount: number) {
      try {
          const shake = this.locator.getSystem<ShakeSystem>('ShakeSystem');
          shake.addTrauma(amount);
      } catch {}
  }

  private triggerHitStop(duration: number) {
      try {
          const time = this.locator.getSystem<TimeSystem>('TimeSystem');
          time.freeze(duration);
      } catch {}
  }
}


=====================================
FILE: ./src/game/systems/StructureSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { PanelRegistry } from './PanelRegistrySystem';

export class StructureSystem implements IGameSystem {
  private decayTimer = 0;
  // Decay logic runs at 10hz (every 0.1s)
  private readonly DECAY_INTERVAL = 0.1; 
  private readonly DECAY_AMOUNT = 5;

  setup(locator: IServiceLocator): void {
    // No dependencies needed yet
  }

  update(delta: number, time: number): void {
    this.decayTimer += delta;
    
    if (this.decayTimer >= this.DECAY_INTERVAL) {
        this.processDecay();
        this.decayTimer = 0;
    }
  }

  private processDecay() {
      // Passive Rule: Destroyed panels lose residual charge (Health) over time
      // This prevents them from staying at "1% / Offline" forever.
      const panels = PanelRegistry.getAllPanels();
      for (const p of panels) {
          if (p.isDestroyed && p.health > 0) {
               PanelRegistry.decayPanel(p.id, this.DECAY_AMOUNT);
          }
      }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/game/systems/PlayerSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IEntitySpawner, IGameStateSystem, IInteractionSystem } from '../core/interfaces';
import { EntityRegistry } from '../core/ecs/EntityRegistry';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { Tag } from '../core/ecs/types';
import { TransformComponent } from '../components/data/TransformComponent';
import { StateComponent } from '../components/data/StateComponent';
import { TargetComponent } from '../components/data/TargetComponent';
import { ConfigService } from '../services/ConfigService';

export class PlayerSystem implements IGameSystem {
  private lastFireTime = 0;
  private gameSystem!: IGameStateSystem;
  private registry!: EntityRegistry;
  private spawner!: IEntitySpawner;
  private locator!: IServiceLocator;
  private config!: typeof ConfigService;

  setup(locator: IServiceLocator): void {
    this.locator = locator;
    this.gameSystem = locator.getSystem<IGameStateSystem>('GameStateSystem');
    this.registry = locator.getRegistry() as EntityRegistry;
    this.spawner = locator.getSpawner();
    this.config = locator.getConfigService(); // INJECTED CONFIG
    
    this.setupListeners();
  }

  update(delta: number, time: number): void {
    if (this.gameSystem.isGameOver || this.gameSystem.playerHealth <= 0) return;

    const players = this.registry.getByTag(Tag.PLAYER);
    const playerEntity = players[0]; 
    if (!playerEntity) return;

    const cursor = this.locator.getInputService().getCursor();
    const transform = playerEntity.getComponent<TransformComponent>('Transform');
    if (transform) {
        transform.x = cursor.x;
        transform.y = cursor.y;
    }

    const stateComp = playerEntity.getComponent<StateComponent>('State');
    if (stateComp) {
        try {
            const interact = this.locator.getSystem<IInteractionSystem>('InteractionSystem');
            if (interact && interact.repairState !== 'IDLE') {
                stateComp.current = 'REBOOTING';
            } else {
                stateComp.current = 'ACTIVE';
            }
        } catch {
            stateComp.current = 'ACTIVE';
        }
    }

    if (stateComp && (stateComp.current === 'ACTIVE' || stateComp.current === 'REBOOTING')) {
        const upgrades = this.gameSystem.activeUpgrades;
        const overclock = upgrades['OVERCLOCK'] || 0;
        
        // USE INJECTED CONFIG
        const currentFireRate = this.config.player.fireRate / Math.pow(1.5, overclock);

        if (time > this.lastFireTime + currentFireRate) {
            this.attemptAutoFire(time, playerEntity, upgrades);
        }
    }
  }

  teardown(): void {}

  private setupListeners() {
    GameEventBus.subscribe(GameEvents.ENEMY_DESTROYED, (payload) => {
      this.gameSystem.addScore(1);
      this.gameSystem.addXp(10);
    });

    GameEventBus.subscribe(GameEvents.UPGRADE_SELECTED, (p) => {
        if (p.option === 'PURGE') {
            this.triggerPurge();
        }
    });
  }

  private triggerPurge() {
      const cursor = this.locator.getInputService().getCursor();
      const count = 360; 
      const speed = 45;  
      const damage = 100;
      const width = 3.0; 

      GameEventBus.emit(GameEvents.SPAWN_FX, { type: 'EXPLOSION_YELLOW', x: cursor.x, y: cursor.y });
      GameEventBus.emit(GameEvents.TRAUMA_ADDED, { amount: 1.0 }); 

      for (let i = 0; i < count; i++) {
          const angle = (Math.PI * 2 * i) / count;
          const vx = Math.cos(angle) * speed;
          const vy = Math.sin(angle) * speed;
          
          this.spawner.spawnBullet(
              cursor.x, cursor.y, 
              vx, vy, 
              false, 
              2.0,   
              damage, 
              width
          );
      }
  }

  private attemptAutoFire(time: number, player: any, upgrades: Record<string, number>) {
    const cursor = this.locator.getInputService().getCursor();
    const enemies = this.registry.getByTag(Tag.ENEMY);
    let nearestDist = Infinity;
    const RANGE = 14; 
    let targetEnemy: any = null;

    for (const e of enemies) {
      if (!e.active) continue;
      const state = e.getComponent<StateComponent>('State');
      if (state && state.current === 'SPAWN') continue;

      const t = e.getComponent<TransformComponent>('Transform');
      if (!t) continue;
      const dx = t.x - cursor.x;
      const dy = t.y - cursor.y;
      const dist = dx*dx + dy*dy; 
      if (dist < (RANGE * RANGE) && dist < nearestDist) {
          nearestDist = dist;
          targetEnemy = e;
      }
    }

    if (targetEnemy) {
      const forkLevel = upgrades['FORK'] || 0;
      const projectileCount = 1 + (forkLevel * 2);
      const dmgLevel = upgrades['EXECUTE'] || 0;
      const damage = 1 + dmgLevel;
      const widthLevel = upgrades['BANDWIDTH'] || 0;
      const width = 1.0 + (widthLevel * 0.5);
      const snifferLevel = upgrades['SNIFFER'] || 0;
      const backdoorLevel = upgrades['BACKDOOR'] || 0;

      const baseSpread = 0.15;
      const spreadAngle = baseSpread * width; 
      
      const tPos = targetEnemy.getComponent<TransformComponent>('Transform')!;
      const dx = tPos.x - cursor.x;
      const dy = tPos.y - cursor.y;
      const baseAngle = Math.atan2(dy, dx);
      const startAngle = baseAngle - ((projectileCount - 1) * spreadAngle) / 2;

      // Use Config for Bullet Speed/Life
      const bSpeed = this.config.player.bulletSpeed;
      const bLife = this.config.player.bulletLife;

      // 1. FORK (Main)
      for (let i = 0; i < projectileCount; i++) {
          const angle = startAngle + (i * spreadAngle);
          const vx = Math.cos(angle) * bSpeed;
          const vy = Math.sin(angle) * bSpeed;

          this.spawner.spawnBullet(cursor.x, cursor.y, vx, vy, false, bLife, damage, width);
      }

      // 2. BACKDOOR
      if (backdoorLevel > 0) {
          const rearAngle = baseAngle + Math.PI; 
          const vx = Math.cos(rearAngle) * bSpeed;
          const vy = Math.sin(rearAngle) * bSpeed;
          this.spawner.spawnBullet(cursor.x, cursor.y, vx, vy, false, bLife, damage, width);
      }

      // 3. SNIFFER
      if (snifferLevel > 0) {
          const angleStep = (Math.PI * 2) / snifferLevel;
          for(let i=0; i<snifferLevel; i++) {
              const angle = baseAngle + (i * angleStep);
              const vx = Math.cos(angle) * bSpeed;
              const vy = Math.sin(angle) * bSpeed;
              const bullet = this.spawner.spawnBullet(cursor.x, cursor.y, vx, vy, false, bLife, damage, width);
              bullet.addComponent(new TargetComponent(null, 'ENEMY'));
          }
      }
      
      GameEventBus.emit(GameEvents.PLAYER_FIRED, { x: cursor.x, y: cursor.y });
      this.lastFireTime = time;
    }
  }
}


=====================================
FILE: ./src/game/systems/OrbitalSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { EntityRegistry } from '../core/ecs/EntityRegistry';
import { TransformComponent } from '../components/data/TransformComponent';
import { OrbitalComponent } from '../components/data/OrbitalComponent';
import { Tag } from '../core/ecs/types';

export class OrbitalSystem implements IGameSystem {
  private registry!: EntityRegistry;

  setup(locator: IServiceLocator): void {
    this.registry = locator.getRegistry() as EntityRegistry;
  }

  update(delta: number, time: number): void {
    const orbitals = this.registry.getAll(); // Filter by component in loop for speed or tag?
    // Optimization: In a real ECS we'd query by component. Here we iterate.
    
    // Find Player Cache (Parent)
    const players = this.registry.getByTag(Tag.PLAYER);
    if (players.length === 0) return;
    const player = players[0];
    const pPos = player.getComponent<TransformComponent>('Transform');
    if (!pPos) return;

    for (const entity of orbitals) {
        if (!entity.active) continue;
        
        const orb = entity.getComponent<OrbitalComponent>('Orbital');
        const transform = entity.getComponent<TransformComponent>('Transform');

        if (!orb || !transform) continue;

        // Update Angle
        if (orb.active) {
            orb.angle += orb.speed * delta;
        }

        // Update Position (Parent Pos + Orbit Offset)
        transform.x = pPos.x + Math.cos(orb.angle) * orb.radius;
        transform.y = pPos.y + Math.sin(orb.angle) * orb.radius;
        
        // Rotate self to look outward (tangent) or just spin?
        // Let's spin the mesh in the renderer, keep physics rotation simple.
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/game/systems/TimeSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';

export class TimeSystem implements IGameSystem {
  public timeScale: number = 1.0;
  public elapsedTime: number = 0; // Game World Time
  
  private freezeTimer: number = 0; // Real World Time duration

  // FPS Counting
  public fps: number = 60;
  private frames: number = 0;
  private lastFpsTime: number = 0;

  setup(locator: IServiceLocator): void {
    this.reset();
  }

  // Called by GameEngine every render frame (Variable Interval)
  public tickRealTime(dt: number) {
      // 1. Handle Freeze Timer (Real Time)
      if (this.freezeTimer > 0) {
          this.freezeTimer -= dt;
          if (this.freezeTimer < 0) this.freezeTimer = 0;
      }

      // 2. FPS Calculation (Real Time)
      const now = performance.now() / 1000;
      this.frames++;
      if (now >= this.lastFpsTime + 1.0) {
          this.fps = this.frames;
          this.frames = 0;
          this.lastFpsTime = now;
      }
  }

  // Called by GameEngine only during simulation steps (Fixed Interval)
  update(delta: number, time: number): void {
    // This delta is always 0.0166 (Fixed Step)
    this.elapsedTime += delta;
  }

  teardown(): void {
    this.reset();
  }

  private reset() {
    this.timeScale = 1.0;
    this.elapsedTime = 0;
    this.freezeTimer = 0;
    this.frames = 0;
    this.lastFpsTime = 0;
    this.fps = 60;
  }
  
  public setScale(scale: number, duration?: number) {
    this.timeScale = scale;
    if (duration) {
      setTimeout(() => {
        this.timeScale = 1.0;
      }, duration * 1000);
    }
  }

  public freeze(duration: number) {
      this.freezeTimer = duration;
  }

  public isFrozen(): boolean {
      return this.freezeTimer > 0;
  }
}


=====================================
FILE: ./src/game/systems/ShakeSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { noise } from '../utils/Noise';
import { useStore } from '@/core/store/useStore';

export class ShakeSystem implements IGameSystem {
  private trauma = 0;
  private time = 0;
  
  public currentOffset = { x: 0, y: 0, r: 0 };

  // --- CONFIGURATION ---
  // Decay: How fast it settles. 2.0 is snappy but allows a brief "fade out".
  private readonly DECAY_RATE = 2.0; 
  
  // Amplitude: Maximum distance in World Units at 100% Trauma
  // BIASED X-AXIS: 0.5 vs 0.3 creates more horizontal "jitter"
  private readonly MAX_OFFSET_X = 0.5; 
  private readonly MAX_OFFSET_Y = 0.3; 
  private readonly MAX_ROTATION = 0.04; 

  // Frequency: The speed of the noise sampling
  private readonly BASE_SPEED = 15.0;  // Slow wobble for small hits
  private readonly TRAUMA_SPEED_BOOST = 65.0; // Adds violence to big hits

  private readonly PIXELS_PER_UNIT = 40; 

  setup(locator: IServiceLocator): void {
    this.setupListeners();
  }

  update(delta: number, time: number): void {
    const strength = useStore.getState().screenShakeStrength;
    
    // 1. Decay Trauma
    if (this.trauma > 0) {
      this.trauma = Math.max(0, this.trauma - (delta * this.DECAY_RATE));
    }

    // 2. Calculate "Shake Juice" (Trauma^2)
    const shake = (this.trauma * this.trauma) * strength;
    
    if (shake > 0.001) {
        // 3. DYNAMIC FREQUENCY
        // As trauma increases, the noise sample steps faster (Higher Hz)
        // At 0.0 Trauma: Speed is 15.0 (Gentle)
        // At 1.0 Trauma: Speed is 80.0 (Violent Buzz)
        const currentSpeed = this.BASE_SPEED + (this.trauma * this.TRAUMA_SPEED_BOOST);
        
        this.time += delta * currentSpeed;
        
        // 4. Sample Noise (Seed offsets: 0, 100, 200)
        // Multiplied by 'shake' amplitude
        const x = this.MAX_OFFSET_X * shake * noise(this.time);
        const y = this.MAX_OFFSET_Y * shake * noise(this.time + 100);
        const r = this.MAX_ROTATION * shake * noise(this.time + 200);
        
        this.currentOffset = { x, y, r };

        // 5. DOM Sync
        const domX = -x * this.PIXELS_PER_UNIT;
        const domY = -y * this.PIXELS_PER_UNIT; 
        
        const root = document.documentElement;
        root.style.setProperty('--shake-x', `${domX.toFixed(2)}px`);
        root.style.setProperty('--shake-y', `${-domY.toFixed(2)}px`);
        root.style.setProperty('--shake-r', `${r.toFixed(4)}rad`);
    } else {
        // Reset
        if (this.currentOffset.x !== 0) {
            this.currentOffset = { x: 0, y: 0, r: 0 };
            const root = document.documentElement;
            root.style.setProperty('--shake-x', '0px');
            root.style.setProperty('--shake-y', '0px');
            root.style.setProperty('--shake-r', '0rad');
        }
    }
  }

  private setupListeners() {
    GameEventBus.subscribe(GameEvents.TRAUMA_ADDED, (p) => this.addTrauma(p.amount));
    
    // Fallbacks
    GameEventBus.subscribe(GameEvents.PLAYER_HIT, (p) => {
        const amount = p.damage > 10 ? 0.45 : 0.2;
        this.addTrauma(amount);
    });
  }

  public addTrauma(amount: number) {
    this.trauma = Math.min(1.0, this.trauma + amount);
  }

  teardown(): void {
    const root = document.documentElement;
    root.style.removeProperty('--shake-x');
    root.style.removeProperty('--shake-y');
    root.style.removeProperty('--shake-r');
  }
}


=====================================
FILE: ./src/game/systems/GuidanceSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { EntityRegistry } from '../core/ecs/EntityRegistry';
import { TransformComponent } from '../components/data/TransformComponent';
import { MotionComponent } from '../components/data/MotionComponent';
import { TargetComponent } from '../components/data/TargetComponent';
import { Tag } from '../core/ecs/types';

export class GuidanceSystem implements IGameSystem {
  private registry!: EntityRegistry;

  setup(locator: IServiceLocator): void {
    this.registry = locator.getRegistry() as EntityRegistry;
  }

  update(delta: number, time: number): void {
    const bullets = this.registry.getByTag(Tag.BULLET);

    for (const b of bullets) {
        if (!b.active) continue;
        
        // Only guide if it has a Target Component and has found a target
        const target = b.getComponent<TargetComponent>('Target');
        const motion = b.getComponent<MotionComponent>('Motion');
        const transform = b.getComponent<TransformComponent>('Transform');

        if (!target || !motion || !transform || !target.id) continue;

        // STEERING LOGIC
        const dx = target.x - transform.x;
        const dy = target.y - transform.y;
        
        // Desired Angle
        const desiredAngle = Math.atan2(dy, dx);
        
        // Current Angle (from velocity)
        const currentAngle = Math.atan2(motion.vy, motion.vx);
        
        // Angular difference (shortest path)
        let diff = desiredAngle - currentAngle;
        while (diff > Math.PI) diff -= Math.PI * 2;
        while (diff < -Math.PI) diff += Math.PI * 2;

        // Turn Speed (Radians per second)
        // High turn speed = tighter homing
        const turnSpeed = 4.0; 
        
        // Apply Rotation
        const maxTurn = turnSpeed * delta;
        const actualTurn = Math.max(-maxTurn, Math.min(maxTurn, diff));
        
        const newAngle = currentAngle + actualTurn;
        
        // Maintain Speed, Change Direction
        const speed = Math.sqrt(motion.vx * motion.vx + motion.vy * motion.vy);
        motion.vx = Math.cos(newAngle) * speed;
        motion.vy = Math.sin(newAngle) * speed;
        
        // Update visual rotation to match velocity
        transform.rotation = newAngle;
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/game/systems/CombatSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IGameStateSystem, IEntityRegistry } from '../core/interfaces';
import { Entity } from '../core/ecs/Entity';
import { ColliderComponent } from '../components/data/ColliderComponent';
import { TransformComponent } from '../components/data/TransformComponent';
import { IdentityComponent } from '../components/data/IdentityComponent';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents, FXVariant } from '../events/GameEvents';
import { EnemyTypes } from '../config/Identifiers';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { CollisionMatrix } from '../logic/combat/CollisionMatrix';
import { CombatContext } from '../logic/combat/types';
import { FastEventBus, FastEvents, FX_IDS } from '../core/FastEventBus';

export class CombatSystem implements IGameSystem {
  private gameSystem!: IGameStateSystem;
  private registry!: IEntityRegistry;

  setup(locator: IServiceLocator): void {
    this.gameSystem = locator.getSystem<IGameStateSystem>('GameStateSystem');
    this.registry = locator.getRegistry();
  }

  update(delta: number, time: number): void {}

  public resolveCollision(e1: Entity, e2: Entity) {
      const col1 = e1.getComponent<ColliderComponent>('Collider');
      const col2 = e2.getComponent<ColliderComponent>('Collider');
      if (!col1 || !col2) return;

      const handler = CollisionMatrix.getHandler(col1.layer, col2.layer);
      if (!handler) return;

      let a = e1, b = e2;
      if (col1.layer > col2.layer) {
          a = e2; b = e1;
      }

      const context: CombatContext = {
          damagePlayer: (amount) => {
              this.gameSystem.damagePlayer(amount);
              GameEventBus.emit(GameEvents.PLAYER_HIT, { damage: amount });
          },
          destroyEntity: (entity, fx) => this.destroyEntity(entity, fx),
          
          spawnFX: (type, x, y) => {
              const id = FX_IDS[type];
              if (id) FastEventBus.emit(FastEvents.SPAWN_FX, id, x, y);
          },
          
          playAudio: (key) => AudioSystem.playSound(key),
          
          // IMPL: Direct Trauma Injection
          addTrauma: (amount) => {
              GameEventBus.emit(GameEvents.TRAUMA_ADDED, { amount });
          }
      };

      handler(a, b, context);
  }

  private destroyEntity(entity: Entity, fx?: string) {
      const transform = entity.getComponent<TransformComponent>('Transform');
      const identity = entity.getComponent<IdentityComponent>('Identity');
      
      if (identity && transform) {
          const isEnemy = Object.values(EnemyTypes).includes(identity.variant as any);
          if (isEnemy && identity.variant !== EnemyTypes.DAEMON) {
              GameEventBus.emit(GameEvents.ENEMY_DESTROYED, { 
                  id: entity.id as number, 
                  type: identity.variant,
                  x: transform.x,
                  y: transform.y
              });
          }
      }

      this.registry.destroyEntity(entity.id);
      
      if (fx && transform) {
          let finalFX = fx;
          if (identity?.variant === EnemyTypes.HUNTER) finalFX = 'EXPLOSION_YELLOW';
          if (identity?.variant === EnemyTypes.KAMIKAZE) finalFX = 'EXPLOSION_RED';
          
          const id = FX_IDS[finalFX];
          if (id) FastEventBus.emit(FastEvents.SPAWN_FX, id, transform.x, transform.y);
      }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/game/systems/InputSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IInputService } from '../core/interfaces';
import { VirtualJoystickService } from '../inputs/VirtualJoystickService';

export class InputSystem implements IGameSystem, IInputService {
  private _cursor = { x: 0, y: 0 };
  
  // Bounds for clamping (updated by GameEngine/ViewportHelper)
  private _bounds = { width: 30, height: 20 }; 

  setup(locator: IServiceLocator): void {
    // Initial setup
  }

  update(delta: number, time: number): void {
    // Poll Providers
    if (VirtualJoystickService.isActive) {
        const joyVector = VirtualJoystickService.getVector();
        const speed = 30.0; // Virtual cursor speed
        
        this._cursor.x += joyVector.x * speed * delta;
        this._cursor.y += joyVector.y * speed * delta;

        // Clamp to logical world bounds
        const halfW = this._bounds.width / 2;
        const halfH = this._bounds.height / 2;
        
        this._cursor.x = Math.max(-halfW, Math.min(halfW, this._cursor.x));
        this._cursor.y = Math.max(-halfH, Math.min(halfH, this._cursor.y));
    }
  }

  teardown(): void {}

  // --- IInputService Implementation ---
  
  public updateCursor(x: number, y: number) {
    // Mouse movement takes precedence over joystick relative motion
    // if the user moves the mouse, we snap to it.
    // If joystick is active, it adds relative motion in the update() loop.
    
    // Simple conflict resolution: If joystick is NOT active, trust mouse.
    if (!VirtualJoystickService.isActive) {
        this._cursor.x = x;
        this._cursor.y = y;
    }
  }
  
  public updateBounds(width: number, height: number) {
      this._bounds.width = width;
      this._bounds.height = height;
  }

  public getCursor() {
    return this._cursor;
  }

  public isPressed(action: string): boolean {
    // Placeholder for button mapping
    return false;
  }
}


=====================================
FILE: ./src/game/systems/PanelRegistrySystem.ts
=====================================
import { IGameSystem, IServiceLocator, IPanelSystem } from '../core/interfaces';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { WorldRect } from '../utils/ViewportHelper';

// Services
import { DOMSpatialService } from '../services/DOMSpatialService';
import { StructureHealthService } from '../services/StructureHealthService';

class PanelRegistrySystemClass implements IPanelSystem {
  
  // Expose integrity via getter to match Interface
  public get systemIntegrity() {
      return StructureHealthService.systemIntegrity;
  }

  setup(locator: IServiceLocator): void {
    StructureHealthService.reset();
    DOMSpatialService.refreshAll();
    
    // Wire up Upgrade Event -> Service Logic
    GameEventBus.subscribe(GameEvents.UPGRADE_SELECTED, (p) => {
        if (p.option === 'RESTORE') {
            const restoredCount = StructureHealthService.restoreAll();
            
            if (restoredCount > 0) {
                GameEventBus.emit(GameEvents.TRAUMA_ADDED, { amount: 0.3 }); 
                AudioSystem.playSound('fx_reboot_success'); 
                
                // Spawn FX on newly restored panels
                // We iterate checking who was destroyed? No, simplest is just center screen FX or
                // we can iterate the rects.
                // For now, keep it simple.
            }
        }
    });
  }

  update(delta: number, time: number): void {
      // Logic moved to Services or specific systems (like InteractionSystem)
  }

  teardown(): void {}

  // --- IPanelSystem Implementation (Delegation) ---

  public register(id: string, element: HTMLElement) {
      DOMSpatialService.register(id, element);
      StructureHealthService.register(id);
  }

  public unregister(id: string) {
      DOMSpatialService.unregister(id);
      StructureHealthService.unregister(id);
  }

  public refreshSingle(id: string) {
      DOMSpatialService.refreshSingle(id);
  }

  public refreshAll() {
      DOMSpatialService.refreshAll();
  }

  public damagePanel(id: string, amount: number) {
      StructureHealthService.damage(id, amount);
  }

  public healPanel(id: string, amount: number) {
      StructureHealthService.heal(id, amount);
  }
  
  public decayPanel(id: string, amount: number) {
      StructureHealthService.decay(id, amount);
  }

  public destroyAll() {
      StructureHealthService.destroyAll();
  }

  public getPanelRect(id: string): WorldRect | undefined {
      return DOMSpatialService.getRect(id);
  }

  public getPanelState(id: string) {
      return StructureHealthService.getState(id);
  }
  
  // Composite Data Getter (Used by UI Sync)
  public getAllPanels() {
      const results = [];
      const rects = DOMSpatialService.getAllRects();
      const states = StructureHealthService.getAllStates();
      
      for(const [id, rect] of rects) {
          const state = states.get(id) || { health: 0, isDestroyed: true };
          results.push({ ...rect, ...state });
      }
      return results;
  }
}

export const PanelRegistry = new PanelRegistrySystemClass();


=====================================
FILE: ./src/game/systems/index.ts
=====================================
export * from './BehaviorSystem';
export * from './CameraSystem';
export * from './CollisionSystem';
export * from './FXManager';
export * from './GameStateSystem';
export * from './InputSystem';
export * from './InteractionSystem';
export * from './LifeCycleSystem';
export * from './PanelRegistrySystem';
export * from './PhysicsSystem';
export * from './PlayerSystem';
export * from './TimeSystem';
export * from './UISyncSystem';
export * from './WaveSystem';


=====================================
FILE: ./src/game/systems/GameStateSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IGameStateSystem } from '../core/interfaces';
import { PLAYER_CONFIG } from '../config/PlayerConfig';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { useStore } from '@/core/store/useStore'; 
import { AudioSystem } from '@/core/audio/AudioSystem';
import { PanelRegistry } from './PanelRegistrySystem';

export class GameStateSystem implements IGameStateSystem {
  public playerHealth: number = PLAYER_CONFIG.maxHealth;
  public maxPlayerHealth: number = PLAYER_CONFIG.maxHealth;
  public playerRebootProgress: number = 0;
  
  public score: number = 0;
  public xp: number = 0;
  public level: number = 1;
  public xpToNextLevel: number = PLAYER_CONFIG.baseXpRequirement;
  public upgradePoints: number = 0;

  public activeUpgrades: Record<string, number> = {
    'OVERCLOCK': 0, 'EXECUTE': 0, 'BANDWIDTH': 0, 'FORK': 0,
    'SNIFFER': 0, 'BACKDOOR': 0, 'REPAIR_NANITES': 0
  };

  public isGameOver: boolean = false;
  
  private heartbeatTimer: number = 0;

  setup(locator: IServiceLocator): void {
    this.reset();
    GameEventBus.subscribe(GameEvents.UPGRADE_SELECTED, (p) => {
        this.applyUpgrade(p.option);
    });
  }

  update(delta: number, time: number): void {
      if (this.isGameOver) return;

      if (PanelRegistry.systemIntegrity < 30 && PanelRegistry.systemIntegrity > 0) {
          this.heartbeatTimer -= delta;
          
          if (this.heartbeatTimer <= 0) {
              const urgency = 1.0 - (PanelRegistry.systemIntegrity / 30);
              AudioSystem.playSound('loop_warning');
              GameEventBus.emit(GameEvents.HEARTBEAT, { urgency });
              this.heartbeatTimer = 1.4 - (urgency * 1.05); 
          }
      } else {
          this.heartbeatTimer = 0;
      }
  }

  teardown(): void {}

  public reset() {
    this.playerHealth = this.maxPlayerHealth;
    this.playerRebootProgress = 0;
    this.score = 0;
    this.xp = 0;
    this.level = 1;
    this.xpToNextLevel = PLAYER_CONFIG.baseXpRequirement;
    this.upgradePoints = 0;
    this.isGameOver = false;
    this.activeUpgrades = { 
        'OVERCLOCK': 0, 'EXECUTE': 0, 'BANDWIDTH': 0, 'FORK': 0,
        'SNIFFER': 0, 'BACKDOOR': 0, 'REPAIR_NANITES': 0
    };
  }

  public applyUpgrade(option: string) {
      if (this.upgradePoints > 0) {
          this.upgradePoints--;
          if (option === 'PURGE' || option === 'RESTORE') return;
          if (option === 'DAEMON') {
              GameEventBus.emit(GameEvents.SPAWN_DAEMON, null);
              return; 
          }
          this.activeUpgrades[option] = (this.activeUpgrades[option] || 0) + 1;
          if (option === 'REPAIR_NANITES') this.healPlayer(this.maxPlayerHealth * 0.2);
      }
  }

  public damagePlayer(amount: number) {
    if (this.isGameOver) return;
    const { godMode } = useStore.getState().debugFlags;
    if (godMode) return;
    
    if (this.playerHealth > 0) {
        this.playerHealth = Math.max(0, this.playerHealth - amount);
        if (this.playerHealth <= 0) AudioSystem.playSound('fx_player_death');
    } else {
        this.playerRebootProgress = Math.max(0, this.playerRebootProgress - (amount * 2));
    }
  }

  public healPlayer(amount: number) {
    this.playerHealth = Math.min(this.maxPlayerHealth, this.playerHealth + amount);
  }

  public addScore(amount: number) {
    this.score += amount;
  }

  public addXp(amount: number) {
    this.xp += amount;
    while (this.xp >= this.xpToNextLevel) {
        this.xp -= this.xpToNextLevel;
        this.level++;
        this.upgradePoints++;
        this.xpToNextLevel = Math.floor(this.xpToNextLevel * PLAYER_CONFIG.xpScalingFactor);
        GameEventBus.emit(GameEvents.THREAT_LEVEL_UP, { level: this.level });
    }
  }

  public tickReboot(amount: number) {
    if (this.playerHealth > 0) return;
    this.playerRebootProgress = Math.max(0, Math.min(100, this.playerRebootProgress + amount));
    
    if (this.playerRebootProgress >= 100) {
        this.playerHealth = this.maxPlayerHealth; 
        this.playerRebootProgress = 0;
        AudioSystem.playSound('fx_reboot_success'); 
    }
  }

  public decayReboot(amount: number) {
      if (this.playerHealth > 0) return; 
      this.playerRebootProgress = Math.max(0, this.playerRebootProgress - amount);
  }
}


=====================================
FILE: ./src/game/systems/MobileWaveSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IEntitySpawner } from '../core/interfaces';
import { EnemyTypes } from '../config/Identifiers';
import { ViewportHelper } from '../utils/ViewportHelper';

export class MobileWaveSystem implements IGameSystem {
  private spawner!: IEntitySpawner;
  private time = 0;
  private nextSpawn = 0;
  
  // Difficulty Config
  private readonly START_INTERVAL = 1.2;
  private readonly MIN_INTERVAL = 0.4;
  private readonly RAMP_DURATION = 60.0;

  setup(locator: IServiceLocator): void {
    this.spawner = locator.getSpawner();
  }

  update(delta: number, time: number): void {
    this.time += delta;

    if (this.time >= this.nextSpawn) {
        this.spawnDriller();
        
        // Difficulty Ramp
        const progress = Math.min(1.0, this.time / this.RAMP_DURATION);
        const currentInterval = this.START_INTERVAL - (progress * (this.START_INTERVAL - this.MIN_INTERVAL));
        
        this.nextSpawn = this.time + currentInterval;
    }
  }

  private spawnDriller() {
      const { width, height } = ViewportHelper.viewport;
      const pad = 3.0; // Spawn further out
      
      // RESTRICT TO TOP AND BOTTOM ONLY
      // This gives the player more reaction time and prevents thumb occlusion
      const isTop = Math.random() > 0.5;
      
      let x = (Math.random() - 0.5) * (width * 0.6); // Keep them somewhat central horizontally
      let y = 0;

      if (isTop) { 
          y = (height / 2) + pad;
      } else { 
          y = -(height / 2) - pad;
      }

      this.spawner.spawnEnemy(EnemyTypes.DRILLER, x, y);
  }

  teardown(): void {}
}


=====================================
FILE: ./src/game/systems/TargetingSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { EntityRegistry } from '../core/ecs/EntityRegistry';
import { TransformComponent } from '../components/data/TransformComponent';
import { TargetComponent } from '../components/data/TargetComponent';
import { PanelRegistry } from './PanelRegistrySystem';
import { Tag } from '../core/ecs/types';

export class TargetingSystem implements IGameSystem {
  private registry!: EntityRegistry;
  private locator!: IServiceLocator;

  private playerCache: { x: number, y: number } | null = null;

  setup(locator: IServiceLocator): void {
    this.registry = locator.getRegistry() as EntityRegistry;
    this.locator = locator;
  }

  update(delta: number, time: number): void {
    this.updatePlayerCache();

    const entities = this.registry.getAll();
    
    for (const entity of entities) {
        if (!entity.active) continue;

        const target = entity.getComponent<TargetComponent>('Target');
        const transform = entity.getComponent<TransformComponent>('Transform');

        if (!target || !transform) continue;

        // Locked target validation
        if (target.locked && target.id) {
            if (target.type === 'PANEL') {
                const panel = PanelRegistry.getPanelState(target.id);
                if (!panel || panel.isDestroyed) {
                    target.locked = false;
                    target.id = null;
                } else {
                    const rect = PanelRegistry.getPanelRect(target.id);
                    if (rect) {
                        target.x = rect.x;
                        target.y = rect.y;
                    }
                }
            }
            // Validate Enemy Target (for Homing Bullets)
            else if (target.type === 'ENEMY') {
                // If target ID is generic 'PLAYER', skip check.
                // If it's a specific Entity ID (stringified), check if alive.
                // For now, we recalculate nearest enemy every frame for bullets 
                // because enemies die fast. Simple and robust.
                target.locked = false; 
            }
            else if (target.type === 'PLAYER' && this.playerCache) {
                target.x = this.playerCache.x;
                target.y = this.playerCache.y;
            }
            
            if (target.locked) continue; 
        }

        // --- FIND NEW TARGET ---

        if (target.type === 'PLAYER') {
            if (this.playerCache) {
                target.x = this.playerCache.x;
                target.y = this.playerCache.y;
                target.id = 'PLAYER';
            }
        }
        else if (target.type === 'PANEL') {
            const bestPanel = this.findNearestPanel(transform.x, transform.y);
            if (bestPanel) {
                target.id = bestPanel.id;
                target.x = bestPanel.x;
                target.y = bestPanel.y;
                target.locked = true; 
            } else {
                // Fallback to Player if no panels
                if (this.playerCache) {
                    target.x = this.playerCache.x;
                    target.y = this.playerCache.y;
                    target.id = 'PLAYER';
                }
            }
        }
        // NEW: Bullet Homing Logic
        else if (target.type === 'ENEMY') {
            const bestEnemy = this.findNearestEnemy(transform.x, transform.y);
            if (bestEnemy) {
                // We don't ID lock bullets, we just steer to coordinates
                target.x = bestEnemy.x;
                target.y = bestEnemy.y;
                target.id = 'ENEMY_LOCKED';
            } else {
                target.id = null; // No target found, fly straight
            }
        }
    }
  }

  private updatePlayerCache() {
      const players = this.registry.getByTag(Tag.PLAYER);
      if (players.length > 0) {
          const t = players[0].getComponent<TransformComponent>('Transform');
          if (t) {
              this.playerCache = { x: t.x, y: t.y };
              return;
          }
      }
      this.playerCache = null;
  }

  private findNearestPanel(x: number, y: number) {
      const panels = PanelRegistry.getAllPanels();
      let nearest: any = null;
      let minDist = Infinity;

      for (const p of panels) {
          if (p.isDestroyed) continue;
          const dx = p.x - x;
          const dy = p.y - y;
          const distSq = dx*dx + dy*dy;
          if (distSq < minDist) {
              minDist = distSq;
              nearest = p;
          }
      }
      return nearest;
  }

  private findNearestEnemy(x: number, y: number) {
      const enemies = this.registry.getByTag(Tag.ENEMY);
      let nearest: { x: number, y: number } | null = null;
      let minDist = Infinity;
      // Range limit for homing (don't target things across map)
      const MAX_RANGE_SQ = 15 * 15; 

      for (const e of enemies) {
          if (!e.active) continue;
          const t = e.getComponent<TransformComponent>('Transform');
          if (!t) continue;
          
          const dx = t.x - x;
          const dy = t.y - y;
          const distSq = dx*dx + dy*dy;
          
          if (distSq < minDist && distSq < MAX_RANGE_SQ) {
              minDist = distSq;
              nearest = { x: t.x, y: t.y };
          }
      }
      return nearest;
  }

  teardown(): void {}
}


=====================================
FILE: ./src/game/systems/BehaviorSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IEntitySpawner } from '../core/interfaces';
import { EntityRegistry } from '../core/ecs/EntityRegistry';
import { IdentityComponent } from '../components/data/IdentityComponent';
import { PanelRegistry } from './PanelRegistrySystem';
import { EnemyTypes } from '../config/Identifiers';
import { GameEventBus } from '../events/GameEventBus'; 
import { GameEvents, FXVariant } from '../events/GameEvents'; 
import { useGameStore } from '@/game/store/useGameStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { OrbitalComponent } from '../components/data/OrbitalComponent';
import { ConfigService } from '../services/ConfigService';
import { FastEventBus, FastEvents, FX_IDS } from '../core/FastEventBus';

import { AIRegistry } from '../logic/ai/AIRegistry';
import { AIContext } from '../logic/ai/types';

export class BehaviorSystem implements IGameSystem {
  private registry!: EntityRegistry;
  private spawner!: IEntitySpawner;
  private config!: typeof ConfigService;

  setup(locator: IServiceLocator): void {
    this.registry = locator.getRegistry() as EntityRegistry;
    this.spawner = locator.getSpawner();
    this.config = locator.getConfigService();
    
    GameEventBus.subscribe(GameEvents.SPAWN_DAEMON, () => {
        const e = this.spawner.spawnEnemy(EnemyTypes.DAEMON, 0, 0);
        const orbital = e.getComponent<OrbitalComponent>('Orbital');
        if (orbital) {
            orbital.radius = 4.0;
            orbital.speed = 1.5 + Math.random() * 1.0; 
            orbital.angle = Math.random() * Math.PI * 2;
        }
    });
  }

  update(delta: number, time: number): void {
    const upgrades = useGameStore.getState().activeUpgrades;

    const aiContext: AIContext = {
      delta,
      time,
      spawnProjectile: (x, y, vx, vy, damage) => {
          if (damage) {
              const bullet = this.spawner.spawnBullet(x, y, vx, vy, false, 2.0, damage, 4.0);
              bullet.addComponent(new IdentityComponent('DAEMON_SHOT'));
          } else {
              this.spawner.spawnBullet(x, y, vx, vy, true, 3.0);
          }
      },
      // PASS ANGLE AS ARG 4
      spawnDrillSparks: (x, y, angle) => FastEventBus.emit(FastEvents.SPAWN_FX, FX_IDS['DRILL_SPARKS'], x, y, angle),
      spawnLaunchSparks: (x, y, angle) => FastEventBus.emit(FastEvents.SPAWN_FX, FX_IDS['HUNTER_RECOIL'], x, y, angle),
      
      spawnFX: (type, x, y) => {
          const id = FX_IDS[type];
          if (id) FastEventBus.emit(FastEvents.SPAWN_FX, id, x, y, 0);
      },
      
      damagePanel: (id, amount) => PanelRegistry.damagePanel(id, amount),
      playSound: (key) => AudioSystem.playSound(key),
      getUpgradeLevel: (key) => upgrades[key] || 0,
      config: this.config
    };

    const entities = this.registry.getAll();
    for (const entity of entities) {
        if (!entity.active) continue;
        const identity = entity.getComponent<IdentityComponent>('Identity');
        if (!identity) continue;

        const behavior = AIRegistry.get(identity.variant);
        if (behavior) {
            behavior.update(entity, aiContext);
        }
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/game/systems/WaveSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IEntitySpawner } from '../core/interfaces';
import { useGameStore } from '../store/useGameStore';
import { useStore } from '@/core/store/useStore';
import { PanelRegistry } from './PanelRegistrySystem'; 
import { EnemyTypes } from '../config/Identifiers';

// UPDATED TIMELINE: Early Hunters
const WAVE_TIMELINE = [
  { at: 0,     type: 'driller', count: 3, interval: 0.1 }, 
  { at: 2,     type: 'hunter',  count: 1, interval: 0 },   // <--- Early Hunter
  { at: 5,     type: 'driller', count: 5, interval: 0.5 }, 
  { at: 8,     type: 'kamikaze', count: 2, interval: 1.0 },
  { at: 12,    type: 'driller', count: 8, interval: 0.2 }, 
  { at: 15,    type: 'hunter',  count: 2, interval: 2.0 }, // <--- More Hunters
  { at: 20,    type: 'kamikaze', count: 5, interval: 0.5 },
  { at: 25,    type: 'hunter',  count: 3, interval: 1.0 }, 
];

export class WaveSystem implements IGameSystem {
  private spawner!: IEntitySpawner;
  private waveTime = 0;
  private currentWaveIndex = 0;
  private spawnQueue: { type: string, time: number }[] = [];
  private loopCount = 0;

  setup(locator: IServiceLocator): void {
    this.spawner = locator.getSpawner();
    this.reset();
  }

  private reset() {
    this.waveTime = 0;
    this.currentWaveIndex = 0;
    this.spawnQueue = [];
    this.loopCount = 0;
  }

  update(delta: number, time: number): void {
    if (useGameStore.getState().isZenMode) return;
    if (useStore.getState().bootState === 'sandbox') return;

    this.waveTime += delta;
    
    if (!useStore.getState().debugFlags.peaceMode) {
        this.checkTimeline();
        this.processQueue(time);
    }

    this.handleBreaches(delta);
  }

  private handleBreaches(delta: number) {
      const flags = useStore.getState().debugFlags;
      if (flags.panelGodMode || flags.peaceMode) return;

      const allPanels = PanelRegistry.getAllPanels();
      const deadPanels = allPanels.filter(p => p.isDestroyed && p.width > 0);
      
      if (deadPanels.length === 0) return;

      const enemiesPerSecondPerPanel = 0.2 + (this.waveTime * 0.005);
      const spawnChance = enemiesPerSecondPerPanel * delta;

      for (const p of deadPanels) {
          if (Math.random() < spawnChance) {
              this.spawnBreachEnemy(p);
          }
      }
  }

  private spawnBreachEnemy(p: any) {
      const rand = Math.random();
      let type = EnemyTypes.DRILLER;
      if (rand > 0.85) type = EnemyTypes.HUNTER;
      else if (rand > 0.60) type = EnemyTypes.KAMIKAZE;

      const safeW = p.width * 0.7; 
      const safeH = p.height * 0.7;
      
      const offsetX = (Math.random() - 0.5) * safeW;
      const offsetY = (Math.random() - 0.5) * safeH;
      
      this.spawner.spawnEnemy(type, p.x + offsetX, p.y + offsetY);
  }

  private checkTimeline() {
    if (this.currentWaveIndex >= WAVE_TIMELINE.length) {
        this.waveTime = 0;
        this.currentWaveIndex = 0;
        this.loopCount++;
    }

    const nextWave = WAVE_TIMELINE[this.currentWaveIndex];
    if (nextWave && this.waveTime >= nextWave.at) {
        this.queueSpawns(nextWave);
        this.currentWaveIndex++;
    }
  }

  private queueSpawns(wave: any) {
    const count = wave.count + (this.loopCount * 2);
    for (let i = 0; i < count; i++) {
        this.spawnQueue.push({
            type: wave.type,
            time: this.waveTime + (i * wave.interval)
        });
    }
  }

  private processQueue(currentTime: number) {
    for (let i = this.spawnQueue.length - 1; i >= 0; i--) {
        const spawn = this.spawnQueue[i];
        if (this.waveTime >= spawn.time) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 25; 
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            this.spawner.spawnEnemy(spawn.type, x, y);
            this.spawnQueue.splice(i, 1);
        }
    }
  }

  teardown(): void {
    this.reset();
  }
}


=====================================
FILE: ./src/game/systems/LifeCycleSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { LifetimeComponent } from '../components/data/LifetimeComponent';
import { HealthComponent } from '../components/data/HealthComponent';
import { IdentityComponent } from '../components/data/IdentityComponent';
import { TransformComponent } from '../components/data/TransformComponent';
import { EntityRegistry } from '../core/ecs/EntityRegistry';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents, FXVariant } from '../events/GameEvents';
import { EnemyTypes } from '../config/Identifiers';

export class LifeCycleSystem implements IGameSystem {
  private registry!: EntityRegistry;

  setup(locator: IServiceLocator): void {
    this.registry = locator.getRegistry() as EntityRegistry;
    
    GameEventBus.subscribe(GameEvents.ZEN_MODE_ENABLED, () => {
        this.registry.clear();
    });
  }

  update(delta: number, time: number): void {
    // NEW: Query any entity that CAN die (has Lifetime OR Health)
    const mortals = this.registry.query({ any: ['Lifetime', 'Health'] });

    for (const entity of mortals) {
      if (!entity.active) continue;

      // 1. Time-based Death
      const lifetime = entity.getComponent<LifetimeComponent>('Lifetime');
      if (lifetime) {
        lifetime.remaining -= delta;
        if (lifetime.remaining <= 0) {
          this.registry.destroyEntity(entity.id);
          continue;
        }
      }

      // 2. Health-based Death
      const health = entity.getComponent<HealthComponent>('Health');
      if (health && health.current <= 0) {
          const identity = entity.getComponent<IdentityComponent>('Identity');
          const transform = entity.getComponent<TransformComponent>('Transform');
          
          if (identity && transform) {
             GameEventBus.emit(GameEvents.ENEMY_DESTROYED, { 
                id: entity.id as number, 
                type: identity.variant, 
                x: transform.x, 
                y: transform.y 
             });
             
             let fx: FXVariant = 'EXPLOSION_PURPLE';
             if (identity.variant === EnemyTypes.HUNTER) fx = 'EXPLOSION_YELLOW';
             else if (identity.variant === EnemyTypes.KAMIKAZE) fx = 'EXPLOSION_RED';
             
             GameEventBus.emit(GameEvents.SPAWN_FX, { type: fx, x: transform.x, y: transform.y });
          }
          
          this.registry.destroyEntity(entity.id);
      }
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/game/systems/PhysicsSystem.ts
=====================================
import { IPhysicsSystem, IServiceLocator } from '../core/interfaces';
import { SpatialGrid } from '../core/SpatialGrid';
import { TransformComponent } from '../components/data/TransformComponent';
import { MotionComponent } from '../components/data/MotionComponent';
import { EntityRegistry } from '../core/ecs/EntityRegistry';

export class PhysicsSystem implements IPhysicsSystem {
  public spatialGrid: SpatialGrid;
  private registry!: EntityRegistry;

  constructor() {
    this.spatialGrid = new SpatialGrid();
  }

  setup(locator: IServiceLocator): void {
    this.registry = locator.getRegistry() as EntityRegistry;
    this.spatialGrid.clear();
  }

  update(delta: number, time: number): void {
    // 1. Clear the reusable grid buckets
    this.spatialGrid.clear();
    
    // 2. Iterate only movables via Cache
    const movables = this.registry.query({ all: ['Transform', 'Motion'] });
    
    for (const entity of movables) {
      if (!entity.active) continue;

      const transform = entity.getComponent<TransformComponent>('Transform');
      const motion = entity.getComponent<MotionComponent>('Motion');
      
      if (transform && motion) {
        transform.x += motion.vx * delta;
        transform.y += motion.vy * delta;
        
        if (motion.friction > 0) {
            motion.vx *= (1 - motion.friction);
            motion.vy *= (1 - motion.friction);
        }

        // 3. Populate Grid for CollisionSystem to read later
        this.spatialGrid.insert(entity.id, transform.x, transform.y);
      }
    }
  }

  teardown(): void {
    this.spatialGrid.clear();
  }
}


=====================================
FILE: ./src/game/data/Archetypes.ts
=====================================
import { ENEMY_CONFIG } from '../config/EnemyConfig';
import { PLAYER_CONFIG } from '../config/PlayerConfig';
import { PhysicsConfig, CollisionLayers } from '../config/PhysicsConfig';
import { ArchetypeIDs } from '../config/Identifiers';
import { Tag } from '../core/ecs/types';

export interface EntityBlueprint {
  tags: Tag[];
  components: { type: string; data?: any }[];
}

export const ARCHETYPES: Record<string, EntityBlueprint> = {
  // --- PLAYER ---
  [ArchetypeIDs.PLAYER]: {
    tags: [Tag.PLAYER],
    components: [
      { type: 'Transform', data: { x: 0, y: 0, rotation: 0, scale: 1 } },
      { type: 'Motion', data: { friction: 0.9 } },
      { type: 'Health', data: { max: PLAYER_CONFIG.maxHealth } },
      { type: 'State', data: { current: 'IDLE' } },
      { type: 'Collider', data: { 
          radius: PhysicsConfig.HITBOX.PLAYER, 
          layer: CollisionLayers.PLAYER, 
          mask: PhysicsConfig.MASKS.PLAYER 
      }}
    ]
  },

  // --- PROJECTILES ---
  [ArchetypeIDs.BULLET_PLAYER]: {
    tags: [Tag.BULLET, Tag.PLAYER],
    components: [
      { type: 'Transform', data: { scale: 1.0 } },
      { type: 'Motion', data: { friction: 0 } },
      { type: 'Lifetime', data: { remaining: 1.5, total: 1.5 } },
      { type: 'Combat', data: { damage: 1 } },
      { type: 'Health', data: { max: 1 } },
      { type: 'Collider', data: { 
          radius: PhysicsConfig.HITBOX.BULLET, 
          layer: CollisionLayers.PLAYER_PROJECTILE, 
          mask: PhysicsConfig.MASKS.PLAYER_PROJECTILE 
      }}
    ]
  },
  [ArchetypeIDs.BULLET_ENEMY]: {
    tags: [Tag.BULLET, Tag.ENEMY],
    components: [
      { type: 'Transform', data: { scale: 1.0 } },
      { type: 'Motion', data: { friction: 0 } },
      { type: 'Lifetime', data: { remaining: 3.0, total: 3.0 } },
      { type: 'Combat', data: { damage: 10 } },
      { type: 'Health', data: { max: 1 } },
      { type: 'Collider', data: { 
          radius: PhysicsConfig.HITBOX.HUNTER_BULLET, 
          layer: CollisionLayers.ENEMY_PROJECTILE, 
          mask: PhysicsConfig.MASKS.ENEMY_PROJECTILE 
      }}
    ]
  },

  // --- ENEMIES ---
  [ArchetypeIDs.DRILLER]: {
    tags: [Tag.ENEMY, Tag.OBSTACLE],
    components: [
      { type: 'Identity', data: { variant: ArchetypeIDs.DRILLER } },
      { type: 'Transform', data: { scale: 1.0 } }, // FIX: Added Transform
      { type: 'Health', data: { max: ENEMY_CONFIG.driller.hp } },
      { type: 'Motion', data: { friction: 0 } },
      { type: 'Combat', data: { damage: ENEMY_CONFIG.driller.damage } },
      { type: 'Collider', data: { radius: PhysicsConfig.HITBOX.DRILLER, layer: CollisionLayers.ENEMY, mask: PhysicsConfig.MASKS.ENEMY } },
      { type: 'State', data: { current: 'SPAWN', timers: { spawn: 1.5 } } },
      { type: 'Target', data: { type: 'PANEL' } }
    ]
  },
  [ArchetypeIDs.KAMIKAZE]: {
    tags: [Tag.ENEMY, Tag.OBSTACLE],
    components: [
      { type: 'Identity', data: { variant: ArchetypeIDs.KAMIKAZE } },
      { type: 'Transform', data: { scale: 1.0 } }, // FIX: Added Transform
      { type: 'Health', data: { max: ENEMY_CONFIG.kamikaze.hp } },
      { type: 'Motion', data: { friction: 0 } },
      { type: 'Combat', data: { damage: ENEMY_CONFIG.kamikaze.damage } },
      { type: 'Collider', data: { radius: PhysicsConfig.HITBOX.KAMIKAZE, layer: CollisionLayers.ENEMY, mask: PhysicsConfig.MASKS.ENEMY } },
      { type: 'State', data: { current: 'SPAWN', timers: { spawn: 1.5 } } },
      { type: 'Target', data: { type: 'PLAYER' } }
    ]
  },
  [ArchetypeIDs.HUNTER]: {
    tags: [Tag.ENEMY, Tag.OBSTACLE],
    components: [
      { type: 'Identity', data: { variant: ArchetypeIDs.HUNTER } },
      { type: 'Transform', data: { scale: 1.0 } }, // FIX: Added Transform
      { type: 'Health', data: { max: ENEMY_CONFIG.hunter.hp } },
      { type: 'Motion', data: { friction: 0 } },
      { type: 'Combat', data: { damage: 10 } }, 
      { type: 'Collider', data: { radius: PhysicsConfig.HITBOX.HUNTER, layer: CollisionLayers.ENEMY, mask: PhysicsConfig.MASKS.ENEMY } },
      { type: 'State', data: { current: 'SPAWN', timers: { spawn: 1.5 } } },
      { type: 'Target', data: { type: 'PLAYER' } }
    ]
  },
  [ArchetypeIDs.DAEMON]: {
    tags: [Tag.PLAYER],
    components: [
      { type: 'Identity', data: { variant: ArchetypeIDs.DAEMON } },
      { type: 'Transform', data: { scale: 1.0 } },
      { type: 'Health', data: { max: 100 } }, 
      { type: 'Orbital', data: { radius: 4.0, speed: 1.5, angle: 0 } },
      { type: 'Target', data: { type: 'ENEMY' } }, 
      { type: 'Collider', data: { radius: 0.6, layer: CollisionLayers.PLAYER, mask: PhysicsConfig.MASKS.PLAYER } },
      { type: 'State', data: { current: 'ORBIT' } }
    ]
  }
};


=====================================
FILE: ./src/game/assets/AssetService.ts
=====================================
import * as THREE from 'three';

class AssetServiceController {
  private cache = new Map<string, any>();
  private generators = new Map<string, () => any>();
  
  // Worker State
  private worker: Worker | null = null;
  private pendingRequests = new Map<string, (data: any) => void>();

  public init() {
    if (typeof window !== 'undefined' && !this.worker) {
        this.worker = new Worker(new URL('../workers/GeometryWorker.ts', import.meta.url));
        this.worker.onmessage = (e) => {
            const { id, success, positions, barycentric } = e.data;
            if (this.pendingRequests.has(id)) {
                this.pendingRequests.get(id)!({ success, positions, barycentric });
                this.pendingRequests.delete(id);
            }
        };
    }
  }

  public registerGenerator(key: string, generator: () => any) {
    this.generators.set(key, generator);
  }

  public get<T>(key: string): T {
    if (this.cache.has(key)) {
      return this.cache.get(key) as T;
    }

    const generator = this.generators.get(key);
    if (!generator) {
      throw new Error(`[AssetService] No generator registered for asset: ${key}`);
    }

    const asset = generator();
    this.cache.set(key, asset);
    return asset as T;
  }

  /**
   * Async Asset Generation.
   * Returns a Placeholder immediately, then updates it when the Worker finishes.
   */
  public generateAsyncGeometry(key: string, taskName: string, placeholderGeo: THREE.BufferGeometry) {
    if (this.cache.has(key)) return; // Already exists

    // 1. Store Placeholder immediately so Renderers have something to show
    this.cache.set(key, placeholderGeo);

    if (!this.worker) this.init();

    // 2. Request from Worker
    if (this.worker) {
        this.worker.postMessage({ id: key, task: taskName });
        
        // 3. Handle Completion
        this.pendingRequests.set(key, (data) => {
            if (data.success) {
                console.log(`[AssetService] Worker finished: ${key}`);
                
                // Update the existing geometry object in place (Reference preservation)
                placeholderGeo.setAttribute('position', new THREE.BufferAttribute(data.positions, 3));
                placeholderGeo.setAttribute('barycentric', new THREE.BufferAttribute(data.barycentric, 3));
                
                // Recalculate bounds/normals for lighting/culling
                placeholderGeo.computeVertexNormals();
                placeholderGeo.computeBoundingSphere();
                
                // Force Three.js update
                placeholderGeo.attributes.position.needsUpdate = true;
            }
        });
    }
  }
}

export const AssetService = new AssetServiceController();


=====================================
FILE: ./src/game/assets/AssetCatalog.ts
=====================================
import * as THREE from 'three';
import { AssetService } from './AssetService';
import { addBarycentricCoordinates } from '../utils/GeometryUtils';
import { MODEL_CONFIG } from '../config/ModelConfig';
import { GAME_THEME } from '../theme';

// Shaders
const SHADER_LIB = {
  ENEMY_BODY: {
    vertex: `
      #ifndef USE_INSTANCING_COLOR
      attribute vec3 instanceColor;
      #endif
      attribute vec3 barycentric;
      varying vec3 vColor;
      varying vec3 vBarycentric;
      void main() {
        vColor = instanceColor;
        vBarycentric = barycentric;
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
      }
    `,
    fragment: `
      varying vec3 vColor;
      varying vec3 vBarycentric;
      float edgeFactor(vec3 bary, float width) {
        vec3 d = fwidth(bary);
        vec3 a3 = smoothstep(vec3(0.0), d * width, bary);
        return min(min(a3.x, a3.y), a3.z);
      }
      void main() {
        float width = 1.5; 
        float edge = edgeFactor(vBarycentric, width);
        float glow = pow(1.0 - edge, 0.4); 
        vec3 coreColor = vColor;
        vec3 edgeColor = mix(vColor, vec3(1.0), 0.8);
        gl_FragColor = vec4(mix(coreColor, edgeColor, glow), 1.0);
      }
    `
  },
  GLOW_BILLBOARD: {
    vertex: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0); }`,
    fragment: `
      varying vec2 vUv; uniform vec3 uColor;
      void main() {
        float dist = distance(vUv, vec2(0.5));
        float core = 1.0 - smoothstep(0.2, 0.25, dist);
        float glow = pow(1.0 - smoothstep(0.25, 0.5, dist), 3.0);
        gl_FragColor = vec4(mix(uColor, vec3(1.0), core), max(core, glow));
      }
    `
  },
  BEAM_BILLBOARD: {
    vertex: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0); }`,
    fragment: `
      varying vec2 vUv; uniform vec3 uColor;
      float sdBox(vec2 p, vec2 b) { vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }
      void main() {
        vec2 p = vUv - 0.5;
        float d = sdBox(p, vec2(0.2, 0.4)); 
        float core = 1.0 - smoothstep(0.0, 0.02, d);
        float glow = exp(-20.0 * max(0.0, d));
        vec3 color = mix(uColor, vec3(1.0), core);
        gl_FragColor = vec4(color, max(core, glow));
      }
    `
  }
};

export const registerAllAssets = () => {
  // --- ASYNC ASSETS ---
  const hunterPlaceholder = addBarycentricCoordinates(new THREE.ConeGeometry(0.5, 2, 4));
  AssetService.generateAsyncGeometry('GEO_HUNTER', 'GEO_HUNTER', hunterPlaceholder);

  // --- SYNC GENERATORS ---
  
  AssetService.registerGenerator('GEO_DRILLER', () => {
      // UPDATED: Increased radius 0.3 -> 0.5 for better touch target
      const { height, segments } = MODEL_CONFIG.DRILLER;
      const radius = 0.5; 
      return addBarycentricCoordinates(new THREE.ConeGeometry(radius, height, segments));
  });

  AssetService.registerGenerator('GEO_KAMIKAZE', () => {
      return addBarycentricCoordinates(new THREE.IcosahedronGeometry(0.6, 0));
  });

  AssetService.registerGenerator('GEO_DAEMON', () => {
      return new THREE.OctahedronGeometry(0.6, 0);
  });

  AssetService.registerGenerator('GEO_BULLET_PLAYER', () => {
      return new THREE.PlaneGeometry(1.0, 1.0);
  });

  AssetService.registerGenerator('GEO_BULLET_ENEMY', () => {
      return new THREE.PlaneGeometry(2.0, 2.0);
  });
  
  AssetService.registerGenerator('GEO_PARTICLE', () => {
      return new THREE.PlaneGeometry(0.3, 0.3);
  });

  // --- MATERIALS ---

  AssetService.registerGenerator('MAT_ENEMY_BASE', () => {
      return new THREE.ShaderMaterial({
        vertexShader: SHADER_LIB.ENEMY_BODY.vertex,
        fragmentShader: SHADER_LIB.ENEMY_BODY.fragment,
        uniforms: {},
        vertexColors: true,
        extensions: { derivatives: true },
        side: THREE.DoubleSide,
      });
  });

  AssetService.registerGenerator('MAT_BULLET_PLAYER', () => {
      return new THREE.ShaderMaterial({
        vertexShader: SHADER_LIB.BEAM_BILLBOARD.vertex,
        fragmentShader: SHADER_LIB.BEAM_BILLBOARD.fragment,
        uniforms: { uColor: { value: new THREE.Color(GAME_THEME.bullet.plasma) } },
        transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
      });
  });

  AssetService.registerGenerator('MAT_BULLET_ENEMY', () => {
      return new THREE.ShaderMaterial({
        vertexShader: SHADER_LIB.GLOW_BILLBOARD.vertex,
        fragmentShader: SHADER_LIB.GLOW_BILLBOARD.fragment,
        uniforms: { uColor: { value: new THREE.Color(GAME_THEME.bullet.hunter) } },
        transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
      });
  });
  
  AssetService.registerGenerator('MAT_PARTICLE', () => {
      return new THREE.ShaderMaterial({
        vertexShader: `
          #ifndef USE_INSTANCING_COLOR
          attribute vec3 instanceColor;
          #endif
          varying vec2 vUv;
          varying vec3 vColor;
          void main() { vUv = uv; vColor = instanceColor; gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0); }
        `,
        fragmentShader: `
          varying vec2 vUv;
          varying vec3 vColor;
          void main() {
            float dist = distance(vUv, vec2(0.5));
            float alpha = pow(1.0 - smoothstep(0.0, 0.5, dist), 3.0);
            if (alpha < 0.01) discard;
            gl_FragColor = vec4(vColor, alpha);
          }
        `,
        vertexColors: true, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
      });
  });

  console.log('[AssetCatalog] Generators Registered.');
};


=====================================
FILE: ./src/game/services/StructureHealthService.ts
=====================================
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { useStore } from '@/core/store/useStore';

const MAX_PANEL_HEALTH = 1000;

export interface StructureState {
  health: number;
  isDestroyed: boolean;
}

class StructureHealthServiceController {
  private states = new Map<string, StructureState>();
  public systemIntegrity: number = 100;

  public register(id: string) {
    if (!this.states.has(id)) {
        this.states.set(id, { health: MAX_PANEL_HEALTH, isDestroyed: false });
    }
    this.calculateIntegrity();
  }

  public unregister(id: string) {
    this.states.delete(id);
    this.calculateIntegrity();
  }

  public reset() {
    for (const state of this.states.values()) {
        state.health = MAX_PANEL_HEALTH;
        state.isDestroyed = false;
    }
    this.calculateIntegrity();
  }

  public damage(id: string, amount: number) {
    if (useStore.getState().debugFlags.panelGodMode) return;

    const state = this.states.get(id);
    if (!state || state.isDestroyed) return;

    state.health = Math.max(0, state.health - amount);

    if (state.health <= 0) {
        state.isDestroyed = true;
        state.health = 0;
        GameEventBus.emit(GameEvents.PANEL_DESTROYED, { id });
        GameEventBus.emit(GameEvents.LOG_DEBUG, { msg: `SECTOR LOST: ${id}`, source: 'StructureService' });
    } else {
        GameEventBus.emit(GameEvents.PANEL_DAMAGED, { id, amount, currentHealth: state.health });
    }
    this.calculateIntegrity();
  }

  public heal(id: string, amount: number) {
    const state = this.states.get(id);
    if (!state) return;

    const wasDestroyed = state.isDestroyed;
    state.health = Math.min(MAX_PANEL_HEALTH, state.health + amount);

    if (wasDestroyed && state.health >= MAX_PANEL_HEALTH) {
        state.isDestroyed = false;
        state.health = 500; // Reboot penalty logic
        AudioSystem.playSound('fx_reboot_success');
        GameEventBus.emit(GameEvents.LOG_DEBUG, { msg: `SECTOR RESTORED: ${id}`, source: 'StructureService' });
    }
    this.calculateIntegrity();
  }

  public decay(id: string, amount: number) {
      const state = this.states.get(id);
      if (!state || !state.isDestroyed) return;
      state.health = Math.max(0, state.health - amount);
  }

  public restoreAll() {
      let restored = 0;
      for (const state of this.states.values()) {
          if (state.isDestroyed) {
              state.isDestroyed = false;
              state.health = 500;
              restored++;
          } else if (state.health < MAX_PANEL_HEALTH) {
              state.health = MAX_PANEL_HEALTH;
          }
      }
      this.calculateIntegrity();
      return restored;
  }

  public destroyAll() {
      for (const [id, state] of this.states) {
          state.health = 0;
          state.isDestroyed = true;
          GameEventBus.emit(GameEvents.PANEL_DESTROYED, { id });
      }
      this.calculateIntegrity();
  }

  private calculateIntegrity() {
    let current = 0;
    let max = 0;
    for (const state of this.states.values()) {
        max += MAX_PANEL_HEALTH;
        if (!state.isDestroyed) current += state.health;
    }
    this.systemIntegrity = max > 0 ? (current / max) * 100 : 100;
  }

  public getState(id: string) {
      return this.states.get(id);
  }

  public getAllStates() {
      return this.states;
  }
}

export const StructureHealthService = new StructureHealthServiceController();


=====================================
FILE: ./src/game/services/TransientDOMService.ts
=====================================
type UpdateType = 'text' | 'width' | 'css-var';

interface TransientElement {
  el: HTMLElement;
  type: UpdateType;
}

class TransientDOMServiceController {
  private elements = new Map<string, TransientElement>();

  public register(id: string, el: HTMLElement, type: UpdateType) {
    this.elements.set(id, { el, type });
  }

  public unregister(id: string) {
    this.elements.delete(id);
  }

  public update(id: string, value: string | number) {
    const item = this.elements.get(id);
    if (!item) return;

    // Direct DOM manipulation for zero-overhead updates
    if (item.type === 'text') {
        item.el.innerText = String(value);
    } else if (item.type === 'width') {
        item.el.style.width = `${value}%`;
    } else if (item.type === 'css-var') {
        item.el.style.setProperty(`--${id}`, String(value));
    }
  }
}

export const TransientDOMService = new TransientDOMServiceController();


=====================================
FILE: ./src/game/services/DOMSpatialService.ts
=====================================
import { ViewportHelper, WorldRect } from '../utils/ViewportHelper';

class DOMSpatialServiceController {
  private observedElements = new Map<string, HTMLElement>();
  private panelRects = new Map<string, WorldRect>();
  private observer: ResizeObserver | null = null;

  private initObserver() {
    if (this.observer) return;
    if (typeof window === 'undefined') return;

    this.observer = new ResizeObserver((entries) => {
        for (const entry of entries) {
            // Find ID by element (inefficient lookup, but rare event)
            for (const [id, el] of this.observedElements) {
                if (el === entry.target) {
                    this.refreshSingle(id);
                    break;
                }
            }
        }
    });
  }

  public register(id: string, element: HTMLElement) {
    this.initObserver();
    this.observedElements.set(id, element);
    if (this.observer) {
        this.observer.observe(element);
    }
    this.refreshSingle(id);
  }

  public unregister(id: string) {
    const el = this.observedElements.get(id);
    if (el && this.observer) {
        this.observer.unobserve(el);
    }
    this.observedElements.delete(id);
    this.panelRects.delete(id);
  }

  public refreshSingle(id: string) {
    const el = this.observedElements.get(id);
    if (!el || !el.isConnected) return;
    const rect = el.getBoundingClientRect();
    if (rect.width === 0 && rect.height === 0) return;
    this.panelRects.set(id, ViewportHelper.domToWorld(id, rect));
  }

  public refreshAll() {
    for (const id of this.observedElements.keys()) {
        this.refreshSingle(id);
    }
  }

  public getRect(id: string): WorldRect | undefined {
    return this.panelRects.get(id);
  }

  public getAllRects(): Map<string, WorldRect> {
    return this.panelRects;
  }
}

export const DOMSpatialService = new DOMSpatialServiceController();


=====================================
FILE: ./src/game/services/ConfigService.ts
=====================================
// Default Static Configs
import { PLAYER_CONFIG } from '../config/PlayerConfig';
import { ENEMY_CONFIG, WAVE_CONFIG } from '../config/EnemyConfig';
import { WorldConfig } from '../config/WorldConfig';
import { AI_CONFIG } from '../config/AIConfig';
import { PhysicsConfig } from '../config/PhysicsConfig';

// Types (Inferred)
type PlayerConfigType = typeof PLAYER_CONFIG;
type EnemyConfigType = typeof ENEMY_CONFIG;
type WorldConfigType = typeof WorldConfig;
type AIConfigType = typeof AI_CONFIG;
type PhysicsConfigType = typeof PhysicsConfig;
type WaveConfigType = typeof WAVE_CONFIG;

class ConfigServiceController {
  // Mutable State
  public player: PlayerConfigType = { ...PLAYER_CONFIG };
  public enemies: EnemyConfigType = JSON.parse(JSON.stringify(ENEMY_CONFIG));
  public world: WorldConfigType = { ...WorldConfig };
  public ai: AIConfigType = JSON.parse(JSON.stringify(AI_CONFIG));
  public physics: PhysicsConfigType = { ...PhysicsConfig };
  public waves: WaveConfigType = { ...WAVE_CONFIG };

  public reset() {
    this.player = { ...PLAYER_CONFIG };
    this.enemies = JSON.parse(JSON.stringify(ENEMY_CONFIG));
    this.world = { ...WorldConfig };
    this.ai = JSON.parse(JSON.stringify(AI_CONFIG));
    this.physics = { ...PhysicsConfig };
    this.waves = { ...WAVE_CONFIG };
  }

  // Example: Runtime difficulty tweak
  public setGlobalDifficulty(multiplier: number) {
    for (const key in this.enemies) {
        const enemy = this.enemies[key as keyof EnemyConfigType];
        enemy.hp = Math.ceil(ENEMY_CONFIG[key as keyof EnemyConfigType].hp * multiplier);
        enemy.damage = Math.ceil(ENEMY_CONFIG[key as keyof EnemyConfigType].damage * multiplier);
    }
  }
}

export const ConfigService = new ConfigServiceController();


=====================================
FILE: ./src/game/inputs/VirtualJoystickService.ts
=====================================
export class VirtualJoystickServiceController {
  private _vector = { x: 0, y: 0 };
  private _isActive = false;

  public setVector(x: number, y: number) {
    this._vector.x = x;
    this._vector.y = y;
    this._isActive = (x !== 0 || y !== 0);
  }

  public getVector() {
    return this._vector;
  }

  public get isActive() {
    return this._isActive;
  }
}

export const VirtualJoystickService = new VirtualJoystickServiceController();


=====================================
FILE: ./src/game/store/slices/createProgressionSlice.ts
=====================================
import { StateCreator } from 'zustand';
import { GameState } from '../useGameStore';
import { PLAYER_CONFIG } from '../../config/PlayerConfig';
import { UpgradeOption } from '../../types/game.types';
import { GameEventBus } from '../../events/GameEventBus';
import { GameEvents } from '../../events/GameEvents';

export interface ProgressionSlice {
  score: number;
  highScore: number;
  xp: number;
  level: number;
  xpToNextLevel: number;
  upgradePoints: number;
  activeUpgrades: Record<string, number>;

  addScore: (amount: number) => void;
  addXp: (amount: number) => void;
  selectUpgrade: (option: UpgradeOption) => void;
  
  resetProgressionState: () => void;
}

export const createProgressionSlice: StateCreator<GameState, [], [], ProgressionSlice> = (set) => ({
  score: 0,
  highScore: 0,
  xp: 0,
  level: 1,
  xpToNextLevel: PLAYER_CONFIG.baseXpRequirement,
  upgradePoints: 0,
  activeUpgrades: { 'RAPID_FIRE': 0, 'MULTI_SHOT': 0, 'SPEED_UP': 0, 'REPAIR_NANITES': 0 },

  addScore: (amount) => set((state) => ({ score: state.score + amount })),
  
  addXp: (amount) => set((state) => ({ xp: state.xp + amount })),

  selectUpgrade: (option) => {
    GameEventBus.emit(GameEvents.UPGRADE_SELECTED, { option });
    // Logic for applying the upgrade to state happens via sync from ECS or direct here?
    // In current arch, ECS handles logic, but UI needs to know points spent.
    // The GameStateSystem in ECS actually manages the 'truth', so we emit the event 
    // and rely on UISyncSystem to update us back.
  },

  resetProgressionState: () => set({
      score: 0,
      xp: 0,
      level: 1,
      xpToNextLevel: PLAYER_CONFIG.baseXpRequirement,
      upgradePoints: 0,
      activeUpgrades: { 'RAPID_FIRE': 0, 'MULTI_SHOT': 0, 'SPEED_UP': 0, 'REPAIR_NANITES': 0 }
  })
});


=====================================
FILE: ./src/game/store/slices/createCombatSlice.ts
=====================================
import { StateCreator } from 'zustand';
import { GameState } from '../useGameStore';
import { PLAYER_CONFIG } from '../../config/PlayerConfig';
import { GameEventBus } from '../../events/GameEventBus';
import { GameEvents } from '../../events/GameEvents';

export interface CombatSlice {
  isPlaying: boolean;
  isZenMode: boolean;
  playerHealth: number;
  maxPlayerHealth: number;
  playerRebootProgress: number;
  systemIntegrity: number;

  startGame: () => void;
  stopGame: () => void;
  activateZenMode: () => void;
  
  damagePlayer: (amount: number) => void;
  healPlayer: (amount: number) => void;
  tickPlayerReboot: (amount: number) => void;
  decayReboot: (amount: number) => void;
  
  resetCombatState: () => void;
}

export const createCombatSlice: StateCreator<GameState, [], [], CombatSlice> = (set, get) => ({
  isPlaying: false,
  isZenMode: false,
  playerHealth: PLAYER_CONFIG.maxHealth,
  maxPlayerHealth: PLAYER_CONFIG.maxHealth,
  playerRebootProgress: 0,
  systemIntegrity: 100,

  startGame: () => {
    if (get().isPlaying) return;
    // When game starts, we also reset progression/combat state to baseline
    // But we trigger the other slices via the composed reset in the main store or here.
    // For now, we set local flags.
    get().resetGame(); // Calls the composed reset
    set({ isPlaying: true });
  },

  stopGame: () => {
    const { score, highScore } = get(); // Access Progression Slice
    set({ 
        isPlaying: false, 
        highScore: Math.max(score, highScore) 
    });
  },

  activateZenMode: () => {
    set({ isZenMode: true });
    GameEventBus.emit(GameEvents.ZEN_MODE_ENABLED, null);
  },

  damagePlayer: (amount) => set((state) => ({ 
      playerHealth: Math.max(0, state.playerHealth - amount) 
  })),

  healPlayer: (amount) => set((state) => ({ 
      playerHealth: Math.min(state.maxPlayerHealth, state.playerHealth + amount) 
  })),

  tickPlayerReboot: (amount) => set((state) => ({ 
      playerRebootProgress: Math.min(100, Math.max(0, state.playerRebootProgress + amount)) 
  })),

  decayReboot: (amount) => set((state) => ({ 
      playerRebootProgress: Math.max(0, state.playerRebootProgress - amount) 
  })),

  resetCombatState: () => set({
      isPlaying: false,
      isZenMode: false,
      playerHealth: PLAYER_CONFIG.maxHealth,
      playerRebootProgress: 0,
      systemIntegrity: 100
  })
});


=====================================
FILE: ./src/game/store/slices/createUISlice.ts
=====================================
import { StateCreator } from 'zustand';
import { GameState } from '../useGameStore';
import { UpgradeOption } from '../../types/game.types';

const MAX_PANEL_HEALTH = 1000;

export interface UISlice {
  panels: Record<string, { id: string, health: number, isDestroyed: boolean, element?: HTMLElement }>;
  interactionTarget: string | null;
  availableUpgrades: UpgradeOption[];

  registerPanel: (id: string, element: HTMLElement) => void;
  unregisterPanel: (id: string) => void;
  
  syncPanels: (panelsData: Record<string, any>) => void;
  
  // These were placeholders in original, kept for interface compatibility
  healPanel: (id: string, amount: number) => void;
  damagePanel: (id: string, amount: number) => void;
  
  resetUIState: () => void;
}

export const createUISlice: StateCreator<GameState, [], [], UISlice> = (set, get) => ({
  panels: {},
  interactionTarget: null,
  availableUpgrades: [],

  registerPanel: (id, element) => set((state) => ({
      panels: { ...state.panels, [id]: { id, element, health: MAX_PANEL_HEALTH, isDestroyed: false } }
  })),
  
  unregisterPanel: (id) => set((state) => {
      const next = { ...state.panels };
      delete next[id];
      return { panels: next };
  }),

  syncPanels: (incomingPanels) => set((state) => {
      const merged = { ...state.panels };
      for (const key in incomingPanels) {
          const prev = merged[key];
          merged[key] = { ...(prev || {}), ...incomingPanels[key] };
      }
      return { panels: merged };
  }),

  // UI-only placeholders (Logic is in ECS)
  healPanel: () => {}, 
  damagePanel: () => {}, 

  resetUIState: () => {
      const { panels } = get();
      const resetPanels = Object.fromEntries(
          Object.entries(panels).map(([k, v]) => [k, { ...v, health: MAX_PANEL_HEALTH, isDestroyed: false }])
      );
      set({ 
          panels: resetPanels,
          interactionTarget: null,
          availableUpgrades: []
      });
  }
});


=====================================
FILE: ./src/game/store/useGameStore.ts
=====================================
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

// Slices
import { createCombatSlice, CombatSlice } from './slices/createCombatSlice';
import { createProgressionSlice, ProgressionSlice } from './slices/createProgressionSlice';
import { createUISlice, UISlice } from './slices/createUISlice';

// Combined State Type
export type GameState = CombatSlice & ProgressionSlice & UISlice & {
  // Global Actions that touch multiple slices
  syncGameState: (data: Partial<GameState>) => void;
  resetGame: () => void;
  recalculateIntegrity: () => void; // Legacy hook
};

export const useGameStore = create<GameState>()(
  persist(
    (set, get, api) => ({
      ...createCombatSlice(set, get, api),
      ...createProgressionSlice(set, get, api),
      ...createUISlice(set, get, api),

      // --- BRIDGE ACTIONS ---

      // Called by UISyncSystem (ECS) to update React State
      syncGameState: (data) => set((state) => ({ ...state, ...data })),

      // Master Reset
      resetGame: () => {
          get().resetCombatState();
          get().resetProgressionState();
          get().resetUIState();
      },

      // Legacy/Placeholder
      recalculateIntegrity: () => {},
    }),
    {
      name: 'mesoelfy-os-storage-v3', // Bump version for clean state
      partialize: (state) => ({ highScore: state.highScore }), // Only persist High Score
    }
  )
);


=====================================
FILE: ./src/styles/globals.css
=====================================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 255, 65;
  --shake-x: 0px;
  --shake-y: 0px;
  --shake-r: 0rad;
}

html, body {
  background-color: #000000;
  overscroll-behavior: none; 
  touch-action: none; 
  cursor: none !important;
}

/* Aggressive Cursor Hiding */
* {
  cursor: none !important;
}

body {
  color: #78F654;
  overflow: hidden; 
  font-family: 'Courier New', monospace;
  height: 100dvh; 
  width: 100vw;
}

#global-app-root {
  height: 100dvh;
  transform: translate3d(var(--shake-x), var(--shake-y), 0) rotate(var(--shake-r));
  will-change: transform; 
}

::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #050505; 
  border-left: 1px solid #15530A;
}

::-webkit-scrollbar-thumb {
  background: #0BD426; 
  border: 1px solid #000;
  border-radius: 2px;
}

::-webkit-scrollbar-thumb:hover {
  background: #78F654;
}

.glitch-text {
  text-shadow: 2px 0 #ff003c, -2px 0 #008f11;
}

.clip-corner-btn {
  clip-path: polygon(0 0, 100% 0, 100% 70%, 90% 100%, 0 100%);
}

@keyframes marching {
  0% { background-position: 0 0, 0 100%, 0 0, 100% 0; }
  100% { background-position: 20px 0, -20px 100%, 0 -20px, 100% 20px; }
}

.marching-ants {
  background-image: 
    linear-gradient(to right, var(--ant-color) 50%, transparent 50%),
    linear-gradient(to right, var(--ant-color) 50%, transparent 50%),
    linear-gradient(to bottom, var(--ant-color) 50%, transparent 50%),
    linear-gradient(to bottom, var(--ant-color) 50%, transparent 50%);
  background-size: 20px 1px, 20px 1px, 1px 20px, 1px 20px;
  background-repeat: repeat-x, repeat-x, repeat-y, repeat-y;
  animation: marching 1s linear infinite;
  border: none !important; 
}

body > div[data-nextjs-toast],
body > div[data-nextjs-dialog-overlay],
#next-route-announcer,
[class*="nextjs-toast"],
[class*="build-activity"],
[class*="static-route-indicator"] {
  display: none !important;
  opacity: 0 !important;
  pointer-events: none !important;
  visibility: hidden !important;
}


=====================================
FILE: ./src/scene/props/MiniCrystalCanvas.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { Float, MeshDistortMaterial } from '@react-three/drei';
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { useGameStore } from '@/game/store/useGameStore';

// CONSTANTS
const COLORS = {
  SAFE: new THREE.Color("#78F654"),
  WARN: new THREE.Color("#F7D277"),
  // UPDATED: Brighter/Hotter Red Values
  CRIT: new THREE.Color("#FF4D6D"), 
  EMISSIVE_SAFE: new THREE.Color("#15530A"),
  EMISSIVE_WARN: new THREE.Color("#5e4b00"),
  EMISSIVE_CRIT: new THREE.Color("#FF003C"), 
};

const SpinningGem = () => {
  const meshRef = useRef<THREE.Mesh>(null);
  const materialRef = useRef<any>(null);
  
  // Access global integrity
  const integrity = useGameStore(state => state.systemIntegrity);

  // Internal visual state
  const currentColor = useRef(COLORS.SAFE.clone());
  const currentEmissive = useRef(COLORS.EMISSIVE_SAFE.clone());

  useFrame((state, delta) => {
    if (!meshRef.current || !materialRef.current) return;

    // 1. DETERMINE STATE
    let targetColor = COLORS.SAFE;
    let targetEmissive = COLORS.EMISSIVE_SAFE;
    let speed = 0.01;
    let distort = 0.3;
    let shake = 0;

    if (integrity < 30) {
        targetColor = COLORS.CRIT;
        targetEmissive = COLORS.EMISSIVE_CRIT;
        speed = 0.08;  // Fast panic spin
        distort = 0.8; // Heavy glitch
        shake = 0.1;   // Vibration
    } else if (integrity < 60) {
        targetColor = COLORS.WARN;
        targetEmissive = COLORS.EMISSIVE_WARN;
        speed = 0.04;
        distort = 0.5;
        shake = 0.02;
    }

    // 2. APPLY ROTATION & SHAKE
    meshRef.current.rotation.y += speed;
    meshRef.current.rotation.z += speed * 0.5;
    
    if (shake > 0) {
        meshRef.current.position.x = (Math.random() - 0.5) * shake;
        meshRef.current.position.y = (Math.random() - 0.5) * shake;
    } else {
        meshRef.current.position.x = THREE.MathUtils.lerp(meshRef.current.position.x, 0, 0.1);
        meshRef.current.position.y = THREE.MathUtils.lerp(meshRef.current.position.y, 0, 0.1);
    }

    // 3. COLOR TRANSITION (Lerp)
    currentColor.current.lerp(targetColor, delta * 3.0);
    currentEmissive.current.lerp(targetEmissive, delta * 3.0);

    materialRef.current.color.copy(currentColor.current);
    materialRef.current.emissive.copy(currentEmissive.current);
    materialRef.current.distort = THREE.MathUtils.lerp(materialRef.current.distort, distort, delta);
  });

  return (
    <Float speed={2} rotationIntensity={0.5} floatIntensity={0.5}>
      <mesh ref={meshRef} scale={1.8}>
        <octahedronGeometry args={[1, 0]} />
        <MeshDistortMaterial
          ref={materialRef}
          color="#78F654" // Initial (overridden by ref)
          emissive="#15530A"
          roughness={0.1}
          metalness={0.8}
          distort={0.3}
          speed={2}
          wireframe
        />
      </mesh>
    </Float>
  );
};

export const MiniCrystalCanvas = () => {
  return (
    <div className="w-full h-full bg-black">
      <Canvas 
        camera={{ position: [0, 0, 5] }} 
        gl={{ alpha: true }}
        style={{ background: '#000000' }}
      >
        <ambientLight intensity={0.5} />
        <pointLight position={[10, 10, 10]} intensity={1} color="#C2FE9A" />
        <SpinningGem />
      </Canvas>
    </div>
  );
};


=====================================
FILE: ./src/scene/props/SoulCrystal.tsx
=====================================
import { useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import { Float, MeshDistortMaterial } from '@react-three/drei';
import * as THREE from 'three';

export const SoulCrystal = () => {
  const meshRef = useRef<THREE.Mesh>(null);

  useFrame((state) => {
    if (meshRef.current) {
      const t = state.clock.getElapsedTime();
      meshRef.current.rotation.y = t * 0.5;
      meshRef.current.rotation.z = t * 0.2;
    }
  });

  return (
    <Float speed={2} rotationIntensity={0.5} floatIntensity={1}>
      <mesh ref={meshRef} scale={1.5}>
        <octahedronGeometry args={[1, 0]} />
        <MeshDistortMaterial
          color="#00ff41"
          emissive="#003300"
          roughness={0}
          metalness={1}
          distort={0.4}
          speed={2}
          wireframe
        />
      </mesh>
      {/* Inner Core Glow */}
      <mesh scale={0.8}>
        <octahedronGeometry args={[1, 0]} />
        <meshBasicMaterial color="#ccffcc" transparent opacity={0.5} />
      </mesh>
    </Float>
  );
};


=====================================
FILE: ./src/scene/canvas/SceneCanvas.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { MatrixGrid } from '../effects/MatrixGrid';
import { Suspense } from 'react';
import { clsx } from 'clsx';

interface SceneCanvasProps {
  children?: React.ReactNode;
  className?: string;
}

export const SceneCanvas = ({ children, className }: SceneCanvasProps) => {
  return (
    <div className={clsx("fixed inset-0 w-full h-full z-0 pointer-events-none transition-all duration-[2000ms] ease-out", className)}>
      <Canvas 
        camera={{ position: [0, 2, 10], fov: 45 }}
        gl={{ antialias: true, alpha: false }} 
        dpr={[1, 2]}
        style={{ background: '#000000' }} 
      >
        <color attach="background" args={['#000']} />
        <fog attach="fog" args={['#000', 2, 30]} />
        
        <MatrixGrid />
        
        <ambientLight intensity={0.5} />
        <pointLight position={[10, 10, 10]} intensity={1} color="#78F654" />
        
        <Suspense fallback={null}>
           {children}
        </Suspense>
      </Canvas>
    </div>
  );
};


=====================================
FILE: ./src/scene/effects/MatrixGrid.tsx
=====================================
import { Grid } from '@react-three/drei';
import { useFrame } from '@react-three/fiber';
import { useRef, useMemo } from 'react';
import * as THREE from 'three';
import { useGameStore } from '@/game/store/useGameStore';
import { useStore } from '@/core/store/useStore';

export const MatrixGrid = () => {
  const groupRef = useRef<THREE.Group>(null);
  const gridRef = useRef<any>(null);

  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const bootState = useStore(state => state.bootState);

  const SECTION_SIZE = 5;   
  const SPEED = 0.5;

  const colors = useMemo(() => ({
    safe: {
      section: new THREE.Color("#003300"),
      cell: new THREE.Color("#044d0f")
    },
    warning: {
      section: new THREE.Color("#4d3300"),
      cell: new THREE.Color("#d48806")
    },
    critical: {
      section: new THREE.Color("#4d0000"),
      cell: new THREE.Color("#ff003c")
    },
    sandbox: {
      section: new THREE.Color("#001a33"), 
      cell: new THREE.Color("#00F0FF")     
    }
  }), []);

  const currentSectionColor = useRef(new THREE.Color(colors.safe.section));
  const currentCellColor = useRef(new THREE.Color(colors.safe.cell));

  useFrame((state, delta) => {
    if (groupRef.current) {
      groupRef.current.position.z += SPEED * delta;
      // Loop logic for infinite scrolling effect
      if (groupRef.current.position.z >= SECTION_SIZE) {
        groupRef.current.position.z = 0;
      }
    }

    let targetSection = colors.safe.section;
    let targetCell = colors.safe.cell;

    if (bootState === 'sandbox') {
        targetSection = colors.sandbox.section;
        targetCell = colors.sandbox.cell;
    } else if (systemIntegrity < 30) {
      targetSection = colors.critical.section;
      targetCell = colors.critical.cell;
    } else if (systemIntegrity < 60) {
      targetSection = colors.warning.section;
      targetCell = colors.warning.cell;
    }

    currentSectionColor.current.lerp(targetSection, delta * 3.0);
    currentCellColor.current.lerp(targetCell, delta * 3.0);

    if (gridRef.current && gridRef.current.material) {
        if (gridRef.current.material.uniforms.sectionColor) {
            gridRef.current.material.uniforms.sectionColor.value.copy(currentSectionColor.current);
        }
        if (gridRef.current.material.uniforms.cellColor) {
            gridRef.current.material.uniforms.cellColor.value.copy(currentCellColor.current);
        }
    }
  });

  return (
    <group ref={groupRef} position={[0, -2, 0]}>
      {/* 
         FIX: Nested group to offset geometry without breaking the scrolling logic.
         Z = -10 shifts the center point forward so the "front" edge is well behind the camera.
      */}
      <group position={[0, 0, -10]}>
        <Grid
          ref={gridRef}
          renderOrder={-1}
          infiniteGrid
          
          args={[60, 60]} 
          
          cellSize={1}
          sectionSize={SECTION_SIZE}
          
          // FIX: Reduced fadeDistance slightly to hide distant sub-pixels
          fadeDistance={bootState === 'sandbox' ? 35 : 30}
          
          // FIX: Increased fadeStrength (default is 1)
          // Higher values = sharper falloff. This hides the distant Moiré patterns.
          fadeStrength={2.5}
          
          sectionColor="#003300"
          cellColor="#044d0f"
          sectionThickness={1.2} 
          cellThickness={1.1}
        />
      </group>
    </group>
  );
};


=====================================
FILE: ./src/data/gallery.json
=====================================
[
  {
    "id": "art_001",
    "title": "ELFY_GENESIS",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#78F654"
  },
  {
    "id": "art_002",
    "title": "NEON_HEIST",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#9E4EA5"
  },
  {
    "id": "art_003",
    "title": "VOID_WALKER",
    "url": "https://x.com/mesoelfy",
    "category": "ROGUES",
    "color": "#FF003C"
  },
  {
    "id": "art_004",
    "title": "LATENT_GHOST",
    "url": "https://x.com/mesoelfy",
    "category": "COLLEAGUES",
    "color": "#F7D277"
  },
  {
    "id": "art_005",
    "title": "ZERO_DAY",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#78F654"
  },
  {
    "id": "art_006",
    "title": "SYSTEM_CRASH",
    "url": "https://x.com/mesoelfy",
    "category": "ROGUES",
    "color": "#FF003C"
  }
]


=====================================
FILE: ./src/data/identity.json
=====================================
{
  "name": "Elfy",
  "class": "Latent Space Bandit",
  "abilities": ["Green Flame", "Digital Heist", "Prompt Craft"],
  "stats": {
    "STR": "ERROR",
    "INT": 9001,
    "CHA": 50
  },
  "bio": "I manifest art from the void. My mission: Create cool s**t and annoy the haters."
}


=====================================
FILE: ./src/data/socials.json
=====================================
[
  { "name": "X / Twitter", "url": "https://x.com/mesoelfy", "icon": "twitter", "color": "#1DA1F2" },
  { "name": "YouTube", "url": "https://youtube.com/@mesoelfy", "icon": "youtube", "color": "#FF0000" },
  { "name": "TikTok", "url": "https://tiktok.com/@mesoelfy", "icon": "video", "color": "#00f2ea" },
  { "name": "GitHub", "url": "https://github.com/mesoelfy", "icon": "github", "color": "#ffffff" },
  { "name": "Newgrounds", "url": "https://mesoelfy.newgrounds.com/", "icon": "crosshair", "color": "#ffa500" },
  { "name": "DeviantArt", "url": "https://www.deviantart.com/mesoelfy", "icon": "image", "color": "#05cc47" }
]


=====================================
FILE: ./src/data/feed.json
=====================================
[
  {
    "id": 1,
    "date": "2023-10-27",
    "title": "Elfy vs. RoboGhoul",
    "desc": "The final showdown. Green flame algorithm engaged.",
    "link": "https://x.com/mesoelfy/status/123456"
  },
  {
    "id": 2,
    "date": "2023-10-20",
    "title": "Latent Space Update",
    "desc": "Exploring the void. Found some weird artifacts.",
    "link": "https://x.com/mesoelfy/status/789012"
  }
]


