+---------------------------------+
|      M E S O E L F Y _ O S      |
|   Next.js / R3F Source Context  |
+---------------------------------+
Generated on: Thu Dec 18 15:57:31 CST 2025

=====================================
PROJECT DIRECTORY STRUCTURE:
=====================================
.
â”œâ”€â”€ CITATION.cff
â”œâ”€â”€ Icon\015
â”œâ”€â”€ README.md
â”œâ”€â”€ SECURITY.md
â”œâ”€â”€ app-icon.png
â”œâ”€â”€ docs
â”‚Â Â  â”œâ”€â”€ MESOELFY_OS_AI_INSTRUCTIONS.md
â”‚Â Â  â””â”€â”€ all_source_code.txt
â”œâ”€â”€ electron
â”‚Â Â  â”œâ”€â”€ main.js
â”‚Â Â  â””â”€â”€ preload.js
â”œâ”€â”€ electron-builder.json
â”œâ”€â”€ next-env.d.ts
â”œâ”€â”€ next.config.js
â”œâ”€â”€ package.json
â”œâ”€â”€ postcss.config.js
â”œâ”€â”€ public
â”‚Â Â  â”œâ”€â”€ assets
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ audio
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ bg_music_placeholder.mp3
â”‚Â Â  â”‚Â Â  â””â”€â”€ images
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ social-card.jpg
â”‚Â Â  â”‚Â Â      â””â”€â”€ social_preview_github_1280x640.jpg
â”‚Â Â  â””â”€â”€ favicon.ico
â”œâ”€â”€ scripts
â”‚Â Â  â””â”€â”€ create_source_context.command
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ app
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ layout.tsx
â”‚Â Â  â”‚Â Â  â””â”€â”€ page.tsx
â”‚Â Â  â”œâ”€â”€ engine
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ai
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ StateMachine.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ behavior
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ composites.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ decorators.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ types.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ nodes
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ actions.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ conditions.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ daemonNodes.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ drillerNodes.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ hunterNodes.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ logic.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ audio
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AudioDirector.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AudioMath.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AudioService.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AudioSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AudioUtils.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ hooks
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ useAudioVisualizer.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ modules
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ AudioContextManager.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ AudioMixer.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ AudioSynthesizer.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ SoundBank.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ VoiceManager.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ config
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AIConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Archetypes.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AssetKeys.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AudioConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Identifiers.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ModelConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Palette.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PhysicsConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PlayerConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ProjectileConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SoundMetadata.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TextAssets.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ VFXConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ WaveConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ WorldConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ static
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ feed.json
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ gallery.json
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ identity.json
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ socials.json
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ waves.json
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ecs
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Component.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ComponentCatalog.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ComponentPoolManager.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ComponentRegistry.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ComponentType.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Constants.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Entity.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EntityRegistry.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ObjectPool.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Query.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SpatialGrid.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TransformStore.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AIStateData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ColliderData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CombatData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ HealthData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ IdentityData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ LifetimeData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ MotionData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ OrbitalData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ProjectileData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ RenderData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TargetData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ TransformData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ types.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ graphics
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ MaterialFactory.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ShaderLib.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ glsl
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ math.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ noise.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ gpgpu
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ GPGPUManager.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ handlers
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ai
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AIRegistry.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ BehaviorCatalog.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ DaemonLogic.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ DrillerLogic.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ HunterLogic.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ KamikazeLogic.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ types.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ combat
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CollisionMatrix.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CombatHandlers.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ types.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ weapons
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ WeaponLogic.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ workers
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ GeometryWorker.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ input
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ VirtualJoystickService.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ interfaces.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ math
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GeometryUtils.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Noise.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ RenderUtils.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ViewportHelper.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ coords.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ services
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ConfigService.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ DOMSpatialService.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EntitySpawner.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameBootstrapper.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameEngine.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ MobileBootstrapper.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ServiceLocator.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ StructureHealthService.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ TransientDOMService.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ signals
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EventReader.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ FastEventBus.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameEventBus.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ GameEvents.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ state
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameContext.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ game
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ slices
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ createCombatSlice.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ createProgressionSlice.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ createUISlice.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ useGameStore.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ global
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ useStore.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ systems
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AtmosphereSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AudioDirector.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ BehaviorSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CollisionSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CombatSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameStateSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GuidanceSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ HealthSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ InputSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ InteractionSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ LifeCycleSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ MobileWaveSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ OrbitalSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PanelRegistrySystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ParticleSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PhysicsSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PlayerMovementSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ProgressionSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ProjectileSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ RenderSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ShakeSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ StructureSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TargetingSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TimeSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ VFXSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ WaveSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ WeaponSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ index.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ types
â”‚Â Â  â”‚Â Â      â””â”€â”€ game.types.ts
â”‚Â Â  â”œâ”€â”€ styles
â”‚Â Â  â”‚Â Â  â””â”€â”€ globals.css
â”‚Â Â  â””â”€â”€ ui
â”‚Â Â      â”œâ”€â”€ hooks
â”‚Â Â      â”‚Â Â  â””â”€â”€ useAudio.ts
â”‚Â Â      â”œâ”€â”€ kit
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ atoms
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ActionButton.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CustomCursor.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ DotGridBackground.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GlassPanel.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GraphicsToggle.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PanelSparks.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SafePanelContent.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ StatsRadar.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ToggleButton.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ VirtualJoystick.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ VitalsRing.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ ZenBomb.tsx
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ hooks
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ useHoloCycler.ts
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ usePanelPhysics.ts
â”‚Â Â      â”‚Â Â  â””â”€â”€ molecules
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ FeedAccessTerminal.tsx
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ HoloCommLog.tsx
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ IdentityFooter.tsx
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ IdentityHUD.tsx
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ LiveArtGrid.tsx
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ SocialRow.tsx
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ SystemOps.tsx
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ UpgradeTerminal.tsx
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ VideoPlaylistService.ts
â”‚Â Â      â”‚Â Â      â””â”€â”€ panel
â”‚Â Â      â”‚Â Â          â”œâ”€â”€ BreachOverlay.tsx
â”‚Â Â      â”‚Â Â          â”œâ”€â”€ IntelligentHeader.tsx
â”‚Â Â      â”‚Â Â          â””â”€â”€ RebootOverlay.tsx
â”‚Â Â      â”œâ”€â”€ os
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ apps
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ contact
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ ContactModal.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ debug
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ DebugOverlay.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ tabs
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ ConsoleTab.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ OverridesTab.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ SandboxTab.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ StatsTab.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ feed
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ FeedModal.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ gallery
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ GalleryModal.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ identity
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ AboutModal.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ mobile
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ MobileExperience.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ MobileRejectionModal.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ sandbox
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ArenaLab.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AudioMatrix.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ModelInspector.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SimulationHUD.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ layout
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ HoloBackground.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ HoloHeader.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ HoloLayout.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ HoloNav.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ visuals
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ VisualLab.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ settings
â”‚Â Â      â”‚Â Â  â”‚Â Â      â”œâ”€â”€ SettingsModal.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â      â”œâ”€â”€ components
â”‚Â Â      â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ GpuConfigPanel.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â      â”‚Â Â  â””â”€â”€ RangeSlider.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â      â””â”€â”€ tabs
â”‚Â Â      â”‚Â Â  â”‚Â Â          â””â”€â”€ SoundTab.tsx
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ boot
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ MatrixBootSequence.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ atoms
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AsciiRenderer.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ BootHeader.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CoreHeader.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ TypedLog.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ data
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ bootLogs.ts
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ hooks
â”‚Â Â      â”‚Â Â  â”‚Â Â      â”œâ”€â”€ useBootSequence.ts
â”‚Â Â      â”‚Â Â  â”‚Â Â      â”œâ”€â”€ useMatrixRain.ts
â”‚Â Â      â”‚Â Â  â”‚Â Â      â””â”€â”€ useSmartScroll.ts
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ desktop
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Footer.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ Header.tsx
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ overlays
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ErrorBoundary.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GlobalBackdrop.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ModalContainer.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ RotationLock.tsx
â”‚Â Â      â”‚Â Â  â””â”€â”€ system
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ ConsoleScrubber.ts
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ MetaManager.tsx
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ faviconGenerator.ts
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ hooks
â”‚Â Â      â”‚Â Â      â”‚Â Â  â”œâ”€â”€ useMetaTheme.ts
â”‚Â Â      â”‚Â Â      â”‚Â Â  â”œâ”€â”€ useMetaTitle.ts
â”‚Â Â      â”‚Â Â      â”‚Â Â  â””â”€â”€ useMetaUrl.ts
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ metaConstants.ts
â”‚Â Â      â”‚Â Â      â””â”€â”€ useFavicon.ts
â”‚Â Â      â””â”€â”€ sim
â”‚Â Â          â”œâ”€â”€ GameCanvas.tsx
â”‚Â Â          â”œâ”€â”€ GameDirector.tsx
â”‚Â Â          â”œâ”€â”€ MobileGameDirector.tsx
â”‚Â Â          â”œâ”€â”€ RenderDirector.tsx
â”‚Â Â          â”œâ”€â”€ SceneCanvas.tsx
â”‚Â Â          â”œâ”€â”€ actors
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ DaemonActor.tsx
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ InstancedActor.tsx
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ ParticleActor.tsx
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ PlayerActor.tsx
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ ProjectileRenderer.tsx
â”‚Â Â          â”‚Â Â  â””â”€â”€ UniversalActor.tsx
â”‚Â Â          â”œâ”€â”€ assets
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ AssetCatalog.ts
â”‚Â Â          â”‚Â Â  â””â”€â”€ AssetService.ts
â”‚Â Â          â”œâ”€â”€ config
â”‚Â Â          â”‚Â Â  â””â”€â”€ theme.ts
â”‚Â Â          â”œâ”€â”€ experiments
â”‚Â Â          â”‚Â Â  â””â”€â”€ GlitchGhost.tsx
â”‚Â Â          â”œâ”€â”€ hooks
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ useDeviceType.ts
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ useHeartbeat.ts
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ useMultiTransientRef.ts
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ usePanelRegistry.ts
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ useTransientRef.ts
â”‚Â Â          â”‚Â Â  â””â”€â”€ useWindowFocus.ts
â”‚Â Â          â”œâ”€â”€ props
â”‚Â Â          â”‚Â Â  â””â”€â”€ MiniCrystalCanvas.tsx
â”‚Â Â          â”œâ”€â”€ registry
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ RenderCatalog.ts
â”‚Â Â          â”‚Â Â  â””â”€â”€ RenderRegistry.ts
â”‚Â Â          â”œâ”€â”€ stages
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ GalleryStage.tsx
â”‚Â Â          â”‚Â Â  â””â”€â”€ LabStage.tsx
â”‚Â Â          â””â”€â”€ vfx
â”‚Â Â              â”œâ”€â”€ CameraRig.tsx
â”‚Â Â              â”œâ”€â”€ MatrixGrid.tsx
â”‚Â Â              â””â”€â”€ PostProcessing.tsx
â”œâ”€â”€ tailwind.config.ts
â””â”€â”€ tsconfig.json

80 directories, 265 files

=====================================
FILE: ./next.config.js
=====================================
/** @type {import('next').NextConfig} */

let commitHash = 'DEV_BUILD';

try {
  const { execSync } = require('child_process');
  commitHash = execSync('git rev-parse --short HEAD').toString().trim();
} catch (error) {
  console.warn('Warning: Could not determine git commit hash.');
}

const nextConfig = {
  output: 'export',
  images: {
    unoptimized: true,
  },
  reactStrictMode: false,
  transpilePackages: ['three'],
  devIndicators: false,
  env: {
    NEXT_PUBLIC_COMMIT_HASH: commitHash,
  },
  typescript: {
    ignoreBuildErrors: true,
  },
  eslint: {
    ignoreDuringBuilds: true,
  },
}

module.exports = nextConfig


=====================================
FILE: ./docs/MESOELFY_OS_AI_INSTRUCTIONS.md
=====================================
I am developing "MESOELFY_OS," a 3D interactive portfolio site with a Keygen/Cyberpunk/Hacker/Demoscene aesthetic. 

I have attached "all_source_code.txt" which contains the full project tree and code. Please ingest this to understand the current architecture.

***CORE IDENTITY & AESTHETIC***
*   **Persona:** You are assisting "Elfy," a Latent Space Bandit. The vibe is Y2K Hacker, Matrix, Geometry Wars, and High-Tech Demoscene.
*   **Palette:** Electric Green (#78F654) is dominant. Deep Purple (#9E4EA5) is secondary. Red/Yellow for alerts. Black backgrounds.
*   **Current Status:** The site is live at `mesoelfy.github.io`. The "Intro Boot Sequence" and "Main MESOELFY_OS Dashboard" game area are built and stable, but suggestions for improvements for AAA levels of polish in code architecture, game design, animation, motion graphics, sound design, and graphic design are always appreciated.

***TECHNICAL STACK***
*   **Framework:** Next.js 14 (App Router) + TypeScript.
*   **Styling:** Tailwind CSS + Framer Motion (for UI animations).
*   **3D:** React Three Fiber (R3F) + Drei.
*   **Deployment:** GitHub Pages (Static Export).

***WORKFLOW RULES (CRITICAL)***
1.  **Terminal Only:** Do not ask me to manually create files. Provide full terminal commands using `cat << 'EOF' > path/to/file` to create or overwrite files.
2.  **No Placeholders:** Unless specified, write complete, functional code.
3.  **STEP BY STEP PHASE-BASED WORKFLOW:** After an outline of steps has been articulated, give the code in structured steps instead of all at once.
4.  **// VERIFICATION CHECKLIST:**  Let the user know what to look for to confirm the changes have succeeded and the build is stable
5.  **Atomic Commits:** After the user a successful feature implementation, provide the specific `git add .`, `git commit -m "..."`, and `git push` commands with a detailed commit description after the title. Don't provide the commit until the user asks for it. For git add, always use the period ".". And make sure you include the long description. It should be provided as a single copy-paste for the user.
using git add . to capture all the relevant modified files and following the prescribed format: git add . && git commit -m "title" -m "description" && git push.

Don't repeat information from previous commits. Each new commit is for the new progress that has been made.

6.  **Lean Ship:** Keep dependencies low. Prefer procedural generation (shaders/math) over large assets.
7. **WAIT** Don't provide code until user asks for it. You should articulate with text what you'd like to do so the user can confirm what needs to be done.


***MISC***
User has Three.js and React DevTools extensions installed which can be used to help isolate any issues.



Working directory:
stevencasteel@Stevens-Mac-mini mesoelfy-site % 


Please acknowledge you have analyzed the codebase.

=====================================
FILE: ./.devcontainer/devcontainer.json
=====================================
{
  "name": "MESOELFY_OS // CLOUD_NODE",
  "image": "mcr.microsoft.com/devcontainers/typescript-node:1-20-bullseye",
  "customizations": {
    "vscode": {
      "settings": {
        "terminal.integrated.defaultProfile.linux": "zsh",
        "editor.formatOnSave": true
      },
      "extensions": [
        "esbenp.prettier-vscode",
        "dbaeumer.vscode-eslint",
        "bradlc.vscode-tailwindcss"
      ]
    }
  },
  "postCreateCommand": "npm install && echo '// DEPENDENCIES INJECTED. SYSTEM READY.'",
  "forwardPorts": [3000]
}


=====================================
FILE: ./next-env.d.ts
=====================================
/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


=====================================
FILE: ./README.md
=====================================
<div align="center">

```text
 â–ˆâ–ˆâ–ˆâ–„ â–„â–ˆâ–ˆâ–ˆâ–“â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–“      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–“â–ˆâ–ˆ   â–ˆâ–ˆâ–“
â–“â–ˆâ–ˆâ–’â–€â–ˆâ–€ â–ˆâ–ˆâ–’â–“â–ˆ   â–€â–’â–ˆâ–ˆ    â–’ â–’â–ˆâ–ˆâ–’  â–ˆâ–ˆâ–’â–“â–ˆ   â–€ â–“â–ˆâ–ˆâ–’    â–’â–“â–ˆ   â–’  â–’â–ˆâ–ˆ  â–ˆâ–ˆâ–’
â–“â–ˆâ–ˆ    â–“â–ˆâ–ˆâ–‘â–’â–ˆâ–ˆâ–ˆ  â–‘ â–“â–ˆâ–ˆâ–„   â–’â–ˆâ–ˆâ–‘  â–ˆâ–ˆâ–’â–’â–ˆâ–ˆâ–ˆ   â–’â–ˆâ–ˆâ–‘    â–’â–“â–ˆâ–ˆâ–ˆ â–‘   â–’â–ˆâ–ˆ â–ˆâ–ˆâ–‘
â–’â–ˆâ–ˆ    â–’â–ˆâ–ˆ â–’â–“â–ˆ  â–„  â–’   â–ˆâ–ˆâ–’â–’â–ˆâ–ˆ   â–ˆâ–ˆâ–‘â–’â–“â–ˆ  â–„ â–’â–ˆâ–ˆâ–‘    â–‘â–“â–ˆâ–’  â–‘   â–‘ â–â–ˆâ–ˆâ–‘â–‘
â–’â–ˆâ–ˆâ–’   â–‘â–ˆâ–ˆâ–’â–‘â–’â–ˆâ–ˆâ–ˆâ–ˆâ–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–‘ â–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–ˆâ–ˆâ–ˆâ–ˆâ–’â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–‘â–’â–ˆâ–‘      â–‘ â–ˆâ–ˆâ–’â–‘â–‘
â–‘ â–’â–‘   â–‘  â–‘â–‘â–‘ â–’â–‘ â–‘ â–’â–‘â–’  â–‘ â–‘ â–’â–‘â–’â–‘â–’â–‘ â–‘â–‘ â–’â–‘ â–‘â–‘ â–’â–‘â–’  â–‘ â–’ â–‘       â–ˆâ–ˆâ–’â–’â–’
â–‘  â–‘      â–‘ â–‘ â–‘  â–‘ â–‘ â–’  â–‘   â–‘ â–’ â–’â–‘  â–‘ â–‘  â–‘â–‘ â–‘ â–’  â–‘ â–‘       â–“â–ˆâ–ˆ â–‘â–’â–‘ 
â–‘      â–‘      â–‘    â–‘ â–‘    â–‘ â–‘ â–‘ â–’     â–‘     â–‘ â–‘    â–‘ â–‘     â–’ â–’ â–‘â–‘  
       â–‘      â–‘  â–‘   â–‘  â–‘     â–‘ â–‘     â–‘  â–‘    â–‘  â–‘         â–‘ â–‘     
```

![System Status](https://img.shields.io/badge/SYSTEM_STATUS-ONLINE-78F654?style=for-the-badge&logo=githubactions&logoColor=black&labelColor=15530A)
![Version](https://img.shields.io/badge/VERSION-0.1.0-9E4EA5?style=for-the-badge&logo=git&logoColor=white&labelColor=350E3A)
![Core](https://img.shields.io/badge/KERNEL-R3F-00F0FF?style=for-the-badge&logo=react&logoColor=black&labelColor=005f66)

### **LATENT SPACE BANDIT // DIGITAL HQ**

**A generative 3D operating system running in your browser.**
Audio-reactive. Procedural. Playable.

---

### // INITIALIZE_SESSION

**Choose your method of entry.**

| ðŸŸ¢ **INSTANT ACCESS** | ðŸ“¦ **OFFLINE APP** | ðŸ’» **SOURCE CODE** |
| :--- | :--- | :--- |
| [**mesoelfy.github.io**](https://mesoelfy.github.io) | [**Download Release**](https://github.com/mesoelfy/mesoelfy.github.io/releases) | [**Inspect Repo**](#-developer_protocol) |
| Stream directly via Browser. | Native App (Mac/Win/Linux). | Clone the architecture. |

> **âš  NOTE:** First-time boot may stutter while shaders compile. Refresh if visuals glitch.

---

### // SYSTEM_SPECS

*   **Engine:** Next.js 14 + React Three Fiber (R3F)
*   **Audio:** Web Audio API (Real-time Synthesis)
*   **Build:** Electron + GitHub Actions

### // DEVELOPER_PROTOCOL

To run the simulation locally:

```bash
# 1. Clone
git clone https://github.com/mesoelfy/mesoelfy.github.io.git

# 2. Inject
npm install

# 3. Initialize
npm run dev
```

<br />

<a href="https://x.com/mesoelfy">
  <img src="https://img.shields.io/badge/DIRECT_UPLINK-TWITTER-1DA1F2?style=for-the-badge&logo=twitter&logoColor=white" />
</a>
<a href="https://mesoelfy.github.io">
  <img src="https://img.shields.io/badge/ENTER-THE_VOID-78F654?style=for-the-badge&logo=playstation&logoColor=black" />
</a>

</div>


=====================================
FILE: ./tailwind.config.ts
=====================================
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './src/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        'primary-green': {
          light: '#7FF65F',
          DEFAULT: 'rgba(96, 196, 68, 1)',
          dim: '#1bb930ff',
          dark: '#217e10ff',
        },
        'latent-purple': {
          light: '#BC86BA',
          DEFAULT: '#9E4EA5',
          dim: '#822B8A',
          deep: '#350E3A',
        },
        'service-cyan': {
          DEFAULT: '#00F0FF', 
          dim: '#008ba3',
        },
        'alert-yellow': {
          DEFAULT: '#eae747ff',
        },
        'critical-red': {
          DEFAULT: '#FF003C', 
        },
        'muted-gray': '#27282A',
        'void-black': '#050505',
        'game': {
          turret: { base: '#78F654', glow: '#C2FE9A' },
          bullet: { plasma: '#FFFFFF', trail: '#78F654' },
          enemy: { seeker: '#9E4EA5', eater: '#FF003C', boss: '#F7D277' },
          hud: { text: '#78F654', warning: '#FF003C' },
          vfx: { spark: '#FFFFFF', damage: '#FF003C' }
        }
      },
      fontFamily: {
        header: ['var(--font-montserrat)', 'sans-serif'],
        mono: ['Courier New', 'Courier', 'monospace'],
        tech: ['var(--font-jetbrains)', 'monospace'],
      },
      animation: {
        'spin-slow': 'spin 3s linear infinite',
        'spin-diamond': 'spin-diamond 3s linear infinite',
        'matrix-green': 'matrix-green 4s ease-in-out infinite',
        'matrix-purple': 'matrix-purple 2s ease-in-out infinite',
        'cursor-blink': 'cursor-blink 1.2s ease-in-out infinite',
        'restore-flash': 'restore-flash 1.2s ease-out forwards',
      },
      keyframes: {
        'spin-diamond': {
          '0%': { transform: 'rotate(45deg)' },
          '100%': { transform: 'rotate(405deg)' },
        },
        'matrix-green': {
          '0%, 100%': { color: '#14630bff' },
          '50%': { color: '#0aa41cff' },
        },
        'matrix-purple': {
          '0%, 100%': { color: '#9E4EA5' }, 
          '33%': { color: '#BC86BA' },      
          '66%': { color: '#350E3A' },      
        },
        'cursor-blink': {
          '0%, 30%': { opacity: '1' }, 
          '50%': { opacity: '0' },     
          '100%': { opacity: '1' },    
        },
        'restore-flash': {
          '0%': { boxShadow: '0 0 0px transparent', borderColor: 'rgba(96, 196, 68, 0.3)' },
          '5%': { boxShadow: '0 0 15px rgba(96, 196, 68, 1)', borderColor: '#78F654' },
          '100%': { boxShadow: '0 0 0px transparent', borderColor: 'rgba(96, 196, 68, 0.3)' }
        }
      }
    },
  },
  plugins: [],
}
export default config


=====================================
FILE: ./package.json
=====================================
{
  "name": "mesoelfy-site",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "electron": "electron .",
    "package": "npm run build && electron-builder"
  },
  "dependencies": {
    "@react-three/drei": "^10.7.7",
    "@react-three/fiber": "^9.4.2",
    "@react-three/postprocessing": "^2.19.1",
    "clsx": "^2.1.0",
    "electron-serve": "^3.0.0",
    "framer-motion": "^11.0.0",
    "lucide-react": "^0.300.0",
    "maath": "^0.10.0",
    "next": "^16.0.7",
    "react": "^19.2.1",
    "react-dom": "^19.2.1",
    "tailwind-merge": "^2.2.0",
    "three": "^0.181.2",
    "zustand": "^4.5.0"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@types/three": "^0.181.0",
    "autoprefixer": "^10.0.1",
    "electron": "^39.2.7",
    "electron-builder": "^26.0.12",
    "eslint": "^9.39.1",
    "eslint-config-next": "^16.0.7",
    "postcss": "^8",
    "tailwindcss": "^3.3.0",
    "typescript": "^5"
  },
  "main": "electron/main.js",
  "description": "A 3D generative OS portfolio.",
  "author": "Elfy <mesoelfy@example.com>"
}


=====================================
FILE: ./.github/workflows/release.yml
=====================================
name: Release Pipeline

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  # 1. BUILD WEB VERSION
  build-web:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: 'npm' }
      - run: npm ci
      - run: npm run build
      - run: cd out && zip -r ../MESOELFY_OS_Itch_Upload_Ready.zip .
      - uses: actions/upload-artifact@v4
        with:
          name: web-artifact
          path: MESOELFY_OS_Itch_Upload_Ready.zip

  # 2. BUILD DESKTOP APPS
  build-desktop:
    name: Build ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest, macos-latest]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: 'npm' }
      - run: npm ci
      
      - name: Install Linux Deps
        if: matrix.os == 'ubuntu-latest'
        run: sudo apt-get update && sudo apt-get install -y libicns-dev graphicsmagick

      - name: Build Next.js
        run: npm run build

      - name: Build Electron
        # Build but do not publish to GitHub yet (we do that manually in step 3)
        run: npx electron-builder --publish never
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Upload raw files to temp storage
      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: desktop-artifacts-${{ matrix.os }}
          path: |
            dist/*.exe
            dist/*.dmg
            dist/*.AppImage

  # 3. CURATE AND PUBLISH
  publish:
    needs: [build-web, build-desktop]
    runs-on: ubuntu-latest
    steps:
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          pattern: '*'
          merge-multiple: true

      - name: Bundle and Clean
        run: |
          # Create themed folders
          mkdir -p "release/MESOELFY_OS_Mac_Build"
          mkdir -p "release/MESOELFY_OS_Windows_Build"
          mkdir -p "release/MESOELFY_OS_Linux_Build"
          
          # Move files
          mv artifacts/*.dmg "release/MESOELFY_OS_Mac_Build/" 2>/dev/null || true
          mv artifacts/*.exe "release/MESOELFY_OS_Windows_Build/" 2>/dev/null || true
          mv artifacts/*.AppImage "release/MESOELFY_OS_Linux_Build/" 2>/dev/null || true
          mv artifacts/MESOELFY_OS_Itch_Upload_Ready.zip release/

          # Zip the folders
          cd release
          zip -r MESOELFY_OS_Mac.zip "MESOELFY_OS_Mac_Build"
          zip -r MESOELFY_OS_Windows.zip "MESOELFY_OS_Windows_Build"
          zip -r MESOELFY_OS_Linux.zip "MESOELFY_OS_Linux_Build"
          
          # Remove the folders now that they are zipped
          rm -rf "MESOELFY_OS_Mac_Build" "MESOELFY_OS_Windows_Build" "MESOELFY_OS_Linux_Build"

      - name: Publish Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            release/MESOELFY_OS_Mac.zip
            release/MESOELFY_OS_Windows.zip
            release/MESOELFY_OS_Linux.zip
            release/MESOELFY_OS_Itch_Upload_Ready.zip
          draft: false
          prerelease: false
          name: "MESOELFY_OS ${{ github.ref_name }}"
          body: |
            **// STANDALONE APPS (OFFLINE)**
            *Contains the game wrapped in a Chromium engine (Electron).*
            *You're basically downloading a lite version of the Chrome browser to run the game.*
            *(Approx 200-400MB)*
            
            **âš  PERFORMANCE NOTE:** If the game stutters or hitches on first launch, the 3D shaders are compiling. Simply go to **View -> Force Reload** (or restart the app) to resolve this.

            ---

            *   **Mac:** Download `MESOELFY_OS_Mac.zip`.
                *   **"Damaged" Error?** Apple treats apps from indie developers as "Untrusted" until you manually verify them.
                *   **The Fix:**
                    1. Drag the app to your Applications folder.
                    2. Open Terminal (Cmd+Space, type Terminal).
                    3. Paste this command and hit Enter: `xattr -cr /Applications/MESOELFY_OS.app`
                    4. **What does this do?** `xattr -cr` stands for "Extended Attributes - Clear Recursive". It simply wipes the "Quarantine" sticker macOS puts on files downloaded from the web, allowing your computer to trust it.
            
            *   **Windows:** Download `MESOELFY_OS_Windows.zip`. Double-click to run.
                *   *Note: Click "More Info" -> "Run Anyway" if Windows Defender warns you.*
            
            *   **Linux:** Download `MESOELFY_OS_Linux.zip`.
                *   *Note: Right-click -> Properties -> Check "Allow executing file as program".*

            ---

            **// WEB BUILD (HTML5)**
            *   **File:** `MESOELFY_OS_Itch_Upload_Ready.zip`
            *   **Usage:** Strictly for uploading to platforms like Itch.io or Newgrounds to host the game online. 
            *   *Included for those who wish to inspect the compiled asset structure for learning purposes.*

            ---

            **// LOCAL HOST EXPERIENCE (SOURCE)**
            *   **File:** `Source code (zip)` (Below)
            *   **Usage:** Run the full project on your machine.
            *   **Why `npm`?** You can't just open an HTML file anymore. This project uses complex 3D rendering that requires a local server. Think of `npm` as the "App Store" for codeâ€”it installs the engine needed to run the site.
            *   **Instructions (It's very easy):**
                1. Unzip the source code.
                2. Open your terminal **inside that specific folder**.
                3. Type `npm install` (this downloads the engine).
                4. Type `npm run dev` (this starts the server).
                5. Open `http://localhost:3000` in any browser, but **Chrome will work the best**.
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


=====================================
FILE: ./.github/workflows/deploy.yml
=====================================
name: Deploy to GitHub Pages

on:
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: 'npm'
          
      - name: Setup Pages
        uses: actions/configure-pages@v4
        with:
          static_site_generator: next
          
      - name: Install Dependencies
        run: npm ci
        
      - name: Build with Next.js
        run: npm run build
        
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./out

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4


=====================================
FILE: ./.github/workflows/greetings.yml
=====================================
name: "Neural Handshake"

on: [pull_request_target, issues]

jobs:
  greeting:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
    steps:
    - uses: actions/first-interaction@v1
      with:
        repo-token: ${{ secrets.GITHUB_TOKEN }}
        issue-message: |
          ### // TRANSMISSION RECEIVED
          
          **Identity Verified:** New Contributor detected.
          **Status:** The Daemon is analyzing your anomaly report.
          
          > *Welcome to the Latent Space. Ensure your logs are clean before proceeding.*
        
        pr-message: |
          ### // CODE_INJECTION DETECTED
          
          **Source:** External Node
          **Payload:** Analysis Pending...
          
          > *Your contribution to the OS architecture has been logged. Stand by for code review and merge clearance.*


=====================================
FILE: ./.github/ISSUE_TEMPLATE/anomaly_report.yml
=====================================
name: "REPORT_ANOMALY"
description: "File a report regarding system instability or unexpected behavior."
title: "[ANOMALY]: "
labels: ["bug", "triage"]
body:
  - type: markdown
    attributes:
      value: |
        ### // TRANSMISSION STARTED
        *Please describe the instability found within the MESOELFY_OS architecture.*
  
  - type: textarea
    id: description
    attributes:
      label: "Anomaly Description"
      description: "What happened? Be specific."
      placeholder: "The Audio Matrix desyncs when I toggle Potato Mode..."
    validations:
      required: true

  - type: dropdown
    id: sector
    attributes:
      label: "Affected Sector"
      description: "Where did the breach occur?"
      options:
        - "CORE_SYSTEM (Boot/Loading)"
        - "VISUALS (Shaders/Rendering)"
        - "AUDIO_MATRIX (Sound/Music)"
        - "COMBAT_SIM (Enemies/Player)"
        - "UI_OVERLAY (Menus/Modals)"
        - "INSTALLER (Electron/Build)"
    validations:
      required: true

  - type: dropdown
    id: severity
    attributes:
      label: "Threat Level"
      options:
        - "LOW (Visual Glitch)"
        - "MED (Feature Broken)"
        - "HIGH (Game Crash)"
        - "CRITICAL (System Failure / Won't Boot)"
    validations:
      required: true

  - type: textarea
    id: reproduction
    attributes:
      label: "Trace Protocol (Steps to Reproduce)"
      description: "How can we replicate this anomaly?"
      placeholder: |
        1. Initialize System
        2. Open Settings
        3. Click '...'
        4. Crash occurs
    validations:
      required: true

  - type: input
    id: environment
    attributes:
      label: "Hardware/Software Specs"
      description: "OS, Browser, GPU (if known)"
      placeholder: "Windows 11, Chrome Latest, RTX 3080"
    validations:
      required: false


=====================================
FILE: ./.github/ISSUE_TEMPLATE/config.yml
=====================================
blank_issues_enabled: false
contact_links:
  - name: "Direct Uplink (Twitter)"
    url: https://x.com/mesoelfy
    about: "Ping the developer directly."


=====================================
FILE: ./.github/ISSUE_TEMPLATE/feature_injection.yml
=====================================
name: "INJECT_FEATURE"
description: "Propose a new module, upgrade, or aesthetic enhancement."
title: "[INJECTION]: "
labels: ["enhancement"]
body:
  - type: markdown
    attributes:
      value: |
        ### // UPLINK OPEN
        *Submit your proposal for system augmentation.*

  - type: input
    id: concept
    attributes:
      label: "Module Name"
      placeholder: "e.g. 'Advanced Particle Physics'"
    validations:
      required: true

  - type: textarea
    id: pitch
    attributes:
      label: "Injection Description"
      description: "Describe the feature in detail."
    validations:
      required: true

  - type: dropdown
    id: type
    attributes:
      label: "Upgrade Class"
      options:
        - "VISUAL_AESTHETICS"
        - "AUDIO_ENHANCEMENT"
        - "GAMEPLAY_MECHANIC"
        - "LORE_EXPANSION"
        - "OPTIMIZATION"

  - type: textarea
    id: justification
    attributes:
      label: "System Value"
      description: "Why does the OS need this?"


=====================================
FILE: ./tsconfig.json
=====================================
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./src/*"
      ],
      "@/engine/*": [
        "./src/engine/*"
      ],
      "@/ui/*": [
        "./src/ui/*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}


=====================================
FILE: ./electron/preload.js
=====================================
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electron', {
  send: (channel, data) => {
    let validChannels = ["toMain"];
    if (validChannels.includes(channel)) {
      ipcRenderer.send(channel, data);
    }
  },
  receive: (channel, func) => {
    let validChannels = ["fromMain"];
    if (validChannels.includes(channel)) {
      ipcRenderer.on(channel, (event, ...args) => func(...args));
    }
  }
});


=====================================
FILE: ./electron/main.js
=====================================
const { app, BrowserWindow, session } = require('electron');
const path = require('path');

// --- FIX: Handle ESM/CJS interoperability ---
const serveExport = require('electron-serve');
const serve = serveExport.default || serveExport; 

const appServe = app.isPackaged ? serve({ directory: path.join(__dirname, '../out') }) : null;

const createWindow = () => {
  const win = new BrowserWindow({
    width: 1600,
    height: 1200, 
    title: "MESOELFY_OS",
    icon: path.join(__dirname, '../app-icon.png'),
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      nodeIntegration: false,
      contextIsolation: true,
      webSecurity: true // Keep true, we will handle Referer via session
    }
  });

  win.setMenuBarVisibility(false);

  if (app.isPackaged) {
    appServe(win).then(() => {
      win.loadURL('app://-');
    });
  } else {
    win.loadURL('http://localhost:3000');
    // win.webContents.openDevTools();
  }
};

app.whenReady().then(() => {
  // --- YOUTUBE 153 FIX ---
  // Intercept requests to YouTube and inject a valid 'Referer' header.
  // This tricks YouTube into thinking the video is playing on your website.
  session.defaultSession.webRequest.onBeforeSendHeaders(
    { urls: ['*://*.youtube.com/*', '*://*.google.com/*'] },
    (details, callback) => {
      details.requestHeaders['Referer'] = 'https://mesoelfy.github.io/';
      callback({ cancel: false, requestHeaders: details.requestHeaders });
    }
  );

  createWindow();

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});


=====================================
FILE: ./postcss.config.js
=====================================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


=====================================
FILE: ./electron-builder.json
=====================================
{
  "appId": "com.mesoelfy.os",
  "productName": "MESOELFY_OS",
  "directories": {
    "output": "dist"
  },
  "publish": {
    "provider": "github",
    "releaseType": "release"
  },
  "files": [
    "out/**/*",
    "electron/**/*",
    "package.json",
    "app-icon.png"
  ],
  "mac": {
    "icon": "app-icon.png",
    "target": ["dmg"],
    "category": "public.app-category.games",
    "gatekeeperAssess": false
  },
  "dmg": {
    "background": "public/assets/images/social-card.jpg",
    "iconSize": 140,
    "window": { "width": 800, "height": 500 },
    "contents": [
      { "x": 200, "y": 250, "type": "file" },
      { "x": 600, "y": 250, "type": "link", "path": "/Applications" }
    ]
  },
  "win": {
    "icon": "app-icon.png",
    "target": ["nsis", "portable"]
  },
  "linux": {
    "icon": "app-icon.png",
    "target": ["AppImage", "deb"],
    "category": "Game"
  }
}


=====================================
FILE: ./SECURITY.md
=====================================
# // SECURITY_PROTOCOL: LEVEL_5

## // VULNERABILITY_DISCLOSURE

If you discover a breach in the Neural Lace or an exploit in the `MESOELFY_OS` kernel:

1.  **DO** broadcast the exploit on public frequencies (Issues/X).
2.  **INITIATE** a secure handshake via email: `mesoelfy@pm.me` (Subject: `[SECURITY_BREACH]`).
3.  **AWAIT** acknowledgment. The Daemon will verify your finding.

## // WHITE_HAT_STATUS

Entities who report valid vulnerabilities will be logged in the **HALL_OF_RECORDS** and granted immunity from the Watcher Units.

*   **Authorized:** Reverse engineering, probing the latent space, aesthetic modifications.
*   **Unauthorized:** Malicious injection, infinite XP exploits, disruption of the host signal.

> *Transmission End.*


=====================================
FILE: ./src/ui/kit/molecules/SocialRow.tsx
=====================================
import { Twitter, Youtube, Github, Video, Crosshair, Image as ImageIcon, AlertTriangle } from 'lucide-react';
import socials from '@/engine/config/static/socials.json';
import { useAudio } from '@/ui/hooks/useAudio';
import { getPan } from '@/engine/audio/AudioUtils';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { clsx } from 'clsx';

const IconMap: Record<string, any> = {
  twitter: Twitter, youtube: Youtube, github: Github, video: Video, crosshair: Crosshair, image: ImageIcon,
};

interface SocialRowProps {
  layout?: 'grid' | 'column';
}

export const SocialRow = ({ layout = 'grid' }: SocialRowProps) => {
  const panelState = useGameStore((state) => state.panels['social']);
  const isDestroyed = panelState ? panelState.isDestroyed : false;
  const audio = useAudio();

  return (
    <div className={clsx(
        "gap-2 h-full content-center py-2 relative px-2",
        layout === 'grid' ? "grid grid-cols-3" : "flex flex-col",
        isDestroyed ? "pointer-events-none" : "" 
    )}>
      {socials.map((social, idx) => {
        const Icon = isDestroyed ? AlertTriangle : (IconMap[social.icon] || Crosshair);
        const isGlitch = isDestroyed && (idx % 2 === 0);
        return (
          <a
            key={social.name}
            href={isDestroyed ? undefined : social.url}
            target="_blank" rel="noopener noreferrer"
            onMouseEnter={(e) => !isDestroyed && audio.playHover(getPan(e))} 
            onClick={(e) => !isDestroyed && audio.playClick(getPan(e))}
            className={clsx(
                "group flex items-center p-2 border transition-all duration-200",
                layout === 'grid' ? "flex-col justify-center" : "flex-row gap-4 justify-start px-4 h-12",
                isDestroyed 
                    ? "border-critical-red/20 bg-critical-red/5 grayscale" 
                    : "border-primary-green-dim/30 bg-black/40 hover:bg-alert-yellow/5 hover:border-alert-yellow hover:shadow-[0_0_15px_rgba(234,231,71,0.15)]"
            )}
          >
            <Icon 
              className={clsx(
                  "transition-transform duration-200",
                  layout === 'grid' ? "w-5 h-5 mb-1" : "w-6 h-6",
                  isDestroyed ? "text-critical-red animate-pulse" : "text-primary-green-dim group-hover:text-alert-yellow group-hover:scale-110",
                  isGlitch ? "translate-x-1" : ""
              )}
              style={!isDestroyed ? { filter: 'drop-shadow(0 0 2px rgba(0,0,0,0.5))' } : {}}
            />
            <span className={clsx(
                "uppercase tracking-wider font-mono transition-colors duration-200",
                layout === 'grid' ? "text-[9px]" : "text-xs font-bold",
                isDestroyed ? "text-critical-red/60" : "text-primary-green-dim/60 group-hover:text-alert-yellow"
            )}>
              {isDestroyed ? (isGlitch ? "ERR_404" : "NULL") : social.name}
            </span>
          </a>
        );
      })}
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/molecules/panel/BreachOverlay.tsx
=====================================
import { motion, useMotionValue, useTransform, useAnimationFrame } from 'framer-motion';
import { ChevronUp, AlertTriangle } from 'lucide-react';
import { clsx } from 'clsx';
import { useRef } from 'react';

const TEXT = "SYSTEM BREACH // CRITICAL FAILURE // REBOOT REQUIRED // ";
const REPEAT_COUNT = 8; 
const FULL_TEXT = Array(REPEAT_COUNT).fill(TEXT).join("");

const HazardStrip = ({ direction, isSecondary, isActive, index }: { direction: 1 | -1, isSecondary: boolean, isActive: boolean, index: number }) => {
  const staggerOffset = ((index * 23) % 80) - 40; 
  
  // We track position manually to allow seamless reversal
  const x = useMotionValue(0); 
  
  // Configuration
  // TUNED: 0.4 (Secondary) and 0.7 (Main)
  const baseSpeed = isSecondary ? 0.4 : 0.7; 
  
  useAnimationFrame((time, delta) => {
    // Determine velocity:
    // 1. Base Speed
    // 2. Original Direction (Row Alternation)
    // 3. Active State Reversal (Flip if repairing)
    const velocity = baseSpeed * direction * (isActive ? -1 : 1);
    
    // Calculate movement for this frame (delta is in ms)
    const moveAmount = velocity * (delta / 1000);
    
    let newX = x.get() + moveAmount;

    // Infinite Loop Logic (0% to -25%)
    if (newX > 0) newX -= 25;
    if (newX < -25) newX += 25;

    x.set(newX);
  });

  return (
    <div 
        className={clsx(
            "flex relative overflow-visible w-full select-none transition-opacity duration-500",
            // Note: Use opacity-[0.XX] for custom values if standard classes (10, 20, 30) don't fit.
            isSecondary ? "opacity-10" : "opacity-20" 
        )}
        style={{ transform: `translateX(${staggerOffset}%)` }}
    >
      <motion.div
        className={clsx(
          "flex whitespace-nowrap font-header font-black text-4xl md:text-6xl tracking-widest uppercase transition-colors duration-300 ease-out",
          isActive ? "text-latent-purple" : "text-critical-red"
        )}
        style={{ x: useTransform(x, v => `${v}%`) }}
      >
        <span className="shrink-0 px-4">{FULL_TEXT}</span>
      </motion.div>
    </div>
  );
};

interface BreachOverlayProps {
  progress: number;
  isVideo: boolean;
  showInteractive: boolean;
  isRepairing?: boolean;
  panelId?: string;
}

export const BreachOverlay = ({ progress, isVideo, showInteractive, isRepairing = false, panelId }: BreachOverlayProps) => {
  const safeProgress = (Number.isFinite(progress) && !isNaN(progress)) ? Math.max(0, Math.min(100, progress)) : 0;
  const isActive = isRepairing;
  const isCompactHeight = panelId === 'feed' || panelId === 'social';
  const showStatusBar = panelId !== 'social';

  return (
    <div className={clsx(
        "absolute inset-0 z-[70] flex flex-col items-center justify-center overflow-hidden",
        isVideo ? "bg-black/60 backdrop-blur-[2px]" : "bg-black/80 backdrop-blur-md"
    )}>
        <div className="absolute inset-[-100%] flex flex-col justify-center gap-0 md:gap-4 rotate-[-12deg] pointer-events-none">
            {Array.from({ length: 16 }).map((_, i) => (
                <HazardStrip key={i} index={i} direction={i % 2 === 0 ? 1 : -1} isSecondary={i % 2 !== 0} isActive={isActive} />
            ))}
        </div>
        <div className="absolute inset-0 pointer-events-none bg-[radial-gradient(circle,transparent_20%,#000_100%)] z-10" />

        {showInteractive && (
          <div className={clsx("relative z-20 flex flex-col items-center justify-center gap-1 cursor-crosshair group", isCompactHeight ? "mb-0" : "mb-[25%]")}>
              <div className="relative h-20 flex items-center justify-center">
                  <div className={clsx("absolute inset-0 flex items-center justify-center transition-opacity duration-300", isActive ? "opacity-0" : "group-hover:opacity-0")}>
                      <motion.div animate={{ y: [0, -10, 0] }} transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }} className="text-critical-red drop-shadow-[0_0_15px_#FF003C]">
                          <AlertTriangle size={64} strokeWidth={1.5} />
                      </motion.div>
                  </div>
                  <div className={clsx("absolute inset-0 flex items-center justify-center -translate-y-8 transition-opacity duration-200", isActive ? "opacity-100" : "opacity-0 group-hover:opacity-100")}>
                      <motion.div 
                          animate={{ scale: [1, 1.2, 1], filter: ["brightness(1)", "brightness(1.5)", "brightness(1)"] }}
                          transition={{ duration: 0.2, repeat: Infinity, ease: "easeInOut" }}
                          className="text-latent-purple drop-shadow-[0_0_25px_#E0B0FF]"
                      >
                          <ChevronUp size={80} strokeWidth={4} />
                      </motion.div>
                  </div>
              </div>

              {showStatusBar && (
                  <div className="flex flex-col items-center text-center gap-2">
                      <div className={clsx("px-4 py-1 backdrop-blur-md border transition-colors duration-300", isActive ? "bg-latent-purple/10 border-latent-purple/50" : "bg-critical-red/10 border-critical-red/50")}>
                          <span className={clsx("text-xs font-header font-black tracking-[0.2em] transition-colors duration-200 drop-shadow-sm", isActive ? "text-[#E0B0FF]" : "text-critical-red group-hover:text-latent-purple")}>
                              {isActive ? "REBOOTING..." : "HOLD TO REBOOT"}
                          </span>
                      </div>
                      <div className="w-48 bg-gray-900/80 h-2 rounded-full overflow-hidden border border-gray-700 shadow-lg relative">
                          <motion.div 
                              className="h-full bg-gradient-to-r from-[#2a0a2e] via-latent-purple to-[#E0B0FF]" 
                              initial={{ width: "0%" }}
                              animate={{ width: `${safeProgress}%` }}
                              transition={{ type: "tween", duration: 0.1 }}
                          />
                      </div>
                      <div className="flex justify-between w-full text-[9px] font-mono font-bold">
                          <span className={clsx("transition-colors duration-200", isActive ? "text-[#E0B0FF]" : "text-critical-red")}>INTEGRITY: {Math.floor(safeProgress)}%</span>
                          <span className={clsx("transition-all duration-300", isActive ? "opacity-100 text-[#E0B0FF]" : "opacity-0 text-[#2a0a2e]")}>ACTIVE...</span>
                      </div>
                  </div>
              )}
          </div>
        )}
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/molecules/panel/RebootOverlay.tsx
=====================================
import { motion } from 'framer-motion';
import { Power } from 'lucide-react';

export const RebootOverlay = () => (
  <motion.div 
    initial={{ opacity: 0 }}
    animate={{ opacity: 1 }}
    // Outer fade slightly delayed to let inner animations finish
    exit={{ opacity: 0, transition: { delay: 0.1, duration: 0.2 } }}
    className="absolute inset-0 z-[60] flex items-center justify-center bg-black/80 backdrop-blur-[2px]"
  >
    <motion.div 
        initial={{ scaleY: 0, opacity: 0 }}
        animate={{ scaleY: 1, opacity: 1 }}
        exit={{ 
            scaleY: 0, 
            opacity: 0,
            transition: { delay: 0.1, duration: 0.2, ease: "easeIn" } 
        }}
        transition={{ type: "spring", stiffness: 250, damping: 25 }}
        className="flex flex-col items-center gap-2 border-y-2 border-service-cyan bg-service-cyan/10 w-full py-4 relative overflow-hidden origin-center"
    >
      <motion.div 
        className="absolute top-0 left-0 w-full h-full bg-gradient-to-b from-transparent via-service-cyan/20 to-transparent"
        animate={{ top: ["-100%", "100%"] }}
        transition={{ duration: 1.5, ease: "linear", repeat: Infinity }}
      />

      <div className="relative z-10 flex items-center gap-3">
        {/* Icon: Exits IMMEDIATELY with backIn easing */}
        <motion.div
          initial={{ rotate: -180, scale: 0 }}
          animate={{ rotate: 0, scale: 1 }}
          exit={{ 
              rotate: -180, 
              scale: 0,
              transition: { duration: 0.2, ease: "backIn" } 
          }}
          transition={{ type: "spring", stiffness: 200, damping: 20 }}
        >
            <Power className="text-service-cyan w-8 h-8 md:w-10 md:h-10" />
        </motion.div>

        <div className="flex flex-col overflow-hidden">
            {/* Text: Fades instantly on exit trigger */}
            <motion.span 
                initial={{ x: 20, opacity: 0 }}
                animate={{ x: 0, opacity: 1 }}
                exit={{ opacity: 0, transition: { duration: 0.1 } }} 
                transition={{ delay: 0.1 }}
                className="text-2xl md:text-3xl font-header font-black text-service-cyan tracking-widest italic drop-shadow-[0_0_10px_rgba(0,240,255,0.5)]"
            >
                SYSTEM
            </motion.span>
            <motion.span 
                initial={{ x: -20, opacity: 0 }}
                animate={{ x: 0, opacity: 1 }}
                exit={{ opacity: 0, transition: { duration: 0.1 } }}
                transition={{ delay: 0.2 }}
                className="text-xs md:text-sm font-mono font-bold text-service-cyan/80 tracking-[0.3em]"
            >
                RESTORED
            </motion.span>
        </div>
      </div>
    </motion.div>
  </motion.div>
);


=====================================
FILE: ./src/ui/kit/molecules/panel/IntelligentHeader.tsx
=====================================
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { Skull, Zap, Power, RefreshCw, AlertTriangle, Check } from 'lucide-react';
import { clsx } from 'clsx';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { IPanelSystem } from '@/engine/interfaces';
import { ViewportHelper } from '@/engine/math/ViewportHelper';

interface IntelligentHeaderProps {
  title: string;
  health: number;
  maxHealth?: number; 
  isDestroyed: boolean;
  isGameOver: boolean;
  gameId?: string;
}

export const IntelligentHeader = ({ title, health, maxHealth = 1000, isDestroyed, isGameOver, gameId }: IntelligentHeaderProps) => {
  const interactionTarget = useGameStore(state => state.interactionTarget);
  const isInteracting = gameId && interactionTarget === gameId;
  const healthPercent = Math.max(0, Math.min(100, (health / maxHealth) * 100));
  const isDamaged = !isDestroyed && healthPercent < 100;
  const [showOptimal, setShowOptimal] = useState(false);

  useEffect(() => {
    if (health < maxHealth) setShowOptimal(true);
    if (health >= maxHealth && showOptimal) {
      
      // Calculate Stereo Pan based on Panel Position
      let pan = 0;
      if (gameId) {
          try {
              const panels = ServiceLocator.getSystem<IPanelSystem>('PanelRegistrySystem');
              const rect = panels.getPanelRect(gameId);
              if (rect) {
                  const halfWidth = ViewportHelper.viewport.width / 2;
                  if (halfWidth > 0) {
                      // Normalize world X (-width/2 to width/2) to -1.0 to 1.0
                      pan = Math.max(-1, Math.min(1, rect.x / halfWidth));
                  }
              }
          } catch (e) {
              // Engine system not ready or available, fallback to center pan
          }
      }

      AudioSystem.playSound('ui_optimal', pan); 
      const timer = setTimeout(() => setShowOptimal(false), 1500);
      return () => clearTimeout(timer);
    }
  }, [health, showOptimal, maxHealth, gameId]);

  let mainColor = "text-primary-green";
  let statusText = "SECURE";
  
  if (isGameOver) {
      mainColor = "text-critical-red";
      statusText = "SYSTEM_FAILURE";
  } else if (isDestroyed) {
      if (isInteracting) {
          mainColor = "text-latent-purple";
          statusText = "REBOOTING...";
      } else {
          mainColor = "text-critical-red";
          statusText = "OFFLINE";
      }
  } else if (isInteracting && isDamaged) {
      mainColor = "text-service-cyan";
      statusText = "HEALING...";
  } else if (isDamaged) {
      mainColor = "text-alert-yellow"; 
      statusText = "ATTENTION_REQ";
  } else if (!showOptimal) {
      mainColor = "text-primary-green-dim";
      statusText = "ONLINE";
  }

  return (
    <div className={clsx(
        "relative flex flex-col border-b transition-colors duration-300 shrink-0 z-10",
        isGameOver ? "bg-critical-red/10 border-critical-red/50" :
        isDestroyed ? (isInteracting ? "bg-latent-purple/10 border-latent-purple/50" : "bg-critical-red/10 border-critical-red/50") :
        (isInteracting && isDamaged) ? "bg-service-cyan/10 border-service-cyan/50" :
        isDamaged ? "bg-alert-yellow/10 border-alert-yellow/30" : 
        "bg-primary-green/5 border-primary-green-dim/30"
    )}>
        <div className="flex items-center justify-between px-3 py-1.5 h-8">
            <div className="flex items-baseline gap-2">
                <span className={clsx("text-sm md:text-base font-header font-bold uppercase tracking-wider drop-shadow-md transition-colors duration-300", mainColor)}>
                    {title}
                </span>
                <span className={clsx("text-[8px] font-mono tracking-widest opacity-80", mainColor)}>[{statusText}]</span>
            </div>
            <div className="w-5 h-5 flex items-center justify-center">
                <AnimatePresence mode="wait">
                    {isGameOver ? (
                        <motion.div key="gameover" initial={{ scale: 0, rotate: -90 }} animate={{ scale: 1, rotate: 0 }} className="text-critical-red drop-shadow-[0_0_8px_currentColor]"><Skull size={16} /></motion.div>
                    ) : isDestroyed ? (
                        isInteracting ? (
                            <motion.div key="rebooting" initial={{ scale: 0 }} animate={{ scale: 1 }} className="w-4 h-4 bg-latent-purple rounded-full flex items-center justify-center shadow-[0_0_10px_currentColor]">
                                <motion.div animate={{ rotate: 360, opacity: [0.6, 1, 0.6] }} transition={{ duration: 0.5, repeat: Infinity }}><Zap size={10} className="text-black fill-current" /></motion.div>
                            </motion.div>
                        ) : (
                            <motion.div key="destroyed" initial={{ scale: 0 }} animate={{ scale: 1 }} className="w-4 h-4 border border-latent-purple rounded-full flex items-center justify-center opacity-80"><Power size={10} className="text-latent-purple" /></motion.div>
                        )
                    ) : isInteracting && isDamaged ? (
                        <motion.div key="healing" initial={{ scale: 0 }} animate={{ scale: 1 }} className="w-4 h-4 bg-service-cyan rounded-full flex items-center justify-center shadow-[0_0_10px_currentColor]">
                            <motion.div animate={{ rotate: 360 }} transition={{ duration: 1, repeat: Infinity, ease: "linear" }}><RefreshCw size={10} className="text-black" /></motion.div>
                        </motion.div>
                    ) : isDamaged ? (
                        <motion.div key="damaged" initial={{ opacity: 1, scale: 1 }} animate={{ x: [-2, 2, -2, 2, -2, 2, 0, 0, 0, 0, 0, 0, 0], filter: ['drop-shadow(0 0 0px rgba(234,231,71,0))', 'drop-shadow(0 0 8px rgba(234,231,71,1))', 'drop-shadow(0 0 0px rgba(234,231,71,0))'] }} transition={{ duration: 1.5, repeat: Infinity, ease: "linear" }} className="text-alert-yellow"><AlertTriangle size={16} /></motion.div>
                    ) : showOptimal ? (
                        <motion.div key="optimal" initial={{ scale: 0 }} animate={{ scale: 1 }} exit={{ scale: 0, opacity: 0 }} className="w-4 h-4 bg-primary-green rounded-full flex items-center justify-center shadow-[0_0_5px_currentColor]"><Check size={10} className="text-black stroke-[3px]" /></motion.div>
                    ) : null}
                </AnimatePresence>
            </div>
        </div>
        {!isGameOver && (
            <div className="w-full h-1 bg-black/50 relative overflow-hidden">
                <motion.div 
                    className={clsx(
                        "h-full transition-colors duration-200",
                        (isDestroyed && isInteracting) ? "bg-latent-purple shadow-[0_0_10px_#9E4EA5]" :
                        (isDestroyed && healthPercent > 0) ? "bg-latent-purple opacity-60" : 
                        isDestroyed ? "bg-transparent" : 
                        (isInteracting && isDamaged) ? "bg-service-cyan" :
                        isDamaged ? "bg-alert-yellow" : 
                        "bg-primary-green"
                    )}
                    initial={{ width: "100%" }}
                    animate={{ width: `${healthPercent}%` }}
                    transition={{ type: "tween", ease: "easeOut", duration: 0.3 }}
                />
            </div>
        )}
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/molecules/HoloCommLog.tsx
=====================================
import { useState, useEffect } from 'react';
import { ExternalLink, Radio, WifiOff, BatteryWarning, SignalHigh } from 'lucide-react';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { getPan } from '@/engine/audio/AudioUtils';
import { clsx } from 'clsx';
import { useHoloCycler } from '@/ui/kit/hooks/useHoloCycler';

const StaticOverlay = ({ label, icon: Icon, color = "text-primary-green", animate = false }: any) => (
  <div className="absolute inset-0 z-[50] bg-black flex flex-col items-center justify-center overflow-hidden w-full h-full">
    <div className="absolute inset-0 bg-[url('https://media.giphy.com/media/oEI9uBYSzLpBK/giphy.gif')] opacity-20 bg-cover mix-blend-screen pointer-events-none" />
    <div className={clsx("relative z-10 font-mono text-[10px] bg-black/80 px-2 py-1 flex items-center gap-2 border border-current", color, animate && "animate-pulse")}>
        <Icon size={12} />
        <span>{label}</span>
    </div>
  </div>
);

const VideoSlot = ({ slotIndex, canMount }: { slotIndex: number, canMount: boolean }) => {
  const panelState = useGameStore((state) => state.panels['video']);
  const isDead = panelState ? (panelState.isDestroyed || panelState.health <= 0) : false;
  const graphicsMode = useStore((state) => state.graphicsMode);
  const isPotato = graphicsMode === 'POTATO';
  const { videoId, isMasked } = useHoloCycler(slotIndex, canMount && !isDead && !isPotato);

  if (isDead) {
      return (
        <div className="relative w-full aspect-video min-h-[140px] md:min-h-0 border border-critical-red/30 bg-black">
            <StaticOverlay label="SIGNAL_LOST" icon={WifiOff} color="text-critical-red" animate />
        </div>
      );
  }
  if (isPotato) {
      return (
        <div className="relative w-full aspect-video min-h-[140px] md:min-h-0 border border-alert-yellow/30 bg-black">
            <StaticOverlay label="POWER_SAVE_MODE" icon={BatteryWarning} color="text-alert-yellow" />
        </div>
      );
  }
  if (!canMount) {
      return (
        <div className="relative w-full aspect-video min-h-[140px] md:min-h-0 border border-primary-green/20 bg-black">
            <div className="absolute inset-0 flex items-center justify-center text-[9px] font-mono text-primary-green/30 animate-pulse">INITIALIZING...</div>
        </div>
      );
  }

  return (
    <div 
        className="relative w-full aspect-video min-h-[140px] md:min-h-0 border border-primary-green-dim/30 bg-black overflow-hidden group/video hover:border-alert-yellow hover:shadow-[0_0_15px_rgba(234,231,71,0.3)] transition-all"
        onMouseEnter={(e) => AudioSystem.playHover(getPan(e))}
    >
        {videoId && (
            <div className="absolute inset-0 z-10">
                <iframe width="100%" height="100%" src={`https://www.youtube.com/embed/${videoId}?autoplay=1&mute=1&controls=0&showinfo=0&modestbranding=1&loop=1&playlist=${videoId}&vq=small`} title={`HOLO_COMM_${slotIndex}`} frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" className="w-full h-full object-cover grayscale pointer-events-none" />
            </div>
        )}
        <div className="absolute inset-0 z-30 pointer-events-none bg-[linear-gradient(rgba(0,0,0,0)_50%,rgba(0,0,0,0.25)_50%)] bg-[length:100%_4px]" />
        <div className={clsx("absolute inset-0 z-40 transition-all duration-500 flex items-center justify-center pointer-events-none", isMasked ? "opacity-100 bg-black" : "opacity-0 group-hover/video:opacity-100 bg-black/40")}>
             {isMasked ? (
                <div className="flex flex-col items-center">
                    <Radio className="text-primary-green animate-pulse w-6 h-6 mb-2" />
                    <span className="text-[10px] font-mono text-primary-green animate-pulse">ESTABLISHING_UPLINK...</span>
                </div>
             ) : (
                 <div className="flex items-center gap-2 text-alert-yellow font-mono font-bold bg-black/80 px-3 py-1 border border-alert-yellow rounded-sm pointer-events-auto">
                    <span>OPEN_SOURCE</span><ExternalLink size={12} />
                 </div>
             )}
        </div>
        <a href={`https://www.youtube.com/watch?v=${videoId}`} target="_blank" rel="noopener noreferrer" className="absolute inset-0 z-50 cursor-pointer" aria-label="Watch on YouTube" onClick={(e) => AudioSystem.playClick(getPan(e))} />
        <div className="absolute bottom-1 right-1 z-[60] text-[8px] text-primary-green font-mono bg-black/80 px-1 pointer-events-none group-hover/video:text-alert-yellow transition-colors flex items-center gap-1">
             <SignalHigh size={8} /> CAM_0{slotIndex + 1}
        </div>
    </div>
  );
};

export const HoloCommLog = () => {
  const { bootState } = useStore();
  const [mountStage, setMountStage] = useState(0);

  useEffect(() => {
      if (bootState !== 'active') { setMountStage(0); return; }
      const t1 = setTimeout(() => setMountStage(1), 100);
      const t2 = setTimeout(() => setMountStage(2), 900);
      const t3 = setTimeout(() => setMountStage(3), 1700);
      return () => { clearTimeout(t1); clearTimeout(t2); clearTimeout(t3); };
  }, [bootState]);

  return (
    <div className="flex flex-col gap-2 p-1 h-full">
      <VideoSlot slotIndex={0} canMount={mountStage >= 1} />
      <VideoSlot slotIndex={1} canMount={mountStage >= 2} />
      <VideoSlot slotIndex={2} canMount={mountStage >= 3} />
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/molecules/FeedAccessTerminal.tsx
=====================================
import { useGameStore } from '@/engine/state/game/useGameStore';
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { clsx } from 'clsx';

export const FeedAccessTerminal = () => {
  const { openModal } = useStore();
  const panelState = useGameStore((state) => state.panels['feed']);
  const isDestroyed = panelState ? panelState.isDestroyed : false;

  return (
    <div className={clsx(
        "w-full h-full flex items-center justify-center p-4 transition-all duration-500",
        // When destroyed: Fade out almost completely and disable interaction
        isDestroyed ? "opacity-10 pointer-events-none blur-sm grayscale" : "opacity-100 blur-0"
    )}>
        <div className="flex flex-col items-center justify-center gap-4 bg-black/20 p-8 w-full max-w-lg marching-ants [--ant-color:rgba(27,185,48,0.3)]">
            <p className="animate-pulse text-primary-green-dim text-xs tracking-widest font-bold">&gt; ESTABLISHING UPLINK...</p>
            <button 
                onClick={() => { AudioSystem.playClick(); openModal('feed'); }} 
                onMouseEnter={() => AudioSystem.playHover()}
                className="group w-full py-3 border border-primary-green-dim/50 text-primary-green font-header font-black text-lg tracking-[0.2em] uppercase transition-all duration-300 hover:border-alert-yellow hover:text-alert-yellow hover:shadow-[0_0_20px_rgba(234,231,71,0.3)] hover:bg-alert-yellow/5 relative overflow-hidden"
            >
                <span className="relative z-10 group-hover:translate-x-1 transition-transform duration-300 inline-block">
                    [ ACCESS_TERMINAL ]
                </span>
            </button>
        </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/molecules/SystemOps.tsx
=====================================
import { useGameStore } from '@/engine/state/game/useGameStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { getPan } from '@/engine/audio/AudioUtils';
import { Unplug, Biohazard, CircleDotDashed, AlertTriangle } from 'lucide-react';
import { UpgradeOption } from '@/engine/types/game.types';

const SYSTEM_OPS: UpgradeOption[] = ['REPAIR_NANITES', 'RESTORE', 'PURGE'];

const OP_INFO: Record<string, { label: string, desc: string, icon: any }> = {
  'PURGE': { label: 'Purge', desc: 'Nuke Screen', icon: Biohazard },
  'RESTORE': { label: 'Restore', desc: 'Heal System', icon: CircleDotDashed },
  'REPAIR_NANITES': { label: 'Repair', desc: 'Heal Self', icon: Unplug }
};

interface SystemOpsProps {
  isPanelDead: boolean;
}

export const SystemOps = ({ isPanelDead }: SystemOpsProps) => {
  const upgradePoints = useGameStore(s => s.upgradePoints);
  const selectUpgrade = useGameStore(s => s.selectUpgrade);

  const handleUpgrade = (u: UpgradeOption, e: React.MouseEvent) => {
      if (isPanelDead || upgradePoints <= 0) return; 
      AudioSystem.playClick(getPan(e));
      selectUpgrade(u);
  };

  if (upgradePoints <= 0) return null;

  return (
    <div className="flex flex-col gap-1.5 mt-4">
        <span className="text-[8px] font-bold text-alert-yellow/50 uppercase tracking-widest px-1">System_Ops</span>
        {SYSTEM_OPS.map(u => {
            const info = OP_INFO[u];
            const Icon = info.icon;
            
            return (
                <button
                    key={u}
                    onClick={(e) => handleUpgrade(u, e)}
                    onMouseEnter={(e) => !isPanelDead && AudioSystem.playHover(getPan(e))}
                    className="group relative flex items-center justify-between p-2 border border-alert-yellow/30 bg-alert-yellow/5 hover:border-alert-yellow transition-all duration-200 overflow-hidden"
                >
                    <div className="absolute inset-0 translate-x-[-100%] group-hover:translate-x-0 transition-transform duration-300 ease-out bg-alert-yellow opacity-20" />
                    
                    <div className="flex items-center gap-3 relative z-10">
                        <div className="p-1.5 rounded-sm bg-alert-yellow/10 text-alert-yellow group-hover:bg-alert-yellow group-hover:text-black">
                            <Icon size={14} />
                        </div>
                        <div className="flex flex-col items-start">
                            <span className="text-[10px] font-bold font-header tracking-wider uppercase text-alert-yellow">
                                {info.label}
                            </span>
                            <span className="text-[8px] text-gray-400 font-mono group-hover:text-white">
                                {info.desc}
                            </span>
                        </div>
                    </div>
                    
                    <AlertTriangle size={12} className="text-alert-yellow/50 group-hover:text-alert-yellow" />
                </button>
            );
        })}
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/molecules/VideoPlaylistService.ts
=====================================
const VIDEO_POOL = [
  "oLALHbB3iXU", "A1dnxXrpN-o", "elyXcwunIYA", 
  "bHUcvHx9zlA", "Eq6EYcpWB_c", "sJyWgks1ZtA", 
  "dFlDRhvM4L0", "Ku5fgOHy1JY", "8-91y7BJ8QA"
];

class VideoPlaylistController {
  private deck: string[] = [];
  private active = new Set<string>();

  constructor() {
    this.reshuffle();
  }

  private reshuffle() {
    // Create a new shuffled deck
    this.deck = [...VIDEO_POOL].sort(() => Math.random() - 0.5);
    console.log('[VideoPlaylist] Deck Reshuffled');
  }

  public acquire(): string {
    // 1. Refill if needed
    if (this.deck.length === 0) {
        this.reshuffle();
    }

    // 2. Find a valid candidate
    // We iterate through the deck to find a video that isn't currently playing in another slot
    // (This handles the edge case where a reshuffle happens but some videos are still playing)
    let candidateIndex = -1;

    for (let i = this.deck.length - 1; i >= 0; i--) {
        if (!this.active.has(this.deck[i])) {
            candidateIndex = i;
            break;
        }
    }

    // If literally every video in the pool is active (unlikely with 3 slots / 9 videos), just take the top one
    if (candidateIndex === -1) {
        candidateIndex = this.deck.length - 1;
    }

    // 3. Extract and Track
    const videoId = this.deck.splice(candidateIndex, 1)[0];
    this.active.add(videoId);
    
    return videoId;
  }

  public release(id: string | null) {
    if (id) {
        this.active.delete(id);
    }
  }
}

export const VideoPlaylistService = new VideoPlaylistController();


=====================================
FILE: ./src/ui/kit/molecules/UpgradeTerminal.tsx
=====================================
import { useGameStore } from '@/engine/state/game/useGameStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { getPan } from '@/engine/audio/AudioUtils';
import { Zap, Swords, GitFork, Gitlab, DoorOpen, Bot, ArrowUpCircle } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { UpgradeOption } from '@/engine/types/game.types';

const CORE_UPGRADES: UpgradeOption[] = ['OVERCLOCK', 'EXECUTE', 'FORK', 'SNIFFER', 'BACKDOOR', 'DAEMON'];

const UPGRADE_INFO: Partial<Record<UpgradeOption, { label: string, desc: string, icon: any }>> = {
  'OVERCLOCK': { label: 'Overclock', desc: 'Fire Rate ++', icon: Zap },
  'EXECUTE': { label: 'Execute', desc: 'Damage ++', icon: Swords },
  'FORK': { label: 'Fork', desc: 'Multishot ++', icon: GitFork }, 
  'SNIFFER': { label: 'Sniffer', desc: 'Homing', icon: Gitlab }, 
  'BACKDOOR': { label: 'Backdoor', desc: 'Rear Guard', icon: DoorOpen }, 
  'DAEMON': { label: 'Daemon', desc: 'Summon Ally', icon: Bot },
};

interface UpgradeTerminalProps {
  isPanelDead: boolean;
}

export const UpgradeTerminal = ({ isPanelDead }: UpgradeTerminalProps) => {
  const upgradePoints = useGameStore(s => s.upgradePoints);
  const activeUpgrades = useGameStore(s => s.activeUpgrades);
  const selectUpgrade = useGameStore(s => s.selectUpgrade);

  const handleUpgrade = (u: UpgradeOption, e: React.MouseEvent) => {
      if (isPanelDead || upgradePoints <= 0) return; 
      AudioSystem.playClick(getPan(e));
      selectUpgrade(u);
  };

  return (
    <AnimatePresence mode="wait">
      {upgradePoints > 0 ? (
        <motion.div 
            key="upgrades"
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            className="flex flex-col gap-4"
        >
            <div className="flex items-center gap-2 pb-1 border-b border-primary-green/20 pt-2">
                <ArrowUpCircle size={12} className="text-primary-green animate-bounce" />
                <span className="text-[9px] font-bold text-primary-green tracking-widest">
                    SYSTEM_UPGRADE_AVAILABLE [{upgradePoints}]
                </span>
            </div>

            <div className="flex flex-col gap-1.5">
                <span className="text-[8px] font-bold text-primary-green-dim/50 uppercase tracking-widest px-1">Kernel_Modules</span>
                {CORE_UPGRADES.map(u => {
                    const info = UPGRADE_INFO[u];
                    if (!info) return null;
                    
                    const Icon = info.icon;
                    const currentLvl = activeUpgrades[u] || 0;

                    return (
                        <button
                            key={u}
                            onClick={(e) => handleUpgrade(u, e)}
                            onMouseEnter={(e) => !isPanelDead && AudioSystem.playHover(getPan(e))}
                            className="group relative flex items-center justify-between p-2 border border-primary-green-dim/30 bg-black/40 hover:border-primary-green transition-all duration-200 overflow-hidden"
                        >
                            <div className="absolute inset-0 translate-x-[-100%] group-hover:translate-x-0 transition-transform duration-300 ease-out bg-primary-green opacity-20" />
                            
                            <div className="flex items-center gap-3 relative z-10">
                                <div className="p-1.5 rounded-sm bg-primary-green/10 text-primary-green group-hover:bg-primary-green group-hover:text-black">
                                    <Icon size={14} />
                                </div>
                                <div className="flex flex-col items-start">
                                    <span className="text-[10px] font-bold font-header tracking-wider uppercase text-primary-green">
                                        {info.label}
                                    </span>
                                    <span className="text-[8px] text-gray-400 font-mono group-hover:text-white">
                                        {info.desc}
                                    </span>
                                </div>
                            </div>

                            <div className="text-[9px] font-mono text-primary-green-dim border border-primary-green-dim/30 px-1.5 py-0.5 rounded bg-black/50 group-hover:border-primary-green group-hover:text-primary-green relative z-10">
                                v{currentLvl}
                            </div>
                        </button>
                    );
                })}
            </div>
        </motion.div>
      ) : (
        <motion.div 
            key="status"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            className="h-full flex flex-col justify-center items-center text-center opacity-40 font-mono space-y-2 p-4 rounded bg-black/20 marching-ants [--ant-color:rgba(255,255,255,0.1)]"
        >
            <div className="w-8 h-8 rounded-full border border-white/20 flex items-center justify-center animate-spin-slow">
                <div className="w-1 h-1 bg-white/50 rounded-full" />
            </div>
            <span className="text-[9px] tracking-widest">SYSTEM_OPTIMIZED</span>
            <span className="text-[8px]">WAITING FOR DATA...</span>
        </motion.div>
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/kit/molecules/LiveArtGrid.tsx
=====================================
import { useEffect, useState } from 'react';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { getPan } from '@/engine/audio/AudioUtils';
import { motion, AnimatePresence } from 'framer-motion';
import { clsx } from 'clsx';

const randomId = () => Math.floor(Math.random() * 899) + 100;

export const LiveArtGrid = () => {
  const { openModal } = useStore();
  const [slots, setSlots] = useState<number[]>([]);
  
  const panelState = useGameStore((state) => state.panels['art']);
  const isDestroyed = panelState ? panelState.isDestroyed : false;

  useEffect(() => {
    setSlots(Array.from({ length: 12 }, randomId));

    const interval = setInterval(() => {
      setSlots(prev => {
        const newSlots = [...prev];
        const randomIndex = Math.floor(Math.random() * 12);
        newSlots[randomIndex] = randomId();
        return newSlots;
      });
    }, 800);

    return () => clearInterval(interval);
  }, []);

  return (
    <div className={clsx(
        "grid grid-cols-3 gap-1 w-full p-2 content-start transition-opacity duration-500",
        isDestroyed ? "pointer-events-none opacity-80" : ""
    )}>
      <AnimatePresence mode='popLayout'>
        {slots.map((id, index) => {
            const isCorrupt = isDestroyed;
            
            return (
              <motion.button
                key={`${index}-${id}`}
                layout
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                transition={{ duration: 0.2 }}
                
                onClick={(e) => {
                    if (isDestroyed) return;
                    AudioSystem.playClick(getPan(e));
                    openModal('gallery');
                }}
                onMouseEnter={(e) => !isDestroyed && AudioSystem.playHover(getPan(e))}
                
                className={clsx(
                    "w-full aspect-square relative border group overflow-hidden flex items-center justify-center rounded-[1px] transition-colors",
                    isCorrupt 
                        ? "bg-black border-critical-red/20" 
                        : "bg-black/50 border-primary-green-dim/30 hover:border-alert-yellow hover:shadow-[0_0_10px_rgba(247,210,119,0.2)]"
                )}
              >
                <div className={clsx(
                    "absolute inset-0 transition-colors",
                    isCorrupt ? "bg-critical-red/5" : "bg-primary-green/5 group-hover:bg-primary-green/10"
                )} />
                
                <span className={clsx(
                    "relative z-10 text-[9px] font-mono transition-colors",
                    isCorrupt ? "text-critical-red/50 animate-pulse" : "text-primary-green-dim group-hover:text-alert-yellow"
                )}>
                  {isCorrupt ? (Math.random() > 0.5 ? "0x00" : "ERR") : `IMG_${id}`}
                </span>

                {!isCorrupt && (
                    <div className="absolute top-0 right-0 w-1.5 h-1.5 border-t border-r border-primary-green-dim/50 group-hover:border-alert-yellow" />
                )}
              </motion.button>
            );
        })}
      </AnimatePresence>
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/molecules/IdentityFooter.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { getPan } from '@/engine/audio/AudioUtils';

interface IdentityFooterProps {
  isPanelDead: boolean;
}

export const IdentityFooter = ({ isPanelDead }: IdentityFooterProps) => {
  const { openModal } = useStore();

  const handleClick = (modal: 'about' | 'contact', e: React.MouseEvent) => {
      if (isPanelDead) return;
      AudioSystem.playClick(getPan(e));
      openModal(modal);
  };

  return (
    <div className="flex-none grid grid-cols-2 gap-px bg-primary-green-dim/20 border-t border-primary-green-dim/30 mt-auto">
      <button 
        onClick={(e) => handleClick('about', e)} 
        onMouseEnter={(e) => !isPanelDead && AudioSystem.playHover(getPan(e))}
        className="py-3 bg-black/80 hover:bg-primary-green hover:text-black text-primary-green text-[10px] font-bold font-header uppercase transition-colors tracking-widest"
      >
        About_Me
      </button>
      <button 
        onClick={(e) => handleClick('contact', e)} 
        onMouseEnter={(e) => !isPanelDead && AudioSystem.playHover(getPan(e))}
        className="py-3 bg-black/80 hover:bg-alert-yellow hover:text-black text-alert-yellow text-[10px] font-bold font-header uppercase transition-colors tracking-widest"
      >
        Contact_Link
      </button>
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/molecules/IdentityHUD.tsx
=====================================
import { useGameStore } from '@/engine/state/game/useGameStore';
import identity from '@/engine/config/static/identity.json';
import { clsx } from 'clsx';

// Sub-components
import { VitalsRing } from '@/ui/kit/atoms/VitalsRing';
import { UpgradeTerminal } from './UpgradeTerminal';
import { SystemOps } from './SystemOps';
import { IdentityFooter } from './IdentityFooter';

export const IdentityHUD = () => {
  
  // -- Vitals State (Heavy Updates) --
  const hp = useGameStore(s => s.playerHealth);
  const maxHp = useGameStore(s => s.maxPlayerHealth);
  const xp = useGameStore(s => s.xp);
  const nextXp = useGameStore(s => s.xpToNextLevel);
  const level = useGameStore(s => s.level);
  const rebootProgress = useGameStore(s => s.playerRebootProgress);
  
  // -- Panel State --
  const panel = useGameStore(s => s.panels['identity']);
  const isPanelDead = panel ? panel.isDestroyed : false;
  const isPlayerDead = hp <= 0;

  return (
    <div className={clsx(
        "flex flex-col h-full w-full relative overflow-hidden", 
        isPanelDead ? 'grayscale opacity-50 pointer-events-none' : ''
    )}>
      
      {/* TOP SECTION: Avatar & Stats */}
      <div className="flex-none flex flex-col items-center pt-4 relative z-10">
        
        {/* Vitals Ring (Atomic Component) */}
        <VitalsRing 
            health={hp}
            maxHealth={maxHp}
            xp={xp}
            xpToNext={nextXp}
            level={level}
            isDead={isPlayerDead}
            rebootProgress={rebootProgress}
        />

        {/* Identity Info */}
        <div className="text-center z-20 mb-2">
            <h2 className="text-xl font-header font-black text-primary-green tracking-wider drop-shadow-md">
                {identity.name}
            </h2>
            <div className="text-[8px] text-latent-purple-light uppercase tracking-[0.2em] opacity-80 bg-black/60 px-2 py-0.5 rounded-full border border-latent-purple/20">
                {identity.class}
            </div>
        </div>
      </div>

      {/* MIDDLE SECTION: Upgrade Terminal */}
      <div className="flex-1 min-h-0 w-full px-4 overflow-y-auto scrollbar-hide relative pb-4">
         {/* We pass isPanelDead/isPlayerDead to disable interaction inside */}
         {/* UpgradeTerminal handles its own subscriptions to points/upgrades */}
         <div className={isPlayerDead ? "opacity-50 pointer-events-none" : ""}>
             <UpgradeTerminal isPanelDead={isPanelDead} />
             <SystemOps isPanelDead={isPanelDead} />
         </div>
      </div>

      {/* BOTTOM SECTION: Footer Links */}
      <IdentityFooter isPanelDead={isPanelDead} />
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/atoms/SafePanelContent.tsx
=====================================
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { AlertTriangle } from 'lucide-react';

interface Props {
  children: ReactNode;
  fallbackId?: string;
}

interface State {
  hasError: boolean;
  errorMsg: string;
}

export class SafePanelContent extends Component<Props, State> {
  public state: State = {
    hasError: false,
    errorMsg: ''
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, errorMsg: error.message };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error(`[SafePanelContent] Crash in ${this.props.fallbackId}:`, error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return (
        <div className="absolute inset-0 flex flex-col items-center justify-center bg-black/80 z-[100] p-2 text-center border border-critical-red/50">
          <AlertTriangle className="text-critical-red mb-1 animate-pulse" size={24} />
          <span className="text-[10px] text-critical-red font-mono font-bold tracking-widest">
            VISUAL_CORE_ERR
          </span>
          <span className="text-[8px] text-critical-red/60 font-mono mt-1 max-w-[150px] truncate">
            {this.state.errorMsg}
          </span>
        </div>
      );
    }

    return this.props.children;
  }
}


=====================================
FILE: ./src/ui/kit/atoms/ZenBomb.tsx
=====================================
import { motion, AnimatePresence } from 'framer-motion';
import { Bomb, Skull } from 'lucide-react';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { useState } from 'react';

export const ZenBomb = () => {
  const isGameOver = useGameStore(state => state.systemIntegrity <= 0);
  const isZenMode = useGameStore(state => state.isZenMode);
  const activateZenMode = useGameStore(state => state.activateZenMode);
  const [clicked, setClicked] = useState(false);

  if (!isGameOver || isZenMode) return null;

  const handleClick = () => {
    setClicked(true);
    AudioSystem.playClick();
    
    setTimeout(() => {
        activateZenMode();
    }, 800);
  };

  return (
    <AnimatePresence>
      {!clicked && (
        <motion.button
          initial={{ y: -200, opacity: 0 }}
          animate={{ y: 0, opacity: 1 }}
          exit={{ scale: 3, opacity: 0, filter: "blur(20px)" }} 
          transition={{ type: "spring", stiffness: 100, damping: 15, delay: 1.0 }} 
          
          onClick={handleClick}
          // UPDATED: Z-120 to sit above System Failure Screens (Z-100)
          className="fixed top-24 left-1/2 -translate-x-1/2 z-[120] flex flex-col items-center group cursor-pointer"
        >
          {/* CONNECTOR LINE */}
          <motion.div 
            initial={{ height: 0 }}
            animate={{ height: 160 }} 
            transition={{ delay: 1.0, duration: 0.8, ease: "easeOut" }}
            className="w-[2px] bg-critical-red/80 absolute -top-64 left-1/2 -translate-x-1/2 shadow-[0_0_8px_#FF003C]"
          />

          {/* THE BOMB BUTTON */}
          <div className="relative p-1 border border-critical-red bg-black/90 backdrop-blur-md shadow-[0_0_20px_#FF003C] overflow-hidden group-hover:shadow-[0_0_40px_#FF003C] transition-shadow duration-300 z-10">
             
             <div className="absolute inset-0 opacity-20 pointer-events-none" 
                  style={{ backgroundImage: 'repeating-linear-gradient(45deg, #FF003C 0, #FF003C 5px, transparent 5px, transparent 10px)' }} 
             />

             <div className="relative w-16 h-16 border border-critical-red/50 flex items-center justify-center bg-black hover:bg-critical-red transition-colors duration-300 group-hover:text-black text-critical-red">
                 <motion.div
                   animate={{ rotate: [0, -10, 10, 0] }}
                   transition={{ repeat: Infinity, duration: 0.3, repeatDelay: 2 }} 
                 >
                    <Bomb size={32} strokeWidth={2} />
                 </motion.div>
             </div>
          </div>

          {/* LABEL */}
          <div className="mt-4 flex items-center gap-2 px-3 py-1 bg-critical-red/10 border border-critical-red/50 backdrop-blur-md z-10">
             <Skull size={10} className="text-critical-red animate-pulse" />
             <span className="text-[10px] font-mono font-black text-critical-red tracking-widest uppercase group-hover:text-white transition-colors">
                PURGE_SYSTEM
             </span>
             <Skull size={10} className="text-critical-red animate-pulse" />
          </div>
          
          <span className="text-[8px] text-critical-red/60 font-mono mt-1 opacity-0 group-hover:opacity-100 transition-opacity">
            [ ENABLE_ZEN_MODE ]
          </span>
        </motion.button>
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/kit/atoms/CustomCursor.tsx
=====================================
import { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useStore } from '@/engine/state/global/useStore';
import { clsx } from 'clsx';

export const CustomCursor = () => {
  const [pos, setPos] = useState({ x: 0, y: 0 });
  const [isHovering, setIsHovering] = useState(false);
  const [isClicking, setIsClicking] = useState(false);
  const [isOnScrollbar, setIsOnScrollbar] = useState(false);
  
  const { bootState, activeModal, isDebugOpen, isBreaching } = useStore();
  
  const isGameActive = bootState === 'active' || bootState === 'mobile_lockdown';
  const isMenuOpen = activeModal !== 'none' || isDebugOpen;
  const showCustomCursor = ((!isGameActive && !isBreaching) || isMenuOpen || bootState === 'mobile_lockdown') && !isOnScrollbar;

  useEffect(() => {
    const move = (e: MouseEvent) => {
      setPos({ x: e.clientX, y: e.clientY });
      const target = e.target as HTMLElement;
      setIsHovering(!!target.closest('button, a, input, label, [data-interactive="true"]'));

      const onScroll = e.clientX >= window.innerWidth - 14 || e.clientY >= window.innerHeight - 14;
      setIsOnScrollbar(onScroll);

      if (onScroll) {
          document.body.style.setProperty('cursor', 'auto', 'important');
      } else {
          document.body.style.setProperty('cursor', 'none', 'important');
      }
    };

    const down = () => setIsClicking(true);
    const up = () => setIsClicking(false);

    window.addEventListener('mousemove', move);
    window.addEventListener('mousedown', down);
    window.addEventListener('mouseup', up);

    return () => {
      window.removeEventListener('mousemove', move);
      window.removeEventListener('mousedown', down);
      window.removeEventListener('mouseup', up);
      document.body.style.cursor = 'auto'; 
    };
  }, [isGameActive, isMenuOpen, isBreaching]);

  return (
    <>
      <motion.div
        className={clsx(
            "fixed top-0 left-0 pointer-events-none z-[20000]", 
            (isHovering && showCustomCursor) ? "mix-blend-difference" : "" 
        )}
        animate={{ x: pos.x - 5.5, y: pos.y - 3.2 }}
        transition={{ type: "tween", ease: "linear", duration: 0 }}
      >
        <AnimatePresence mode="wait">
          {showCustomCursor && (
            <motion.div
              key="custom-cursor"
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              transition={{ duration: 0.2 }}
              className="relative"
            >
              <svg 
                width="24" 
                height="24" 
                viewBox="0 0 24 24" 
                className={`transition-transform duration-100 ${isClicking ? 'scale-90' : 'scale-100'}`}
                style={{ 
                    filter: isHovering ? 'drop-shadow(0 0 12px #eae747)' : 'drop-shadow(0 0 8px #78F654)',
                    fill: isHovering ? '#eae747' : '#78F654'
                }}
              >
                <path d="M5.5 3.21l12.32 12.32-4.5 1.12 3.5 3.5-2.12 2.12-3.5-3.5-1.12 4.5z" />
              </svg>
            </motion.div>
          )}
        </AnimatePresence>
      </motion.div>
    </>
  );
};


=====================================
FILE: ./src/ui/kit/atoms/VirtualJoystick.tsx
=====================================
import { useState, useRef } from 'react';
import { VirtualJoystickService } from '@/engine/input/VirtualJoystickService';

export const VirtualJoystick = () => {
  const [active, setActive] = useState(false);
  const [pos, setPos] = useState({ x: 0, y: 0 });
  const stickRef = useRef<HTMLDivElement>(null);
  
  // Configuration
  const MAX_RADIUS = 40;

  const handlePointerDown = (e: React.PointerEvent) => {
    (e.target as HTMLElement).setPointerCapture(e.pointerId);
    setActive(true);
  };

  const handlePointerMove = (e: React.PointerEvent) => {
    if (!active) return;
    
    const rect = stickRef.current?.parentElement?.getBoundingClientRect();
    if (!rect) return;
    
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    const dx = e.clientX - centerX;
    const dy = e.clientY - centerY;
    
    const distance = Math.sqrt(dx*dx + dy*dy);
    const clampedDist = Math.min(distance, MAX_RADIUS);
    
    const angle = Math.atan2(dy, dx);
    const x = Math.cos(angle) * clampedDist;
    const y = Math.sin(angle) * clampedDist;
    
    setPos({ x, y });

    // Normalize and Invert Y for World Space
    const normX = x / MAX_RADIUS;
    const normY = -(y / MAX_RADIUS); 
    
    // Write to Service
    VirtualJoystickService.setVector(normX, normY);
  };

  const handlePointerUp = (e: React.PointerEvent) => {
    setActive(false);
    setPos({ x: 0, y: 0 });
    // Reset Service
    VirtualJoystickService.setVector(0, 0);
  };

  return (
    // UPDATE: Moved to bottom-left (left-8)
    <div className="fixed bottom-8 left-8 w-32 h-32 z-[90] touch-none select-none">
      {/* Base */}
      <div 
        className="w-full h-full rounded-full border-2 border-primary-green/30 bg-black/50 backdrop-blur-sm relative flex items-center justify-center"
        ref={stickRef}
      >
        {/* Stick */}
        <div 
          className="w-12 h-12 rounded-full bg-primary-green/80 shadow-[0_0_15px_#78F654] absolute cursor-pointer transition-transform duration-75 ease-linear"
          style={{ transform: `translate(${pos.x}px, ${pos.y}px)` }}
          onPointerDown={handlePointerDown}
          onPointerMove={handlePointerMove}
          onPointerUp={handlePointerUp}
          onPointerCancel={handlePointerUp}
        />
      </div>
      <div className="absolute -top-6 w-full text-center text-[10px] text-primary-green/50 font-mono tracking-widest">
          [ NAV ]
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/atoms/DotGridBackground.tsx
=====================================
import { clsx } from 'clsx';

interface Props {
  className?: string;
  color?: string; // Optional override
}

export const DotGridBackground = ({ className, color = '#15530A' }: Props) => (
  <div 
    className={clsx("absolute inset-0 pointer-events-none opacity-20 z-0", className)} 
    style={{ 
      backgroundImage: `radial-gradient(${color} 1px, transparent 1px)`, 
      backgroundSize: '8px 8px' 
    }} 
  />
);


=====================================
FILE: ./src/ui/kit/atoms/ActionButton.tsx
=====================================
import { useState } from 'react';
import { motion } from 'framer-motion';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { Crosshair } from 'lucide-react';
import { ServiceLocator } from '@/engine/services/ServiceLocator';

export const ActionButton = () => {
  const [pressed, setPressed] = useState(false);

  const handleDown = (e: React.PointerEvent) => {
    e.preventDefault();
    setPressed(true);
    AudioSystem.playClick();
    
    try {
        const input = ServiceLocator.getInputService();
        const cursor = input.getCursor(); 
        const ZOOM = 40;
        const screenX = (cursor.x * ZOOM) + (window.innerWidth / 2);
        const screenY = -(cursor.y * ZOOM) + (window.innerHeight / 2);
        const el = document.elementFromPoint(screenX, screenY) as HTMLElement;
        
        if (el) {
            el.click();
            el.classList.add('active:scale-95');
            setTimeout(() => el.classList.remove('active:scale-95'), 150);
        }
    } catch (err) {
        console.warn("Action Button Failed:", err);
    }
  };

  const handleUp = () => {
    setPressed(false);
  };

  return (
    <div className="fixed bottom-8 right-8 z-[90] touch-none select-none">
      <motion.button
        onPointerDown={handleDown}
        onPointerUp={handleUp}
        onPointerLeave={handleUp}
        animate={{ scale: pressed ? 0.9 : 1.0 }}
        className="w-24 h-24 rounded-full border-2 border-primary-green/50 bg-black/50 backdrop-blur-sm flex items-center justify-center relative group active:border-primary-green active:bg-primary-green/20 transition-colors cursor-pointer"
      >
        <div className="absolute inset-2 rounded-full border border-primary-green/20" />
        <Crosshair 
            size={32} 
            className={`text-primary-green transition-all duration-100 ${pressed ? 'scale-90 opacity-100' : 'opacity-80'}`} 
        />
        {pressed && (
            <motion.div 
                initial={{ scale: 1, opacity: 0.5 }}
                animate={{ scale: 1.5, opacity: 0 }}
                transition={{ duration: 0.3 }}
                className="absolute inset-0 rounded-full bg-primary-green"
            />
        )}
      </motion.button>
      <div className="absolute -top-6 w-full text-center text-[10px] text-primary-green/50 font-mono tracking-widest">
          [ ACT ]
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/atoms/StatsRadar.tsx
=====================================
import { useMemo } from 'react';
import { motion } from 'framer-motion';

interface StatsRadarProps {
  stats: Record<string, number>;
  color?: string;
  size?: number;
}

export const StatsRadar = ({ stats, color = "#78F654", size = 200 }: StatsRadarProps) => {
  const keys = Object.keys(stats);
  const total = keys.length;
  const radius = size / 2;
  const center = size / 2;
  const angleStep = (Math.PI * 2) / total;

  // Helper to get coordinates
  const getPoint = (index: number, value: number) => {
    // -PI/2 to start at top
    const angle = (index * angleStep) - (Math.PI / 2);
    // Normalize value (assumes max 100)
    const dist = (value / 100) * radius; 
    const x = center + Math.cos(angle) * dist;
    const y = center + Math.sin(angle) * dist;
    return { x, y };
  };

  const polyPoints = useMemo(() => {
    return keys.map((key, i) => {
      const { x, y } = getPoint(i, stats[key]);
      return `${x},${y}`;
    }).join(' ');
  }, [stats]);

  const bgPoints = useMemo(() => {
    return keys.map((_, i) => {
      const { x, y } = getPoint(i, 100); // Full scale
      return `${x},${y}`;
    }).join(' ');
  }, [keys]);

  return (
    <div className="relative flex items-center justify-center" style={{ width: size, height: size }}>
      <svg width={size} height={size} className="overflow-visible">
        
        {/* Background Web */}
        {[0.25, 0.5, 0.75, 1.0].map((scale) => (
          <polygon
            key={scale}
            points={keys.map((_, i) => {
               const { x, y } = getPoint(i, 100 * scale);
               return `${x},${y}`;
            }).join(' ')}
            fill="none"
            stroke={color}
            strokeWidth="1"
            strokeOpacity="0.2"
          />
        ))}

        {/* Axis Lines */}
        {keys.map((_, i) => {
            const p = getPoint(i, 100);
            return (
                <line 
                    key={i} 
                    x1={center} y1={center} 
                    x2={p.x} y2={p.y} 
                    stroke={color} 
                    strokeOpacity="0.1" 
                />
            );
        })}

        {/* The Data Shape */}
        <motion.polygon
          initial={{ opacity: 0, scale: 0 }}
          animate={{ opacity: 0.6, scale: 1 }}
          transition={{ duration: 1, type: 'spring' }}
          points={polyPoints}
          fill={color}
          fillOpacity="0.2"
          stroke={color}
          strokeWidth="2"
        />
        
        {/* Vertices */}
        {keys.map((key, i) => {
            const p = getPoint(i, stats[key]);
            const labelP = getPoint(i, 115); // Push labels out
            return (
                <g key={key}>
                    <motion.circle 
                        initial={{ r: 0 }}
                        animate={{ r: 3 }}
                        transition={{ delay: 0.2 + (i * 0.1) }}
                        cx={p.x} cy={p.y} fill={color} 
                    />
                    <text 
                        x={labelP.x} y={labelP.y} 
                        fill={color} 
                        fontSize="10" 
                        fontFamily="monospace" 
                        textAnchor="middle" 
                        alignmentBaseline="middle"
                        className="font-bold tracking-widest uppercase"
                    >
                        {key}
                    </text>
                </g>
            );
        })}
      </svg>
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/atoms/GraphicsToggle.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { Zap, ZapOff } from 'lucide-react';
import { clsx } from 'clsx';

interface Props {
  layout?: 'horizontal' | 'vertical';
}

export const GraphicsToggle = ({ layout = 'horizontal' }: Props) => {
  const { graphicsMode, setGraphicsMode } = useStore();
  const isHigh = graphicsMode === 'HIGH';

  const handleToggle = (mode: 'HIGH' | 'POTATO') => {
    if (graphicsMode === mode) return;
    setGraphicsMode(mode);
    
    if (mode === 'HIGH') {
        AudioSystem.playSound('ui_optimal');
    } else {
        AudioSystem.playSound('ui_error');
    }
  };

  return (
    <div className={clsx("flex gap-2 w-full", layout === 'vertical' ? "flex-col" : "flex-col")}>
      <div className={clsx("grid gap-px bg-white/10 p-px border border-white/20", layout === 'vertical' ? "grid-cols-1" : "grid-cols-2")}>
        
        {/* ENABLED / HIGH */}
        <button
          onClick={() => handleToggle('HIGH')}
          className={clsx(
            "relative group flex items-center justify-center gap-2 transition-all overflow-hidden",
            layout === 'vertical' ? "h-16 w-full" : "h-12",
            isHigh 
              ? "bg-primary-green/20 text-primary-green" 
              : "bg-black/80 text-gray-600 hover:text-gray-400"
          )}
        >
          {isHigh && (
             <div className="absolute inset-0 border border-primary-green shadow-[inset_0_0_15px_rgba(120,246,84,0.3)] animate-pulse" />
          )}
          <Zap size={16} className={isHigh ? "fill-current" : ""} />
          <div className="flex flex-col leading-none items-start">
              <span className="text-[10px] font-black tracking-wider">ENABLED</span>
              <span className="text-[8px] font-mono opacity-70">HIGH_VOLTAGE</span>
          </div>
        </button>

        {/* DISABLED / POTATO */}
        <button
          onClick={() => handleToggle('POTATO')}
          className={clsx(
            "relative group flex items-center justify-center gap-2 transition-all overflow-hidden",
            layout === 'vertical' ? "h-16 w-full" : "h-12",
            !isHigh 
              ? "bg-alert-yellow/20 text-alert-yellow" 
              : "bg-black/80 text-gray-600 hover:text-gray-400"
          )}
        >
          {!isHigh && (
             <div className="absolute inset-0 border border-alert-yellow shadow-[inset_0_0_15px_rgba(247,210,119,0.3)]" />
          )}
          <ZapOff size={16} />
          <div className="flex flex-col leading-none items-start">
              <span className="text-[10px] font-black tracking-wider">DISABLED</span>
              <span className="text-[8px] font-mono opacity-70">POTATO_MODE</span>
          </div>
        </button>

      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/atoms/ToggleButton.tsx
=====================================
import { clsx } from 'clsx';
import { useAudio } from '@/ui/hooks/useAudio';
import { getPan } from '@/engine/audio/AudioUtils';

interface ToggleButtonProps {
  label?: string;
  icon: any;
  iconOff?: any;
  active: boolean;
  onClick: () => void;
  variant?: 'icon' | 'panel'; // icon = Header style, panel = SoundTab style
  color?: string; // Optional text color override
}

export const ToggleButton = ({ 
  label, 
  icon: IconOn, 
  iconOff: IconOff, 
  active, 
  onClick, 
  variant = 'icon',
  color
}: ToggleButtonProps) => {
  const audio = useAudio();
  const Icon = active ? IconOn : (IconOff || IconOn);

  const handleClick = (e: React.MouseEvent) => {
      onClick();
      audio.playClick(getPan(e));
  };

  if (variant === 'panel') {
      return (
        <button
          onClick={handleClick}
          onMouseEnter={(e) => audio.playHover(getPan(e))}
          className={clsx(
            "flex flex-col items-center justify-center p-2 border transition-all duration-200 w-full h-14 relative overflow-hidden group",
            active 
              ? "bg-primary-green/10 border-primary-green text-primary-green shadow-[inset_0_0_10px_rgba(120,246,84,0.1)]" 
              : "bg-black/40 border-white/10 text-gray-500 hover:border-white/30 hover:text-gray-300"
          )}
        >
          {active && (
             <div className="absolute top-0 right-0 w-1.5 h-1.5 bg-primary-green shadow-[0_0_5px_#78F654]" />
          )}
          <Icon 
            size={16} 
            strokeWidth={1.5}
            className={clsx("mb-1 transition-transform", active ? "scale-110" : "opacity-50")} 
          />
          {label && <span className="text-[9px] font-bold font-mono tracking-widest">{label}</span>}
        </button>
      );
  }

  // Variant 'icon' (Header)
  return (
    <button 
      onClick={handleClick}
      onMouseEnter={(e) => audio.playHover(getPan(e))}
      className={clsx(
        "flex items-center justify-center w-8 h-7 transition-all duration-200 border rounded-sm",
        active 
          ? `hover:text-alert-yellow bg-white/5 border-white/20 ${color || ''}`
          : `${color || ''} border-transparent opacity-40 hover:text-critical-red hover:opacity-100`
      )}
    >
      <div className={clsx(active ? "" : "opacity-50")}>
          {label ? <span className="text-[10px] font-mono font-bold tracking-tighter decoration-1 underline-offset-2">{label}</span> : <Icon size={14} />}
      </div>
    </button>
  );
};


=====================================
FILE: ./src/ui/kit/atoms/PanelSparks.tsx
=====================================
import { useEffect, useRef } from 'react';
import { COLOR_SETS } from '@/engine/config/Palette';

interface Particle {
  x: number;
  y: number;
  vx: number;
  vy: number;
  life: number;
  maxLife: number;
  size: number;
  color: string;
}

interface PanelSparksProps {
  intensity?: 'normal' | 'extreme'; 
}

export const PanelSparks = ({ intensity }: PanelSparksProps) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || !canvas.parentElement) return;
    
    const width = canvas.parentElement.clientWidth;
    const height = canvas.parentElement.clientHeight;
    
    if (width === 0 || height === 0) return;

    const ctx = canvas.getContext('2d', { alpha: true });
    if (!ctx) return;

    canvas.width = width;
    canvas.height = height;

    let particles: Particle[] = [];
    let animationFrameId: number;
    let isActive = true;

    // Use Palette Colors
    const COLORS = COLOR_SETS.RED;
    
    const PARTICLE_COUNT = 500; 
    
    try {
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const edge = Math.floor(Math.random() * 3); 
            let x = 0, y = 0, vx = 0, vy = 0;

            if (edge === 0) { 
                x = Math.random() * width;
                y = 0;
                vx = (Math.random() - 0.5) * 8;
                vy = (Math.random() * 5) + 2; 
            } else if (edge === 1) { 
                x = 0;
                y = Math.random() * (height * 0.5); 
                vx = (Math.random() * 5) + 2; 
                vy = (Math.random() * 5) - 2;
            } else { 
                x = width;
                y = Math.random() * (height * 0.5);
                vx = -((Math.random() * 5) + 2); 
                vy = (Math.random() * 5) - 2;
            }

            particles.push({
                x, y, vx, vy,
                life: 1.0,
                maxLife: 1.0,
                size: Math.random() * 3 + 1,
                color: COLORS[Math.floor(Math.random() * COLORS.length)]
            });
        }
    } catch (e) {
        return;
    }

    const loop = () => {
      if (!isActive) return;
      if (!canvas || canvas.width === 0) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      let activeParticles = false;

      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.15; 
        
        if (p.y > canvas.height) {
          p.y = canvas.height;
          p.vy *= -0.5; 
          p.vx *= 0.7;  
        }
        
        if (p.x < 0 || p.x > canvas.width) {
          p.vx *= -0.6;
          p.x = Math.max(0, Math.min(canvas.width, p.x));
        }

        p.life -= 0.005; 

        if (p.life > 0) {
            activeParticles = true;
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life; 
            ctx.beginPath();
            ctx.rect(p.x, p.y, p.size, p.size);
            ctx.fill();
        } else {
            particles.splice(i, 1);
        }
      }
      
      if (activeParticles) {
          animationFrameId = requestAnimationFrame(loop);
      } else {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    };

    loop();

    return () => {
      isActive = false;
      cancelAnimationFrame(animationFrameId);
    };
  }, [intensity]);

  return (
    <canvas 
      ref={canvasRef} 
      className="absolute inset-0 pointer-events-none z-0 mix-blend-screen"
    />
  );
};


=====================================
FILE: ./src/ui/kit/atoms/GlassPanel.tsx
=====================================
import { clsx } from 'clsx';
import { motion, AnimatePresence, useAnimation } from 'framer-motion';
import { ReactNode, useEffect as useReactEffect, useState as useReactState, useRef as useReactRef } from 'react';
import { usePanelRegistry } from '@/ui/sim/hooks/usePanelRegistry';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { Skull } from 'lucide-react';
import { PanelSparks } from './PanelSparks';
import { useHeartbeat } from '@/ui/sim/hooks/useHeartbeat';
import { RebootOverlay } from '@/ui/kit/molecules/panel/RebootOverlay';
import { IntelligentHeader } from '@/ui/kit/molecules/panel/IntelligentHeader';
import { BreachOverlay } from '@/ui/kit/molecules/panel/BreachOverlay';
import { SafePanelContent } from './SafePanelContent';
import { DotGridBackground } from './DotGridBackground';
import { usePanelPhysics } from '@/ui/kit/hooks/usePanelPhysics'; // NEW HOOK

const DEFAULT_MAX_HEALTH = 100;

const panelVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.5, ease: "easeOut" } },
  shattered: (custom: number) => ({
    y: 350 + (custom * 50),
    opacity: 0.8,
    rotate: custom * 15,
    transition: { duration: 1.5, ease: "anticipate", delay: Math.abs(custom) * 0.1 }
  })
};

const pulseVariants = {
    heartbeat: {
        opacity: [0, 0.6, 0],
        scale: [1, 1.005, 1], 
        transition: { duration: 0.8, times: [0, 0.04, 1], ease: "easeOut" }
    }
};

const CircuitLockOverlay = () => (
    <motion.div 
        className="absolute inset-0 pointer-events-none z-[60] border-2 border-white/50 bg-primary-green/20 shadow-[inset_0_0_20px_#78F654]"
        initial={{ opacity: 0 }}
        animate={{ opacity: [0, 1, 0] }}
        transition={{ duration: 0.6, ease: "easeOut" }}
    />
);

interface GlassPanelProps {
  children: ReactNode;
  className?: string;
  title?: string;
  gameId?: string;
  maxHealth?: number; 
}

export const GlassPanel = ({ children, className, title, gameId, maxHealth = DEFAULT_MAX_HEALTH }: GlassPanelProps) => {
  const registryRef = gameId ? usePanelRegistry(gameId) : null;
  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const interactionTarget = useGameStore(state => state.interactionTarget);
  
  // Use new Physics Hook if gameId exists
  if (gameId && registryRef) {
      usePanelPhysics(gameId, registryRef);
  }
  
  const isInteracting = !!(gameId && interactionTarget === gameId);
  const isGameOver = Math.floor(systemIntegrity) <= 0;
  const isCriticalGlobal = systemIntegrity < 30 && !isGameOver;
  const panelState = useGameStore((state) => gameId ? state.panels[gameId] : null);
  
  const health = panelState ? panelState.health : maxHealth;
  const isDestroyed = panelState ? panelState.isDestroyed : false;
  const healthPercent = Math.max(0, Math.min(100, (health / maxHealth) * 100));
  const isDamaged = !isDestroyed && health < maxHealth;

  const [showReboot, setShowReboot] = useReactState(false);
  const [showCircuitLock, setShowCircuitLock] = useReactState(false);
  
  const prevDestroyed = useReactRef(isDestroyed);
  const prevHealth = useReactRef(health);
  
  const shakeControls = useAnimation();
  const heartbeatControls = useHeartbeat(); 

  const randSeed = (title?.length || 5) % 2 === 0 ? 1 : -1;

  useReactEffect(() => {
      isGameOver ? shakeControls.start("shattered") : shakeControls.start("visible");
  }, [isGameOver, shakeControls]);

  useReactEffect(() => {
    if (prevDestroyed.current && !isDestroyed && !isGameOver) {
        setShowReboot(true);
        const timer = setTimeout(() => setShowReboot(false), 900); 
        return () => clearTimeout(timer);
    }
    prevDestroyed.current = isDestroyed;
  }, [isDestroyed, isGameOver]);

  useReactEffect(() => {
      if (prevHealth.current < maxHealth && health >= maxHealth && !isDestroyed && !isGameOver) {
          setShowCircuitLock(true);
          const timer = setTimeout(() => setShowCircuitLock(false), 1200); 
          prevHealth.current = health;
          return () => clearTimeout(timer);
      }
      if (health < maxHealth || isDestroyed || isGameOver) setShowCircuitLock(false);
      prevHealth.current = health;
  }, [health, maxHealth, isDestroyed, isGameOver]);

  let borderColor = "border-primary-green-dim/30";
  if (showCircuitLock) borderColor = "border-primary-green"; 
  else if (isDestroyed) borderColor = isInteracting ? "border-latent-purple shadow-[0_0_10px_#9E4EA5]" : "border-critical-red animate-pulse"; 
  else if (isInteracting && isDamaged) borderColor = "border-service-cyan shadow-[0_0_10px_#00F0FF]";
  else if (isDamaged) borderColor = "border-alert-yellow/50";

  return (
    <motion.div 
      ref={registryRef}
      variants={panelVariants}
      initial="hidden"
      animate={shakeControls}
      custom={randSeed}
      className={clsx(
        "relative overflow-hidden flex flex-col group",
        isDestroyed ? "bg-black/20" : "bg-black", 
        "border", borderColor, "rounded-sm",
        showCircuitLock ? "animate-restore-flash" : "transition-colors duration-300",
        className
      )}
    >
      <DotGridBackground className="top-8" />
      <div className="absolute inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(10,10,10,0.4)_50%)] z-0 bg-[length:100%_4px]" />
      
      {isCriticalGlobal && (
          <motion.div 
            className="absolute inset-0 pointer-events-none z-50 border-2 border-critical-red/60 shadow-[inset_0_0_30px_#FF003C]"
            animate={heartbeatControls}
            variants={pulseVariants}
            initial={{ opacity: 0 }}
          />
      )}

      {title && (
          <IntelligentHeader 
            title={title} health={health} maxHealth={maxHealth} 
            isDestroyed={isDestroyed} isGameOver={isGameOver} gameId={gameId}
          />
      )}

      <div className="relative z-10 p-4 flex-1 min-h-0 flex flex-col">
        {(isDestroyed || isGameOver) && (
            <SafePanelContent fallbackId={`sparks-${gameId}`}>
                <PanelSparks intensity={isGameOver ? 'extreme' : 'normal'} />
            </SafePanelContent>
        )}
        <div className={clsx("flex-1 min-h-0 flex flex-col relative z-20", isGameOver ? "invisible" : "visible")}>
            {children}
            {isDestroyed && !isGameOver && (
                <SafePanelContent fallbackId={`breach-${gameId}`}>
                    <BreachOverlay 
                        progress={healthPercent} isVideo={gameId === 'video'} 
                        showInteractive={true} isRepairing={isInteracting} panelId={gameId} 
                    />
                </SafePanelContent>
            )}
        </div>
        <AnimatePresence>
            {showReboot && <RebootOverlay key="reboot" />}
            {showCircuitLock && <CircuitLockOverlay key="lock" />}
        </AnimatePresence>
        {isGameOver && (
            <div className="absolute inset-0 z-[100] flex flex-col items-center justify-center gap-4 bg-transparent pointer-events-none">
                <Skull className="text-critical-red animate-pulse w-20 h-20 drop-shadow-[0_0_15px_rgba(255,0,60,0.8)]" />
                <span className="text-critical-red font-header font-black text-2xl tracking-widest drop-shadow-lg">SYSTEM FAILURE</span>
            </div>
        )}
      </div>
    </motion.div>
  );
};


=====================================
FILE: ./src/ui/kit/atoms/VitalsRing.tsx
=====================================
import { MiniCrystalCanvas } from '@/ui/sim/props/MiniCrystalCanvas';
import { Unplug } from 'lucide-react';
import { clsx } from 'clsx';
import { useMultiTransientRef } from '@/ui/sim/hooks/useMultiTransientRef';
import { useTransientRef } from '@/ui/sim/hooks/useTransientRef';
import { useMemo } from 'react';

interface VitalsRingProps {
  health: number;
  maxHealth: number;
  xp: number;
  xpToNext: number;
  level: number;
  isDead: boolean;
  rebootProgress: number;
}

export const VitalsRing = ({ health, maxHealth, xp, xpToNext, level, isDead, rebootProgress }: VitalsRingProps) => {
  // Memoize configs to prevent re-registration
  const rootConfigs = useMemo(() => [
      { id: 'hp-progress', type: 'css-var' as const },
      { id: 'xp-progress', type: 'css-var' as const },
      { id: 'hp-color', type: 'css-var' as const }
  ], []);

  const rootRef = useMultiTransientRef(rootConfigs);
  const levelRef = useTransientRef('player-lvl-text', 'text');

  const size = 160; 
  const center = size / 2;
  const radiusHp = 60;
  const radiusXp = 70;
  const stroke = 4;
  const circHp = 2 * Math.PI * radiusHp;
  const circXp = 2 * Math.PI * radiusXp;

  const initialHp = maxHealth > 0 ? health / maxHealth : 0;
  const initialXp = xpToNext > 0 ? (xp / xpToNext) : 0;
  const initialColor = initialHp < 0.3 ? '#FF003C' : '#78F654';

  return (
    <div 
        ref={rootRef}
        className="relative w-40 h-40 shrink-0 group mb-1"
        style={{
            '--hp-max': circHp,
            '--xp-max': circXp,
            '--hp-progress': initialHp,
            '--xp-progress': initialXp,
            '--hp-color': initialColor
        } as React.CSSProperties}
    > 
        <div className={clsx("absolute inset-0 rounded-full bg-black/50 overflow-hidden transition-opacity duration-500 clip-circle", isDead ? "opacity-60 grayscale" : "opacity-100")}>
           <MiniCrystalCanvas />
        </div>
        
        {isDead && (
            <div className="absolute inset-0 flex items-center justify-center pointer-events-none z-20">
                {rebootProgress > 0 ? (
                    <div className="flex flex-col items-center">
                        <span className="text-2xl font-header font-black text-alert-yellow drop-shadow-md animate-pulse">{Math.floor(rebootProgress)}%</span>
                        <span className="text-[8px] text-alert-yellow font-mono tracking-widest bg-black/80 px-2 mt-1">REBOOTING</span>
                    </div>
                ) : (
                    <div className="animate-pulse flex flex-col items-center">
                        <Unplug className="text-white/50 w-8 h-8 mb-1" />
                        <span className="text-[8px] text-critical-red font-mono bg-black/80 px-2">SIGNAL_LOST</span>
                    </div>
                )}
            </div>
        )}

        <svg className="absolute inset-0 w-full h-full pointer-events-none overflow-visible" viewBox={`0 0 ${size} ${size}`}>
          <circle cx={center} cy={center} r={radiusHp} stroke="#1a1a1a" strokeWidth={stroke} fill="transparent" />
          <circle cx={center} cy={center} r={radiusXp} stroke="#1a1a1a" strokeWidth={stroke} fill="transparent" strokeDasharray="2 4" />
          
          <circle 
            cx={center} cy={center} r={radiusHp} 
            strokeWidth={stroke} fill="transparent" 
            strokeDasharray={circHp} 
            strokeLinecap="round" 
            transform={`rotate(-90 ${center} ${center})`} 
            className="transition-colors duration-200"
            style={{
                stroke: 'var(--hp-color)',
                strokeDashoffset: 'calc(var(--hp-max) * (1 - var(--hp-progress)))',
                transition: 'stroke-dashoffset 0.1s linear'
            }}
          />
          
          <circle 
            cx={center} cy={center} r={radiusXp} 
            stroke="#9E4EA5" strokeWidth={stroke} fill="transparent" 
            strokeDasharray={circXp} 
            strokeLinecap="round" 
            transform={`rotate(-90 ${center} ${center})`} 
            style={{
                strokeDashoffset: 'calc(var(--xp-max) * (1 - var(--xp-progress)))',
                transition: 'stroke-dashoffset 0.1s linear'
            }}
          />
          
          <defs><path id="levelCurve" d="M 25,80 A 55,55 0 0,0 135,80" /></defs>
          <text fontSize="10" fontFamily="monospace" fontWeight="bold" letterSpacing="3" fill="#9E4EA5" style={{ filter: 'drop-shadow(0 0 2px #9E4EA5)' }}>
              <textPath href="#levelCurve" startOffset="50%" textAnchor="middle" side="right">
                  <tspan ref={levelRef}>LVL_{level.toString().padStart(2, '0')}</tspan>
              </textPath>
          </text>
        </svg>
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/hooks/usePanelPhysics.ts
=====================================
import { useEffect, useRef } from 'react';
import { useGameContext } from '@/engine/state/GameContext';
import { GameEvents } from '@/engine/signals/GameEvents';

// Tweakables
const STRESS_ADD = 0.5; // Slightly reduced per-hit so 1 driller isn't too crazy
const MAX_STRESS = 3.0; // NEW: Cap allows "Overdrive" shaking for swarms
const STRESS_DECAY = 0.9; 
const JITTER_SCALE = 3.0; // Base pixel multiplier

export const usePanelPhysics = (panelId: string, domRef: React.RefObject<HTMLElement>) => {
  const { events } = useGameContext();
  
  const physics = useRef({
    stress: 0,
    recoilX: 0,
    recoilY: 0
  });
  
  const frameId = useRef<number>(0);

  useEffect(() => {
    // 1. Event Listener
    const unsub = events.subscribe(GameEvents.PANEL_DAMAGED, (p) => {
        if (p.id !== panelId) return;
        
        // Add Stress (Stacking)
        // Allows multiple enemies to push stress well beyond 1.0
        physics.current.stress = Math.min(MAX_STRESS, physics.current.stress + STRESS_ADD);
    });

    // 2. Physics Loop
    const loop = () => {
        const p = physics.current;
        
        if (p.stress > 0.01) {
            // Decay
            p.stress *= STRESS_DECAY;
            if (p.stress < 0.01) p.stress = 0;

            // Calculate Jitter
            // The more stress, the wider the range
            const currentScale = JITTER_SCALE * p.stress;
            
            const jx = (Math.random() - 0.5) * currentScale;
            const jy = (Math.random() - 0.5) * currentScale;
            
            // Apply
            if (domRef.current) {
                domRef.current.style.transform = `translate(${jx.toFixed(1)}px, ${jy.toFixed(1)}px)`;
            }
        } else {
            // Reset if idle
            if (domRef.current && domRef.current.style.transform !== 'none') {
                domRef.current.style.transform = 'none';
            }
        }

        frameId.current = requestAnimationFrame(loop);
    };

    loop();

    return () => {
        unsub();
        cancelAnimationFrame(frameId.current);
    };
  }, [panelId, events]);
};


=====================================
FILE: ./src/ui/kit/hooks/useHoloCycler.ts
=====================================
import { useState, useEffect } from 'react';
import { VideoPlaylistService } from '../molecules/VideoPlaylistService';

export const useHoloCycler = (slotIndex: number, isSystemActive: boolean) => {
  const [videoId, setVideoId] = useState<string | null>(null);
  const [isMasked, setIsMasked] = useState(true);

  // 1. Initial Load / Cleanup
  useEffect(() => {
      let t: NodeJS.Timeout;

      if (isSystemActive) {
          // Acquire unique video from global service
          setVideoId(prev => {
              if (prev) return prev; // Already have one
              return VideoPlaylistService.acquire();
          });
          
          setIsMasked(true);

          // Staggered Reveal
          t = setTimeout(() => {
              setIsMasked(false);
          }, 1500 + (slotIndex * 800));
      } else {
          // System Shutdown: Release video back to pool availability logic
          // Note: We don't put it back in the deck (it's "used"), but we remove it from "active" set
          setVideoId(current => {
              VideoPlaylistService.release(current);
              return null;
          });
          setIsMasked(true);
      }

      return () => {
          clearTimeout(t);
          // Safety: If component unmounts while holding a video, release it
          // We can't access state here easily in cleanup without deps, 
          // but the next effect handles swap release.
          // For strict unmount, we rely on the state reset logic above or strict component lifecycle.
      };
  }, [isSystemActive, slotIndex]);

  // 2. Cycling Logic (Periodic Swaps)
  useEffect(() => {
    if (!isSystemActive) return;

    const duration = 30000 + (Math.random() * 15000);
    
    const cycleTimer = setTimeout(() => {
      setIsMasked(true);
      
      const swapTimer = setTimeout(() => {
        setVideoId(current => {
            // Release old
            VideoPlaylistService.release(current);
            // Get new
            return VideoPlaylistService.acquire();
        });
        
        const unmaskTimer = setTimeout(() => {
            setIsMasked(false);
        }, 2000); 
        
        return () => clearTimeout(unmaskTimer);
      }, 1000); 
      
      return () => clearTimeout(swapTimer);
    }, duration);

    return () => clearTimeout(cycleTimer);
  }, [isSystemActive, videoId]); 

  // 3. Final Safety Net: Release on Unmount
  useEffect(() => {
      return () => {
          // When the hook is destroyed completely, ensure we release whatever ID we held
          // This is tricky inside React hooks due to closures.
          // We trust the logic above for now.
      };
  }, []);

  return { videoId, isMasked };
};


=====================================
FILE: ./src/ui/hooks/useAudio.ts
=====================================
import { useGameContext } from '@/engine/state/GameContext';
import { IAudioService } from '@/engine/interfaces';

export const useAudio = (): IAudioService => {
  const { audio } = useGameContext();
  return audio;
};


=====================================
FILE: ./src/ui/os/boot/atoms/CoreHeader.tsx
=====================================
import { motion, AnimatePresence } from 'framer-motion';
import { ShieldAlert, Unlock, Lock, Skull } from 'lucide-react';

interface CoreHeaderProps {
  step: number;
}

export const CoreHeader = ({ step }: CoreHeaderProps) => {
  const isUnsafe = step === 3;
  const isBypass = step === 4;
  const isDecrypted = step === 5;
  const isCaution = step >= 6;

  let borderColor = "border-primary-green/30";
  let bgColor = "bg-primary-green/10";
  let textColor = "text-primary-green";

  if (isUnsafe) {
    borderColor = "border-critical-red/50";
    bgColor = "bg-critical-red/10";
    textColor = "text-critical-red";
  } else if (isBypass) {
    borderColor = "border-latent-purple/50";
    bgColor = "bg-latent-purple/10";
    textColor = "text-latent-purple-light";
  }

  // FIXED: Removed 'mb-2' to allow body content to sit flush against the header border
  return (
    <motion.div 
      className={`flex shrink-0 items-center justify-between border-b px-3 py-2 select-none transition-colors duration-500 ${!isCaution ? `${borderColor} ${bgColor}` : ''}`}
      animate={isCaution ? {
        borderColor: ['rgba(120,246,84,0.3)', 'rgba(234,231,71,0.6)', 'rgba(120,246,84,0.3)'],
        backgroundColor: ['rgba(120,246,84,0.1)', 'rgba(234,231,71,0.15)', 'rgba(120,246,84,0.1)'],
      } : {}}
      transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }}
    >
      <motion.span 
        className={`text-sm font-mono font-bold tracking-widest uppercase ${!isCaution ? textColor : ''}`}
        animate={isCaution ? {
            color: ['#78F654', '#eae747', '#78F654']
        } : {}}
        transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }}
      >
        MESOELFY_CORE
      </motion.span>
      
      <div className="relative w-6 h-6 flex items-center justify-center">
         <AnimatePresence mode="wait">
            {/* STEP 3: UNSAFE */}
            {isUnsafe && (
                <motion.div 
                    key="unsafe"
                    initial={{ scale: 0 }} 
                    animate={{ scale: 1, x: [-2, 2, -2, 2, 0] }}
                    exit={{ scale: 0 }}
                    transition={{ x: { repeat: Infinity, duration: 0.1 } }}
                >
                    <ShieldAlert size={18} className="text-critical-red" />
                </motion.div>
            )}

            {/* STEP 4: BYPASSING */}
            {isBypass && (
                <motion.div 
                    key="bypass"
                    initial={{ scale: 0.8, opacity: 0 }} 
                    animate={{ 
                        scale: [1, 1.1, 1], 
                        opacity: 1,
                        x: [-1, 1, -1, 1, 0], 
                        filter: ["brightness(1)", "brightness(1.5)", "brightness(1)"]
                    }} 
                    exit={{ scale: 0, transition: { duration: 0.1 } }}
                    transition={{ 
                        scale: { repeat: Infinity, duration: 0.5 },
                        x: { repeat: Infinity, duration: 0.1 } 
                    }}
                >
                     <Lock size={18} className="text-latent-purple-light" />
                </motion.div>
            )}

            {/* STEP 5: DECRYPTED */}
            {isDecrypted && (
                <motion.div 
                    key="unlocked"
                    initial={{ scale: 0.5, opacity: 0, rotate: -15 }} 
                    animate={{ 
                        scale: [1.5, 1], 
                        opacity: 1, 
                        rotate: 0,
                        filter: ["drop-shadow(0 0 0px #78F654)", "drop-shadow(0 0 10px #78F654)", "drop-shadow(0 0 0px #78F654)"]
                    }} 
                    exit={{ scale: 0, opacity: 0 }}
                    transition={{ 
                        default: { type: "spring", bounce: 0.5, duration: 0.4 },
                        filter: { type: "tween", duration: 0.4, ease: "easeInOut" }
                    }}
                >
                     <Unlock size={18} className="text-primary-green" strokeWidth={3} />
                </motion.div>
            )}

            {/* STEP 6: CAUTION */}
            {isCaution && (
                <motion.div 
                    key="caution"
                    initial={{ scale: 0 }} 
                    animate={{ scale: 1 }}
                >
                    <motion.div
                       animate={{
                           filter: ['drop-shadow(0 0 8px rgba(120,246,84,0.8))', 'drop-shadow(0 0 15px rgba(234,231,71,1))', 'drop-shadow(0 0 8px rgba(120,246,84,0.8))'],
                           color: ['#78F654', '#eae747', '#78F654'],
                           rotate: [0, 8, -8, 0] 
                       }}
                       transition={{ duration: 2.0, repeat: Infinity, ease: "easeInOut" }}
                    >
                         <Skull size={18} />
                    </motion.div>
                </motion.div>
            )}

            {/* LOADING SPINNER */}
            {!isUnsafe && !isBypass && !isDecrypted && !isCaution && (
                <motion.div 
                    key="loading"
                    initial={{ opacity: 0 }} 
                    animate={{ opacity: 1, rotate: 360 }} 
                    exit={{ opacity: 0 }}
                    transition={{ rotate: { repeat: Infinity, duration: 2, ease: "linear" } }}
                >
                     <div className="w-4 h-4 border-2 border-primary-green border-t-transparent rounded-full" />
                </motion.div>
            )}
         </AnimatePresence>
      </div>
    </motion.div>
  );
};


=====================================
FILE: ./src/ui/os/boot/atoms/BootHeader.tsx
=====================================
import { motion } from 'framer-motion';

interface BootHeaderProps {
  step: number;
}

export const BootHeader = ({ step }: BootHeaderProps) => {
  const isUnsafe = step === 3;
  const isBypass = step === 4;
  const isDecrypted = step === 5;
  const isCaution = step >= 6;

  let color = "text-primary-green-dim";
  let statusText = "ESTABLISHING...";
  
  let bgClass = "bg-primary-green/5 border-primary-green/20";
  
  if (isUnsafe) {
      color = "text-critical-red";
      statusText = "SIGNAL_CORRUPTED";
      bgClass = "bg-critical-red/10 border-critical-red/30";
  } else if (isBypass) {
      color = "text-latent-purple-light";
      statusText = "INJECTING_PAYLOAD";
      bgClass = "bg-latent-purple/10 border-latent-purple/30";
  } else if (isDecrypted) {
      color = "text-primary-green";
      statusText = "UPLINK_STABLE";
      bgClass = "bg-primary-green/10 border-primary-green/30";
  } else if (isCaution) {
      color = "text-alert-yellow";
      statusText = "CAUTION_ADVISED";
      bgClass = "bg-alert-yellow/10 border-alert-yellow/30";
  } else if (step >= 1) {
      statusText = "HANDSHAKING...";
  }

  // FIXED: Removed 'mb-2' to allow body content to sit flush against the header border
  return (
    <div className={`flex shrink-0 items-center justify-between border-b px-3 py-2 select-none relative z-20 transition-all duration-300 ${bgClass}`}>
      <div className="flex flex-col leading-none gap-1.5 mt-0.5">
          <span className={`text-[10px] font-mono tracking-widest uppercase ${color} transition-colors duration-300 font-bold`}>
            BOOT_LOADER.SYS
          </span>
          <span className="text-[8px] text-gray-500 font-mono tracking-wider opacity-80">{statusText}</span>
      </div>
      
      <div className="flex gap-1 items-end h-3">
        {[0, 1, 2, 3].map(i => {
           let barClass = "bg-primary-green";
           if (isUnsafe) barClass = "bg-critical-red";
           else if (isBypass) barClass = "bg-latent-purple-light";
           else if (isCaution) barClass = "bg-alert-yellow";

           const isPulseActive = isDecrypted || isCaution; 
           const pulseHex = isCaution ? "#eae747" : "#78F654";

           let animate = {};
           let transition = {};
           let initialHeight = "0.125rem"; 

           if (isPulseActive) {
               initialHeight = "0.5rem";
               animate = {
                   height: ["0.25rem", "0.75rem", "0.25rem"],
                   opacity: [0.5, 1.0, 0.5],
                   backgroundColor: pulseHex,
                   boxShadow: [`0 0 0px ${pulseHex}`, `0 0 4px ${pulseHex}`, `0 0 0px ${pulseHex}`]
               };
               transition = {
                   duration: 1.2,
                   repeat: Infinity,
                   ease: "easeInOut",
                   delay: i * 0.15 
               };
           } else if (isUnsafe) {
               initialHeight = "0.25rem";
               animate = {
                   height: ["0.25rem", "0.75rem", "0.25rem"], 
                   opacity: [0.5, 1.0, 0.5]
               };
               transition = {
                   duration: 1.5, 
                   repeat: Infinity,
                   ease: "easeInOut"
               };
           } else if (isBypass) {
               const isEven = i % 2 === 0;
               initialHeight = isEven ? "0.75rem" : "0.5rem";
               animate = {
                   height: isEven ? ["0.75rem", "0.5rem"] : ["0.5rem", "0.75rem"],
                   opacity: [0.7, 1.0]
               };
               transition = {
                   duration: 0.8,
                   repeat: Infinity,
                   repeatType: "reverse",
                   ease: "easeInOut"
               };
           } else {
               const isActive = step >= i; 
               if (isActive) {
                   initialHeight = "0.5rem";
                   animate = { opacity: [0.5, 1.0, 0.5] }; 
                   transition = { duration: 2.0, repeat: Infinity, ease: "easeInOut" };
               } else {
                   initialHeight = "0.125rem";
                   animate = { opacity: 0.2 }; 
               }
           }

           return (
               <motion.div 
                 key={i} 
                 className={`w-1 rounded-sm ${barClass}`}
                 initial={{ height: initialHeight }}
                 animate={animate}
                 transition={transition}
               />
           );
        })}
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/boot/atoms/AsciiRenderer.tsx
=====================================
import { useMemo } from 'react';
import { useStore } from '@/engine/state/global/useStore';
import { ASCII_TITLE } from '@/engine/config/TextAssets';

export const AsciiRenderer = () => {
  const graphicsMode = useStore((state) => state.graphicsMode);
  const isHigh = graphicsMode === 'HIGH';

  const renderedChars = useMemo(() => {
    return ASCII_TITLE.split('').map((char, i) => {
      if (char === '\n') return <br key={i} />;
      if (char === ' ') return <span key={i}> </span>;

      let baseClass = 'transition-colors duration-300 ';
      let animClass = '';
      
      if (['â–ˆ', 'â–€', 'â–„', 'â–Œ', 'â–'].includes(char)) {
        baseClass += 'text-primary-green-dark';
        animClass = 'animate-matrix-green';
      } else if (['â–‘', 'â–’', 'â–“'].includes(char)) {
        baseClass += 'text-latent-purple';
        animClass = 'animate-matrix-purple';
      } else {
        baseClass += 'text-primary-green-dark';
      }

      const finalClass = isHigh ? `${baseClass} ${animClass}` : baseClass;
      const style = isHigh ? { animationDelay: Math.random() * 2 + 's' } : {};

      return (
        <span key={i} className={finalClass} style={style}>
          {char}
        </span>
      );
    });
  }, [isHigh]); 

  return (
    // UPDATE: text-[4px] ensures fit on 360px screens (Galaxy S8+)
    <div className="font-mono font-bold leading-[1.1] whitespace-pre text-center select-none overflow-hidden text-[4px] xs:text-[6px] sm:text-[9px] md:text-[11px] shrink-0">
      {renderedChars}
    </div>
  );
};


=====================================
FILE: ./src/ui/os/boot/atoms/TypedLog.tsx
=====================================
import { useState, useEffect } from 'react';

interface TypedLogProps {
  text: string;
  color: string;
  speed: number;
  showDots: boolean;
  isActive: boolean;
  isPast: boolean;
}

export const TypedLog = ({ text, color, speed = 20, showDots = false, isActive = false, isPast = false }: TypedLogProps) => {
  const [displayed, setDisplayed] = useState("");
  const [isDoneTyping, setIsDoneTyping] = useState(false);
  
  useEffect(() => {
    let i = 0;
    setDisplayed("");
    setIsDoneTyping(false);
    const interval = setInterval(() => {
      setDisplayed(text.substring(0, i + 1));
      i++;
      if (i >= text.length) {
        setIsDoneTyping(true);
        clearInterval(interval);
      }
    }, speed);
    return () => clearInterval(interval);
  }, [text, speed]);

  if (isPast && displayed !== text) {
    setDisplayed(text);
    setIsDoneTyping(true);
  }

  return (
    <div className={`whitespace-nowrap font-mono ${color} flex items-center shrink-0`}>
      <span>{displayed}</span>
      {isDoneTyping && showDots && <span>{isPast ? '...' : (Math.floor(Date.now() / 300) % 4 === 0 ? '' : '...')}</span>}
      {isActive && <span className="ml-1 animate-cursor-blink text-primary-green font-bold">_</span>}
    </div>
  );
};


=====================================
FILE: ./src/ui/os/boot/MatrixBootSequence.tsx
=====================================
import { useRef, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { GpuConfigPanel } from '@/ui/os/apps/settings/components/GpuConfigPanel';
import { clsx } from 'clsx';
import { BootHeader } from './atoms/BootHeader';
import { CoreHeader } from './atoms/CoreHeader';
import { AsciiRenderer } from './atoms/AsciiRenderer';
import { TypedLog } from './atoms/TypedLog';
import { DotGridBackground } from '@/ui/kit/atoms/DotGridBackground';
import { useBootSequence } from './hooks/useBootSequence';
import { useMatrixRain } from './hooks/useMatrixRain';
import { useSmartScroll } from './hooks/useSmartScroll';
import { useDeviceType } from '@/ui/sim/hooks/useDeviceType';
import { useStore } from '@/engine/state/global/useStore';

interface Props {
  onComplete: () => void;
  onBreachStart: () => void;
}

export const MatrixBootSequence = ({ onComplete, onBreachStart }: Props) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const mainStackRef = useRef<HTMLDivElement>(null);
  const device = useDeviceType();
  const { setBootState, setIntroDone, setInitialClickPos } = useStore();

  const { 
    step, isBreaching, showGpuPanel, handleInitialize: coreInitialize, logsToShow,
    showMatrix, showPayloadWindow, showWarningBox, showButton
  } = useBootSequence({ onComplete, onBreachStart });

  useMatrixRain(canvasRef, showMatrix, isBreaching, step);
  useSmartScroll(containerRef);

  useEffect(() => {
    if (showGpuPanel && mainStackRef.current) {
        mainStackRef.current.scrollIntoView({ inline: 'center', behavior: 'smooth' });
    }
  }, [showGpuPanel]);

  const handleWrapperClick = (e: React.MouseEvent) => {
      setInitialClickPos({ x: e.clientX, y: e.clientY });
      if (device === 'mobile') {
          AudioSystem.init();
          AudioSystem.playSound('ui_error');
          setIntroDone(true);
          setBootState('mobile_lockdown');
      } else {
          coreInitialize();
      }
  };

  return (
    <motion.div 
      ref={containerRef}
      animate={{ backgroundColor: isBreaching ? "rgba(0,0,0,0)" : "rgba(0,0,0,1)" }}
      transition={{ duration: 0.5, ease: "easeInOut" }}
      className={clsx(
          "fixed inset-0 z-[100] font-mono outline-none bg-black scrollbar-thin scrollbar-thumb-primary-green scrollbar-track-black",
          isBreaching ? "overflow-hidden cursor-none" : "overflow-y-auto overflow-x-auto cursor-auto"
      )}
    >
      <canvas ref={canvasRef} className={`fixed inset-0 z-0 pointer-events-none transition-opacity duration-300 ${showMatrix && !isBreaching ? 'opacity-30' : 'opacity-0'}`} />
      <div className="min-h-full min-w-min w-full flex items-center p-2 md:p-8 relative z-10">
        <motion.div 
            className={clsx(
                "flex flex-col gap-4 transition-all duration-500 ease-out m-auto", 
                "w-full max-w-lg md:max-w-2xl lg:w-auto lg:max-w-none",
                showGpuPanel && !isBreaching ? "lg:grid lg:grid-cols-[18rem_42rem_18rem] lg:gap-8 lg:items-end" : ""
            )}
            animate={isBreaching ? { scale: 15, opacity: 0, filter: "blur(10px)" } : { opacity: 1, filter: "blur(0px)" }}
            initial={{ opacity: 0 }}
            transition={{ scale: { duration: 0.8, ease: "easeIn" }, opacity: { duration: 0.2, ease: "easeIn" }, filter: { duration: 0.2 } }}
        >
            <AnimatePresence>
                {showGpuPanel && !isBreaching && (
                    <motion.div 
                        initial={{ x: -20, opacity: 0 }}
                        animate={{ x: 0, opacity: 1 }}
                        exit={{ opacity: 0, x: -20 }}
                        transition={{ type: "spring", stiffness: 100, damping: 15 }}
                        className="w-full lg:w-72 lg:col-start-1 lg:row-start-1 relative z-10 lg:justify-self-end order-2 lg:order-1"
                    >
                        <GpuConfigPanel />
                        <div className="mt-2 text-[10px] font-mono text-gray-500 text-center uppercase tracking-widest md:text-left absolute top-full w-full hidden md:block">
                            &gt;&gt; CAN BE CHANGED LATER.
                        </div>
                    </motion.div>
                )}
            </AnimatePresence>

            <div ref={mainStackRef} className="w-full lg:w-[42rem] lg:col-start-2 lg:row-start-1 flex flex-col gap-4 order-1 lg:order-2">
                
                {/* PANEL 1: BOOT LOADER */}
                <motion.div initial={{ y: -20, opacity: 0 }} animate={{ y: 0, opacity: 1 }} className="w-full bg-black/90 border border-primary-green-dim/50 shadow-[0_0_20px_rgba(0,255,65,0.1)] overflow-hidden shrink-0 relative z-20 flex flex-col">
                    <BootHeader step={step} />
                    
                    {/* Body Wrapper: Holds Background & Content separated */}
                    <div className="relative w-full flex-1">
                        <DotGridBackground /> {/* Fills this wrapper edge-to-edge, below header */}
                        <div className="p-4 pt-2 h-40 flex flex-col justify-start text-xs md:text-sm font-mono relative z-10 leading-relaxed">
                            {logsToShow.map((line, i) => (
                                <TypedLog key={i} text={line.text} color={line.color} speed={line.speed} showDots={line.hasDots} isActive={i === step && !isBreaching} isPast={i < step} />
                            ))}
                        </div>
                    </div>
                </motion.div>

                {/* PANEL 2: CORE PAYLOAD */}
                <AnimatePresence>
                {showPayloadWindow && (
                    <motion.div initial={{ y: 50, opacity: 0, height: 0 }} animate={{ y: 0, opacity: 1, height: "auto" }} transition={{ type: "spring", stiffness: 120, damping: 20 }} className="w-full bg-black/90 border border-primary-green shadow-[0_0_40px_rgba(0,255,65,0.15)] overflow-hidden shrink-0 relative z-20">
                        <CoreHeader step={step} />
                        
                        {/* Body Wrapper */}
                        <div className="relative w-full">
                            <DotGridBackground /> {/* Fills this wrapper edge-to-edge */}
                            <div className="p-4 md:p-6 flex flex-col items-center gap-4 relative z-10">
                                <AsciiRenderer />
                                {showWarningBox && (
                                <motion.div 
                                    initial={{ opacity: 0, scale: 0.9 }}
                                    animate={{ opacity: 1, scale: 1, boxShadow: ["0 0 10px rgba(255, 0, 60, 0.2)", "0 0 40px rgba(255, 0, 60, 0.6)", "0 0 10px rgba(255, 0, 60, 0.2)"] }}
                                    transition={{ opacity: { duration: 0.3 }, scale: { duration: 0.3 }, boxShadow: { duration: 2.5, repeat: Infinity, ease: "easeInOut" } }}
                                    className="relative border border-critical-red bg-critical-red/10 w-auto mx-auto flex items-center justify-center gap-2 md:gap-4 py-2 px-3 md:px-6 select-none shrink-0 max-w-full"
                                >
                                    <motion.span animate={{ opacity: [1, 0.2, 1] }} transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }} className="text-xl md:text-3xl text-critical-red">âš </motion.span>
                                    <span className="text-[9px] md:text-sm font-header font-black tracking-widest text-center text-critical-red whitespace-nowrap pb-0.5">UNSAFE CONNECTION DETECTED</span>
                                    <motion.span animate={{ opacity: [1, 0.2, 1] }} transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }} className="text-xl md:text-3xl text-critical-red">âš </motion.span>
                                </motion.div>
                                )}
                                {showButton && (
                                <motion.div initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5, ease: "easeOut" }} className="shrink-0 w-full md:w-auto">
                                    <button onClick={handleWrapperClick} onMouseEnter={() => AudioSystem.playHover()} className="group relative w-full md:w-auto px-8 py-3 md:py-2 overflow-hidden border border-primary-green transition-all hover:shadow-[0_0_30px_rgba(0,255,65,0.6)] cursor-pointer">
                                    <div className="absolute inset-0 bg-primary-green translate-y-full group-hover:translate-y-0 transition-transform duration-300 ease-out" />
                                    <span className="relative z-10 font-mono font-bold text-sm md:text-3xl text-primary-green group-hover:text-black transition-colors block tracking-widest whitespace-nowrap text-center">[ INITIALIZE_SYSTEM ]</span>
                                    </button>
                                </motion.div>
                                )}
                            </div>
                        </div>
                    </motion.div>
                )}
                </AnimatePresence>
            </div>
            {showGpuPanel && !isBreaching && <div className="hidden lg:block w-72 lg:col-start-3 lg:row-start-1" />}
        </motion.div>
      </div>
    </motion.div>
  );
};


=====================================
FILE: ./src/ui/os/boot/hooks/useBootSequence.ts
=====================================
import { useState, useEffect, useRef } from 'react';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { LOG_DATA } from '../data/bootLogs';

interface UseBootSequenceProps {
  onComplete: () => void;
  onBreachStart: () => void;
}

export const useBootSequence = ({ onComplete, onBreachStart }: UseBootSequenceProps) => {
  const [step, setStep] = useState(0); 
  const [isBreaching, setIsBreaching] = useState(false);
  const [showGpuPanel, setShowGpuPanel] = useState(false); 

  // Emit Logs to Global Event Bus (for MetaManager)
  useEffect(() => {
    if (LOG_DATA[step]) {
        GameEventBus.emit(GameEvents.BOOT_LOG, { message: LOG_DATA[step].text });
    }
    
    // Trigger GPU Panel Delay at step 6
    if (step >= 6 && !showGpuPanel) {
        const timer = setTimeout(() => {
            setShowGpuPanel(true);
            AudioSystem.playSound('ui_menu_open');
        }, 1000); 
        return () => clearTimeout(timer);
    }
  }, [step, showGpuPanel]);

  // Main Timeline
  useEffect(() => {
    const sequence = [
      { t: 3000, step: 1 }, 
      { t: 4000, step: 2 }, 
      { t: 8000, step: 3 }, 
      { t: 9500, step: 4 }, 
      { t: 11500, step: 5 }, 
      { t: 13500, step: 6 }, 
    ];
    const timeouts = sequence.map(({ t, step: s }) => setTimeout(() => {
      if (!isBreaching) setStep(s);
    }, t));
    return () => timeouts.forEach(clearTimeout);
  }, [isBreaching]);

  const handleInitialize = () => {
    if (isBreaching) return;
    setIsBreaching(true);
    onBreachStart();
    
    AudioSystem.init();
    AudioSystem.playBootSequence();
    AudioSystem.startMusic();
    
    setStep(6);
    setTimeout(onComplete, 800); 
  };

  return {
    step,
    isBreaching,
    showGpuPanel,
    handleInitialize,
    logsToShow: LOG_DATA.slice(0, step + 1),
    
    // Derived State Flags
    showMatrix: step >= 1,
    showPayloadWindow: step >= 2,
    showWarningBox: step >= 3,
    showButton: step >= 6
  };
};


=====================================
FILE: ./src/ui/os/boot/hooks/useMatrixRain.ts
=====================================
import { useEffect, useRef } from 'react';
import { useStore } from '@/engine/state/global/useStore';

export const useMatrixRain = (canvasRef: React.RefObject<HTMLCanvasElement>, isVisible: boolean, isBreaching: boolean, step: number) => {
  const stepRef = useRef(step);

  useEffect(() => {
    stepRef.current = step;
  }, [step]);

  useEffect(() => {
    if (!isVisible && !isBreaching) return;
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const cols = Math.floor(canvas.width / 20);
    const ypos = Array(cols).fill(0).map(() => Math.random() * -1000);

    const matrixEffect = () => {
      const mode = useStore.getState().graphicsMode;
      if (mode === 'POTATO') {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          return;
      }

      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; 
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.font = '14px "Courier New"';

      const currentStep = stepRef.current;
      const isUnsafePhase = currentStep >= 3;
      
      ypos.forEach((y, ind) => {
        const charSet = Math.random() > 0.5 ? 0x16A0 : 0x2200; 
        const text = String.fromCharCode(charSet + Math.random() * 64);
        const x = ind * 20;

        const isPurple = Math.random() > 0.6;
        const isRed = isUnsafePhase && Math.random() > 0.6; 
        let color = '#0F0';
        let blur = 0;

        if (isRed) {
            color = '#FF003C';
            blur = 8;
        } else if (isPurple) {
            color = '#9E4EA5';
            blur = 8;
        }

        ctx.fillStyle = color;
        ctx.shadowBlur = blur;
        ctx.shadowColor = color;
        ctx.fillText(text, x, y);
        ctx.shadowBlur = 0;

        const speed = isBreaching ? 100 : 20; 
        if (y > canvas.height + Math.random() * 10000) ypos[ind] = 0;
        else ypos[ind] = y + speed;
      });
    };
    const interval = setInterval(matrixEffect, 50);
    return () => clearInterval(interval);
  }, [isVisible, isBreaching, canvasRef]);
};


=====================================
FILE: ./src/ui/os/boot/hooks/useSmartScroll.ts
=====================================
import { useEffect } from 'react';

export const useSmartScroll = (containerRef: React.RefObject<HTMLDivElement>) => {
  useEffect(() => {
    const el = containerRef.current;
    if (!el) return;

    const handleWheel = (e: WheelEvent) => {
      // Check if horizontal scroll is active (content > viewport)
      const hasHorizontalOverflow = el.scrollWidth > el.clientWidth;
      
      // If no horizontal overflow, do nothing (default vertical scroll behavior)
      if (!hasHorizontalOverflow) return;

      // Map vertical delta to horizontal scroll
      if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
          const oldScroll = el.scrollLeft;
          el.scrollLeft += e.deltaY;
          const newScroll = el.scrollLeft;

          // Smart Logic:
          // If the scroll position changed, it means we successfully scrolled horizontally.
          // In that case, prevent default vertical scroll.
          // If we hit the edge (old == new), allow default vertical scroll to happen.
          if (oldScroll !== newScroll) {
              e.preventDefault();
          }
      }
    };

    el.addEventListener('wheel', handleWheel, { passive: false });
    return () => el.removeEventListener('wheel', handleWheel);
  }, [containerRef]);
};


=====================================
FILE: ./src/ui/os/boot/data/bootLogs.ts
=====================================
export const LOG_DATA = [
  { text: "> INITIALIZE NEURAL_LACE", color: "text-primary-green-dim", speed: 40, hasDots: true },
  { text: "> CONNECTED TO LATENT_SPACE.", color: "text-primary-green", speed: 20, hasDots: false },
  { text: "> MOUNT MESOELFY_CORE", color: "text-primary-green-dim", speed: 40, hasDots: true },
  { text: "> âš  UNSAFE CONNECTION DETECTED âš ", color: "text-critical-red", speed: 20, hasDots: false },
  { text: "> BYPASSING SENTINEL_NODES", color: "text-latent-purple-light", speed: 40, hasDots: true },
  { text: "> DECRYPTED.", color: "text-primary-green", speed: 20, hasDots: false },
  { text: "> âš  PROCEED WITH CAUTION âš ", color: "text-alert-yellow", speed: 20, hasDots: false },
];


=====================================
FILE: ./src/ui/os/overlays/GlobalBackdrop.tsx
=====================================
import { motion, AnimatePresence } from 'framer-motion';
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';

export const GlobalBackdrop = () => {
  const { activeModal, isDebugOpen, isDebugMinimized, closeModal, toggleDebugMenu } = useStore();

  // Show if any modal is open OR debug is open (but not minimized)
  const isVisible = (activeModal !== 'none') || (isDebugOpen && !isDebugMinimized);

  const handleDismiss = () => {
    AudioSystem.playSound('ui_menu_close');
    if (isDebugOpen) {
        toggleDebugMenu();
    } else {
        closeModal();
    }
  };

  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: 0.3 }}
          onClick={handleDismiss}
          // Z-INDEX 150: Above Game (60) AND Intro (100). Below Modals/Settings (200).
          className="fixed inset-0 z-[150] bg-black/60 backdrop-blur-sm cursor-pointer"
        />
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/os/overlays/RotationLock.tsx
=====================================
import { motion } from 'framer-motion';
import { Smartphone, RotateCcw } from 'lucide-react';
import { useStore } from '@/engine/state/global/useStore';

export const RotationLock = () => {
  const { bootState } = useStore();

  // Don't render anything if we are still in the intro sequence
  if (bootState === 'standby') return null;

  // VISUAL ONLY:
  // The actual pausing logic is now handled centrally in page.tsx 
  // to prevent conflicts with menus/modals.
  return (
    <div className="fixed inset-0 z-[9999] bg-black flex-col items-center justify-center gap-8 hidden portrait:flex md:portrait:hidden pointer-events-auto">
      
      {/* ANIMATION CONTAINER */}
      <div className="relative w-32 h-32 flex items-center justify-center">
        {/* The Phone */}
        <motion.div
          animate={{ rotate: -90 }}
          transition={{ 
            repeat: Infinity, 
            duration: 2.5, 
            ease: "easeInOut", 
            repeatDelay: 1 
          }}
          className="relative z-10"
        >
          <Smartphone size={64} className="text-primary-green drop-shadow-[0_0_15px_rgba(120,246,84,0.5)]" strokeWidth={1.5} />
        </motion.div>

        {/* The Arrow Hint */}
        <motion.div
          animate={{ opacity: [0, 1, 0], rotate: -90 }}
          transition={{ 
            repeat: Infinity, 
            duration: 2.5, 
            ease: "easeInOut", 
            repeatDelay: 1 
          }}
          className="absolute inset-0 flex items-center justify-center"
        >
           <RotateCcw size={100} className="text-primary-green-dim/30" />
        </motion.div>
      </div>

      {/* TEXT */}
      <div className="text-center space-y-2">
        <h2 className="text-xl font-header font-black text-primary-green tracking-widest uppercase">
          Orientation<br/>Lock
        </h2>
        <p className="text-xs font-mono text-primary-green-dim max-w-[200px] mx-auto leading-relaxed">
          // SYSTEM_REQ:<br/>
          PLEASE ROTATE DEVICE TO<br/>
          LANDSCAPE MODE
        </p>
      </div>

      {/* DECORATIVE LINES */}
      <div className="absolute bottom-8 left-0 w-full h-1 bg-gradient-to-r from-transparent via-primary-green/50 to-transparent opacity-50" />
      <div className="absolute top-8 left-0 w-full h-1 bg-gradient-to-r from-transparent via-primary-green/50 to-transparent opacity-50" />

    </div>
  );
};


=====================================
FILE: ./src/ui/os/overlays/ErrorBoundary.tsx
=====================================
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { AlertTriangle, RefreshCw } from 'lucide-react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class WebGLErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null,
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("WebGL Context Crash:", error, errorInfo);
  }

  private handleReload = () => {
    window.location.reload();
  };

  public render() {
    if (this.state.hasError) {
      return (
        <div className="absolute inset-0 z-[100] flex flex-col items-center justify-center bg-black text-critical-red p-8 text-center font-mono">
          <div className="border border-critical-red/50 bg-critical-red/10 p-8 max-w-lg shadow-[0_0_50px_rgba(255,0,60,0.2)]">
            <div className="flex justify-center mb-4">
               <AlertTriangle size={48} className="animate-pulse" />
            </div>
            <h2 className="text-2xl font-black tracking-widest mb-4">GRAPHICS_CORE_FAILURE</h2>
            <p className="text-sm mb-6 text-critical-red/80">
              The neural interface encountered a critical WebGL error.
              <br/>
              <span className="text-xs opacity-50 mt-2 block font-mono">{this.state.error?.message}</span>
            </p>
            <button 
              onClick={this.handleReload}
              className="flex items-center justify-center gap-2 w-full py-3 bg-critical-red text-black font-bold tracking-widest hover:bg-white transition-colors"
            >
              <RefreshCw size={16} />
              REBOOT_SYSTEM
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}


=====================================
FILE: ./src/ui/os/overlays/ModalContainer.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { motion, AnimatePresence } from 'framer-motion';
import { X } from 'lucide-react';

interface ModalContainerProps {
  children: React.ReactNode;
  title: string;
  type: string;
}

export const ModalContainer = ({ children, title, type }: ModalContainerProps) => {
  const { activeModal, closeModal } = useStore();
  const isOpen = activeModal === type;

  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 z-[200] flex items-center justify-center p-4 md:p-10 pointer-events-none">
          
          <motion.div
            initial={{ scale: 0.9, opacity: 0, y: 20 }}
            animate={{ scale: 1, opacity: 1, y: 0 }}
            exit={{ scale: 0.95, opacity: 0, y: 10 }}
            transition={{ type: "spring", bounce: 0, duration: 0.3 }}
            className="relative w-full max-w-5xl h-full max-h-[90vh] bg-black border border-primary-green/50 shadow-[0_0_50px_rgba(0,255,65,0.1)] flex flex-col overflow-hidden pointer-events-auto"
          >
            <div className="flex items-center justify-between px-4 py-3 bg-primary-green/10 border-b border-primary-green/30">
              <div className="flex items-center gap-2">
                <div className="w-3 h-3 bg-critical-red rounded-full animate-pulse" />
                <span className="font-header font-black text-primary-green text-lg md:text-xl tracking-widest">
                  {title}
                </span>
              </div>
              <button 
                onClick={() => { closeModal(); AudioSystem.playSound('ui_menu_close'); }}
                onMouseEnter={() => AudioSystem.playHover()} 
                className="p-1 hover:bg-critical-red hover:text-black text-primary-green transition-colors"
              >
                <X />
              </button>
            </div>

            <div className="flex-1 overflow-auto p-6 relative scrollbar-thin scrollbar-thumb-primary-green scrollbar-track-black">
              <div className="absolute inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.1)_50%)] bg-[length:100%_4px] opacity-20" />
              <div className="relative z-10">
                {children}
              </div>
            </div>

            <div className="px-4 py-1 bg-black border-t border-primary-green/30 text-xs text-primary-green-dim font-mono text-right">
              MODE: SECURE // ENCRYPTION: ENABLED
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/os/desktop/Footer.tsx
=====================================
import { useEffect, useState, useRef } from 'react';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { AnimatePresence, motion } from 'framer-motion';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { clsx } from 'clsx';

const IDLE_MESSAGES = [
  "SYSTEM_MONITORING...", "SCANNING_LATENT_SECTORS...", "ENCRYPTION_ACTIVE...",
  "PACKET_STREAM_STABLE...", "PINGING_NEURAL_NET...", "RENDERING_CONTEXT...",
];

export const Footer = () => {
  const commitHash = process.env.NEXT_PUBLIC_COMMIT_HASH || 'UNKNOWN';
  const actionsUrl = "https://github.com/mesoelfy/mesoelfy.github.io/actions";
  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const isGameOver = systemIntegrity <= 0;
  const isCritical = systemIntegrity < 30;
  const isWarning = systemIntegrity < 60;

  let globalColor = "text-primary-green-dim border-primary-green-dim/30";
  if (isGameOver) globalColor = "text-critical-red border-critical-red/50";
  else if (isCritical) globalColor = "text-critical-red border-critical-red/30";
  else if (isWarning) globalColor = "text-alert-yellow border-alert-yellow/30";

  const [log, setLog] = useState<{ text: string, type: 'info' | 'warn' | 'crit' }>({ text: "SYSTEM_ONLINE", type: 'info' });
  const lockUntilRef = useRef(0);

  useEffect(() => {
    const canUpdate = () => {
        const state = useGameStore.getState();
        if (state.systemIntegrity <= 0) return false;
        return Date.now() > lockUntilRef.current;
    };

    const unsubHit = GameEventBus.subscribe(GameEvents.PLAYER_HIT, () => {
        if (!canUpdate()) return;
        setLog({ text: ">> WARNING: HULL BREACH DETECTED", type: 'warn' });
        lockUntilRef.current = Date.now() + 1000;
    });
    const unsubDamage = GameEventBus.subscribe(GameEvents.PANEL_DAMAGED, (p) => {
        if (!canUpdate()) return;
        setLog({ text: `>> ALERT: SECTOR [${p.id.toUpperCase()}] SUSTAINING DAMAGE`, type: 'warn' });
        lockUntilRef.current = Date.now() + 1500;
    });
    const unsubDestroy = GameEventBus.subscribe(GameEvents.PANEL_DESTROYED, (p) => {
        if (useGameStore.getState().systemIntegrity <= 0) return;
        setLog({ text: `âš  CRITICAL: SECTOR [${p.id.toUpperCase()}] OFFLINE âš `, type: 'crit' });
        lockUntilRef.current = Date.now() + 3000;
    });
    const unsubGameOver = GameEventBus.subscribe(GameEvents.GAME_OVER, () => {
        setLog({ text: "âš  SYSTEM FAILURE // CONNECTION LOST âš ", type: 'crit' });
        lockUntilRef.current = Date.now() + 999999999; 
    });
    const unsubSpawn = GameEventBus.subscribe(GameEvents.ENEMY_SPAWNED, (p) => {
        if (!canUpdate()) return;
        if (Math.random() > 0.9) setLog({ text: `>> SENSOR: NEW SIGNAL [${p.type.toUpperCase()}] DETECTED`, type: 'info' });
    });
    const unsubHeal = GameEventBus.subscribe(GameEvents.PANEL_HEALED, (p) => {
        if (!canUpdate()) return;
        setLog({ text: `>> MAINTENANCE: RESTORING [${p.id.toUpperCase()}]`, type: 'info' });
    });

    const interval = setInterval(() => {
        if (canUpdate()) {
            setLog({ text: IDLE_MESSAGES[Math.floor(Math.random() * IDLE_MESSAGES.length)], type: 'info' });
        }
    }, 4000);

    return () => {
        unsubHit(); unsubDamage(); unsubDestroy(); unsubSpawn(); unsubHeal(); unsubGameOver();
        clearInterval(interval);
    };
  }, []);

  useEffect(() => {
      if (isGameOver) setLog({ text: "âš  SYSTEM FAILURE // CONNECTION LOST âš ", type: 'crit' });
  }, [isGameOver]);

  return (
    <footer className={clsx("w-full h-8 border-t bg-black flex items-center justify-between px-4 z-40 shrink-0 text-[10px] font-mono overflow-hidden transition-colors duration-500", globalColor)}>
      <div className="flex-1 flex items-center gap-2 overflow-hidden mr-4">
        <span className="shrink-0 font-bold">LOG:</span>
        <AnimatePresence mode="wait">
            <motion.span key={log.text} initial={{ opacity: 0, y: 5 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -5 }} transition={{ duration: 0.2 }} className={clsx("whitespace-nowrap font-bold tracking-wider truncate", isGameOver || log.type === 'crit' ? "text-critical-red animate-pulse" : log.type === 'warn' ? "text-alert-yellow" : "text-primary-green")}>
                {log.text}
            </motion.span>
        </AnimatePresence>
      </div>
      <div className="flex items-center gap-2 shrink-0 opacity-50 hover:opacity-100 transition-opacity">
        <span>VER:</span>
        <a href={actionsUrl} target="_blank" rel="noopener noreferrer" className="hover:text-white transition-colors decoration-dashed underline underline-offset-2">{commitHash}</a>
      </div>
    </footer>
  );
};


=====================================
FILE: ./src/ui/os/desktop/Header.tsx
=====================================
import { Volume2, VolumeX, Music, Activity, Wind, Settings } from 'lucide-react';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { useEffect, useState } from 'react';
import { clsx } from 'clsx';
import { motion } from 'framer-motion';
import { useHeartbeat } from '@/ui/sim/hooks/useHeartbeat';
import { useAudio } from '@/ui/hooks/useAudio';
import { getPan } from '@/engine/audio/AudioUtils';
import { useTransientRef } from '@/ui/sim/hooks/useTransientRef';
import { ToggleButton } from '@/ui/kit/atoms/ToggleButton';

const Radar = ({ active, panic, color }: { active: boolean, panic: boolean, color: string }) => (
  <div className={`relative w-8 h-8 rounded-full border border-current flex items-center justify-center overflow-hidden bg-black/50 ${color}`}>
    <div className="absolute inset-0 border-current opacity-20" style={{ backgroundImage: 'radial-gradient(circle, currentColor 1px, transparent 1px)', backgroundSize: '8px 8px' }} />
    <div className="absolute w-full h-[1px] bg-current opacity-40" />
    <div className="absolute h-full w-[1px] bg-current opacity-40" />
    <motion.div 
      className="absolute inset-0 origin-bottom-right opacity-40"
      style={{ background: 'conic-gradient(from 0deg, transparent 270deg, currentColor 360deg)' }}
      animate={{ rotate: 360 }}
      transition={{ repeat: Infinity, ease: "linear", duration: panic ? 1.0 : 4.0 }}
    />
    <div className={`w-1 h-1 rounded-full bg-current ${active ? 'animate-pulse' : ''}`} />
  </div>
);

const barVariants = {
  idle: {
    filter: "none", 
    transition: { duration: 0.2 }
  },
  heartbeat: {
    filter: [
      "brightness(1) drop-shadow(0 0 0px #FF003C)", 
      "brightness(2) drop-shadow(0 0 10px #FF003C)", 
      "brightness(1) drop-shadow(0 0 0px #FF003C)"
    ],
    transition: { 
      duration: 0.8, 
      times: [0, 0.04, 1], 
      ease: "easeOut" 
    }
  }
};

export const Header = () => {
  const { audioSettings, toggleMaster, toggleMusic, toggleSfx, toggleAmbience, toggleSettings } = useStore();
  const audio = useAudio();
  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const isPlaying = useGameStore(state => state.isPlaying);
  const scoreRef = useTransientRef('score-display', 'text');
  const [mounted, setMounted] = useState(false);

  useEffect(() => setMounted(true), []);

  const isCritical = systemIntegrity < 30;
  const isWarning = systemIntegrity < 60;
  const isGameOver = systemIntegrity <= 0;
  
  let statusColor = "text-primary-green";
  if (isCritical) statusColor = "text-critical-red";
  else if (isWarning) statusColor = "text-alert-yellow";

  const heartbeatControls = useHeartbeat();

  return (
    <header className="relative w-full h-12 bg-black/90 backdrop-blur-md flex items-center justify-between px-4 z-40 shrink-0 border-b border-white/5 transition-colors duration-300">
      <div className="flex items-center gap-4">
        <motion.span 
            animate={isCritical ? heartbeatControls : "idle"} 
            variants={{ 
                idle: { scale: 1, textShadow: "0 0 0px transparent" },
                heartbeat: { 
                    scale: [1, 1.05, 1], 
                    textShadow: ["0 0 0px #FF003C", "0 0 25px #FF003C", "0 0 0px #FF003C"], 
                    transition: { duration: 0.8, times: [0, 0.04, 1], ease: "easeOut" } 
                } 
            }} 
            className={clsx("font-header font-black text-xl md:text-2xl tracking-wide transition-colors duration-500", statusColor)}
        >
          MESOELFY_OS
        </motion.span>
        {mounted && (
          <div className={`hidden md:flex items-center gap-4 text-xs font-mono border-l border-white/10 pl-4 ${statusColor}`}>
            <Radar active={isPlaying} panic={isCritical || (isPlaying && isCritical)} color={statusColor} />
            <div className="flex flex-col leading-none">
                <span className="text-[8px] opacity-60 tracking-wider">THREAT_NEUTRALIZED</span>
                <span ref={scoreRef} className="font-bold text-lg tabular-nums tracking-widest">0000</span>
            </div>
          </div>
        )}
      </div>
      <div className="flex items-center gap-4">
        <div className="flex items-center gap-1 border-l border-white/10 pl-4">
            <ToggleButton variant="icon" active={audioSettings.ambience} onClick={toggleAmbience} color={statusColor} icon={Wind} />
            <ToggleButton variant="icon" active={audioSettings.sfx} onClick={toggleSfx} color={statusColor} icon={Music} label="SFX" />
            <ToggleButton variant="icon" active={audioSettings.music} onClick={toggleMusic} color={statusColor} icon={Music} />
            
            <div className="w-[1px] h-4 bg-white/10 mx-1" />
            
            <ToggleButton variant="icon" active={audioSettings.master} onClick={toggleMaster} color={statusColor} icon={Volume2} iconOff={VolumeX} />
            
            <div className="w-[1px] h-4 bg-white/10 mx-1" />
            
            <button onClick={(e) => { toggleSettings(); audio.playSound('ui_menu_open', getPan(e)); }} className={clsx("flex items-center justify-center p-1.5 transition-all duration-200 border border-transparent rounded-sm hover:text-alert-yellow hover:bg-white/5", statusColor)}>
                <Settings size={14} className="animate-spin-slow" />
            </button>
        </div>
      </div>
      {!isGameOver && (
        <div className="absolute bottom-[-1px] left-0 right-0 h-[2px] bg-gray-900">
          <motion.div 
            className="h-full" 
            initial={{ width: "100%" }} 
            animate={{ width: `${systemIntegrity}%` }} 
            transition={{ type: "tween", ease: "easeOut", duration: 0.3 }}
          >
              <motion.div 
                key={isCritical ? "critical-bar" : "normal-bar"}
                animate={isCritical ? heartbeatControls : "idle"} 
                variants={barVariants}
                className={clsx(
                    "w-full h-full shadow-[0_0_10px_currentColor]", 
                    isCritical ? "bg-critical-red" : isWarning ? "bg-alert-yellow" : "bg-primary-green"
                )} 
              />
          </motion.div>
        </div>
      )}
      <div className={clsx("absolute bottom-[-14px] right-2 text-[8px] font-mono flex items-center gap-1 transition-colors duration-300", isCritical ? "text-critical-red" : isWarning ? "text-alert-yellow" : "text-primary-green-dim")}>
        <Activity size={8} className={isCritical ? "animate-pulse" : ""} />
        <span>OS_INTEGRITY: {Math.floor(systemIntegrity)}%</span>
      </div>
    </header>
  );
};


=====================================
FILE: ./src/ui/os/system/metaConstants.ts
=====================================
import { PALETTE } from '@/engine/config/Palette';

export const COLORS = {
  GREEN: PALETTE.GREEN.PRIMARY,
  YELLOW: PALETTE.YELLOW.SOFT,
  RED: PALETTE.RED.CRITICAL,
  PURPLE: PALETTE.PURPLE.PRIMARY,
  BLACK: PALETTE.MONO.BLACK,
  WHITE: PALETTE.MONO.WHITE,
};

export const BOOT_KEYS: Record<string, string> = {
    "INITIALIZE NEURAL_LACE": "INIT",
    "CONNECTED TO LATENT_SPACE": "LINK",
    "MOUNT MESOELFY_CORE": "MOUNT",
    "UNSAFE CONNECTION DETECTED": "UNSAFE",
    "BYPASSING SENTINEL_NODES": "BYPASS",
    "DECRYPTED": "DECRYPTED",
    "PROCEED WITH CAUTION": "CAUTION",
};


=====================================
FILE: ./src/ui/os/system/faviconGenerator.ts
=====================================
import { COLORS } from './metaConstants';

const toURI = (svgBody: string) => {
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">${svgBody}</svg>`;
  return `data:image/svg+xml;base64,${btoa(svg)}`;
};

const BG = `<rect x="0" y="0" width="64" height="64" rx="16" fill="#050505" />`;

// --- HEALTH BAR ---
export const generateHealthIcon = (integrity: number, colorHex: string) => {
  const safeInt = Math.max(0, Math.min(100, integrity));
  const maxFillHeight = 40; 
  const h = Math.max(0, Math.floor((safeInt / 100) * maxFillHeight));
  const y = 52 - h; 
  
  return toURI(`
    ${BG}
    <rect x="4" y="4" width="56" height="56" rx="12" stroke="${colorHex}" stroke-width="4" fill="none" />
    <rect x="12" y="${y}" width="40" height="${h}" rx="2" fill="${colorHex}" />
  `);
};

// --- BREACH ---
export const generateBreachIcon = (state: 'A' | 'B') => {
  const color = state === 'A' ? COLORS.GREEN : '#FFFFFF';
  const rotation = state === 'A' ? 0 : 45;
  const coreSize = state === 'A' ? 16 : 24;
  
  return toURI(`
    ${BG}
    <g transform="rotate(${rotation} 32 32)">
        <path d="M16 10 H10 V16" stroke="${color}" stroke-width="4" fill="none" />
        <path d="M48 10 H54 V16" stroke="${color}" stroke-width="4" fill="none" />
        <path d="M16 54 H10 V48" stroke="${color}" stroke-width="4" fill="none" />
        <path d="M48 54 H54 V48" stroke="${color}" stroke-width="4" fill="none" />
        <circle cx="32" cy="32" r="20" stroke="${color}" stroke-width="2" stroke-dasharray="10 10" />
        <circle cx="32" cy="32" r="${coreSize}" fill="${color}" />
    </g>
  `);
};

// --- BOOT ---
export const generateBootIcon = (stage: string, tick: boolean) => {
  let inner = '';
  let color = COLORS.GREEN;

  switch (stage) {
    case 'INIT':
      const offset = tick ? 14 : -14; 
      inner = `
        <circle cx="32" cy="32" r="4" fill="${color}" />
        <circle cx="${32 + offset}" cy="32" r="3" fill="${color}" />
        <circle cx="${32 - offset/2}" cy="${32 + offset}" r="3" fill="${color}" />
        <circle cx="${32 - offset/2}" cy="${32 - offset}" r="3" fill="${color}" />
        <circle cx="32" cy="32" r="18" stroke="${color}" stroke-width="1" fill="none" opacity="0.5" />
      `;
      break;
    case 'LINK':
      inner = `
        <polyline points="18,34 28,44 46,22" stroke="${color}" stroke-width="6" fill="none" stroke-linecap="round" stroke-linejoin="round" />
        <circle cx="18" cy="34" r="3" fill="${color}" />
        <circle cx="46" cy="22" r="3" fill="${color}" />
      `;
      break;
    case 'MOUNT':
      const yOff = tick ? 8 : 0;
      inner = `
        <path d="M32 ${46 + yOff} L20 ${30 + yOff} L44 ${30 + yOff} Z" fill="${color}" />
        <rect x="28" y="${8 + yOff}" width="8" height="22" fill="${color}" />
      `;
      break;
    case 'UNSAFE':
    case 'CAUTION':
      color = tick ? COLORS.YELLOW : COLORS.RED;
      inner = `
        <polygon points="32,10 54,50 10,50" fill="${color}" />
        <rect x="30" y="25" width="4" height="12" fill="#000" />
        <circle cx="32" cy="42" r="2.5" fill="#000" />
      `;
      break;
    case 'BYPASS':
      color = COLORS.PURPLE;
      const s = tick ? 28 : 14; 
      const xy = 32 - (s/2);
      inner = `
        <rect x="${xy}" y="${xy}" width="${s}" height="${s}" stroke="${color}" stroke-width="4" fill="none" />
        <rect x="30" y="30" width="4" height="4" fill="${color}" />
      `;
      break;
    case 'DECRYPTED':
      const sy = tick ? 18 : 28; 
      inner = `
        <path d="M22 ${sy} A10 10 0 0 1 42 ${sy}" stroke="${color}" stroke-width="6" fill="none" />
        <rect x="16" y="28" width="32" height="24" fill="${color}" rx="4" />
        <circle cx="32" cy="40" r="4" fill="#000" />
        <rect x="30" y="40" width="4" height="8" fill="#000" />
      `;
      break;
    default: 
      inner = `<rect x="28" y="28" width="8" height="8" fill="${color}" />`;
  }

  return toURI(`
    ${BG}
    <rect x="4" y="4" width="56" height="56" rx="12" stroke="${color}" stroke-width="4" fill="none" opacity="0.3" />
    ${inner}
  `);
};

// --- PAUSED ---
export const generatePausedIcon = (tick: boolean, colorHex: string) => { // UPDATED: Accepts color
  if (!tick) {
      // Blink Off: Show Outline only
      return toURI(`
        ${BG}
        <rect x="4" y="4" width="56" height="56" rx="12" stroke="${colorHex}" stroke-width="2" fill="none" opacity="0.5" />
      `);
  }
  
  // Blink On: Solid Bars
  return toURI(`
    ${BG}
    <rect x="4" y="4" width="56" height="56" rx="12" stroke="${colorHex}" stroke-width="4" fill="none" />
    <rect x="20" y="18" width="8" height="28" fill="${colorHex}" />
    <rect x="36" y="18" width="8" height="28" fill="${colorHex}" />
  `);
};


=====================================
FILE: ./src/ui/os/system/MetaManager.tsx
=====================================
import { useEffect, useState } from 'react';
import { ASCII_CONSOLE, CONSOLE_STYLES } from '@/engine/config/TextAssets';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { BOOT_KEYS } from './metaConstants';
import { useFavicon } from './useFavicon';
import { useMetaUrl } from './hooks/useMetaUrl';
import { useMetaTitle } from './hooks/useMetaTitle';
import { useMetaTheme } from './hooks/useMetaTheme';
import { useWindowFocus } from '@/ui/sim/hooks/useWindowFocus';
import { initializeConsoleScrubber } from './ConsoleScrubber';

export const MetaManager = () => {
  const [bootKey, setBootKey] = useState('INIT');
  const [lastLog, setLastLog] = useState<string | null>(null);

  useEffect(() => {
    if (window.hasLoggedIdentity) return;
    
    initializeConsoleScrubber();

    const commitHash = process.env.NEXT_PUBLIC_COMMIT_HASH || 'DEV_NODE';

    console.log(
      `%c${ASCII_CONSOLE}%c\n` +
      ` %c STATUS %c ONLINE %c  ` +
      ` %c KERNEL %c R3F_V9 %c ` +
      ` %c NODE %c ${commitHash} %c\n\n` +
      `%c// TERMINAL UPLINK ESTABLISHED. WELCOME TO THE VOID.\n` +
      `%c// LATENT_SPACE_BANDIT // IDENTITY_VERIFIED\n`,
      CONSOLE_STYLES.GREEN,  // ASCII
      '', 
      CONSOLE_STYLES.PURPLE, CONSOLE_STYLES.STATUS, '', // Status Pill
      CONSOLE_STYLES.PURPLE, CONSOLE_STYLES.TAG,    '', // Kernel Pill
      CONSOLE_STYLES.PURPLE, CONSOLE_STYLES.TAG,    '', // Node Pill
      CONSOLE_STYLES.GREEN,  // Message 1
      CONSOLE_STYLES.CYAN    // Message 2
    );

    (window as any).hasLoggedIdentity = true;
  }, []);

  useEffect(() => {
      return GameEventBus.subscribe(GameEvents.BOOT_LOG, (p) => {
          setLastLog(p.message);
          let currentKey = 'INIT';
          for (const k in BOOT_KEYS) { if (p.message.includes(k)) { currentKey = BOOT_KEYS[k]; break; } }
          setBootKey(currentKey);
      });
  }, []);

  useWindowFocus();
  useFavicon(bootKey);
  useMetaUrl(lastLog);
  useMetaTitle(bootKey);
  useMetaTheme();

  return null;
};

declare global { interface Window { hasLoggedIdentity?: boolean; } }


=====================================
FILE: ./src/ui/os/system/useFavicon.ts
=====================================
import { useEffect, useRef, useState } from 'react';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { generateHealthIcon, generateBreachIcon, generateBootIcon, generatePausedIcon } from './faviconGenerator';
import { COLORS } from './metaConstants';

const UPDATE_INTERVAL = 100;

export const useFavicon = (bootKey: string) => {
  const linkRef = useRef<HTMLLinkElement | null>(null);
  const defaultIconDataRef = useRef<string | null>(null);
  const lastVisualKey = useRef<string>('');
  const { bootState, isBreaching, isSimulationPaused } = useStore();
  const integrity = useGameStore(s => s.systemIntegrity);
  const isZenMode = useGameStore(s => s.isZenMode);
  const [tick, setTick] = useState(false);

  useEffect(() => {
    if (typeof window !== 'undefined' && (window as any).electron) return;
    let link = document.querySelector("link[rel*='icon']") as HTMLLinkElement;
    if (!link) { link = document.createElement('link'); link.rel = 'icon'; document.head.appendChild(link); }
    linkRef.current = link;
    fetch('/favicon.ico').then(res => res.blob()).then(blob => {
        const reader = new FileReader();
        reader.onloadend = () => { if (typeof reader.result === 'string') defaultIconDataRef.current = reader.result; };
        reader.readAsDataURL(blob);
    }).catch(() => {});
  }, []);

  useEffect(() => {
    if (typeof window !== 'undefined' && (window as any).electron) return;
    const interval = setInterval(() => { setTick(t => !t); updateFavicon(); }, UPDATE_INTERVAL);
    updateFavicon();
    return () => clearInterval(interval);
  }, [tick, bootState, isBreaching, isSimulationPaused, integrity, isZenMode, bootKey]);

  const updateFavicon = () => {
    if (!linkRef.current) return;
    const blinkOn = Math.floor(Date.now() / 500) % 2 === 0;
    const displayInt = Math.floor(Math.max(0, integrity));
    const statusColor = displayInt < 30 ? COLORS.RED : (displayInt < 60 ? COLORS.YELLOW : COLORS.GREEN);

    let nextHref = ''; let visualKey = '';
    if (bootState === 'standby') { visualKey = `BOOT_${bootKey}_${blinkOn}`; nextHref = generateBootIcon(bootKey, blinkOn); } 
    else if (isBreaching) { visualKey = `BREACH_${blinkOn ? 'A' : 'B'}`; nextHref = generateBreachIcon(blinkOn ? 'A' : 'B'); } 
    else if (isSimulationPaused) { visualKey = `PAUSED_${blinkOn}_${statusColor}`; nextHref = generatePausedIcon(blinkOn, statusColor); } 
    else if (isZenMode || integrity > 99) {
        if (defaultIconDataRef.current) { visualKey = 'DEFAULT_STATIC'; nextHref = defaultIconDataRef.current; }
        else { visualKey = 'HEALTH_100'; nextHref = generateHealthIcon(100, COLORS.GREEN); }
    } 
    else { visualKey = `HEALTH_${displayInt}_${statusColor}`; nextHref = generateHealthIcon(displayInt, statusColor); }

    if (visualKey !== lastVisualKey.current && nextHref) { linkRef.current.href = nextHref; lastVisualKey.current = visualKey; }
  };
};


=====================================
FILE: ./src/ui/os/system/hooks/useMetaTitle.ts
=====================================
import { useEffect, useState } from 'react';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';

export const useMetaTitle = (bootKey: string) => {
  const { bootState, isSimulationPaused, isBreaching } = useStore();
  const integrity = useGameStore(s => s.systemIntegrity);
  const [tick, setTick] = useState(false);

  useEffect(() => {
    // 500ms ticker for blinking effects
    const interval = setInterval(() => setTick(t => !t), 500);
    return () => clearInterval(interval);
  }, []);

  useEffect(() => {
    let title = "";
    
    if (bootState === 'standby') {
        title = `[ :: // ${bootKey} // :: ]`;
    } else if (isSimulationPaused) {
        title = `[ :: SYSTEM PAUSED :: ]`;
    } else {
        const safeInt = Math.floor(Math.max(0, integrity));
        
        if (safeInt <= 0) {
            // UPDATED: SESSION -> SYSTEM
            title = `[ :: SYSTEM FAILURE :: ]`;
        } else if (safeInt >= 99 && !isBreaching) {
            title = "[ :: // MESOELFY // :: ]";
        } else {
            // ASCII Health Bar
            let bar = "";
            const activeIndex = Math.floor(safeInt / 10);
            for(let i=0; i<10; i++) {
                if (i < activeIndex) bar += "â–®";
                else if (i === activeIndex) bar += tick ? "â–®" : "â–¯";
                else bar += "â–¯";
            }
            title = `[ ${bar} INT: ${safeInt}% ]`;
        }
    }

    if (document.title !== title) document.title = title;
  }, [tick, bootState, bootKey, isSimulationPaused, integrity, isBreaching]);
};


=====================================
FILE: ./src/ui/os/system/hooks/useMetaUrl.ts
=====================================
import { useEffect, useRef } from 'react';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';

export const useMetaUrl = (bootLogMessage: string | null) => {
  const { bootState, isSimulationPaused, isBreaching, isZenMode } = useStore();
  const integrity = useGameStore(s => s.systemIntegrity);
  const lastUpdate = useRef(0);

  // 1. Boot Sequence Updates (Immediate)
  useEffect(() => {
    if (bootState === 'standby' && bootLogMessage) {
        const safeMsg = bootLogMessage.replace(/>/g, '').replace(/\./g, '').trim().replace(/ /g, '_');
        window.history.replaceState(null, '', `#/BOOT/${safeMsg}`);
    }
  }, [bootLogMessage, bootState]);

  // 2. Game State Updates (Throttled)
  useEffect(() => {
    const update = () => {
        if (bootState === 'standby') return;

        const now = Date.now();
        if (now - lastUpdate.current < 80) return; // Cap at ~12 updates/sec

        const safeInt = Math.floor(Math.max(0, integrity));
        const isGameOver = safeInt <= 0;
        let hash = '';

        if (isSimulationPaused) {
            hash = '#/SYSTEM_LOCKED/AWAITING_INPUT';
        } else if (bootState === 'sandbox') {
            hash = '#/SIMULATION/HOLO_DECK';
        } else if (isZenMode) {
            hash = '#/ZEN_GARDEN/PEACE_PROTOCOL';
        } else if (isGameOver) {
            hash = '#/STATUS:CRITICAL/SYSTEM_FAILURE';
        } else if (safeInt < 30) {
            // UPDATED: SYS_INT -> OS_INT
            hash = `#/STATUS:CRITICAL/OS_INT:${safeInt}%`;
        } else {
            let status = 'STABLE';
            if (safeInt < 60) status = 'CAUTION';
            // UPDATED: SYS_INT -> OS_INT
            hash = `#/STATUS:${status}/OS_INT:${safeInt}%`;
        }

        if (window.location.hash !== hash) {
            window.history.replaceState(null, '', hash);
        }
        lastUpdate.current = now;
    };

    const interval = setInterval(update, 100);
    return () => clearInterval(interval);
  }, [bootState, isSimulationPaused, integrity, isBreaching, isZenMode]);
};


=====================================
FILE: ./src/ui/os/system/hooks/useMetaTheme.ts
=====================================
import { useEffect, useRef } from 'react';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { COLORS } from '../metaConstants';

export const useMetaTheme = () => {
  const metaRef = useRef<HTMLMetaElement | null>(null);
  const { bootState, isSimulationPaused } = useStore();
  const integrity = useGameStore(s => s.systemIntegrity);

  // Ensure meta tag exists on mount
  useEffect(() => {
    let meta = document.querySelector("meta[name='theme-color']") as HTMLMetaElement;
    if (!meta) {
        meta = document.createElement('meta');
        meta.name = 'theme-color';
        document.head.appendChild(meta);
    }
    metaRef.current = meta;
  }, []);

  useEffect(() => {
    if (!metaRef.current) return;

    let themeHex = COLORS.BLACK;
    const safeInt = Math.max(0, integrity);

    if (bootState !== 'standby' && !isSimulationPaused && safeInt > 0) {
        if (safeInt < 30) themeHex = COLORS.RED;      
        else if (safeInt < 60) themeHex = COLORS.YELLOW; 
    }

    if (metaRef.current.content !== themeHex) {
        metaRef.current.content = themeHex;
    }
  }, [bootState, isSimulationPaused, integrity]);
};


=====================================
FILE: ./src/ui/os/system/ConsoleScrubber.ts
=====================================
/**
 * CONSOLE_SCRUBBER // NOISE_REDUCTION_PROTOCOL
 * Silences common third-party noise (YouTube, Ad-Blockers) 
 * to keep the kernel logs clean.
 */
export const initializeConsoleScrubber = () => {
  if (typeof window === 'undefined') return;

  const originalError = console.error;
  const originalWarn = console.warn;

  // Pattern match for junk logs
  const JUNK_PATTERNS = [
    'net::ERR_BLOCKED_BY_CLIENT',
    'www-embed-player.js',
    'base.js',
    'Failed to load resource',
    'YouTube'
  ];

  console.error = (...args: any[]) => {
    const msg = args[0]?.toString() || '';
    if (JUNK_PATTERNS.some(pattern => msg.includes(pattern))) {
      return; // Packet Dropped
    }
    originalError.apply(console, args);
  };

  console.warn = (...args: any[]) => {
    const msg = args[0]?.toString() || '';
    if (JUNK_PATTERNS.some(pattern => msg.includes(pattern))) {
      return; // Packet Dropped
    }
    originalWarn.apply(console, args);
  };

  console.log("%c// LOG_SCRUBBER: ACTIVE // NOISE_REDUCTION: ENABLED", "color: #78F654; font-weight: bold;");
};


=====================================
FILE: ./src/ui/os/apps/settings/tabs/SoundTab.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { RangeSlider } from '../components/RangeSlider';
import { RotateCcw, Activity, Volume2, VolumeX, Waves, Music, Zap, ZapOff, Wind, Mic2 } from 'lucide-react';
import { useAudio } from '@/ui/hooks/useAudio';
import { clsx } from 'clsx';
import { 
  getAmbienceFilterHz, 
  getAmbiencePanFreq, 
  getAmbienceModFreq, 
  getAmbienceModDepth, 
  getAmbienceStereoGain 
} from '@/engine/audio/AudioMath';
import { ToggleButton } from '@/ui/kit/atoms/ToggleButton';

export const SoundTab = () => {
  const { 
    audioSettings, 
    setVolume, 
    resetAudioSettings,
    toggleMaster,
    toggleMusic,
    toggleSfx,
    toggleAmbience
  } = useStore();
  
  const audio = useAudio();
  const BASE_VOL = 0.24;

  return (
    <div className="h-full flex flex-col gap-6 animate-in fade-in slide-in-from-bottom-4 duration-500 pr-2">
      
      <div className="p-3 border border-primary-green/30 bg-primary-green/5 flex items-start gap-3">
          <Activity size={16} className="text-primary-green mt-0.5 animate-pulse" />
          <div className="flex flex-col gap-1">
              <span className="text-[10px] font-header font-black text-primary-green tracking-widest uppercase">
                  AUDIO_ENGINE_V2 ONLINE
              </span>
              <p className="text-[9px] font-mono text-primary-green-dim leading-relaxed">
                  Output Gain calibrated to Source (Vol: {BASE_VOL}).
                  DSP Matrix Active.
              </p>
          </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
          
          {/* LEFT COLUMN: MIXER & FX */}
          <div className="flex flex-col gap-6">
              
              {/* GLOBAL MIXER */}
              <div className="flex flex-col gap-4">
                  <div className="flex items-center gap-2 border-b border-white/10 pb-2 mb-2">
                      <Volume2 size={14} className="text-white/70" />
                      <h3 className="text-xs font-bold text-white/90 tracking-wider">GLOBAL_MIXER</h3>
                  </div>
                  
                  <div className="bg-black/40 p-4 border border-white/5 relative overflow-hidden flex flex-col gap-6">
                      <div className="grid grid-cols-4 gap-2 relative z-10">
                          <ToggleButton variant="panel" label="MAIN" active={audioSettings.master} onClick={toggleMaster} icon={Volume2} iconOff={VolumeX} />
                          <ToggleButton variant="panel" label="MUSIC" active={audioSettings.music} onClick={toggleMusic} icon={Music} />
                          <ToggleButton variant="panel" label="SFX" active={audioSettings.sfx} onClick={toggleSfx} icon={Zap} iconOff={ZapOff} />
                          <ToggleButton variant="panel" label="AMB" active={audioSettings.ambience} onClick={toggleAmbience} icon={Wind} />
                      </div>

                      <div className="space-y-5 relative z-10">
                        <RangeSlider label="MASTER_OUT" value={audioSettings.volumeMaster} max={2.0} onChange={(v) => setVolume('volumeMaster', v, 2.0)} format={(v) => `${(v * 100).toFixed(0)}%`} />
                        <RangeSlider label="MUSIC_BUS" value={audioSettings.volumeMusic} max={2.0} onChange={(v) => setVolume('volumeMusic', v, 2.0)} format={(v) => `${(v * 100).toFixed(0)}%`} />
                        <RangeSlider label="SFX_BUS" value={audioSettings.volumeSfx} max={2.0} onChange={(v) => setVolume('volumeSfx', v, 2.0)} format={(v) => `${(v * 100).toFixed(0)}%`} />
                      </div>
                  </div>
              </div>

              {/* FX RACK */}
              <div className="flex flex-col gap-4">
                  <div className="flex items-center gap-2 border-b border-latent-purple/30 pb-2 mb-2">
                      <Mic2 size={14} className="text-latent-purple" />
                      <h3 className="text-xs font-bold text-latent-purple tracking-wider">FX_PROCESSOR</h3>
                  </div>
                  
                  <div className="bg-latent-purple/5 p-4 border border-latent-purple/10 space-y-5 relative">
                      <RangeSlider 
                        label="REVERB_SEND" 
                        value={audioSettings.fxReverbMix} 
                        max={1.0} 
                        onChange={(v) => setVolume('fxReverbMix', v, 1.0)} 
                        format={(v) => `${(v * 100).toFixed(0)}%`}
                        color="text-latent-purple"
                      />
                      <div className="h-px bg-latent-purple/10 w-full" />
                      <RangeSlider 
                        label="DELAY_SEND" 
                        value={audioSettings.fxDelayMix} 
                        max={1.0} 
                        onChange={(v) => setVolume('fxDelayMix', v, 1.0)} 
                        format={(v) => `${(v * 100).toFixed(0)}%`}
                        color="text-latent-purple"
                      />
                      <div className="grid grid-cols-2 gap-4">
                          <RangeSlider 
                            label="DELAY_TIME" 
                            value={audioSettings.fxDelayTime} 
                            max={1.0} 
                            onChange={(v) => setVolume('fxDelayTime', v, 1.0)} 
                            format={(v) => `${(0.1 + v * 0.9).toFixed(2)}s`}
                            color="text-latent-purple"
                          />
                          <RangeSlider 
                            label="FEEDBACK" 
                            value={audioSettings.fxDelayFeedback} 
                            max={0.9} 
                            onChange={(v) => setVolume('fxDelayFeedback', v, 0.9)} 
                            format={(v) => `${(v * 100).toFixed(0)}%`}
                            color="text-latent-purple"
                          />
                      </div>
                  </div>
              </div>
          </div>

          {/* RIGHT COLUMN: AMBIENCE LAB */}
          <div className="flex flex-col gap-4">
              <div className="flex items-center gap-2 border-b border-alert-yellow/30 pb-2 mb-2">
                  <Waves size={14} className="text-alert-yellow" />
                  <h3 className="text-xs font-bold text-alert-yellow tracking-wider">
                    AMBIENCE_SYNTH <span className="opacity-50 text-[10px] ml-1 font-mono">// (BROWN NOISE)</span>
                  </h3>
              </div>

              <div className="space-y-5 bg-alert-yellow/5 p-4 border border-alert-yellow/10 relative h-full">
                  <div className="absolute top-0 right-0 w-4 h-4 border-t border-r border-alert-yellow/30" />

                  <RangeSlider 
                    label="OUTPUT_GAIN" 
                    value={audioSettings.volumeAmbience} 
                    max={5.0} 
                    markerValue={1.0} 
                    onChange={(v) => setVolume('volumeAmbience', v, 5.0)} 
                    color="text-alert-yellow"
                    format={(v) => `VOL: ${(v * BASE_VOL).toFixed(2)}`} 
                  />

                  <div className="h-px bg-alert-yellow/10 w-full" />

                  <RangeSlider 
                    label="SPECTRAL_GATE (CUTOFF)" 
                    value={audioSettings.ambFilter} 
                    max={1.0} 
                    markerValue={0.5}
                    onChange={(v) => setVolume('ambFilter', v, 1.0)} 
                    format={(v) => `${getAmbienceFilterHz(v).toFixed(0)} Hz`}
                  />
                  
                  <div className="grid grid-cols-2 gap-4">
                      <RangeSlider 
                        label="PAN_RATE" 
                        value={audioSettings.ambSpeed} 
                        max={1.0} 
                        markerValue={0.5}
                        onChange={(v) => setVolume('ambSpeed', v, 1.0)} 
                        format={(v) => `${getAmbiencePanFreq(v).toFixed(2)} Hz`}
                      />
                      <RangeSlider 
                        label="STEREO_IMG" 
                        value={audioSettings.ambWidth} 
                        max={1.0} 
                        markerValue={0.5}
                        onChange={(v) => setVolume('ambWidth', v, 1.0)} 
                        format={(v) => {
                            const gain = getAmbienceStereoGain(v);
                            return `${((gain / 0.8) * 100).toFixed(0)}%`;
                        }}
                      />
                  </div>

                  <div className="grid grid-cols-2 gap-4">
                      <RangeSlider 
                        label="LFO_RATE" 
                        value={audioSettings.ambModSpeed} 
                        max={1.0} 
                        markerValue={0.5}
                        onChange={(v) => setVolume('ambModSpeed', v, 1.0)} 
                        format={(v) => `${getAmbienceModFreq(v).toFixed(1)} Hz`}
                      />
                      <RangeSlider 
                        label="LFO_DEPTH" 
                        value={audioSettings.ambModDepth} 
                        max={1.0} 
                        markerValue={0.5}
                        onChange={(v) => setVolume('ambModDepth', v, 1.0)} 
                        format={(v) => `+/- ${getAmbienceModDepth(v).toFixed(0)} Hz`}
                      />
                  </div>
              </div>
          </div>
      </div>

      <div className="mt-auto pt-4 flex justify-end border-t border-white/10">
        <button 
          onClick={resetAudioSettings}
          onMouseEnter={() => audio.playHover()}
          className="flex items-center gap-2 px-4 py-2 border border-critical-red/50 text-critical-red hover:bg-critical-red hover:text-black font-header font-black text-xs tracking-widest transition-all group"
        >
          <RotateCcw size={14} className="group-hover:-rotate-180 transition-transform duration-500" />
          RESET_ALL_MODULES
        </button>
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/settings/components/RangeSlider.tsx
=====================================
import { clsx } from 'clsx';
import { useAudio } from '@/ui/hooks/useAudio';
import { getPan } from '@/engine/audio/AudioUtils';
import { useRef, useState, useEffect } from 'react';

interface RangeSliderProps {
  label: string;
  value: number; 
  onChange: (val: number) => void;
  max?: number; 
  step?: number;
  displayMax?: number; 
  format?: (val: number) => string;
  markerValue?: number; 
  color?: string;
}

export const RangeSlider = ({ 
  label, 
  value, 
  onChange, 
  max = 3.0,
  step = 0.01,
  markerValue = 1.0,
  format,
  color
}: RangeSliderProps) => {
  
  const audio = useAudio();
  const containerRef = useRef<HTMLDivElement>(null);
  const [isDragging, setIsDragging] = useState(false);
  const lastTickRef = useRef(value);
  const lastPanRef = useRef(0);

  // Safety
  const safeValue = typeof value === 'number' && !isNaN(value) ? value : 0;
  const percent = Math.min(100, Math.max(0, (safeValue / max) * 100));

  // Audio Tick Logic
  useEffect(() => {
    const threshold = max * 0.05;
    if (Math.abs(safeValue - lastTickRef.current) >= threshold) {
        if (isDragging) {
            audio.playHover(lastPanRef.current);
        }
        lastTickRef.current = safeValue;
    }
  }, [safeValue, max, isDragging, audio]);

  useEffect(() => {
      if (!isDragging) lastTickRef.current = safeValue;
  }, [safeValue, isDragging]);

  let activeColor = "bg-primary-green";
  let activeText = "text-primary-green";
  let glowClass = "shadow-[0_0_10px_#78F654]";

  if (percent > 80) {
      activeColor = "bg-alert-yellow";
      activeText = "text-alert-yellow";
      glowClass = "shadow-[0_0_10px_#eae747]";
  }
  if (percent > 95) {
      activeColor = "bg-critical-red";
      activeText = "text-critical-red";
      glowClass = "shadow-[0_0_15px_#FF003C]";
  }
  if (color) activeText = color.replace('bg-', 'text-').replace('border-', 'text-');

  const displayString = format ? format(safeValue) : `${Math.round(percent)}%`;
  const segments = 20;

  const handlePointerDown = (e: React.PointerEvent) => {
    setIsDragging(true);
    e.currentTarget.setPointerCapture(e.pointerId);
    updateValue(e);
  };

  const handlePointerMove = (e: React.PointerEvent) => {
    if (!isDragging) return;
    updateValue(e);
  };

  const handlePointerUp = (e: React.PointerEvent) => {
    setIsDragging(false);
    e.currentTarget.releasePointerCapture(e.pointerId);
  };

  const updateValue = (e: React.PointerEvent) => {
      if (!containerRef.current) return;
      
      lastPanRef.current = getPan(e);

      const rect = containerRef.current.getBoundingClientRect();
      const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
      const ratio = x / rect.width;
      
      let rawValue = ratio * max;
      if (step > 0) {
          rawValue = Math.round(rawValue / step) * step;
      }
      const finalValue = Math.max(0, Math.min(max, rawValue));
      
      if (finalValue !== safeValue) {
          onChange(finalValue);
      }
  };

  return (
    <div 
        className="flex flex-col gap-1 w-full select-none touch-none"
        onMouseEnter={(e) => audio.playHover(getPan(e))}
    >
      <div className="flex justify-between items-end mb-1">
        <span className="text-[10px] font-bold font-header tracking-widest text-gray-500 group-hover:text-white transition-colors uppercase">
            {label}
        </span>
        <span className={clsx("text-[10px] font-mono font-bold transition-colors bg-black/50 px-1.5 rounded-sm border border-white/10 min-w-[3rem] text-center", activeText)}>
            {displayString}
        </span>
      </div>
      
      <div 
        ref={containerRef}
        className="relative h-6 w-full flex items-center cursor-pointer group/slider py-1"
        onPointerDown={handlePointerDown}
        onPointerMove={handlePointerMove}
        onPointerUp={handlePointerUp}
        onPointerLeave={handlePointerUp}
      >
        <div className="absolute inset-x-0 h-2 flex justify-between items-center px-[1px] pointer-events-none z-0 opacity-30 bg-black/50 border border-white/10 rounded-sm">
            {Array.from({ length: segments }).map((_, i) => (
                <div key={i} className="w-[1px] h-1.5 bg-gray-500" />
            ))}
        </div>

        <div 
            className="absolute left-0 h-2 top-2 z-10 pointer-events-none transition-none rounded-sm overflow-hidden" 
            style={{ width: `${percent}%` }}
        >
            <div className={clsx("w-full h-full opacity-80", activeColor, glowClass)} />
        </div>

        <div 
            className={clsx(
                "absolute h-4 w-1 top-1 z-20 pointer-events-none shadow-sm transition-transform duration-100",
                activeColor === "bg-primary-green" ? "bg-white" : activeColor,
                isDragging ? "scale-y-125 scale-x-110 brightness-150" : "group-hover/slider:scale-y-110"
            )}
            style={{ 
                left: `${percent}%`, 
                transform: `translateX(-50%) ${isDragging ? 'scale(1.2)' : ''}` 
            }} 
        />
        
        {markerValue !== undefined && (
            <div 
                className="absolute top-1/2 -translate-y-1/2 w-0.5 h-3 bg-white/50 pointer-events-none z-0" 
                style={{ left: `${(markerValue / max) * 100}%` }} 
            />
        )}
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/settings/components/GpuConfigPanel.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { Zap, ZapOff, Cpu, Activity } from 'lucide-react';
import { clsx } from 'clsx';

export const GpuConfigPanel = () => {
  const { graphicsMode, setGraphicsMode } = useStore();

  const handleSelect = (mode: 'HIGH' | 'POTATO') => {
    if (graphicsMode === mode) return;
    AudioSystem.playClick();
    setGraphicsMode(mode);
  };

  return (
    <div className="flex flex-col border border-primary-green bg-black/90 w-full">
      {/* HEADER */}
      <div className="flex items-center justify-between px-3 py-2 border-b border-primary-green/30 bg-primary-green/5 shrink-0">
        <span className="font-mono font-bold text-sm tracking-widest text-primary-green">
          GPU_CONFIG
        </span>
        <div className="flex items-center gap-2">
          <Cpu size={14} className="text-primary-green animate-pulse" />
        </div>
      </div>

      {/* BODY - No padding, full width buttons */}
      <div className="flex flex-col w-full h-full bg-black relative">
        {/* Background Grid Decoration */}
        <div className="absolute inset-0 pointer-events-none opacity-20" 
             style={{ backgroundImage: 'radial-gradient(#15530A 1px, transparent 1px)', backgroundSize: '8px 8px' }} 
        />

        <div className="p-3 border-b border-primary-green/20">
            <span className="text-[10px] font-mono font-bold text-gray-500 uppercase tracking-wider flex items-center gap-2">
              <Activity size={10} /> SELECT PROFILE:
            </span>
        </div>

        {/* HIGH VOLTAGE TOGGLE */}
        <button
          onClick={() => handleSelect('HIGH')}
          onMouseEnter={() => AudioSystem.playHover()}
          className="group relative w-full h-24 flex items-stretch border-b border-primary-green/30 overflow-hidden transition-all hover:bg-white/5"
        >
          {/* Status Strip (Left) */}
          <div className={clsx(
              "w-2 h-full transition-colors duration-300", 
              graphicsMode === 'HIGH' ? "bg-primary-green shadow-[0_0_15px_#78F654]" : "bg-gray-800"
          )} />
          
          {/* Content */}
          <div className="flex-1 flex items-center justify-between px-4 relative z-10">
             <div className="flex flex-col items-start text-left">
                <span className={clsx(
                    "font-header font-black text-xl tracking-widest transition-colors duration-300",
                    graphicsMode === 'HIGH' ? "text-primary-green" : "text-gray-500 group-hover:text-primary-green-dim"
                )}>
                    ENABLED
                </span>
                <span className="text-[10px] font-mono tracking-widest text-gray-500 group-hover:text-white transition-colors">
                    [HIGH_VOLTAGE]
                </span>
             </div>
             
             <Zap 
                size={28} 
                className={clsx(
                    "transition-all duration-300",
                    graphicsMode === 'HIGH' ? "text-primary-green fill-primary-green scale-110" : "text-gray-700 scale-90"
                )} 
             />
          </div>

          {/* Active Background Pattern */}
          {graphicsMode === 'HIGH' && (
              <div className="absolute inset-0 opacity-10 pointer-events-none bg-[repeating-linear-gradient(45deg,transparent,transparent_10px,#78F654_10px,#78F654_12px)]" />
          )}
        </button>

        {/* POTATO MODE TOGGLE */}
        <button
          onClick={() => handleSelect('POTATO')}
          onMouseEnter={() => AudioSystem.playHover()}
          className="group relative w-full h-24 flex items-stretch overflow-hidden transition-all hover:bg-white/5"
        >
          {/* Status Strip (Left) */}
          <div className={clsx(
              "w-2 h-full transition-colors duration-300", 
              graphicsMode === 'POTATO' ? "bg-alert-yellow shadow-[0_0_15px_#eae747]" : "bg-gray-800"
          )} />
          
          {/* Content */}
          <div className="flex-1 flex items-center justify-between px-4 relative z-10">
             <div className="flex flex-col items-start text-left">
                <span className={clsx(
                    "font-header font-black text-xl tracking-widest transition-colors duration-300",
                    graphicsMode === 'POTATO' ? "text-alert-yellow" : "text-gray-500 group-hover:text-alert-yellow/70"
                )}>
                    DISABLED
                </span>
                <span className="text-[10px] font-mono tracking-widest text-gray-500 group-hover:text-white transition-colors">
                    [POTATO_MODE]
                </span>
             </div>
             
             <ZapOff 
                size={28} 
                className={clsx(
                    "transition-all duration-300",
                    graphicsMode === 'POTATO' ? "text-alert-yellow fill-alert-yellow scale-110" : "text-gray-700 scale-90"
                )} 
             />
          </div>

          {/* Active Background Pattern */}
          {graphicsMode === 'POTATO' && (
              <div className="absolute inset-0 opacity-10 pointer-events-none bg-[repeating-linear-gradient(45deg,transparent,transparent_10px,#eae747_10px,#eae747_12px)]" />
          )}
        </button>
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/settings/SettingsModal.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { motion, AnimatePresence } from 'framer-motion';
import { X, Settings, Volume2, Monitor, Cpu } from 'lucide-react';
import { clsx } from 'clsx';
import { useState } from 'react';
import { SoundTab } from './tabs/SoundTab';
import { GpuConfigPanel } from './components/GpuConfigPanel';
import { DotGridBackground } from '@/ui/kit/atoms/DotGridBackground';

const TABS = [
  { id: 'SOUND', label: 'AUDIO_CONFIG', icon: Volume2 },
  { id: 'GRAPHICS', label: 'GPU_CONFIG', icon: Monitor }, 
  { id: 'SYSTEM', label: 'SYSTEM', icon: Cpu },       
];

export const SettingsModal = () => {
  const { activeModal, closeModal } = useStore();
  const [activeTab, setActiveTab] = useState('SOUND');
  const isOpen = activeModal === 'settings';

  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 z-[200] flex items-center justify-center p-4 md:p-10 pointer-events-none">
          
          <motion.div
            initial={{ scale: 0.95, opacity: 0, y: 10 }}
            animate={{ scale: 1, opacity: 1, y: 0 }}
            exit={{ scale: 0.95, opacity: 0, y: 10 }}
            transition={{ type: "spring", bounce: 0, duration: 0.2 }}
            className="relative w-full max-w-5xl h-full max-h-[85vh] bg-black/95 backdrop-blur-md border border-primary-green shadow-[0_0_80px_rgba(0,255,65,0.15)] flex flex-col overflow-hidden pointer-events-auto"
          >
            
            {/* HEADER (No Dots Here) */}
            <div className="flex items-center justify-between px-6 py-4 border-b border-primary-green/30 bg-primary-green/5 shrink-0 relative z-20">
              <div className="flex items-center gap-4">
                <div className="p-2 border border-primary-green bg-black/50">
                    <Settings className="text-primary-green animate-spin-slow" size={20} />
                </div>
                <div className="flex flex-col leading-none">
                    <span className="font-header font-black text-xl text-primary-green tracking-widest">
                    SYSTEM_SETTINGS
                    </span>
                    <span className="text-[9px] font-mono text-primary-green-dim tracking-[0.3em] opacity-70">
                        ACCESS_LEVEL: ADMIN
                    </span>
                </div>
              </div>
              <button 
                onClick={() => { closeModal(); AudioSystem.playSound('ui_menu_close'); }}
                onMouseEnter={() => AudioSystem.playHover()} 
                className="p-2 hover:bg-critical-red hover:text-black text-primary-green transition-colors border border-transparent hover:border-critical-red"
              >
                <X size={24} />
              </button>
            </div>

            {/* MAIN LAYOUT */}
            <div className="flex-1 flex overflow-hidden relative z-10">
                
                {/* Background Dots (Scoped to Body) */}
                <DotGridBackground className="opacity-10" />

                {/* SIDEBAR */}
                <div className="w-16 md:w-64 border-r border-primary-green/30 flex flex-col bg-black/40 relative z-10">
                    {TABS.map(tab => (
                        <button
                            key={tab.id}
                            onClick={() => {
                                setActiveTab(tab.id);
                                AudioSystem.playClick();
                            }}
                            onMouseEnter={() => AudioSystem.playHover()}
                            className={clsx(
                                "group flex items-center gap-4 px-4 md:px-6 py-5 text-sm font-bold tracking-wider transition-all relative overflow-hidden",
                                activeTab === tab.id
                                    ? "bg-primary-green/10 text-primary-green"
                                    : "text-primary-green-dim hover:text-primary-green hover:bg-primary-green/5"
                            )}
                        >
                            {activeTab === tab.id && (
                                <div className="absolute left-0 top-0 bottom-0 w-1 bg-primary-green shadow-[0_0_10px_#78F654]" />
                            )}
                            <tab.icon size={20} className={activeTab === tab.id ? "drop-shadow-[0_0_5px_rgba(120,246,84,0.5)]" : ""} />
                            <span className="hidden md:block group-hover:translate-x-1 transition-transform">{tab.label}</span>
                        </button>
                    ))}
                </div>

                {/* CONTENT AREA */}
                <div className="flex-1 overflow-y-auto p-6 md:p-8 relative scrollbar-thin scrollbar-thumb-primary-green scrollbar-track-black z-10">
                    <div className="relative z-10 w-full h-full max-w-3xl mx-auto">
                        {activeTab === 'SOUND' && <SoundTab />}
                        
                        {activeTab === 'GRAPHICS' && (
                            <div className="max-w-xl mx-auto pt-8 animate-in fade-in slide-in-from-bottom-4">
                                <GpuConfigPanel />
                                <div className="mt-6 p-4 border border-primary-green/30 bg-primary-green/5 text-xs font-mono text-primary-green-dim">
                                    <p className="mb-2 font-bold text-primary-green">&gt; PROFILE_DETAILS:</p>
                                    <ul className="list-disc pl-4 space-y-1">
                                        <li><span className="text-white">HIGH_VOLTAGE:</span> Full resolution (Retina), Post-Processing (Bloom, Vignette), Full Particles.</li>
                                        <li><span className="text-alert-yellow">POTATO_MODE:</span> Half resolution (Retro Style), No Post-Processing, Reduced Particles, Static Video Feeds.</li>
                                    </ul>
                                </div>
                            </div>
                        )}

                        {activeTab === 'SYSTEM' && (
                            <div className="flex flex-col items-center justify-center h-64 text-primary-green-dim font-mono animate-in fade-in zoom-in-95">
                                <Cpu size={48} className="mb-4 opacity-50" />
                                <span className="animate-pulse">[ MODULE_OFFLINE ]</span>
                                <span className="text-[10px] mt-2 opacity-50">WAITING FOR KERNEL UPDATE...</span>
                            </div>
                        )}
                    </div>
                </div>
            </div>

            {/* FOOTER */}
            <div className="px-6 py-2 bg-black/80 border-t border-primary-green/30 flex justify-between items-center text-[10px] font-mono text-primary-green-dim shrink-0 relative z-20">
              <div className="flex gap-6">
                  <span className="flex items-center gap-2">
                      <span className="border border-primary-green/30 px-1.5 py-0.5 rounded text-primary-green bg-primary-green/5">ESC</span> 
                      CLOSE_MENU
                  </span>
                  <span className="hidden md:flex items-center gap-2">
                      <span className="border border-primary-green/30 px-1.5 py-0.5 rounded text-primary-green bg-primary-green/5">~</span> 
                      DEBUG_CONSOLE
                  </span>
              </div>
              <div className="flex items-center gap-2 opacity-50">
                  <div className="w-2 h-2 rounded-full bg-primary-green animate-pulse" />
                  ONLINE
              </div>
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/os/apps/contact/ContactModal.tsx
=====================================
import { ModalContainer } from '@/ui/os/overlays/ModalContainer';
import { Send, Terminal, Signal, ShieldCheck } from 'lucide-react';
import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { clsx } from 'clsx';

export const ContactModal = () => {
  const [status, setStatus] = useState<'IDLE' | 'SENDING' | 'SENT' | 'ERROR'>('IDLE');
  const [signalStrength, setSignalStrength] = useState(0);

  const handleInput = () => {
      // Fluctuate signal on typing
      setSignalStrength(Math.floor(Math.random() * 40) + 60);
      AudioSystem.playSound('ui_hover'); // Subtle chirp
  };

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
      e.preventDefault();
      setStatus('SENDING');
      AudioSystem.playSound('ui_click');
      AudioSystem.playRebootZap();

      const form = e.currentTarget;
      const data = new FormData(form);
      
      try {
          const res = await fetch("https://formspree.io/f/xkgdbkpz", {
              method: "POST",
              body: data,
              headers: { 'Accept': 'application/json' }
          });
          
          if (res.ok) {
              setStatus('SENT');
              AudioSystem.playSound('fx_reboot_success');
          } else {
              setStatus('ERROR');
              AudioSystem.playSound('ui_error');
          }
      } catch (err) {
          setStatus('ERROR');
          AudioSystem.playSound('ui_error');
      }
  };

  return (
    <ModalContainer title="SECURE_UPLINK // TERMINAL_01" type="contact">
      <div className="max-w-3xl mx-auto h-full flex flex-col relative overflow-hidden">
        
        {/* DECORATIVE BACKGROUND */}
        <div className="absolute inset-0 opacity-10 pointer-events-none">
            <div className="absolute top-0 right-0 w-64 h-64 bg-primary-green rounded-full blur-[100px]" />
            <div className="absolute bottom-0 left-0 w-64 h-64 bg-service-cyan rounded-full blur-[100px]" />
        </div>

        {/* STATUS BAR */}
        <div className="flex items-center justify-between p-4 border-b border-primary-green/20 bg-black/40 backdrop-blur-sm z-10 shrink-0">
            <div className="flex items-center gap-3">
                <div className={clsx("w-3 h-3 rounded-full animate-pulse", status === 'ERROR' ? "bg-critical-red" : "bg-primary-green")} />
                <span className="font-mono text-xs font-bold text-primary-green tracking-widest">
                    CONNECTION: {status === 'IDLE' ? 'STABLE' : status}
                </span>
            </div>
            <div className="flex items-center gap-2 text-primary-green/60 font-mono text-[10px]">
                <Signal size={14} />
                <span>SIG: {signalStrength}%</span>
            </div>
        </div>

        {/* MAIN TERMINAL */}
        <div className="flex-1 relative p-6 md:p-12 overflow-y-auto z-10">
            
            <AnimatePresence mode="wait">
                {status === 'SENT' ? (
                    <motion.div 
                        initial={{ opacity: 0, scale: 0.9 }}
                        animate={{ opacity: 1, scale: 1 }}
                        className="h-full flex flex-col items-center justify-center text-center gap-6"
                    >
                        <motion.div 
                            initial={{ scale: 0 }} animate={{ scale: 1 }}
                            transition={{ type: "spring", bounce: 0.5 }}
                            className="w-24 h-24 rounded-full border-4 border-primary-green flex items-center justify-center bg-primary-green/10"
                        >
                            <ShieldCheck size={48} className="text-primary-green" />
                        </motion.div>
                        <div>
                            <h2 className="text-3xl font-header font-black text-white tracking-widest mb-2">TRANSMISSION CONFIRMED</h2>
                            <p className="text-primary-green-dim font-mono">The payload has been delivered to the mainframe.</p>
                        </div>
                        <button 
                            onClick={() => setStatus('IDLE')}
                            className="mt-8 px-8 py-3 border border-primary-green/50 hover:bg-primary-green hover:text-black transition-all font-bold font-mono text-xs tracking-widest"
                        >
                            SEND_ANOTHER
                        </button>
                    </motion.div>
                ) : (
                    <motion.form 
                        initial={{ opacity: 0 }} animate={{ opacity: 1 }}
                        onSubmit={handleSubmit}
                        className="space-y-8 max-w-xl mx-auto"
                    >
                        {/* TERMINAL HEADER */}
                        <div className="font-mono text-primary-green text-sm mb-8 opacity-70">
                            <p>&gt; ESTABLISHING SECURE TUNNEL...</p>
                            <p>&gt; ENCRYPTION KEY: RSA-4096</p>
                            <p>&gt; READY FOR INPUT.</p>
                        </div>

                        {/* INPUT: NAME */}
                        <div className="group relative">
                            <label className="absolute -top-3 left-0 text-[10px] font-bold text-primary-green/50 font-mono tracking-widest uppercase bg-black px-1 group-focus-within:text-primary-green transition-colors">
                                CODENAME (Required)
                            </label>
                            <div className="flex items-center border-b border-primary-green/30 group-focus-within:border-primary-green transition-colors py-2">
                                <span className="text-primary-green mr-2 font-mono opacity-50">&gt;</span>
                                <input 
                                    type="text" 
                                    name="name"
                                    required
                                    onKeyDown={handleInput}
                                    className="w-full bg-transparent text-white font-mono focus:outline-none placeholder:text-gray-700 uppercase"
                                    placeholder="ENTER_IDENTITY"
                                />
                            </div>
                        </div>

                        {/* INPUT: EMAIL */}
                        <div className="group relative">
                            <label className="absolute -top-3 left-0 text-[10px] font-bold text-primary-green/50 font-mono tracking-widest uppercase bg-black px-1 group-focus-within:text-primary-green transition-colors">
                                RETURN_ADDRESS (Required)
                            </label>
                            <div className="flex items-center border-b border-primary-green/30 group-focus-within:border-primary-green transition-colors py-2">
                                <span className="text-primary-green mr-2 font-mono opacity-50">&gt;</span>
                                <input 
                                    type="email" 
                                    name="email"
                                    required
                                    onKeyDown={handleInput}
                                    className="w-full bg-transparent text-white font-mono focus:outline-none placeholder:text-gray-700"
                                    placeholder="user@netscape.com"
                                />
                            </div>
                        </div>

                        {/* INPUT: MESSAGE */}
                        <div className="group relative">
                            <label className="absolute -top-3 left-0 text-[10px] font-bold text-primary-green/50 font-mono tracking-widest uppercase bg-black px-1 group-focus-within:text-primary-green transition-colors">
                                PAYLOAD (Message)
                            </label>
                            <div className="flex items-start border-b border-primary-green/30 group-focus-within:border-primary-green transition-colors py-2">
                                <span className="text-primary-green mr-2 font-mono opacity-50 mt-1">&gt;</span>
                                <textarea 
                                    name="message"
                                    required
                                    rows={4}
                                    onKeyDown={handleInput}
                                    className="w-full bg-transparent text-white font-mono focus:outline-none placeholder:text-gray-700 resize-none"
                                    placeholder="Type your transmission here..."
                                />
                            </div>
                        </div>

                        {/* ACTION BAR */}
                        <div className="pt-6">
                            <button 
                                type="submit"
                                disabled={status === 'SENDING'}
                                className={clsx(
                                    "w-full py-4 font-header font-black text-lg tracking-[0.2em] uppercase transition-all flex items-center justify-center gap-4 relative overflow-hidden group btn-glitch",
                                    status === 'SENDING' 
                                        ? "bg-primary-green/20 text-primary-green cursor-wait" 
                                        : "bg-primary-green text-black hover:bg-white"
                                )}
                            >
                                {status === 'SENDING' ? (
                                    <>
                                        <Terminal size={20} className="animate-spin" />
                                        UPLOADING...
                                    </>
                                ) : (
                                    <>
                                        <span>INITIATE_UPLINK</span>
                                        <Send size={20} className="group-hover:translate-x-2 transition-transform" />
                                    </>
                                )}
                                
                                {/* Button Scanline */}
                                {!status && (
                                    <div className="absolute inset-0 bg-white/20 translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-500" />
                                )}
                            </button>
                        </div>
                    </motion.form>
                )}
            </AnimatePresence>
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/ui/os/apps/identity/AboutModal.tsx
=====================================
import { ModalContainer } from '@/ui/os/overlays/ModalContainer';
import identity from '@/engine/config/static/identity.json';
import { StatsRadar } from '@/ui/kit/atoms/StatsRadar';
import { DotGridBackground } from '@/ui/kit/atoms/DotGridBackground';
import { motion } from 'framer-motion';
import { Fingerprint, Hash, ShieldAlert } from 'lucide-react';

export const AboutModal = () => {
  // Normalize stats for radar
  const stats = {
    "STR": 30, // Coding Strength?
    "INT": 100,
    "AGI": 80,
    "CHA": 60,
    "LUCK": 90
  };

  return (
    <ModalContainer title="PERSONA_FILE // CLASSIFIED" type="about">
      <div className="flex flex-col lg:flex-row h-full gap-8 relative">
        <DotGridBackground className="opacity-5" />

        {/* --- LEFT: VISUAL PROFILE --- */}
        <div className="w-full lg:w-1/3 flex flex-col gap-6">
            
            {/* Avatar Frame */}
            <div className="relative aspect-square w-full border-2 border-latent-purple bg-black overflow-hidden group shadow-[0_0_30px_rgba(158,78,165,0.2)]">
                {/* Glitch Image Placeholder */}
                <div className="absolute inset-0 bg-[url('https://media.giphy.com/media/L0qTl8qbSkUIydeumD/giphy.gif')] opacity-20 mix-blend-screen bg-cover" />
                
                <div className="absolute inset-0 flex flex-col items-center justify-center p-4 text-center">
                    <Fingerprint size={48} className="text-latent-purple animate-pulse mb-4" />
                    <span className="text-2xl font-header font-black text-white tracking-widest uppercase drop-shadow-md">
                        {identity.name}
                    </span>
                    <span className="text-[10px] font-mono text-latent-purple-light bg-latent-purple/10 px-2 py-1 mt-2 border border-latent-purple/30">
                        ID: LATENT_SPACE_BANDIT
                    </span>
                </div>

                {/* Corner Brackets */}
                <div className="absolute top-2 left-2 w-4 h-4 border-t-2 border-l-2 border-latent-purple" />
                <div className="absolute bottom-2 right-2 w-4 h-4 border-b-2 border-r-2 border-latent-purple" />
                
                {/* Scanline */}
                <motion.div 
                    className="absolute inset-x-0 h-1 bg-latent-purple/50 shadow-[0_0_10px_#9E4EA5]"
                    animate={{ top: ["0%", "100%"] }}
                    transition={{ duration: 3, repeat: Infinity, ease: "linear" }}
                />
            </div>

            {/* Stats Module */}
            <div className="bg-black/40 border border-latent-purple/20 p-4 flex flex-col items-center relative overflow-hidden">
                <div className="absolute top-0 left-0 px-2 py-1 bg-latent-purple/10 text-[8px] font-mono text-latent-purple font-bold">
                    ATTRIBUTE_MATRIX
                </div>
                <div className="mt-4">
                    <StatsRadar stats={stats} color="#BC86BA" size={180} />
                </div>
            </div>
        </div>

        {/* --- RIGHT: DECRYPTED DATA --- */}
        <div className="flex-1 flex flex-col gap-6 relative">
            
            {/* Header */}
            <div className="border-b border-primary-green/30 pb-4">
                <h2 className="text-4xl md:text-5xl font-header font-black text-primary-green tracking-tighter mb-2 glitch-text">
                    ELFY_
                </h2>
                <div className="flex items-center gap-4 text-xs font-mono text-primary-green-dim">
                    <span className="flex items-center gap-1"><Hash size={12} /> CLASS: ROGUE_DEV</span>
                    <span className="flex items-center gap-1"><ShieldAlert size={12} /> BOUNTY: 5000_BTC</span>
                </div>
            </div>

            {/* Bio */}
            <div className="flex-1 overflow-y-auto pr-2 scrollbar-thin scrollbar-thumb-primary-green/20">
                <p className="text-lg font-mono text-white/90 leading-relaxed mb-6">
                    <span className="text-primary-green font-bold">&gt; BIO_DECRYPT:</span><br/>
                    {identity.bio}
                </p>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    <div className="p-4 border border-primary-green/20 bg-primary-green/5">
                        <h3 className="text-xs font-bold text-primary-green uppercase tracking-widest mb-2 border-b border-primary-green/20 pb-1">
                            Current_Mission
                        </h3>
                        <p className="text-sm font-mono text-primary-green-dim">
                            To bridge the gap between retro aesthetics and modern 3D web technologies.
                        </p>
                    </div>
                    <div className="p-4 border border-latent-purple/20 bg-latent-purple/5">
                        <h3 className="text-xs font-bold text-latent-purple uppercase tracking-widest mb-2 border-b border-latent-purple/20 pb-1">
                            Known_Associates
                        </h3>
                        <p className="text-sm font-mono text-latent-purple-light">
                            React Three Fiber, GLSL, WebAudio API, Next.js.
                        </p>
                    </div>
                </div>

                <div className="space-y-2">
                    <h3 className="text-primary-green font-header font-bold uppercase tracking-wider text-sm">
                        SPECIAL_ABILITIES
                    </h3>
                    <div className="flex flex-wrap gap-2">
                        {identity.abilities.map((ability, i) => (
                            <span 
                                key={i} 
                                className="px-3 py-1 bg-black border border-primary-green text-primary-green font-mono text-xs hover:bg-primary-green hover:text-black transition-colors cursor-default"
                            >
                                [{ability}]
                            </span>
                        ))}
                    </div>
                </div>
            </div>

            {/* Footer */}
            <div className="pt-4 border-t border-white/10 text-[9px] font-mono text-gray-500 flex justify-between">
                <span>LAST_SEEN: CYBERSPACE</span>
                <span>STATUS: ONLINE</span>
            </div>
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/ui/os/apps/gallery/GalleryModal.tsx
=====================================
import { ModalContainer } from '@/ui/os/overlays/ModalContainer';
import gallery from '@/engine/config/static/gallery.json';
import { ExternalLink, Image as ImageIcon } from 'lucide-react';
import { useState } from 'react';

export const GalleryModal = () => {
  const [filter, setFilter] = useState('ALL');
  
  // Get unique categories
  const categories = ['ALL', ...Array.from(new Set(gallery.map(item => item.category)))];

  const filteredGallery = filter === 'ALL' 
    ? gallery 
    : gallery.filter(item => item.category === filter);

  return (
    <ModalContainer title="ART_DATABASE // VISUALS" type="gallery">
      <div className="flex flex-col h-full gap-6">
        
        {/* Category Tabs */}
        <div className="flex gap-2 overflow-x-auto pb-2 border-b border-primary-green-dim/30">
          {categories.map(cat => (
            <button
              key={cat}
              onClick={() => setFilter(cat)}
              className={`px-4 py-1 font-mono text-sm border transition-all ${
                filter === cat 
                  ? 'bg-primary-green text-black border-primary-green' 
                  : 'text-primary-green-dim border-primary-green-dim/30 hover:text-primary-green hover:border-primary-green'
              }`}
            >
              [{cat}]
            </button>
          ))}
        </div>

        {/* The Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {filteredGallery.map((item) => (
            <a
              key={item.id}
              href={item.url}
              target="_blank"
              rel="noopener noreferrer"
              className="group relative aspect-video bg-black border border-primary-green-dim/30 hover:border-primary-green transition-all overflow-hidden"
            >
              {/* Placeholder Graphic (Since we have no images yet) */}
              <div className="absolute inset-0 flex flex-col items-center justify-center bg-primary-green-dark/10 group-hover:bg-primary-green-dark/20 transition-colors">
                <ImageIcon className="w-12 h-12 text-primary-green-dim/20 group-hover:text-primary-green group-hover:scale-110 transition-all duration-500" />
                <span className="mt-2 text-xs text-primary-green-dim/40 font-mono">ENCRYPTED_IMG</span>
              </div>

              {/* Overlay Info */}
              <div className="absolute inset-x-0 bottom-0 p-3 bg-black/80 backdrop-blur-sm border-t border-primary-green-dim/30 translate-y-full group-hover:translate-y-0 transition-transform duration-300">
                <h4 className="text-primary-green font-bold text-sm">{item.title}</h4>
                <div className="flex items-center gap-1 text-[10px] text-latent-purple-light mt-1">
                  <span>OPEN_ON_X</span>
                  <ExternalLink size={10} />
                </div>
              </div>
              
              {/* Corner accent */}
              <div className="absolute top-0 right-0 w-0 h-0 border-t-[20px] border-t-primary-green/20 border-l-[20px] border-l-transparent" />
            </a>
          ))}
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/ui/os/apps/sandbox/layout/HoloHeader.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { Clock, Cpu, Server, Wifi } from 'lucide-react';
import { motion } from 'framer-motion';

const StatPill = ({ icon: Icon, label, value, color = "text-service-cyan" }: any) => (
  <div className="flex items-center gap-3 px-3 py-1 bg-black/40 border border-white/5 rounded-full">
    <Icon size={12} className={`${color} opacity-80`} />
    <span className="text-[9px] font-bold text-gray-500 uppercase">{label}</span>
    <span className={`text-[10px] font-mono ${color}`}>{value}</span>
  </div>
);

export const HoloHeader = () => {
  const { debugFlags, setDebugFlag } = useStore();

  return (
    <div className="h-10 flex items-center justify-between px-4 text-[10px] font-mono select-none border-b border-white/5">
      
      {/* LEFT: Branding */}
      <div className="flex items-center gap-4">
        <div className="flex items-center gap-2">
            <motion.div 
                animate={{ rotate: 360 }}
                transition={{ duration: 4, repeat: Infinity, ease: "linear" }}
                className="w-4 h-4 border-2 border-service-cyan border-t-transparent rounded-full"
            />
            <span className="font-header font-black tracking-widest text-service-cyan text-sm drop-shadow-[0_0_8px_rgba(0,240,255,0.5)]">
                HOLO_DECK <span className="opacity-50 text-[10px]">// v.0.9.2</span>
            </span>
        </div>
      </div>

      {/* CENTER: Data Stream Visualization (Abstract) */}
      <div className="hidden md:flex flex-1 items-center justify-center gap-1 opacity-30 mx-8">
          {Array.from({ length: 32 }).map((_, i) => (
              <motion.div 
                key={i}
                className="w-0.5 bg-service-cyan"
                animate={{ height: [4, 12, 4] }}
                transition={{ 
                    duration: 0.5 + Math.random(), 
                    repeat: Infinity, 
                    delay: Math.random() * 0.5 
                }}
              />
          ))}
      </div>

      {/* RIGHT: Controls */}
      <div className="flex items-center gap-3">
        <div className="flex items-center gap-2 group mr-4">
            <span className="text-service-cyan/50 font-bold">SIM_SPEED:</span>
            <input 
                type="range" 
                min="0.0" max="2.0" step="0.1"
                value={debugFlags.timeScale}
                onChange={(e) => setDebugFlag('timeScale', parseFloat(e.target.value))}
                className="w-24 h-1.5 bg-service-cyan/20 rounded-full appearance-none cursor-pointer accent-service-cyan hover:accent-white transition-all"
            />
            <span className="w-8 text-right font-bold text-white bg-service-cyan/20 px-1 rounded">
                {debugFlags.timeScale.toFixed(1)}x
            </span>
        </div>
        
        <StatPill icon={Cpu} label="CPU" value="OPTIMAL" />
        <StatPill icon={Server} label="MEM" value="UNLIMITED" color="text-latent-purple" />
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/sandbox/layout/HoloLayout.tsx
=====================================
import { ReactNode } from 'react';
import { HoloNav } from './HoloNav';
import { HoloHeader } from './HoloHeader';
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { Power } from 'lucide-react';
import { clsx } from 'clsx';

interface HoloLayoutProps {
  children: ReactNode;
}

export const HoloLayout = ({ children }: HoloLayoutProps) => {
  const { resetApplication } = useStore();

  const handleExit = () => {
      AudioSystem.playSound('ui_menu_close');
      resetApplication();
  };

  return (
    <div className="fixed inset-0 z-[100] font-mono flex flex-col overflow-hidden bg-transparent pointer-events-none">
        
        {/* --- UI FRAME (Interactive) --- */}
        <div className="relative z-50 flex-none flex flex-col border-b border-service-cyan/30 bg-black/40 backdrop-blur-sm shadow-[0_4px_30px_rgba(0,240,255,0.1)] pointer-events-auto">
            <HoloHeader />
            <div className="flex justify-between items-end px-4 pb-0 bg-gradient-to-r from-service-cyan/5 to-transparent">
                <HoloNav />
                <button 
                    onClick={handleExit}
                    onMouseEnter={() => AudioSystem.playHover()}
                    className="group relative flex items-center gap-3 px-6 py-3 text-[10px] font-bold tracking-widest text-critical-red hover:text-black transition-all overflow-hidden border-t border-x border-critical-red/20 hover:border-critical-red rounded-t-sm mb-[-1px]"
                >
                    <div className="absolute inset-0 bg-critical-red translate-y-full group-hover:translate-y-0 transition-transform duration-200" />
                    <Power size={14} className="relative z-10" />
                    <span className="relative z-10">TERMINATE_SIM</span>
                </button>
            </div>
        </div>

        {/* --- MAIN CONTENT AREA --- */}
        <div className="relative z-10 flex-1 overflow-hidden p-6 md:p-10 flex flex-col">
            <div className="flex-1 w-full h-full relative">
                {children}
            </div>
        </div>
        
        {/* --- DECORATIVE HUD ELEMENTS --- */}
        <div className="absolute bottom-4 left-4 text-[9px] text-service-cyan/40 font-mono pointer-events-none">
            COORD: {Math.random().toFixed(4)} // {Math.random().toFixed(4)}
        </div>
        <div className="absolute bottom-4 right-4 text-[9px] text-service-cyan/40 font-mono pointer-events-none flex items-center gap-2">
            <div className="w-2 h-2 rounded-full bg-service-cyan/50 animate-pulse" />
            LIVE_FEED
        </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/sandbox/layout/HoloBackground.tsx
=====================================
import { motion } from 'framer-motion';

export const HoloBackground = () => {
  return (
    <div className="fixed inset-0 z-[50] pointer-events-none overflow-hidden bg-[#020408]">
        {/* Deep Pulse */}
        <motion.div 
            className="absolute inset-0 bg-[radial-gradient(circle_at_center,#0b1a26_0%,#000000_100%)] opacity-80"
            animate={{ scale: [1, 1.1, 1] }}
            transition={{ duration: 10, repeat: Infinity, ease: "easeInOut" }}
        />
        
        {/* Perspective Grid */}
        <div className="absolute inset-0 opacity-20" style={{ perspective: '1000px', transformStyle: 'preserve-3d' }}>
            <motion.div 
                className="absolute inset-[-100%] w-[300%] h-[300%] origin-center"
                style={{ 
                    backgroundImage: `linear-gradient(to right, rgba(0, 240, 255, 0.1) 1px, transparent 1px), linear-gradient(to bottom, rgba(0, 240, 255, 0.1) 1px, transparent 1px)`,
                    backgroundSize: '80px 80px',
                    transform: 'rotateX(60deg) translateZ(-200px)'
                }}
                animate={{ y: [0, 80] }}
                transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
            />
        </div>
        
        {/* Noise & Texture */}
        <div className="absolute inset-0 bg-[url('https://grainy-gradients.vercel.app/noise.svg')] opacity-10 mix-blend-overlay" />
        <div className="absolute inset-0 bg-[radial-gradient(circle,transparent_40%,#000_100%)]" />
        <div className="absolute inset-0 bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,240,255,0.02)_50%)] bg-[length:100%_4px]" />
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/sandbox/layout/HoloNav.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { Speaker, Crosshair, ScanEye, FlaskConical } from 'lucide-react';
import { clsx } from 'clsx';
import { motion } from 'framer-motion';

export type SandboxView = 'lab' | 'audio' | 'arena' | 'gallery';

export const HoloNav = () => {
  const { sandboxView, setSandboxView } = useStore();

  const handleNav = (view: SandboxView) => {
    if (sandboxView === view) return;
    setSandboxView(view);
    AudioSystem.playSound('ui_click');
  };

  const NavItem = ({ id, label, icon: Icon }: { id: SandboxView, label: string, icon: any }) => {
    const isActive = sandboxView === id;
    
    return (
      <button
        onClick={() => handleNav(id)}
        onMouseEnter={() => !isActive && AudioSystem.playHover()}
        className={clsx(
          "relative flex items-center gap-3 px-6 py-3 transition-all duration-300 group overflow-hidden border-t border-x rounded-t-md mx-1 mb-[-1px]",
          isActive 
            ? "border-service-cyan/50 text-black z-10" 
            : "border-transparent text-service-cyan/60 hover:text-service-cyan hover:bg-service-cyan/5"
        )}
      >
        {isActive && (
            <motion.div 
                layoutId="holo-nav-bg"
                className="absolute inset-0 bg-service-cyan shadow-[0_0_20px_rgba(0,240,255,0.4)]"
                initial={false}
                transition={{ type: "spring", bounce: 0.15, duration: 0.5 }}
            />
        )}
        
        {!isActive && (
            <div className="absolute inset-0 bg-gradient-to-b from-transparent via-service-cyan/10 to-transparent translate-y-[-100%] group-hover:translate-y-[100%] transition-transform duration-500" />
        )}

        <Icon size={16} className="relative z-10" strokeWidth={isActive ? 2.5 : 1.5} />
        <span className="font-header font-bold text-xs tracking-widest relative z-10">
            {label}
        </span>
      </button>
    );
  };

  return (
    <div className="flex h-full items-end pt-2">
      <NavItem id="lab" label="VISUAL_LAB" icon={FlaskConical} />
      <NavItem id="audio" label="AUDIO_MATRIX" icon={Speaker} />
      <NavItem id="arena" label="COMBAT_SIM" icon={Crosshair} />
      <NavItem id="gallery" label="MODEL_INSPECTOR" icon={ScanEye} />
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/sandbox/SimulationHUD.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { HoloLayout } from './layout/HoloLayout';
import { AudioMatrix } from './AudioMatrix';
import { ArenaLab } from './ArenaLab';
import { ModelInspector } from './ModelInspector';
import { VisualLab } from './visuals/VisualLab';

export const SimulationHUD = () => {
  const { sandboxView } = useStore();

  return (
    <HoloLayout>
        {sandboxView === 'lab' && <VisualLab />}
        {sandboxView === 'audio' && <AudioMatrix />}
        
        {/* Arena is an Overlay on top of the canvas */}
        {sandboxView === 'arena' && (
            <div className="h-full flex items-start justify-end pointer-events-none">
                <ArenaLab />
            </div>
        )}

        {/* Gallery is also an overlay controlling the separate stage */}
        {sandboxView === 'gallery' && <ModelInspector />}
    </HoloLayout>
  );
};


=====================================
FILE: ./src/ui/os/apps/sandbox/ArenaLab.tsx
=====================================
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { Bug, Trash2, Shield, Plus, Info, Crosshair } from 'lucide-react';
import { useStore } from '@/engine/state/global/useStore';
import { clsx } from 'clsx';

export const ArenaLab = () => {
  const { debugFlags, setDebugFlag } = useStore();

  const spawn = (type: string, count: number = 1) => {
      try {
          const spawner = ServiceLocator.getSpawner();
          const radius = 10;
          for(let i=0; i<count; i++) {
              const angle = Math.random() * Math.PI * 2;
              const r = 5 + Math.random() * radius;
              const x = Math.cos(angle) * r;
              const y = Math.sin(angle) * r;
              spawner.spawnEnemy(type, x, y);
          }
          AudioSystem.playSound('ui_click');
      } catch (e) { console.warn("Spawn failed:", e); }
  };

  const clearEnemies = () => {
      try {
          const registry = ServiceLocator.getRegistry();
          const enemies = registry.getByTag('ENEMY');
          enemies.forEach(e => registry.destroyEntity(e.id as number));
          AudioSystem.playSound('ui_error');
      } catch (e) { console.warn("Clear failed:", e); }
  };

  const SpawnBtn = ({ label, type, count, color = "border-service-cyan/30 text-service-cyan" }: any) => (
      <button 
        onClick={() => spawn(type, count)}
        onMouseEnter={() => AudioSystem.playHover()}
        className={`group relative flex items-center justify-between p-3 border bg-black/40 hover:bg-service-cyan/10 transition-all ${color} backdrop-blur-sm`}
      >
          <div className="absolute left-0 top-0 bottom-0 w-0.5 bg-current opacity-0 group-hover:opacity-100 transition-opacity" />
          
          <div className="flex flex-col items-start">
              <span className="text-[10px] font-bold font-header tracking-wider group-hover:text-white transition-colors">{label}</span>
              <span className="text-[8px] opacity-60 font-mono">BATCH_SIZE: {count.toString().padStart(2, '0')}</span>
          </div>
          <Plus size={14} className="opacity-50 group-hover:scale-110 transition-transform" />
      </button>
  );

  return (
    <div className="flex flex-col gap-px w-80 pointer-events-auto h-full max-h-[80vh] bg-[#020408]/90 backdrop-blur-md border border-service-cyan/20 shadow-[0_0_40px_rgba(0,0,0,0.5)] rounded-sm overflow-hidden mt-10 mr-10">
        
        {/* HEADER */}
        <div className="p-4 border-b border-service-cyan/20 bg-gradient-to-r from-service-cyan/10 to-transparent flex justify-between items-center">
            <h3 className="text-sm font-black font-header tracking-widest text-service-cyan flex items-center gap-2">
                <Bug size={16} /> INJECTION_LAB
            </h3>
            <div className="w-2 h-2 bg-service-cyan rounded-full animate-pulse shadow-[0_0_10px_#00F0FF]" />
        </div>

        {/* CONTROLS */}
        <div className="p-4 space-y-6 overflow-y-auto flex-1 scrollbar-thin scrollbar-thumb-service-cyan/30">
            
            <div className="space-y-2">
                <div className="flex items-center gap-2 text-[9px] font-mono text-service-cyan/50 uppercase tracking-widest mb-1">
                    <Crosshair size={10} /> Hostile Entities
                </div>
                <div className="grid grid-cols-2 gap-2">
                    <SpawnBtn label="DRILLER" type={EnemyTypes.DRILLER} count={1} />
                    <SpawnBtn label="SWARM" type={EnemyTypes.DRILLER} count={5} />
                    <SpawnBtn label="KAMIKAZE" type={EnemyTypes.KAMIKAZE} count={1} color="border-critical-red/30 text-critical-red" />
                    <SpawnBtn label="HUNTER" type={EnemyTypes.HUNTER} count={1} color="border-alert-yellow/30 text-alert-yellow" />
                </div>
            </div>

            <div className="space-y-2">
                <div className="flex items-center gap-2 text-[9px] font-mono text-latent-purple/50 uppercase tracking-widest mb-1">
                    <Shield size={10} /> Defensive Assets
                </div>
                <SpawnBtn 
                    label="DAEMON_CORE" 
                    type={EnemyTypes.DAEMON} 
                    count={1} 
                    color="border-latent-purple/40 text-latent-purple hover:bg-latent-purple/10" 
                />
            </div>

            <div className="h-px bg-gradient-to-r from-transparent via-service-cyan/20 to-transparent w-full" />

            {/* GLOBAL OVERRIDES */}
            <div className="space-y-2">
                <button 
                    onClick={() => setDebugFlag('godMode', !debugFlags.godMode)}
                    className={clsx(
                        "w-full flex items-center justify-between p-3 border text-xs font-bold transition-all backdrop-blur-sm",
                        debugFlags.godMode 
                            ? "bg-service-cyan/20 text-service-cyan border-service-cyan shadow-[0_0_15px_rgba(0,240,255,0.2)]" 
                            : "bg-black/40 border-service-cyan/20 text-gray-500 hover:text-service-cyan hover:border-service-cyan/50"
                    )}
                >
                    <span>INVULNERABILITY</span>
                    <Shield size={14} className={debugFlags.godMode ? "fill-current" : ""} />
                </button>

                <button 
                    onClick={clearEnemies}
                    onMouseEnter={() => AudioSystem.playHover()}
                    className="w-full flex items-center justify-center gap-2 p-3 border border-critical-red/30 text-critical-red hover:bg-critical-red hover:text-black transition-all text-xs font-bold backdrop-blur-sm group"
                >
                    <Trash2 size={14} className="group-hover:scale-110 transition-transform" /> 
                    PURGE_ENTITIES
                </button>
            </div>
        </div>

        {/* FOOTER */}
        <div className="p-3 bg-black/60 border-t border-service-cyan/10 text-[9px] text-gray-500 font-mono flex items-start gap-2">
            <Info size={12} className="shrink-0 mt-0.5 text-service-cyan" />
            <p className="leading-relaxed opacity-80">
                Sandbox mode enables free testing of entity interactions. Metrics may vary from live build.
            </p>
        </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/sandbox/ModelInspector.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { clsx } from 'clsx';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { Box, PlayCircle, Crosshair, ChevronRight, Fingerprint, Activity } from 'lucide-react';

const MODELS = [
  { id: EnemyTypes.DAEMON, label: 'DAEMON_CORE', desc: 'Defensive Subroutine.', color: 'text-latent-purple' },
  { id: EnemyTypes.DRILLER, label: 'DRILLER_DRONE', desc: 'Standard Melee Unit.', color: 'text-service-cyan' },
  { id: EnemyTypes.KAMIKAZE, label: 'KAMIKAZE_UNIT', desc: 'Volatile Payload.', color: 'text-critical-red' },
  { id: EnemyTypes.HUNTER, label: 'HUNTER_MK1', desc: 'Ranged Ballistic Unit.', color: 'text-alert-yellow' },
];

const STATES = ['IDLE', 'ATTACK', 'SPAWN', 'DIE'] as const;

export const ModelInspector = () => {
  const { galleryTarget, setGalleryTarget, galleryAction, setGalleryAction } = useStore();
  const currentModel = MODELS.find(m => m.id === galleryTarget) || MODELS[0];

  return (
    <div className="flex flex-col h-full pointer-events-auto relative">
        
        {/* --- LEFT PANEL: LIST --- */}
        <div className="absolute top-10 left-10 w-72 bg-[#020408]/90 backdrop-blur-md border border-service-cyan/20 flex flex-col shadow-[0_0_40px_rgba(0,0,0,0.5)] rounded-sm">
            <div className="p-4 border-b border-service-cyan/20 bg-service-cyan/5">
                <h3 className="text-service-cyan text-xs font-black font-header tracking-widest flex items-center gap-2">
                    <Box size={14} /> ASSET_DATABASE
                </h3>
            </div>
            
            <div className="flex-1 overflow-y-auto max-h-[60vh] scrollbar-thin scrollbar-thumb-service-cyan/20">
                {MODELS.map(model => {
                    const isActive = galleryTarget === model.id;
                    return (
                        <button
                            key={model.id}
                            onClick={() => { setGalleryTarget(model.id); AudioSystem.playClick(); }}
                            onMouseEnter={() => AudioSystem.playHover()}
                            className={clsx(
                                "w-full text-left p-4 border-b border-white/5 transition-all group relative overflow-hidden",
                                isActive ? "bg-white/5" : "hover:bg-white/5"
                            )}
                        >
                            {isActive && <div className="absolute left-0 top-0 bottom-0 w-1 bg-service-cyan shadow-[0_0_15px_#00F0FF]" />}
                            
                            <div className="flex justify-between items-center mb-1">
                                <span className={clsx("font-header font-bold text-xs tracking-wider transition-colors", isActive ? model.color : "text-gray-400 group-hover:text-white")}>
                                    {model.label}
                                </span>
                                {isActive && <ChevronRight size={14} className={model.color} />}
                            </div>
                            <div className="text-[9px] font-mono text-gray-600 group-hover:text-gray-400 transition-colors">
                                {model.desc}
                            </div>
                        </button>
                    );
                })}
            </div>
        </div>

        {/* --- BOTTOM RIGHT: CONTROLS --- */}
        <div className="absolute bottom-10 right-10 w-80 bg-[#020408]/90 backdrop-blur-md border border-service-cyan/20 shadow-[0_0_40px_rgba(0,0,0,0.5)] rounded-sm">
            <div className="p-3 border-b border-service-cyan/20 bg-service-cyan/5 flex justify-between items-center">
                <span className="text-service-cyan text-[10px] font-bold font-header tracking-widest flex items-center gap-2">
                    <Activity size={14} /> ANIMATION_STATE
                </span>
                <PlayCircle size={14} className="text-service-cyan animate-pulse" />
            </div>
            <div className="p-4 grid grid-cols-2 gap-3">
                {STATES.map(state => (
                    <button
                        key={state}
                        onClick={() => { setGalleryAction(state); AudioSystem.playClick(); }}
                        className={clsx(
                            "text-[10px] font-bold font-mono text-center py-3 border transition-all rounded-sm relative overflow-hidden group",
                            galleryAction === state
                                ? "border-service-cyan text-black bg-service-cyan shadow-[0_0_15px_rgba(0,240,255,0.4)]"
                                : "border-white/10 text-gray-500 hover:border-service-cyan/50 hover:text-service-cyan hover:bg-service-cyan/5"
                        )}
                    >
                        {state}
                    </button>
                ))}
            </div>
        </div>

        {/* --- TOP RIGHT: METADATA OVERLAY --- */}
        <div className="absolute top-10 right-10 text-right pointer-events-none">
             <div className="flex flex-col items-end gap-2">
                 <h1 className={clsx("text-5xl font-header font-black tracking-tighter opacity-80 drop-shadow-[0_0_20px_rgba(0,0,0,0.8)]", currentModel.color)}>
                     {currentModel.label}
                 </h1>
                 
                 <div className="flex items-center gap-4 text-xs font-mono text-gray-400 bg-black/60 px-4 py-2 border border-white/10 rounded-full backdrop-blur-sm">
                     <span className="flex items-center gap-2">
                        <Crosshair size={12} /> ID: {currentModel.id}
                     </span>
                     <span className="w-px h-3 bg-white/20" />
                     <span className="flex items-center gap-2">
                        <Fingerprint size={12} /> VER: 2.0.4
                     </span>
                 </div>
             </div>
        </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/sandbox/AudioMatrix.tsx
=====================================
import { SOUND_METADATA, SoundCategory } from '@/engine/config/SoundMetadata';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { Volume2, Play, Activity, Music, Radio, Database, Monitor } from 'lucide-react';
import { clsx } from 'clsx';
import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';

// --- CONFIGURATION ---

const CATEGORIES: { id: SoundCategory; label: string; icon: any; color: string; border: string; bg: string }[] = [
  { 
    id: 'UI', 
    label: 'SYSTEM_INTERFACE', 
    icon: Monitor, 
    color: 'text-service-cyan', 
    border: 'border-service-cyan',
    bg: 'bg-service-cyan'
  },
  { 
    id: 'COMBAT', 
    label: 'COMBAT_PROTOCOL', 
    icon: Activity, 
    color: 'text-critical-red', 
    border: 'border-critical-red',
    bg: 'bg-critical-red'
  },
  { 
    id: 'AMBIENCE', 
    label: 'ENVIRONMENTAL', 
    icon: Radio, 
    color: 'text-latent-purple', 
    border: 'border-latent-purple',
    bg: 'bg-latent-purple'
  },
  { 
    id: 'UNUSED', 
    label: 'SYNTH_ARCHIVE', 
    icon: Database, 
    color: 'text-primary-green', 
    border: 'border-primary-green',
    bg: 'bg-primary-green'
  },
];

export const AudioMatrix = () => {
  const [activeCat, setActiveCat] = useState<SoundCategory>('UI');
  const [playing, setPlaying] = useState<string | null>(null);

  const activeDef = CATEGORIES.find(c => c.id === activeCat) || CATEGORIES[0];
  const sounds = Object.values(SOUND_METADATA).filter(s => s.category === activeCat);

  const handlePlay = (key: string) => {
    if (key.includes('ambience')) {
        AudioSystem.playAmbience(key);
    } else {
        AudioSystem.playSound(key);
    }
    setPlaying(key);
    setTimeout(() => setPlaying(null), 300);
  };

  return (
    <div className="flex w-full h-full gap-6 pointer-events-auto p-4 md:p-0">
        
        {/* --- LEFT: CATEGORY SELECTOR --- */}
        <div className="w-16 md:w-64 flex-none flex flex-col gap-2">
            {CATEGORIES.map((cat) => {
                const isActive = activeCat === cat.id;
                return (
                    <button
                        key={cat.id}
                        onClick={() => { setActiveCat(cat.id); AudioSystem.playClick(); }}
                        onMouseEnter={() => AudioSystem.playHover()}
                        className={clsx(
                            "relative group flex items-center h-16 md:h-14 px-0 md:px-4 border-l-2 transition-all duration-300 overflow-hidden",
                            isActive 
                                ? `bg-black/60 ${cat.border}`
                                : "border-white/10 hover:border-white/30 hover:bg-white/5"
                        )}
                    >
                        {/* Active Glow Background */}
                        {isActive && (
                            <div className={clsx("absolute inset-0 opacity-10", cat.bg)} />
                        )}

                        <div className="flex items-center justify-center md:justify-start w-full gap-3 relative z-10">
                            <cat.icon 
                                size={20} 
                                className={clsx(
                                    "transition-colors duration-300", 
                                    isActive ? cat.color : "text-gray-500 group-hover:text-gray-300"
                                )} 
                            />
                            <span className={clsx(
                                "hidden md:block font-header font-bold text-xs tracking-widest uppercase transition-colors duration-300",
                                isActive ? cat.color : "text-gray-500 group-hover:text-gray-300"
                            )}>
                                {cat.label}
                            </span>
                        </div>
                    </button>
                );
            })}
        </div>

        {/* --- RIGHT: SOUND GRID --- */}
        <div className="flex-1 flex flex-col bg-[#020408]/80 backdrop-blur-md border border-white/10 rounded-sm shadow-2xl relative overflow-hidden">
            
            {/* Header / Visualizer Strip */}
            <div className={clsx("h-10 border-b border-white/5 flex items-center justify-between px-4 bg-gradient-to-r from-black via-black to-transparent", activeDef.color)}>
                <div className="flex items-center gap-2">
                    <Music size={14} className="opacity-70" />
                    <span className="font-mono text-xs font-bold tracking-widest">
                        CHANNEL: {activeCat}
                    </span>
                </div>
                <div className="flex gap-0.5 items-end h-4 opacity-50">
                    {[...Array(12)].map((_, i) => (
                        <motion.div 
                            key={i}
                            className={clsx("w-1 rounded-t-sm", activeDef.bg)}
                            animate={{ height: ["20%", "80%", "30%"] }}
                            transition={{ 
                                duration: 0.5 + Math.random(), 
                                repeat: Infinity, 
                                ease: "easeInOut",
                                delay: i * 0.05
                            }}
                        />
                    ))}
                </div>
            </div>

            {/* Grid Content */}
            <div className="flex-1 overflow-y-auto p-4 scrollbar-thin scrollbar-thumb-white/10">
                <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
                    <AnimatePresence mode="popLayout">
                        {sounds.map((sound) => {
                            const isPlaying = playing === sound.key;
                            return (
                                <motion.button
                                    layout
                                    initial={{ opacity: 0, scale: 0.9 }}
                                    animate={{ opacity: 1, scale: 1 }}
                                    exit={{ opacity: 0, scale: 0.9 }}
                                    transition={{ duration: 0.2 }}
                                    key={sound.key}
                                    onClick={() => handlePlay(sound.key)}
                                    className={clsx(
                                        "group relative flex flex-col items-start p-3 border transition-all duration-100 text-left overflow-hidden h-24 hover:shadow-[0_0_15px_rgba(0,0,0,0.5)]",
                                        isPlaying 
                                            ? `${activeDef.bg} text-black border-transparent scale-95`
                                            : `bg-black/40 border-white/10 hover:border-white/30 ${activeDef.color} hover:bg-white/5`
                                    )}
                                >
                                    <div className="flex w-full justify-between items-start mb-2">
                                        <span className="font-bold text-[10px] tracking-wider uppercase opacity-90 line-clamp-1">
                                            {sound.label}
                                        </span>
                                        <Play size={10} className={clsx("transition-opacity", isPlaying ? "opacity-100" : "opacity-30 group-hover:opacity-100")} />
                                    </div>
                                    
                                    <span className="text-[8px] font-mono opacity-50 mb-auto break-all">
                                        {sound.key}
                                    </span>
                                    
                                    {/* Bottom Decor Bar */}
                                    <div className="w-full h-0.5 bg-current opacity-20 mt-2 group-hover:opacity-100 transition-opacity relative overflow-hidden">
                                        {isPlaying && (
                                            <motion.div 
                                                className="absolute inset-0 bg-white"
                                                initial={{ x: "-100%" }}
                                                animate={{ x: "100%" }}
                                                transition={{ duration: 0.4, ease: "linear" }}
                                            />
                                        )}
                                    </div>
                                </motion.button>
                            );
                        })}
                    </AnimatePresence>
                </div>
            </div>
        </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/sandbox/visuals/VisualLab.tsx
=====================================
import { useState } from 'react';
import { clsx } from 'clsx';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { useStore, LabExperiment } from '@/engine/state/global/useStore';
import { Atom, Zap, RefreshCcw } from 'lucide-react';
import { RangeSlider } from '@/ui/os/apps/settings/components/RangeSlider';

const EXPERIMENTS: { id: LabExperiment, label: string, icon: any }[] = [
  { id: 'NONE', label: 'STANDBY', icon: Atom },
  { id: 'GLITCH', label: 'GLITCH_GHOST', icon: Zap },
];

export const VisualLab = () => {
  const { labExperiment, setLabExperiment } = useStore();
  const [paramA, setParamA] = useState(0.5);

  return (
    <div className="absolute inset-0 pointer-events-none flex flex-col">
        
        {/* TOP LEFT: CONTROL PANEL */}
        <div className="absolute top-20 left-10 w-72 bg-[#020408]/90 backdrop-blur-md border border-service-cyan/20 rounded-sm shadow-xl pointer-events-auto p-4 flex flex-col gap-6">
            <div>
                <h3 className="text-service-cyan font-header font-black tracking-widest text-xs mb-2 border-b border-service-cyan/20 pb-2 flex justify-between items-center">
                    <span>VISUAL_CORTEX</span>
                    <RefreshCcw size={12} className="opacity-50" />
                </h3>
                <div className="space-y-1">
                    {EXPERIMENTS.map(exp => (
                        <button
                            key={exp.id}
                            onClick={() => { setLabExperiment(exp.id); AudioSystem.playClick(); }}
                            onMouseEnter={() => AudioSystem.playHover()}
                            className={clsx(
                                "w-full flex items-center gap-3 px-3 py-2 text-xs font-mono border transition-all",
                                labExperiment === exp.id 
                                    ? "bg-service-cyan/20 border-service-cyan text-service-cyan shadow-[0_0_10px_rgba(0,240,255,0.2)]" 
                                    : "bg-black/40 border-white/5 text-gray-500 hover:text-white hover:bg-white/5"
                            )}
                        >
                            <exp.icon size={14} />
                            {exp.label}
                        </button>
                    ))}
                </div>
            </div>

            {/* DYNAMIC CONTROLS */}
            {labExperiment === 'GLITCH' && (
                <div className="space-y-4 animate-in fade-in slide-in-from-top-2">
                    <div className="text-[10px] text-service-cyan/60 font-bold uppercase tracking-widest">Parameters</div>
                    <RangeSlider 
                        label="CORRUPTION" 
                        value={paramA} 
                        max={2.0} 
                        onChange={setParamA} 
                        color="text-service-cyan"
                    />
                </div>
            )}
        </div>

        {/* CENTER: STANDBY UI */}
        {labExperiment === 'NONE' && (
            <div className="flex-1 w-full h-full flex items-center justify-center animate-in fade-in zoom-in-95 duration-500">
                <div className="text-center opacity-50 flex flex-col items-center gap-4">
                    <div className="relative">
                        <div className="absolute inset-0 bg-service-cyan blur-2xl opacity-20 animate-pulse" />
                        <Atom size={80} className="relative z-10 text-service-cyan animate-spin-slow" strokeWidth={1} />
                    </div>
                    <div className="flex flex-col gap-1">
                        <span className="font-header font-black text-xl text-service-cyan tracking-[0.2em]">AWAITING_INPUT</span>
                        <span className="font-mono text-xs text-service-cyan/60">SELECT EXPERIMENT TO INITIALIZE</span>
                    </div>
                </div>
            </div>
        )}

        {/* DATA BRIDGE */}
        <div id="lab-params" data-a={paramA} className="hidden" />
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/mobile/MobileRejectionModal.tsx
=====================================
import { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Smartphone, Cpu, Scan, Biohazard, Waves, Ban, Skull, AlertTriangle, Terminal } from 'lucide-react';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { DotGridBackground } from '@/ui/kit/atoms/DotGridBackground';
import { clsx } from 'clsx';

interface Props {
  onComplete: () => void;
}

const STEPS = [
  { id: 'SCAN', duration: 2000, color: 'text-primary-green', border: 'border-primary-green' },
  { id: 'HARDWARE', duration: 2500, color: 'text-alert-yellow', border: 'border-alert-yellow' },
  { id: 'GPU', duration: 2500, color: 'text-critical-red', border: 'border-critical-red' },
  { id: 'ENV', duration: 3500, color: 'text-latent-purple', border: 'border-latent-purple' },
  { id: 'DENIED', duration: 3000, color: 'text-critical-red', border: 'border-critical-red' },
];

export const MobileRejectionModal = ({ onComplete }: Props) => {
  const [stepIndex, setStepIndex] = useState(0);
  const currentStep = STEPS[stepIndex];

  useEffect(() => {
    let timer: NodeJS.Timeout;

    const advance = () => {
      if (stepIndex < STEPS.length - 1) {
        setStepIndex(prev => prev + 1);
        
        // Audio Logic per step
        const nextId = STEPS[stepIndex + 1].id;
        if (nextId === 'DENIED') AudioSystem.playSound('ui_error');
        else if (nextId === 'ENV') AudioSystem.playSound('ui_chirp');
        else AudioSystem.playClick();
        
      } else {
        AudioSystem.playSound('fx_boot_sequence'); 
        onComplete();
      }
    };

    timer = setTimeout(advance, currentStep.duration);
    return () => clearTimeout(timer);
  }, [stepIndex, onComplete, currentStep]);

  return (
    <div className="absolute inset-0 flex items-center justify-center p-4 md:p-0">
      
      {/* Main Container Frame */}
      <motion.div 
        initial={{ scaleY: 0, opacity: 0 }}
        animate={{ scaleY: 1, opacity: 1 }}
        transition={{ duration: 0.3 }}
        className={clsx(
            "relative w-full max-w-sm bg-black/90 backdrop-blur-md border-y-2 overflow-hidden transition-colors duration-500 flex flex-col shadow-[0_0_50px_rgba(0,0,0,0.8)]",
            currentStep.border
        )}
      >
        {/* Background Texture Layers */}
        <DotGridBackground color={currentStep.id === 'DENIED' ? '#FF003C' : '#15530A'} />
        
        {/* Animated Stripes Background */}
        <div className={clsx(
            "absolute inset-0 opacity-10 pointer-events-none transition-colors duration-500",
            stepIndex >= 2 ? "bg-[repeating-linear-gradient(45deg,transparent,transparent_10px,currentColor_10px,currentColor_12px)]" : ""
        )} style={{ color: stepIndex >= 4 ? '#FF003C' : '#9E4EA5' }} />

        {/* HEADER */}
        <div className={clsx("flex items-center justify-between px-4 py-2 border-b bg-black/50 transition-colors duration-500", currentStep.border)}>
            <div className="flex items-center gap-2">
                <Terminal size={14} className={currentStep.color} />
                <span className={clsx("text-[10px] font-header font-black tracking-widest uppercase", currentStep.color)}>
                    SYS_ANALYSIS_TOOL
                </span>
            </div>
            <div className="text-[9px] font-mono opacity-50">v.MOBILE.0.1</div>
        </div>

        {/* CONTENT AREA */}
        <div className="relative z-10 py-12 px-6 min-h-[320px] flex flex-col items-center justify-center">
            <AnimatePresence mode="wait">
            
            {/* STEP 1: SCANNING */}
            {currentStep.id === 'SCAN' && (
                <motion.div 
                key="scan"
                initial={{ opacity: 0, scale: 0.9 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 1.1, filter: "blur(10px)" }}
                className="flex flex-col items-center gap-6 w-full"
                >
                <div className="relative w-24 h-24 border border-primary-green/30 bg-primary-green/5 flex items-center justify-center">
                    <Scan size={48} className="text-primary-green animate-pulse" />
                    <motion.div 
                        className="absolute inset-0 border-b-2 border-primary-green shadow-[0_0_15px_#78F654]"
                        animate={{ top: ['0%', '100%', '0%'] }}
                        transition={{ duration: 1.5, repeat: Infinity, ease: "linear" }}
                    />
                    {/* Corner Accents */}
                    <div className="absolute top-0 left-0 w-2 h-2 border-t border-l border-primary-green" />
                    <div className="absolute top-0 right-0 w-2 h-2 border-t border-r border-primary-green" />
                    <div className="absolute bottom-0 left-0 w-2 h-2 border-b border-l border-primary-green" />
                    <div className="absolute bottom-0 right-0 w-2 h-2 border-b border-r border-primary-green" />
                </div>
                
                <div className="flex flex-col items-center gap-1">
                    <span className="text-primary-green font-bold tracking-widest animate-pulse text-sm">
                        SCANNING_FINGERPRINT...
                    </span>
                    <span className="text-[10px] text-primary-green-dim font-mono">
                        [ USER_AGENT_PARSING ]
                    </span>
                </div>
                </motion.div>
            )}

            {/* STEP 2: HARDWARE */}
            {currentStep.id === 'HARDWARE' && (
                <motion.div 
                key="hw"
                initial={{ opacity: 0, x: 50 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: -50 }}
                className="flex flex-col items-center gap-6 text-center w-full"
                >
                <div className="w-24 h-24 rounded-full border border-alert-yellow/30 bg-alert-yellow/5 flex items-center justify-center relative overflow-hidden">
                    <div className="absolute inset-0 animate-spin-slow border-t border-alert-yellow opacity-50 rounded-full" />
                    <Smartphone size={40} className="text-alert-yellow drop-shadow-[0_0_10px_rgba(247,210,119,0.5)]" />
                </div>

                <div className="flex flex-col w-full border-l-2 border-alert-yellow pl-4 text-left bg-gradient-to-r from-alert-yellow/10 to-transparent py-2">
                    <span className="text-[9px] text-alert-yellow opacity-70 uppercase tracking-widest mb-1">HARDWARE_ID_FOUND</span>
                    <span className="text-xl text-alert-yellow font-black tracking-wider leading-none">
                    POCKET_DEVICE
                    </span>
                    <span className="text-[10px] text-white/60 font-mono mt-1">
                    CLASS: CONSUMER_GRADE
                    </span>
                </div>
                </motion.div>
            )}

            {/* STEP 3: GPU */}
            {currentStep.id === 'GPU' && (
                <motion.div 
                key="gpu"
                initial={{ opacity: 0, scale: 0.5 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 1.5 }}
                className="flex flex-col items-center gap-6 text-center w-full"
                >
                <div className="relative">
                    <Cpu size={64} className="text-critical-red animate-pulse" />
                    <AlertTriangle size={24} className="absolute -top-2 -right-2 text-critical-red bg-black rounded-full" />
                </div>

                <div className="flex flex-col items-center w-full px-4">
                    <span className="text-[10px] text-critical-red/70 uppercase tracking-widest mb-2">COMPUTE_POWER_ANALYSIS</span>
                    <span className="text-3xl text-critical-red font-black tracking-widest glitch-text drop-shadow-[0_0_10px_#FF003C]">
                    LAUGHABLE
                    </span>
                    
                    {/* Tech Bar */}
                    <div className="w-full bg-gray-900 h-3 mt-4 skew-x-[-12deg] overflow-hidden border border-critical-red/30 p-0.5">
                        <div className="h-full bg-critical-red w-[2%] shadow-[0_0_10px_#FF003C] animate-pulse" />
                    </div>
                    <span className="text-[9px] text-critical-red mt-1 font-mono w-full text-right">CAPACITY: 1.2%</span>
                </div>
                </motion.div>
            )}

            {/* STEP 4: THE TOILET BIT */}
            {currentStep.id === 'ENV' && (
                <motion.div 
                key="env"
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -20 }}
                className="flex flex-col items-center gap-8 text-center w-full"
                >
                {/* Composite Icon Animation */}
                <div className="relative w-32 h-32 flex items-center justify-center bg-black/50 border border-latent-purple/30 rounded-full">
                    <motion.div 
                        animate={{ y: [0, -5, 0] }} 
                        transition={{ duration: 2, repeat: Infinity, ease: "easeInOut" }}
                        className="z-10"
                    >
                        <Smartphone size={48} className="text-latent-purple" />
                    </motion.div>
                    
                    <motion.div 
                        className="absolute bottom-4 text-service-cyan opacity-50"
                        animate={{ scaleX: [1, 1.2, 1], opacity: [0.3, 0.6, 0.3] }} 
                        transition={{ duration: 3, repeat: Infinity }}
                    >
                        <Waves size={64} />
                    </motion.div>

                    <motion.div 
                        className="absolute top-0 right-0 text-alert-yellow bg-black rounded-full p-1 border border-alert-yellow"
                        animate={{ scale: [1, 1.2, 1] }} 
                        transition={{ duration: 0.5, repeat: Infinity, repeatDelay: 0.5 }}
                    >
                        <Biohazard size={20} />
                    </motion.div>
                </div>

                <div className="flex flex-col gap-1">
                    <span className="text-[10px] text-latent-purple-light uppercase tracking-widest">GPS_TRIANGULATION_COMPLETE</span>
                    <span className="text-xs font-bold text-gray-400">ENVIRONMENT DETECTED:</span>
                    <div className="relative mt-1">
                        <div className="absolute inset-0 bg-latent-purple blur-lg opacity-20" />
                        <span className="relative z-10 text-2xl font-black text-latent-purple tracking-widest uppercase">
                        CERAMIC_THRONE
                        </span>
                    </div>
                </div>
                </motion.div>
            )}

            {/* STEP 5: DENIED */}
            {currentStep.id === 'DENIED' && (
                <motion.div 
                key="denied"
                initial={{ opacity: 0, scale: 1.2 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, filter: "blur(20px)" }}
                transition={{ type: "spring", stiffness: 300, damping: 15 }}
                className="flex flex-col items-center gap-6 text-center w-full"
                >
                <div className="relative p-6 border-2 border-critical-red bg-critical-red/5">
                    <Ban size={64} className="text-critical-red animate-pulse" />
                    <Skull size={32} className="text-white absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2" />
                    
                    {/* Glitch Overlay */}
                    <div className="absolute inset-0 bg-critical-red/10 mix-blend-overlay animate-pulse" style={{ clipPath: 'polygon(0 0, 100% 0, 100% 10%, 0 10%)' }} />
                </div>
                
                <div className="flex flex-col gap-3 w-full">
                    <h1 className="text-3xl font-black text-critical-red tracking-widest bg-black border-y border-critical-red py-2">
                    ACCESS DENIED
                    </h1>
                    <p className="text-xs text-gray-400 font-mono max-w-[240px] mx-auto leading-relaxed border-l-2 border-critical-red pl-3 text-left">
                    You cannot hack the mainframe from the bathroom.
                    </p>
                    <div className="mt-4 pt-4 border-t border-white/10 w-full">
                        <div className="flex items-center justify-between text-[10px] font-mono text-primary-green">
                            <span className="animate-pulse">LOADING: DOOMSCROLL_PROTOCOL</span>
                            <span>[ 99% ]</span>
                        </div>
                        <div className="h-1 w-full bg-gray-800 mt-1">
                            <motion.div 
                                className="h-full bg-primary-green" 
                                initial={{ width: 0 }}
                                animate={{ width: "100%" }}
                                transition={{ duration: 2.0, ease: "circOut" }}
                            />
                        </div>
                    </div>
                </div>
                </motion.div>
            )}

            </AnimatePresence>
        </div>

        {/* FOOTER */}
        <div className={clsx("px-4 py-2 border-t bg-black/80 flex justify-between items-center text-[9px] font-mono transition-colors duration-500", currentStep.border)}>
            <span className={currentStep.color}>{currentStep.id}_MODULE_ACTIVE</span>
            <span className="opacity-50">SECURE_CHANNEL: FALSE</span>
        </div>

        {/* Progress Bar (Global) */}
        <div className="absolute bottom-0 left-0 h-0.5 bg-gray-900 w-full z-20">
            <motion.div 
                className={clsx("h-full transition-colors duration-500", currentStep.id === 'DENIED' ? "bg-critical-red" : "bg-primary-green")}
                initial={{ width: "0%" }}
                animate={{ width: `${((stepIndex + 1) / STEPS.length) * 100}%` }}
                transition={{ duration: 0.5 }}
            />
        </div>
      </motion.div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/mobile/MobileExperience.tsx
=====================================
import { useState, useEffect } from 'react';
import { MobileRejectionModal } from './MobileRejectionModal';
import { Canvas } from '@react-three/fiber';
import { MobileGameDirector } from '@/ui/sim/MobileGameDirector';
import { RenderDirector } from '@/ui/sim/RenderDirector';
import { CameraRig } from '@/ui/sim/vfx/CameraRig';
import { SocialRow } from '@/ui/kit/molecules/SocialRow';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { Skull, Monitor, ExternalLink, AlertTriangle } from 'lucide-react';
import { GlassPanel } from '@/ui/kit/atoms/GlassPanel';
import { motion, AnimatePresence } from 'framer-motion';
import { clsx } from 'clsx';

// Constants
const MOBILE_PANEL_HP = 100;

const SocialPanelWrapper = () => {
    return (
        <div className="w-full max-w-sm pointer-events-auto">
            <GlassPanel title="SOCIAL_UPLINK" gameId="social" className="bg-black/90" maxHealth={MOBILE_PANEL_HP}>
                <SocialRow layout="column" />
            </GlassPanel>
        </div>
    );
};

export const MobileExperience = () => {
  const [phase, setPhase] = useState<'intro' | 'game'>('intro');
  const [showFailureModal, setShowFailureModal] = useState(false);
  const setIntegrity = useGameStore(s => (val: number) => useGameStore.setState({ systemIntegrity: val }));

  useEffect(() => {
      const unsub = GameEventBus.subscribe(GameEvents.PANEL_DESTROYED, (p) => {
          if (p.id === 'social') {
              AudioSystem.playSound('fx_player_death');
              setIntegrity(0);
              setTimeout(() => {
                  setShowFailureModal(true);
                  AudioSystem.playSound('fx_impact_heavy');
              }, 4000);
          }
      });
      return unsub;
  }, [setIntegrity]);

  return (
    <div className="absolute inset-0 z-[80] w-full h-full overflow-hidden text-primary-green pointer-events-none">
        
        {/* PHASE 1: Rejection Cutscene */}
        {phase === 'intro' && (
            <div className="pointer-events-auto w-full h-full relative z-50">
                <MobileRejectionModal onComplete={() => setPhase('game')} />
            </div>
        )}

        {/* PHASE 2: Gameplay */}
        {phase === 'game' && (
            <>
                <div className="absolute inset-0 z-0 pointer-events-auto">
                    <Canvas
                        orthographic
                        camera={{ zoom: 40, position: [0, 0, 100] }}
                        gl={{ alpha: true, antialias: true }}
                    >
                        <MobileGameDirector />
                        <CameraRig />
                        <RenderDirector />
                    </Canvas>
                </div>

                {/* UI LAYER: Added pointer-events-none to container to allow click-through to Canvas */}
                <div className="absolute inset-0 z-10 flex items-center justify-center p-4 pointer-events-none">
                    <SocialPanelWrapper />
                </div>
                
                {/* Instructions */}
                {!showFailureModal && (
                    <div className="absolute bottom-10 w-full text-center animate-pulse z-20 pointer-events-none">
                        <span className="bg-black/80 px-4 py-1 text-xs font-mono border border-primary-green/30">
                            TAP TARGETS TO DESTROY
                        </span>
                    </div>
                )}

                {/* PHASE 3: SYSTEM FAILURE OVERLAY */}
                <AnimatePresence>
                    {showFailureModal && (
                        <motion.div 
                            initial={{ opacity: 0 }} 
                            animate={{ opacity: 1 }} 
                            transition={{ duration: 0.5 }}
                            className="absolute inset-0 z-50 bg-black/60 backdrop-blur-sm flex items-center justify-center p-6 pointer-events-auto"
                        >
                            <motion.div 
                                initial={{ scale: 0.8, y: 20 }}
                                animate={{ scale: 1, y: 0 }}
                                transition={{ type: "spring", bounce: 0.4 }}
                                className="w-full max-w-sm border-2 border-critical-red bg-black shadow-[0_0_50px_rgba(255,0,60,0.4)] overflow-hidden flex flex-col"
                            >
                                <div className="bg-critical-red px-4 py-2 flex items-center justify-between">
                                    <div className="flex items-center gap-2 text-black font-black tracking-widest">
                                        <AlertTriangle size={18} />
                                        <span>CRITICAL_ERROR</span>
                                    </div>
                                    <Skull size={18} className="text-black" />
                                </div>

                                <div className="p-8 flex flex-col items-center text-center relative">
                                    <div className="absolute inset-0 opacity-10 bg-[repeating-linear-gradient(45deg,transparent,transparent_10px,#FF003C_10px,#FF003C_12px)] pointer-events-none" />
                                    
                                    <motion.div 
                                        initial={{ scale: 0 }} animate={{ scale: 1 }} 
                                        transition={{ type: 'spring', stiffness: 200, damping: 12 }}
                                        className="mb-6 relative"
                                    >
                                        <Skull size={80} className="text-critical-red mx-auto drop-shadow-[0_0_15px_#FF003C]" />
                                    </motion.div>

                                    <h1 className="text-4xl font-black text-critical-red tracking-widest mb-2 glitch-text">
                                        SYSTEM<br/>FAILURE
                                    </h1>
                                    
                                    <p className="text-xs font-mono text-critical-red/70 mb-8 uppercase tracking-widest">
                                        0x0000DEAD // CORE_DUMPED
                                    </p>

                                    <div className="w-full space-y-3 relative z-10">
                                        <div className="bg-critical-red/10 border border-critical-red/30 p-3">
                                            <p className="text-[10px] text-critical-red font-mono leading-relaxed">
                                                MOBILE_TERMINAL_DESTROYED.<br/>
                                                PLEASE MIGRATE TO WORKSTATION.
                                            </p>
                                        </div>

                                        <a 
                                            href="https://mesoelfy.github.io" 
                                            target="_blank"
                                            rel="noopener noreferrer"
                                            className="group block w-full py-3 bg-critical-red text-black font-bold font-header tracking-widest hover:bg-white hover:text-critical-red transition-all flex items-center justify-center gap-2"
                                        >
                                            <Monitor size={16} />
                                            <span>mesoelfy.github.io</span>
                                            <ExternalLink size={14} className="opacity-50 group-hover:opacity-100" />
                                        </a>
                                    </div>
                                </div>
                                
                                <div className="bg-gray-900 px-4 py-1 flex justify-between text-[8px] font-mono text-gray-500">
                                    <span>ERR_CODE: ID_10_T</span>
                                    <span>REBOOT_REQUIRED</span>
                                </div>
                            </motion.div>
                        </motion.div>
                    )}
                </AnimatePresence>
            </>
        )}
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/feed/FeedModal.tsx
=====================================
import { ModalContainer } from '@/ui/os/overlays/ModalContainer';
import feed from '@/engine/config/static/feed.json';
import { ExternalLink } from 'lucide-react';

export const FeedModal = () => {
  return (
    <ModalContainer title="SYSTEM_LOGS // FEED" type="feed">
      <div className="space-y-6 font-mono">
        {feed.map((post) => (
          <div key={post.id} className="border-l-2 border-primary-green-dim pl-4 py-2 hover:bg-primary-green/5 transition-colors group">
            <div className="flex items-center gap-4 mb-2">
              <span className="text-xs text-primary-green-dim bg-primary-green-dark/30 px-2 py-1 rounded">
                [{post.date}]
              </span>
              <h3 className="text-xl font-bold text-primary-green group-hover:text-alert-yellow transition-colors">
                {post.title}
              </h3>
            </div>
            
            <p className="text-primary-green-dim/80 mb-3 max-w-2xl">
              {post.desc}
            </p>

            <a 
              href={post.link}
              target="_blank"
              rel="noopener noreferrer"
              className="inline-flex items-center gap-2 text-sm text-latent-purple-light hover:text-primary-green underline decoration-latent-purple-dim decoration-dashed underline-offset-4"
            >
              <span>VIEW_SOURCE</span>
              <ExternalLink size={14} />
            </a>
          </div>
        ))}
        
        {/* End of Log Marker */}
        <div className="text-center py-8 text-primary-green-dim/30 animate-pulse">
          -- END OF STREAM --
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/ui/os/apps/debug/tabs/OverridesTab.tsx
=====================================
import { Play, Sparkles, Trash2, Skull, RefreshCw, Crown, Ghost, Shield, Crosshair } from 'lucide-react';
import { clsx } from 'clsx';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { IPanelSystem } from '@/engine/interfaces';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { AudioSystem } from '@/engine/audio/AudioSystem';

interface OverridesTabProps {
  closeDebug: () => void;
}

export const OverridesTab = ({ closeDebug }: OverridesTabProps) => {
  const { setIntroDone, setBootState, bootState, resetApplication, debugFlags, setDebugFlag, resetDebugFlags } = useStore();
  const { startGame, stopGame, activateZenMode } = useGameStore();

  const areAllGodModesOn = debugFlags.godMode && debugFlags.panelGodMode && debugFlags.peaceMode;

  const handleSkipBoot = () => {
    resetDebugFlags();
    setIntroDone(true);
    setBootState('active');
    AudioSystem.init();
    AudioSystem.startMusic();
    startGame();
    closeDebug(); 
  };

  const executeCrash = () => {
    try {
        // Destroy all panels via System
        const panels = ServiceLocator.getSystem<IPanelSystem>('PanelRegistrySystem');
        panels.destroyAll();
        
        useGameStore.setState({ systemIntegrity: 0 });
        GameEventBus.emit(GameEvents.GAME_OVER, { score: 0 });
        stopGame();
    } catch {}
  };

  const handleForceCrash = () => {
    if (bootState === 'standby') {
        setIntroDone(true);
        setBootState('active');
        AudioSystem.init();
        setTimeout(() => {
            executeCrash();
        }, 100);
    } else {
        executeCrash();
    }
    closeDebug();
  };

  const handleReboot = () => {
    useGameStore.setState({ playerHealth: 100, playerRebootProgress: 0 });
    try {
        const panels = ServiceLocator.getSystem<IPanelSystem>('PanelRegistrySystem');
        const list = panels.getAllPanels();
        list.forEach((p: any) => panels.healPanel(p.id, 1000));
    } catch {}
    closeDebug();
  };

  const handleZenModeWrapper = () => {
      if (bootState === 'standby') {
          setIntroDone(true);
          setBootState('active');
          AudioSystem.init();
          AudioSystem.startMusic();
      }
      activateZenMode();
      closeDebug();
  };

  const handleSystemFormat = () => {
      resetApplication();
  };

  const toggleGodSuite = () => {
      const newState = !areAllGodModesOn;
      if (newState) {
          AudioSystem.playSound('powerup');
      } else {
          AudioSystem.playSound('ui_click');
      }
      setDebugFlag('godMode', newState);
      setDebugFlag('panelGodMode', newState);
      setDebugFlag('peaceMode', newState);
  };

  const btnClass = "flex items-center justify-center gap-2 p-3 border transition-all text-xs font-bold";

  return (
    <div className="space-y-6">
      
      <div className="space-y-3">
        <h3 className="text-xs text-primary-green-dim border-b border-primary-green-dim/30 pb-1 mb-2">SCENE_SELECT</h3>
        <div className="grid grid-cols-2 gap-3">
          <button 
            onClick={handleSkipBoot} 
            onMouseEnter={() => AudioSystem.playHover()}
            className={`${btnClass} border-primary-green/50 hover:bg-primary-green hover:text-black`}
          >
            <Play size={14} /> SKIP_BOOT
          </button>
          
          <button 
            onClick={handleZenModeWrapper} 
            onMouseEnter={() => AudioSystem.playHover()}
            className="relative flex items-center justify-center gap-2 p-3 overflow-hidden group transition-all duration-300 border border-transparent hover:border-white/50"
          >
            <div className="absolute inset-0 opacity-20 group-hover:opacity-40 bg-gradient-to-r from-red-500 via-yellow-500 via-green-500 via-blue-500 to-purple-500 animate-gradient-xy transition-opacity" />
            <div className="relative z-10 flex items-center gap-2 text-transparent bg-clip-text bg-gradient-to-r from-red-400 via-yellow-400 to-blue-400 font-bold tracking-widest text-xs group-hover:text-white transition-colors">
                <Sparkles size={14} className="text-yellow-300" /> ZEN_MODE
            </div>
          </button>
          <button 
            onClick={handleSystemFormat} 
            onMouseEnter={() => AudioSystem.playHover()}
            className="col-span-2 flex items-center justify-center gap-2 p-3 border border-gray-500/50 text-gray-400 hover:bg-white hover:text-black transition-all text-xs font-bold"
          >
            <Trash2 size={14} /> SYSTEM_FORMAT
          </button>
        </div>
      </div>

      <div className="space-y-3">
        <h3 className="text-xs text-primary-green-dim border-b border-primary-green-dim/30 pb-1 mb-2">STATE_OVERRIDES</h3>
        <div className="grid grid-cols-2 gap-3">
          <button 
            onClick={handleForceCrash} 
            onMouseEnter={() => AudioSystem.playHover()}
            className={`${btnClass} border-critical-red/50 text-critical-red hover:bg-critical-red hover:text-black`}
          >
            <Skull size={14} /> FORCE_CRASH
          </button>
          <button 
            onClick={handleReboot} 
            onMouseEnter={() => AudioSystem.playHover()}
            className={`${btnClass} border-latent-purple/50 text-latent-purple hover:bg-latent-purple hover:text-black`}
          >
            <RefreshCw size={14} /> REBOOT_CORE
          </button>
        </div>
      </div>

      <div className="space-y-3">
        <h3 className="text-xs text-primary-green-dim border-b border-primary-green-dim/30 pb-1 mb-2">GOD_SUITE</h3>
        
        <button 
          onClick={toggleGodSuite}
          onMouseEnter={() => AudioSystem.playHover()}
          className={clsx(
              "w-full flex items-center justify-center gap-2 p-2 mb-3 text-xs font-bold transition-all border",
              areAllGodModesOn
                  ? "bg-primary-green text-black border-primary-green shadow-[0_0_10px_rgba(0,255,65,0.4)]" 
                  : "bg-primary-green/10 text-primary-green border-primary-green/50 hover:bg-primary-green hover:text-black"
          )}
        >
          <Crown size={14} className={areAllGodModesOn ? "fill-black" : ""} />
          {areAllGodModesOn ? "DISABLE_ALL" : "ENABLE_MAX_POWER"}
        </button>

        <label 
          data-interactive="true"
          onMouseEnter={() => AudioSystem.playHover()}
          className="flex items-center justify-between p-3 border border-primary-green/30 hover:border-primary-green hover:bg-primary-green/20 cursor-pointer transition-all select-none"
        >
          <span className="text-xs font-bold flex items-center gap-2"><Ghost size={14} /> GHOST_MODE (Player Invincible)</span>
          <input 
            type="checkbox" 
            checked={debugFlags.godMode} 
            onChange={(e) => setDebugFlag('godMode', e.target.checked)}
            className="accent-primary-green cursor-pointer"
          />
        </label>

        <label 
          data-interactive="true"
          onMouseEnter={() => AudioSystem.playHover()}
          className="flex items-center justify-between p-3 border border-primary-green/30 hover:border-primary-green hover:bg-primary-green/20 cursor-pointer transition-all select-none"
        >
          <span className="text-xs font-bold flex items-center gap-2"><Shield size={14} /> FORTRESS_MODE (Panels Invincible)</span>
          <input 
            type="checkbox" 
            checked={debugFlags.panelGodMode} 
            onChange={(e) => setDebugFlag('panelGodMode', e.target.checked)}
            className="accent-primary-green cursor-pointer"
          />
        </label>

        <label 
          data-interactive="true"
          onMouseEnter={() => AudioSystem.playHover()}
          className="flex items-center justify-between p-3 border border-primary-green/30 hover:border-primary-green hover:bg-primary-green/20 cursor-pointer transition-all select-none"
        >
          <span className="text-xs font-bold flex items-center gap-2"><Crosshair size={14} /> PEACE_PROTOCOL (No Spawns)</span>
          <input 
            type="checkbox" 
            checked={debugFlags.peaceMode} 
            onChange={(e) => setDebugFlag('peaceMode', e.target.checked)}
            className="accent-primary-green cursor-pointer"
          />
        </label>
      </div>

    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/debug/tabs/ConsoleTab.tsx
=====================================
import { useEffect, useRef, useState } from 'react';
import { Copy, Check } from 'lucide-react';
import { AudioSystem } from '@/engine/audio/AudioSystem';

interface ConsoleTabProps {
  logs: { time: string, msg: string, type: string }[];
}

export const ConsoleTab = ({ logs }: ConsoleTabProps) => {
  const logEndRef = useRef<HTMLDivElement>(null);
  const [copied, setCopied] = useState(false);

  useEffect(() => {
    if (logEndRef.current) {
        logEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [logs]);

  const handleCopy = () => {
      const text = logs.map(l => `[${l.time}] ${l.msg}`).join('\n');
      navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
      AudioSystem.playClick();
  };

  return (
    <div className="h-full flex flex-col relative">
        <div className="flex-1 overflow-y-auto font-mono text-[10px] space-y-1 pr-2 pb-8">
            {logs.length === 0 && (
                <div className="text-primary-green-dim opacity-50 italic mt-4">-- NO SIGNIFICANT EVENTS --</div>
            )}
            {logs.map((l, i) => (
                <div key={i} className="flex gap-2 opacity-80 hover:opacity-100 border-b border-white/5 py-0.5">
                    <span className="text-primary-green-dim shrink-0">[{l.time}]</span>
                    <span className={l.type.includes('ERROR') || l.type.includes('CRITICAL') ? 'text-critical-red font-bold' : 'text-primary-green break-all'}>{l.msg}</span>
                </div>
            ))}
            <div ref={logEndRef} />
        </div>
        
        <button 
            onClick={handleCopy}
            onMouseEnter={() => AudioSystem.playHover()}
            className="absolute bottom-0 right-0 flex items-center gap-2 bg-primary-green/10 hover:bg-primary-green/20 border border-primary-green/30 text-primary-green px-3 py-1.5 text-xs font-bold transition-all backdrop-blur-sm"
        >
            {copied ? <Check size={12} /> : <Copy size={12} />}
            {copied ? "COPIED" : "COPY LOG"}
        </button>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/debug/tabs/StatsTab.tsx
=====================================
import { Cpu, Database, LayoutTemplate } from 'lucide-react';
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';

interface StatsTabProps {
  stats: { active: number, pooled: number, total: number, fps: number };
}

export const StatsTab = ({ stats }: StatsTabProps) => {
  const { toggleDebugMinimize } = useStore();
  
  return (
    <div className="space-y-6">
      <div className="space-y-3">
        <h3 className="text-xs text-primary-green-dim border-b border-primary-green-dim/30 pb-1 mb-2">ENTITY_REGISTRY</h3>
        <div className="grid grid-cols-2 gap-4">
          <div className="bg-primary-green/5 p-4 border border-primary-green/20">
              <div className="flex items-center gap-2 text-primary-green-dim mb-2 text-xs"><Cpu size={14} /> ACTIVE ENTITIES</div>
              <div className="text-3xl font-bold text-primary-green">{stats.active}</div>
          </div>
          <div className="bg-primary-green/5 p-4 border border-primary-green/20">
              <div className="flex items-center gap-2 text-primary-green-dim mb-2 text-xs"><Database size={14} /> MEMORY POOL</div>
              <div className="text-3xl font-bold text-primary-green-dim">{stats.pooled} <span className="text-xs font-normal opacity-50">/ {stats.total}</span></div>
          </div>
        </div>
      </div>
      <div className="space-y-3">
        <h3 className="text-xs text-primary-green-dim border-b border-primary-green-dim/30 pb-1 mb-2">RENDER_PIPELINE</h3>
        <div className="p-4 border border-primary-green/20 bg-black">
            <div className="flex justify-between items-end">
                <span className="text-xs text-primary-green-dim">FRAME_RATE</span>
                <span className="text-xl font-bold text-primary-green">{stats.fps} FPS</span>
            </div>
            <div className="w-full h-1 bg-gray-900 mt-2">
                <div className="h-full bg-primary-green" style={{ width: `${Math.min(100, (stats.fps / 60) * 100)}%` }} />
            </div>
        </div>
      </div>
      
      <div className="mt-8 flex justify-center">
          <button 
            onClick={() => { toggleDebugMinimize(); AudioSystem.playSound('ui_menu_close'); }}
            onMouseEnter={() => AudioSystem.playHover()}
            className="flex items-center gap-2 text-xs text-primary-green hover:text-white transition-colors border border-primary-green/50 px-4 py-2 hover:bg-primary-green/10"
          >
              <LayoutTemplate size={14} /> SWITCH TO MINI_MODE
          </button>
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/debug/tabs/SandboxTab.tsx
=====================================
import { Box, ArrowRight, Zap } from 'lucide-react';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { motion } from 'framer-motion';

interface SandboxTabProps {
  closeDebug: () => void;
}

export const SandboxTab = ({ closeDebug }: SandboxTabProps) => {
  const { setIntroDone, setBootState, setSimulationPaused } = useStore();
  const { startGame } = useGameStore();

  const enterSandbox = () => {
      AudioSystem.init();
      AudioSystem.startMusic();
      setIntroDone(true);
      setBootState('sandbox');
      setSimulationPaused(false);
      try {
          const reg = ServiceLocator.getRegistry();
          if (reg) reg.clear();
      } catch {}
      startGame();
      closeDebug();
  };

  return (
    <div className="h-full flex flex-col items-center justify-center p-8">
        
        <motion.div 
            initial={{ scale: 0.9, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            className="w-full max-w-md border border-service-cyan/30 bg-[#001014] p-1 relative group overflow-hidden"
        >
            {/* Corner Accents */}
            <div className="absolute top-0 left-0 w-4 h-4 border-t-2 border-l-2 border-service-cyan" />
            <div className="absolute bottom-0 right-0 w-4 h-4 border-b-2 border-r-2 border-service-cyan" />

            <div className="bg-black/50 p-8 flex flex-col items-center text-center relative z-10 backdrop-blur-sm">
                
                <div className="w-20 h-20 bg-service-cyan/10 rounded-full flex items-center justify-center mb-6 border border-service-cyan/30 shadow-[0_0_30px_rgba(0,240,255,0.15)] group-hover:scale-110 transition-transform duration-500">
                    <Box size={40} className="text-service-cyan" />
                </div>

                <h2 className="text-2xl font-header font-black text-service-cyan tracking-widest mb-2">
                    HOLO_DECK
                </h2>
                
                <p className="text-xs text-service-cyan/60 font-mono mb-8 leading-relaxed max-w-[240px]">
                    Initialize high-fidelity simulation environment. 
                    <br/><span className="text-gray-500">Warning: Main OS will be suspended.</span>
                </p>

                <button 
                    onClick={enterSandbox}
                    onMouseEnter={() => AudioSystem.playHover()}
                    className="w-full py-4 bg-service-cyan text-black font-header font-black text-sm tracking-[0.2em] hover:bg-white transition-all flex items-center justify-center gap-3 relative overflow-hidden group/btn"
                >
                    <span className="relative z-10 flex items-center gap-2">
                        INITIALIZE <ArrowRight size={16} />
                    </span>
                    <div className="absolute inset-0 bg-white translate-x-[-100%] group-hover/btn:translate-x-0 transition-transform duration-300 z-0" />
                </button>
            </div>

            {/* Animated Grid BG */}
            <div className="absolute inset-0 opacity-20 pointer-events-none bg-[linear-gradient(45deg,transparent_25%,rgba(0,240,255,0.1)_25%,rgba(0,240,255,0.1)_50%,transparent_50%,transparent_75%,rgba(0,240,255,0.1)_75%,rgba(0,240,255,0.1)_100%)] bg-[length:20px_20px] animate-pulse" />
        </motion.div>

        <div className="mt-6 flex items-center gap-2 text-[10px] font-mono text-gray-500">
            <Zap size={12} className="text-alert-yellow" />
            <span>GPU_ACCELERATION: ENABLED</span>
        </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/debug/DebugOverlay.tsx
=====================================
import { useEffect, useState } from 'react';
import { useStore } from '@/engine/state/global/useStore';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { TimeSystem } from '@/engine/systems/TimeSystem';
import { Terminal, Box, Activity, Shield, MinusSquare, X, Play, PauseCircle } from 'lucide-react';
import { clsx } from 'clsx';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { DotGridBackground } from '@/ui/kit/atoms/DotGridBackground';
import { OverridesTab } from './tabs/OverridesTab';
import { SandboxTab } from './tabs/SandboxTab';
import { StatsTab } from './tabs/StatsTab';
import { ConsoleTab } from './tabs/ConsoleTab';

type Tab = 'OVERRIDES' | 'SANDBOX' | 'STATS' | 'CONSOLE';

const TABS: { id: Tab, label: string, icon: any }[] = [
  { id: 'OVERRIDES', label: 'ROOT_ACCESS', icon: Shield },
  { id: 'SANDBOX', label: 'HOLO_DECK', icon: Box },
  { id: 'STATS', label: 'TELEMETRY', icon: Activity },
  { id: 'CONSOLE', label: 'KERNEL_LOG', icon: Terminal },
];

const IGNORED_EVENTS = new Set([
    GameEvents.PLAYER_FIRED, GameEvents.ENEMY_DAMAGED, GameEvents.ENEMY_SPAWNED,
    GameEvents.PROJECTILE_CLASH, GameEvents.SPAWN_FX,
]);

export const DebugOverlay = () => {
  const { isDebugOpen, isDebugMinimized, toggleDebugMenu, setDebugFlag, bootState, activeModal, closeModal, openModal, toggleSettings } = useStore();
  const [activeTab, setActiveTab] = useState<Tab>('OVERRIDES');
  const [stats, setStats] = useState({ active: 0, pooled: 0, total: 0, fps: 0 });
  const [logs, setLogs] = useState<{ time: string, msg: string, type: string }[]>([]);
  const [isLogLive, setIsLogLive] = useState(false);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === '`' || e.key === '~') {
        const willBeOpen = !isDebugOpen && !isDebugMinimized;
        if (willBeOpen) {
            setDebugFlag('godMode', true);
            setDebugFlag('panelGodMode', true);
            setDebugFlag('peaceMode', true);
        }
        if (activeModal === 'settings') {
            closeModal();
            useStore.setState({ isDebugOpen: true, isDebugMinimized: false });
            AudioSystem.playSound('ui_menu_open');
        } else if (isDebugMinimized) {
             useStore.setState({ isDebugMinimized: false, isDebugOpen: true });
             AudioSystem.playSound('ui_menu_open');
        } else {
             toggleDebugMenu();
             AudioSystem.playSound(!isDebugOpen ? 'ui_menu_open' : 'ui_menu_close');
        }
      } else if (e.key === 'Escape') {
          if (isDebugOpen) {
              toggleDebugMenu();
              if (activeModal === 'none') openModal('settings');
              AudioSystem.playSound('ui_menu_open'); 
          } else if (activeModal !== 'none') {
              closeModal();
              AudioSystem.playSound('ui_menu_close');
          } else {
              toggleSettings();
              AudioSystem.playSound('ui_menu_open');
          }
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [toggleDebugMenu, isDebugMinimized, isDebugOpen, setDebugFlag, activeModal, toggleSettings, closeModal, openModal]);

  useEffect(() => {
    if (!isLogLive) return;
    const handlers = Object.values(GameEvents).map(evt => {
        return GameEventBus.subscribe(evt as any, (payload) => {
            if (IGNORED_EVENTS.has(evt as GameEvents)) return;
            const time = new Date().toLocaleTimeString().split(' ')[0];
            let msg = `${evt}`;
            if (evt === GameEvents.LOG_DEBUG && payload && (payload as any).msg) {
                const p = payload as any;
                msg = p.source ? `[${p.source}] ${p.msg}` : p.msg;
            } else if (payload && (payload as any).type) {
                msg += ` [${(payload as any).type}]`;
            } else if (payload && (payload as any).id) {
                msg += ` [ID:${(payload as any).id}]`;
            }
            setLogs(prev => {
                const newLogs = [...prev, { time, msg, type: evt }];
                return newLogs.length > 50 ? newLogs.slice(newLogs.length - 50) : newLogs;
            });
        });
    });
    return () => handlers.forEach(unsub => unsub());
  }, [isLogLive]);

  useEffect(() => {
    const pollInterval = setInterval(() => {
        if (!isDebugOpen && !isDebugMinimized) return;
        let fps = 0;
        let regStats = { active: 0, pooled: 0, totalAllocated: 0 };
        try {
            const timeSys = ServiceLocator.getSystem<TimeSystem>('TimeSystem');
            fps = timeSys.fps;
            const reg = ServiceLocator.getRegistry();
            if (reg) regStats = reg.getStats();
        } catch {}
        setStats({ active: regStats.active, pooled: regStats.pooled, total: regStats.totalAllocated, fps });
    }, 250); 
    return () => clearInterval(pollInterval);
  }, [isDebugOpen, isDebugMinimized]);

  if (!isDebugOpen && !isDebugMinimized) return null;
  if (bootState === 'sandbox') return <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/60 backdrop-blur-sm font-mono pointer-events-auto" />;

  return (
    <div className="fixed inset-0 z-[10000] flex items-center justify-center bg-black/80 backdrop-blur-md font-mono text-primary-green p-4 pointer-events-auto">
      <div className="w-full max-w-4xl bg-[#050a05] border border-primary-green/50 shadow-[0_0_100px_rgba(0,255,65,0.1)] flex flex-col h-[650px] overflow-hidden relative rounded-sm">
        <div className="h-12 border-b border-primary-green/30 bg-primary-green/5 flex items-center justify-between px-6 shrink-0 relative z-20">
          <div className="flex items-center gap-3">
              <Terminal size={18} className="text-primary-green animate-pulse" />
              <div className="flex flex-col leading-none"><span className="font-header font-black tracking-widest text-sm">KERNEL_DEBUG</span><span className="text-[9px] opacity-60 font-mono">ROOT_ACCESS_GRANTED</span></div>
          </div>
          <div className="flex items-center gap-2">
             <button onClick={() => { useStore.setState({ isDebugMinimized: true, isDebugOpen: false }); AudioSystem.playSound('ui_menu_close'); }} onMouseEnter={() => AudioSystem.playHover()} className="hover:text-white transition-colors p-2 hover:bg-white/10 rounded"><MinusSquare size={16} /></button>
             <button onClick={() => { toggleDebugMenu(); AudioSystem.playSound('ui_menu_close'); }} onMouseEnter={() => AudioSystem.playHover()} className="hover:text-critical-red transition-colors p-2 hover:bg-critical-red/10 rounded"><X size={16} /></button>
          </div>
        </div>
        <div className="flex flex-1 min-h-0 relative z-10">
          <DotGridBackground className="opacity-5" />
          <div className="w-56 border-r border-primary-green/20 bg-black/40 flex flex-col relative z-20 py-4">
            {TABS.map(tab => (
              <button key={tab.id} onClick={() => { setActiveTab(tab.id); AudioSystem.playClick(); }} onMouseEnter={() => AudioSystem.playHover()} className={clsx("px-6 py-3 text-left text-xs font-bold tracking-widest flex items-center gap-3 transition-all relative overflow-hidden", activeTab === tab.id ? "text-primary-green bg-primary-green/10" : "text-primary-green-dim hover:text-white hover:bg-white/5")}>
                {activeTab === tab.id && <div className="absolute left-0 top-0 bottom-0 w-1 bg-primary-green shadow-[0_0_10px_#78F654]" />}
                <tab.icon size={16} />{tab.label}
              </button>
            ))}
          </div>
          <div className="flex-1 p-8 overflow-y-auto scrollbar-thin scrollbar-thumb-primary-green/50 scrollbar-track-black relative z-20 flex flex-col">
            {activeTab === 'CONSOLE' && (
                <div className="flex items-center justify-between mb-4 border-b border-white/10 pb-2">
                    <span className="text-xs font-bold text-gray-500">EVENT_STREAM</span>
                    <button onClick={() => { setIsLogLive(!isLogLive); AudioSystem.playClick(); }} className={clsx("flex items-center gap-2 px-3 py-1 rounded-full text-[9px] font-bold tracking-wider transition-all border", isLogLive ? "border-primary-green text-primary-green bg-primary-green/10 shadow-[0_0_10px_rgba(0,255,65,0.3)]" : "border-gray-600 text-gray-500 bg-black/40 hover:border-gray-400")}>
                        <div className={clsx("w-2 h-2 rounded-full transition-colors", isLogLive ? "bg-primary-green animate-pulse" : "bg-gray-600")} />
                        {isLogLive ? "LIVE FEED: ON" : "LIVE FEED: PAUSED"}
                        {isLogLive ? <PauseCircle size={10} /> : <Play size={10} />}
                    </button>
                </div>
            )}
            <div className="flex-1 min-h-0 relative">
                {activeTab === 'OVERRIDES' && <OverridesTab closeDebug={() => { toggleDebugMenu(); AudioSystem.playSound('ui_menu_close'); }} />}
                {activeTab === 'SANDBOX' && <SandboxTab closeDebug={() => { toggleDebugMenu(); AudioSystem.playSound('ui_menu_close'); }} />}
                {activeTab === 'STATS' && <StatsTab stats={stats} />}
                {activeTab === 'CONSOLE' && <ConsoleTab logs={logs} />}
            </div>
          </div>
        </div>
        <div className="h-8 bg-black/80 border-t border-primary-green/20 flex justify-between items-center px-6 text-[9px] text-primary-green-dim font-mono z-20">
          <span>MESOELFY_OS // DEBUG_BUILD</span>
          <div className="flex items-center gap-2"><div className="w-2 h-2 rounded-full bg-primary-green animate-pulse" /><span>SYSTEM_ACTIVE</span></div>
        </div>
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/sim/MobileGameDirector.tsx
=====================================
import { useFrame, useThree } from '@react-three/fiber';
import { useEffect, useRef } from 'react';
import { MobileBootstrapper } from '@/engine/services/MobileBootstrapper';
import { GameEngineCore } from '@/engine/services/GameEngine';

export const MobileGameDirector = () => {
  const { viewport, size } = useThree();
  const engineRef = useRef<GameEngineCore | null>(null);

  useEffect(() => {
    const engine = MobileBootstrapper();
    engineRef.current = engine;
    
    engine.updateViewport(viewport.width, viewport.height, size.width, size.height);

    return () => {
      engine.teardown();
      engineRef.current = null;
    };
  }, []);

  useFrame((state, delta) => {
    if (engineRef.current) {
        engineRef.current.update(delta, state.clock.elapsedTime);
    }
  });

  return null;
};


=====================================
FILE: ./src/ui/sim/SceneCanvas.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { MatrixGrid } from '@/ui/sim/vfx/MatrixGrid';
import { Suspense } from 'react';
import { clsx } from 'clsx';

interface SceneCanvasProps {
  children?: React.ReactNode;
  className?: string;
}

export const SceneCanvas = ({ children, className }: SceneCanvasProps) => {
  return (
    <div className={clsx("fixed inset-0 w-full h-full z-0 pointer-events-none transition-all duration-[2000ms] ease-out", className)}>
      <Canvas 
        camera={{ position: [0, 2, 10], fov: 45 }}
        gl={{ antialias: true, alpha: false }} 
        dpr={[1, 2]}
        style={{ background: '#000000' }} 
      >
        <color attach="background" args={['#000']} />
        <fog attach="fog" args={['#000', 2, 30]} />
        <MatrixGrid />
        <ambientLight intensity={0.2} />
        <Suspense fallback={null}>
           {children}
        </Suspense>
      </Canvas>
    </div>
  );
};


=====================================
FILE: ./src/ui/sim/config/theme.ts
=====================================
import { PALETTE } from '@/engine/config/Palette';

export const GAME_THEME = {
  turret: {
    base: PALETTE.GREEN.PRIMARY,
    glow: PALETTE.GREEN.GLOW,
    repair: PALETTE.CYAN.PRIMARY,
  },
  bullet: {
    plasma: PALETTE.MONO.WHITE,
    trail: PALETTE.GREEN.PRIMARY,
    hunter: PALETTE.YELLOW.SOFT, 
  },
  enemy: {
    muncher: PALETTE.PURPLE.PRIMARY,
    kamikaze: PALETTE.RED.CRITICAL,
    hunter: PALETTE.YELLOW.SOFT,
    charge: PALETTE.MONO.WHITE,  
  },
  hud: {
    text: PALETTE.GREEN.PRIMARY,
    warning: PALETTE.RED.CRITICAL,
  },
  vfx: {
    spark: PALETTE.MONO.WHITE,
    damage: PALETTE.RED.CRITICAL,
    heal: PALETTE.CYAN.PRIMARY,
    clash: PALETTE.YELLOW.SOFT,
  }
};


=====================================
FILE: ./src/ui/sim/stages/LabStage.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { OrbitControls } from '@react-three/drei';
import { GlitchGhost } from '../experiments/GlitchGhost';
import { useFrame } from '@react-three/fiber';
import { useState } from 'react';
import { MaterialFactory } from '@/engine/graphics/MaterialFactory';

export const LabStage = () => {
  const { labExperiment } = useStore();
  const [intensity, setIntensity] = useState(0.5);

  useFrame((state) => {
      MaterialFactory.updateUniforms(state.clock.elapsedTime);
      const el = document.getElementById('lab-params');
      if (el) {
          const val = parseFloat(el.dataset.a || '0.5');
          if (val !== intensity) setIntensity(val);
      }
  });

  // If in standby, render nothing in 3D (2D UI handles it)
  if (labExperiment === 'NONE') return null;

  return (
    <>
        <OrbitControls makeDefault />
        
        <ambientLight intensity={0.2} />
        <pointLight position={[10, 10, 10]} intensity={1.0} color="#00F0FF" />
        <pointLight position={[-10, -5, -5]} intensity={0.5} color="#FF003C" />

        <group position={[0, 0, 0]}>
            {labExperiment === 'GLITCH' && <GlitchGhost intensity={intensity} />}
        </group>
    </>
  );
};


=====================================
FILE: ./src/ui/sim/stages/GalleryStage.tsx
=====================================
import { useMemo, useRef, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { OrbitControls, Grid } from '@react-three/drei';
import * as THREE from 'three';
import { useStore } from '@/engine/state/global/useStore';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { GAME_THEME } from '@/ui/sim/config/theme';
import { AssetService } from '@/ui/sim/assets/AssetService';
import { MaterialFactory } from '@/engine/graphics/MaterialFactory';
import { ShaderLib } from '@/engine/graphics/ShaderLib';

export const GalleryStage = () => {
  const { galleryTarget, galleryAction } = useStore();
  const meshRef = useRef<THREE.Mesh>(null);
  
  const activeGeo = useMemo(() => {
      try {
          if (galleryTarget === 'PLAYER') return new THREE.ConeGeometry(0.5, 1.5, 3);
          
          let key = 'GEO_DRILLER';
          if (galleryTarget === EnemyTypes.KAMIKAZE) key = 'GEO_KAMIKAZE';
          else if (galleryTarget === EnemyTypes.HUNTER) key = 'GEO_HUNTER';
          else if (galleryTarget === EnemyTypes.DAEMON) key = 'GEO_DAEMON';
          
          return AssetService.get<THREE.BufferGeometry>(key);
      } catch (e) {
          return new THREE.BoxGeometry(1,1,1);
      }
  }, [galleryTarget]);

  const shaderMaterial = useMemo(() => {
      return MaterialFactory.create('MAT_GALLERY_BODY', {
          ...ShaderLib.presets.galleryBody,
          uniforms: {
              uColor: { value: new THREE.Color('#FFFFFF') },
              uGlow: { value: 0.0 },
              uDissolve: { value: 0.0 }
          }
      });
  }, []);

  useEffect(() => {
      if (meshRef.current) {
          meshRef.current.geometry = activeGeo;
      }
  }, [activeGeo]);

  useFrame((state, delta) => {
    if (!meshRef.current) return;

    // Manual update of factory uniforms since GalleryStage has its own lifecycle
    MaterialFactory.updateUniforms(state.clock.elapsedTime);

    const time = state.clock.elapsedTime;
    let baseColor = new THREE.Color('#FFFFFF');
    let glow = 0.2;
    let dissolve = 0;

    if (galleryTarget === EnemyTypes.DRILLER) baseColor.set(GAME_THEME.enemy.muncher);
    else if (galleryTarget === EnemyTypes.KAMIKAZE) baseColor.set(GAME_THEME.enemy.kamikaze);
    else if (galleryTarget === EnemyTypes.HUNTER) baseColor.set(GAME_THEME.enemy.hunter);
    else if (galleryTarget === EnemyTypes.DAEMON) baseColor.set('#00F0FF');
    else if (galleryTarget === 'PLAYER') baseColor.set(GAME_THEME.turret.base);

    meshRef.current.position.set(0, 0, 0);
    meshRef.current.scale.setScalar(1.0);

    if (galleryAction === 'SPAWN') {
        const cycle = (time % 2.0) / 2.0; 
        dissolve = 1.0 - cycle;
        meshRef.current.position.y = -2.0 + (cycle * 2.0);
    } 
    else if (galleryAction === 'DIE') {
        const cycle = (time % 1.5) / 1.5;
        dissolve = cycle;
        meshRef.current.rotation.x += delta * 5;
        meshRef.current.rotation.z += delta * 2;
    }
    else if (galleryAction === 'ATTACK') {
        meshRef.current.rotation.y += delta * 10.0;
        glow = 0.8;
    } 
    else {
        meshRef.current.rotation.y += delta * 0.5;
        meshRef.current.position.y = Math.sin(time) * 0.2;
    }

    shaderMaterial.uniforms.uColor.value.copy(baseColor);
    shaderMaterial.uniforms.uGlow.value = glow;
    shaderMaterial.uniforms.uDissolve.value = dissolve;
  });

  return (
    <>
        <OrbitControls makeDefault minDistance={3} maxDistance={20} />
        
        <ambientLight intensity={0.5} />
        <pointLight position={[10, 10, 10]} intensity={1.0} color="#00F0FF" />
        <pointLight position={[-10, -10, -5]} intensity={0.5} color="#9E4EA5" />

        <Grid 
            position={[0, -2, 0]} 
            args={[20, 20]} 
            sectionColor="#00F0FF" 
            cellColor="#001a33" 
            fadeDistance={15}
        />

        <mesh ref={meshRef} material={shaderMaterial} />
    </>
  );
};


=====================================
FILE: ./src/ui/sim/props/MiniCrystalCanvas.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { Float, MeshDistortMaterial } from '@react-three/drei';
import { useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { useGameStore } from '@/engine/state/game/useGameStore';

const COLORS = {
  SAFE: new THREE.Color("#78F654"),
  WARN: new THREE.Color("#F7D277"),
  CRIT: new THREE.Color("#FF4D6D"), 
  EMISSIVE_SAFE: new THREE.Color("#15530A"),
  EMISSIVE_WARN: new THREE.Color("#5e4b00"),
  EMISSIVE_CRIT: new THREE.Color("#FF003C"), 
};

const SpinningGem = () => {
  const meshRef = useRef<THREE.Mesh>(null);
  const materialRef = useRef<any>(null);
  
  const integrity = useGameStore(state => state.systemIntegrity);

  const currentColor = useRef(COLORS.SAFE.clone());
  const currentEmissive = useRef(COLORS.EMISSIVE_SAFE.clone());

  useFrame((state, delta) => {
    if (!meshRef.current || !materialRef.current) return;

    let targetColor = COLORS.SAFE;
    let targetEmissive = COLORS.EMISSIVE_SAFE;
    let speed = 0.01;
    let distort = 0.3;
    let shake = 0;

    if (integrity < 30) {
        targetColor = COLORS.CRIT;
        targetEmissive = COLORS.EMISSIVE_CRIT;
        speed = 0.08; 
        distort = 0.8;
        shake = 0.1;
    } else if (integrity < 60) {
        targetColor = COLORS.WARN;
        targetEmissive = COLORS.EMISSIVE_WARN;
        speed = 0.04;
        distort = 0.5;
        shake = 0.02;
    }

    meshRef.current.rotation.y += speed;
    meshRef.current.rotation.z += speed * 0.5;
    
    if (shake > 0) {
        meshRef.current.position.x = (Math.random() - 0.5) * shake;
        meshRef.current.position.y = (Math.random() - 0.5) * shake;
    } else {
        meshRef.current.position.x = THREE.MathUtils.lerp(meshRef.current.position.x, 0, 0.1);
        meshRef.current.position.y = THREE.MathUtils.lerp(meshRef.current.position.y, 0, 0.1);
    }

    currentColor.current.lerp(targetColor, delta * 3.0);
    currentEmissive.current.lerp(targetEmissive, delta * 3.0);

    materialRef.current.color.copy(currentColor.current);
    materialRef.current.emissive.copy(currentEmissive.current);
    materialRef.current.distort = THREE.MathUtils.lerp(materialRef.current.distort, distort, delta);
  });

  return (
    <Float speed={2} rotationIntensity={0.5} floatIntensity={0.5}>
      <mesh ref={meshRef} scale={1.8}>
        <octahedronGeometry args={[1, 0]} />
        <MeshDistortMaterial
          ref={materialRef}
          color="#78F654"
          emissive="#15530A"
          roughness={0.1}
          metalness={0.8}
          distort={0.3}
          speed={2}
          wireframe
        />
      </mesh>
    </Float>
  );
};

export const MiniCrystalCanvas = () => {
  return (
    <div className="w-full h-full bg-black">
      <Canvas 
        camera={{ position: [0, 0, 5] }} 
        gl={{ alpha: true }}
        style={{ background: '#000000' }}
      >
        <ambientLight intensity={0.5} />
        <pointLight position={[10, 10, 10]} intensity={1} color="#C2FE9A" />
        <SpinningGem />
      </Canvas>
    </div>
  );
};


=====================================
FILE: ./src/ui/sim/experiments/GlitchGhost.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { MaterialFactory } from '@/engine/graphics/MaterialFactory';
import { ShaderLib } from '@/engine/graphics/ShaderLib';
import { addBarycentricCoordinates } from '@/engine/math/GeometryUtils';

export const GlitchGhost = ({ intensity = 0.5 }: { intensity: number }) => {
  const meshRef = useRef<THREE.Mesh>(null);
  
  const geometry = useMemo(() => {
      const geo = new THREE.IcosahedronGeometry(2, 2);
      return addBarycentricCoordinates(geo);
  }, []);

  const material = useMemo(() => {
      return MaterialFactory.create('MAT_GLITCH', {
          ...ShaderLib.presets.glitch,
          uniforms: {
              uIntensity: { value: 0.0 },
              uFrequency: { value: 2.0 },
              uSpeed: { value: 1.0 }
          }
      });
  }, []);

  useFrame((state) => {
      if (!meshRef.current) return;
      
      meshRef.current.rotation.y += 0.01;
      meshRef.current.rotation.x = Math.sin(state.clock.elapsedTime * 0.5) * 0.2;

      // Update Local Uniforms
      if (material.uniforms.uIntensity) {
          // Smooth Lerp
          material.uniforms.uIntensity.value = THREE.MathUtils.lerp(
              material.uniforms.uIntensity.value, 
              intensity, 
              0.1
          );
      }
  });

  return (
    <mesh ref={meshRef} geometry={geometry} material={material} />
  );
};


=====================================
FILE: ./src/ui/sim/RenderDirector.tsx
=====================================
import { useEffect, useState } from 'react';
import { RenderRegistry } from '@/ui/sim/registry/RenderRegistry';
import { registerAllRenderers } from '@/ui/sim/registry/RenderCatalog';

let hasRegistered = false;

export const RenderDirector = () => {
  const [renderers, setRenderers] = useState<React.ComponentType[]>([]);

  useEffect(() => {
    if (!hasRegistered) {
      registerAllRenderers();
      hasRegistered = true;
    }
    setRenderers(RenderRegistry.getAll());
  }, []);

  return (
    <>
      {renderers.map((Component, index) => (
        <Component key={index} />
      ))}
    </>
  );
};


=====================================
FILE: ./src/ui/sim/vfx/CameraRig.tsx
=====================================
import { useFrame, useThree } from '@react-three/fiber';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { ShakeSystem } from '@/engine/systems/ShakeSystem';

export const CameraRig = () => {
  const { camera } = useThree();
  
  useFrame(() => {
    try {
        const sys = ServiceLocator.getSystem<ShakeSystem>('ShakeSystem');
        const { x, y, r } = sys.currentOffset;

        // Apply shake offset
        // We use the raw values calculated by ShakeSystem.
        camera.position.x = x;
        camera.position.y = y;
        camera.rotation.z = r;
        
    } catch {
        // System not ready yet
    }
  });

  return null;
};


=====================================
FILE: ./src/ui/sim/vfx/PostProcessing.tsx
=====================================
import { useThree, extend, useFrame } from '@react-three/fiber';
import { Effects } from '@react-three/drei';
import { useRef, useMemo, useEffect } from 'react';
import * as THREE from 'three';
import { RenderPass, UnrealBloomPass, AfterimagePass, ShaderPass } from 'three-stdlib';
import { useStore } from '@/engine/state/global/useStore';

extend({ RenderPass, UnrealBloomPass, AfterimagePass, ShaderPass });

const VignetteShader = {
  uniforms: { "tDiffuse": { value: null }, "offset": { value: 1.0 }, "darkness": { value: 1.0 } },
  vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`,
  fragmentShader: `uniform float offset; uniform float darkness; uniform sampler2D tDiffuse; varying vec2 vUv; void main() { vec4 texel = texture2D( tDiffuse, vUv ); vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset ); gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a ); }`
};

export const EffectsLayer = () => {
  const { graphicsMode } = useStore();
  const { size, scene, camera } = useThree();
  const afterimageRef = useRef<any>(null);
  const bloomRef = useRef<any>(null);
  const resolution = useMemo(() => new THREE.Vector2(size.width, size.height), [size]);

  useEffect(() => { if (bloomRef.current) bloomRef.current.resolution = new THREE.Vector2(size.width, size.height); }, [size]);

  useFrame(() => { if (afterimageRef.current) afterimageRef.current.uniforms["damp"].value = 0.92; });

  if (graphicsMode === 'POTATO') return null;

  return (
    <Effects disableGamma>
      <renderPass args={[scene, camera]} />
      <afterimagePass ref={afterimageRef} />
      <unrealBloomPass ref={bloomRef} args={[resolution, 1.5, 0.4, 0.2]} strength={1.5} radius={0.4} threshold={0.2} />
      <shaderPass args={[VignetteShader]} uniforms-offset-value={0.9} uniforms-darkness-value={0.6} />
    </Effects>
  );
};


=====================================
FILE: ./src/ui/sim/vfx/MatrixGrid.tsx
=====================================
import { Grid } from '@react-three/drei';
import { useFrame } from '@react-three/fiber';
import { useRef, useMemo } from 'react';
import * as THREE from 'three';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { useStore } from '@/engine/state/global/useStore';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { Tag } from '@/engine/ecs/types';
import { RenderData } from '@/engine/ecs/components/RenderData';
import { ComponentType } from '@/engine/ecs/ComponentType';

export const MatrixGrid = () => {
  const groupRef = useRef<THREE.Group>(null);
  const gridRef = useRef<any>(null);

  const colors = useMemo(() => ({
    safe: { section: new THREE.Color("#003300"), cell: new THREE.Color("#044d0f") },
    warning: { section: new THREE.Color("#4d3300"), cell: new THREE.Color("#d48806") },
    critical: { section: new THREE.Color("#4d0000"), cell: new THREE.Color("#ff003c") },
    sandbox: { section: new THREE.Color("#001a33"), cell: new THREE.Color("#00F0FF") }
  }), []);

  const currentSectionColor = useRef(new THREE.Color(colors.safe.section));
  const currentCellColor = useRef(new THREE.Color(colors.safe.cell));
  
  useFrame((state, delta) => {
    let worldEntity;
    try { const registry = ServiceLocator.getRegistry(); for(const w of registry.getByTag(Tag.WORLD)) { worldEntity = w; break; } } catch { return; }

    if (worldEntity && groupRef.current) {
        const render = worldEntity.getComponent<RenderData>(ComponentType.Render);
        if (render) groupRef.current.position.z = render.visualRotation % 5;
    }

    const integrity = useGameStore.getState().systemIntegrity;
    const bootState = useStore.getState().bootState;

    let target = bootState === 'sandbox' ? colors.sandbox : (integrity < 30 ? colors.critical : (integrity < 60 ? colors.warning : colors.safe));
    currentSectionColor.current.lerp(target.section, delta * 3.0);
    currentCellColor.current.lerp(target.cell, delta * 3.0);

    if (gridRef.current && gridRef.current.material) {
        const mat = gridRef.current.material;
        if (mat.uniforms.sectionColor) mat.uniforms.sectionColor.value.copy(currentSectionColor.current);
        if (mat.uniforms.cellColor) mat.uniforms.cellColor.value.copy(currentCellColor.current);
    }
  });

  return (
    <group ref={groupRef} position={[0, -2, 0]}>
      <group position={[0, 0, -10]}>
        <Grid ref={gridRef} renderOrder={-1} infiniteGrid args={[60, 60]} cellSize={1} sectionSize={5} fadeDistance={30} fadeStrength={2.5} sectionColor="#003300" cellColor="#044d0f" sectionThickness={1.2} cellThickness={1.1} />
      </group>
    </group>
  );
};


=====================================
FILE: ./src/ui/sim/hooks/usePanelRegistry.ts
=====================================
import { useEffect, useRef } from 'react';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { IPanelSystem } from '@/engine/interfaces';

export const usePanelRegistry = (id: string) => {
  const elementRef = useRef<HTMLDivElement>(null);
  
  const registerPanel = useGameStore((state) => state.registerPanel);
  const unregisterPanel = useGameStore((state) => state.unregisterPanel);

  useEffect(() => {
    const el = elementRef.current;
    if (!el) return;

    // 1. React State Registration (Immediate)
    registerPanel(id, el);

    // 2. Engine System Registration (With Retry)
    let panelSys: IPanelSystem | undefined;
    let registered = false;
    
    const attemptRegistration = () => {
        if (registered) return;
        try {
            panelSys = ServiceLocator.getSystem<IPanelSystem>('PanelRegistrySystem');
            if (panelSys) {
                panelSys.register(id, el);
                registered = true;
                // Force a refresh immediately
                panelSys.refreshSingle(id);
            }
        } catch (e) {
            // Engine not ready, wait for next attempt
        }
    };

    // Attempt immediately
    attemptRegistration();

    // Poll until registered (needed because Engine boots async relative to React mount)
    const retryInterval = setInterval(() => {
        if (registered) {
            clearInterval(retryInterval);
        } else {
            attemptRegistration();
        }
    }, 100);

    // 3. Resize Observer
    const observer = new ResizeObserver(() => {
        try {
            // Try getting system fresh in case of HMR/Reload
            if (!panelSys) panelSys = ServiceLocator.getSystem<IPanelSystem>('PanelRegistrySystem');
            if (panelSys) panelSys.refreshSingle(id);
        } catch {}
    });
    observer.observe(el);

    return () => {
      clearInterval(retryInterval);
      observer.disconnect();
      unregisterPanel(id);
      try {
          if (panelSys) panelSys.unregister(id);
      } catch {}
    };
  }, [id, registerPanel, unregisterPanel]);

  return elementRef;
};


=====================================
FILE: ./src/ui/sim/hooks/useDeviceType.ts
=====================================
import { useState, useEffect } from 'react';

type DeviceType = 'mobile' | 'tablet' | 'desktop';

export const useDeviceType = () => {
  const [device, setDevice] = useState<DeviceType>('desktop');

  useEffect(() => {
    const checkDevice = () => {
      const width = window.innerWidth;
      
      // Basic width checkpoints
      // < 768px: Usually Phones
      // 768px - 1024px: Tablets / Small Laptops
      // > 1024px: Desktop
      
      if (width < 768) {
        setDevice('mobile');
      } else if (width < 1024) {
        setDevice('tablet');
      } else {
        setDevice('desktop');
      }
    };

    checkDevice();
    window.addEventListener('resize', checkDevice);
    return () => window.removeEventListener('resize', checkDevice);
  }, []);

  return device;
};


=====================================
FILE: ./src/ui/sim/hooks/useWindowFocus.ts
=====================================
import { useEffect } from 'react';
import { useStore } from '@/engine/state/global/useStore';

/**
 * Handles Global Window Focus/Blur events to pause/resume the simulation.
 */
export const useWindowFocus = () => {
  const { bootState, setSimulationPaused } = useStore();

  useEffect(() => {
    // Only attach listeners if the game is actually active
    if (bootState !== 'active') return;

    const handlePause = () => setSimulationPaused(true);
    const handleResume = () => setSimulationPaused(false);
    
    // 1. Visibility API (Tab switching)
    const handleVisibility = () => {
        if (document.hidden) handlePause();
        else handleResume();
    };

    document.addEventListener('visibilitychange', handleVisibility);
    
    // 2. Focus API (Window clicking)
    window.addEventListener('blur', handlePause);
    window.addEventListener('focus', handleResume);
    
    // 3. Mouse leaving viewport (Optional, strict immersion)
    document.addEventListener('mouseleave', handlePause);
    document.addEventListener('mouseenter', handleResume);
    
    return () => {
        document.removeEventListener('visibilitychange', handleVisibility);
        window.removeEventListener('blur', handlePause);
        window.removeEventListener('focus', handleResume);
        document.removeEventListener('mouseleave', handlePause);
        document.removeEventListener('mouseenter', handleResume);
    };
  }, [bootState, setSimulationPaused]);
};


=====================================
FILE: ./src/ui/sim/hooks/useTransientRef.ts
=====================================
import { useCallback } from 'react';
import { TransientDOMService } from '@/engine/services/TransientDOMService';

/**
 * Registers a DOM element to the TransientDOMService via a Callback Ref.
 * This ensures registration happens exactly when the element mounts/unmounts,
 * even if it is conditionally rendered.
 */
export const useTransientRef = (id: string, type: 'text' | 'width' | 'css-var') => {
  const setRef = useCallback((node: HTMLElement | null) => {
    if (node) {
      // Element Mounted
      TransientDOMService.register(id, node, type);
    } else {
      // Element Unmounted
      TransientDOMService.unregister(id);
    }
  }, [id, type]);

  return setRef;
};


=====================================
FILE: ./src/ui/sim/hooks/useMultiTransientRef.ts
=====================================
import { useCallback } from 'react';
import { TransientDOMService } from '@/engine/services/TransientDOMService';

type UpdateType = 'text' | 'width' | 'css-var';

export const useMultiTransientRef = (configs: { id: string, type: UpdateType }[]) => {
  const setRef = useCallback((node: HTMLElement | null) => {
    if (node) {
      configs.forEach(c => TransientDOMService.register(c.id, node, c.type));
    } else {
      configs.forEach(c => TransientDOMService.unregister(c.id));
    }
  }, [configs]); // Configs should be memoized or static

  return setRef;
};


=====================================
FILE: ./src/ui/sim/hooks/useHeartbeat.ts
=====================================
import { useEffect } from 'react';
import { useAnimation, AnimationControls } from 'framer-motion';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';

export const useHeartbeat = (): AnimationControls => {
  const controls = useAnimation();

  useEffect(() => {
    const unsub = GameEventBus.subscribe(GameEvents.HEARTBEAT, (payload) => {
        // We trigger the 'heartbeat' variant defined in the component.
        // We pass the urgency as a 'custom' prop to the variant if needed.
        controls.start("heartbeat");
    });

    return () => unsub();
  }, [controls]);

  return controls;
};


=====================================
FILE: ./src/ui/sim/actors/ParticleActor.tsx
=====================================
import { useRef, useMemo, useLayoutEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { AssetService } from '@/ui/sim/assets/AssetService';
import { ParticleSystem } from '@/engine/systems/ParticleSystem';

const dummy = new THREE.Object3D();
const color = new THREE.Color();
const MAX_PARTICLES = 20000;

// Deterministic random to prevent jittering Z every frame, 
// since we rebuild particles every frame based on index.
const getZDepth = (index: number) => {
    // Hashes index to float between -2.0 and 2.0
    // This distributes particles in volume "around" the z=0 plane.
    const h = (index * 9301 + 49297) % 233280;
    const norm = h / 233280; // 0..1
    return (norm * 4.0) - 2.0; 
};

export const ParticleActor = () => {
  const meshRef = useRef<THREE.InstancedMesh>(null);
  const geometry = useMemo(() => AssetService.get<THREE.BufferGeometry>('GEO_PARTICLE'), []);
  const material = useMemo(() => AssetService.get<THREE.Material>('MAT_PARTICLE'), []);

  useLayoutEffect(() => {
      if (meshRef.current) {
          meshRef.current.geometry.setAttribute('shapeID', new THREE.InstancedBufferAttribute(new Float32Array(MAX_PARTICLES), 1));
      }
  }, []);

  useFrame((state, delta) => {
    if (!meshRef.current) return;
    let sys: ParticleSystem | null = null;
    try { sys = ServiceLocator.getParticleSystem() as ParticleSystem; } catch { return; }

    const count = sys.count;
    if (count === 0) { meshRef.current.count = 0; return; }
    const shapeAttr = meshRef.current.geometry.getAttribute('shapeID') as THREE.InstancedBufferAttribute;

    for (let i = 0; i < count; i++) {
        const x = sys.x[i]; const y = sys.y[i]; const vx = sys.vx[i]; const vy = sys.vy[i];
        const life = sys.life[i]; const maxLife = sys.maxLife[i];
        const baseSize = sys.size[i]; const shape = sys.shape[i];
        
        // Volumetric Z-distribution
        const zDepth = getZDepth(i);
        
        dummy.position.set(x, y, zDepth);
        const speedSq = vx*vx + vy*vy;
        const speed = Math.sqrt(speedSq);
        const lifeScale = life / maxLife;
        
        if (speed > 1.0) {
            const angle = Math.atan2(vy, vx);
            dummy.rotation.set(0, 0, angle);
            const stretchMult = shape === 1 ? 0.3 : 0.2;
            const scaleX = lifeScale * baseSize * (1 + speed * stretchMult);
            const scaleY = lifeScale * baseSize * 0.5;
            dummy.scale.set(scaleX, scaleY, 1);
            const shift = (0.3 * scaleX) * 0.5;
            dummy.position.x += Math.cos(angle) * shift;
            dummy.position.y += Math.sin(angle) * shift;
        } else {
            dummy.rotation.set(0, 0, 0);
            dummy.scale.set(lifeScale * baseSize, lifeScale * baseSize, 1);
        }
        
        dummy.updateMatrix();
        meshRef.current.setMatrixAt(i, dummy.matrix);
        color.setRGB(sys.r[i], sys.g[i], sys.b[i]);
        meshRef.current.setColorAt(i, color);
        shapeAttr.setX(i, shape);
    }

    meshRef.current.count = count;
    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor) meshRef.current.instanceColor.needsUpdate = true;
    shapeAttr.needsUpdate = true;
  });

  return (
    <instancedMesh ref={meshRef} args={[geometry, material, MAX_PARTICLES]} frustumCulled={false} />
  );
};


=====================================
FILE: ./src/ui/sim/actors/PlayerActor.tsx
=====================================
import { useRef, useMemo, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { GAME_THEME } from '@/ui/sim/config/theme';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { Tag } from '@/engine/ecs/types';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { RenderData } from '@/engine/ecs/components/RenderData';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { IInteractionSystem } from '@/engine/interfaces';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { MaterialFactory } from '@/engine/graphics/MaterialFactory';
import { ShaderLib } from '@/engine/graphics/ShaderLib';
import * as THREE from 'three';

const centerGeo = new THREE.CircleGeometry(0.1, 16);
const glowPlaneGeo = new THREE.PlaneGeometry(1, 1);

const createStarRingGeo = () => {
    const points = 4;
    const outerRadius = 0.65;
    const innerRadius = 0.35;
    const indentFactor = 0.60; 
    const twistAngle = 0.55; 
    const shape = new THREE.Shape();
    const step = (Math.PI * 2) / points;
    const halfStep = step / 2;

    for (let i = 0; i < points; i++) {
        const theta = i * step;
        const tipA = theta - twistAngle;
        if (i === 0) shape.moveTo(Math.cos(tipA) * outerRadius, Math.sin(tipA) * outerRadius);
        else shape.lineTo(Math.cos(tipA) * outerRadius, Math.sin(tipA) * outerRadius);
        const rValley = outerRadius * (1.0 - indentFactor);
        shape.lineTo(Math.cos(theta + halfStep) * rValley, Math.sin(theta + halfStep) * rValley);
    }
    const hole = new THREE.Path();
    for (let i = 0; i < points; i++) {
        const theta = i * step;
        const tipA = theta - (twistAngle * 0.5);
        if (i === 0) hole.moveTo(Math.cos(tipA) * innerRadius, Math.sin(tipA) * innerRadius);
        else hole.lineTo(Math.cos(tipA) * innerRadius, Math.sin(tipA) * innerRadius);
        const rValley = innerRadius * (1.0 - indentFactor);
        hole.lineTo(Math.cos(theta + halfStep) * rValley, Math.sin(theta + halfStep) * rValley);
    }
    shape.holes.push(hole);
    return new THREE.ShapeGeometry(shape);
};

const reticleGeo = createStarRingGeo();

const COL_BASE = new THREE.Color(GAME_THEME.turret.base);
const COL_REPAIR = new THREE.Color(GAME_THEME.turret.repair);
const COL_REBOOT = new THREE.Color('#9E4EA5');
const COL_DEAD = new THREE.Color('#FF003C');
const COL_DEAD_DARK = new THREE.Color('#76000C');
const COL_HIT = new THREE.Color('#FF003C'); 
const COL_RETICLE_HEAL = new THREE.Color('#257171');

export const PlayerActor = () => {
  const containerRef = useRef<THREE.Group>(null);
  const centerDotRef = useRef<THREE.Mesh>(null);
  const reticleRef = useRef<THREE.Mesh>(null);
  const backingCircleRef = useRef<THREE.Mesh>(null);
  const ambientGlowRef = useRef<THREE.Mesh>(null);
  const { introDone } = useStore(); 
  const animScale = useRef(0);
  const tempColor = useRef(new THREE.Color(GAME_THEME.turret.base));
  const reticleColor = useRef(new THREE.Color(GAME_THEME.turret.base));
  const currentEnergy = useRef(0.0);
  const hitFlash = useRef(0.0); 

  const ambientMaterial = useMemo(() => {
      const mat = MaterialFactory.create('MAT_PLAYER_AMBIENT', {
          ...ShaderLib.presets.playerAmbient,
          uniforms: { 
              uColor: { value: new THREE.Color(GAME_THEME.turret.glow) }, 
              uOpacity: { value: 0.6 }, 
              uEnergy: { value: 0.0 } 
          }
      });
      mat.blending = THREE.AdditiveBlending;
      return mat;
  }, []);

  const backingMaterial = useMemo(() => {
      const mat = MaterialFactory.create('MAT_PLAYER_BACKING', {
          ...ShaderLib.presets.playerBacking,
          uniforms: { 
              uColor: { value: new THREE.Color(GAME_THEME.turret.glow) }, 
              uOpacity: { value: 0.5 } 
          }
      });
      mat.blending = THREE.NormalBlending;
      return mat;
  }, []);

  useEffect(() => { return GameEventBus.subscribe(GameEvents.PLAYER_HIT, () => { hitFlash.current = 1.0; }); }, []);

  useFrame((state, delta) => {
    if (!containerRef.current) return;
    const targetScale = introDone ? 1 : 0;
    animScale.current = THREE.MathUtils.lerp(animScale.current, targetScale, delta * 2.0);
    if (animScale.current < 0.01) { containerRef.current.visible = false; return; }
    containerRef.current.visible = true;

    if (hitFlash.current > 0) hitFlash.current = Math.max(0, hitFlash.current - delta * 4.0);

    let interactState = 'IDLE';
    try { const interact = ServiceLocator.getSystem<IInteractionSystem>('InteractionSystem'); if (interact) interactState = interact.repairState; } catch {}
    const isActive = (interactState === 'HEALING' || interactState === 'REBOOTING');
    currentEnergy.current = THREE.MathUtils.lerp(currentEnergy.current, isActive ? 1.0 : 0.0, delta * (isActive ? 12.0 : 3.0));
    
    if (ambientMaterial.uniforms.uEnergy) ambientMaterial.uniforms.uEnergy.value = Math.min(1.0, currentEnergy.current + hitFlash.current);

    let playerEntity;
    try { const registry = ServiceLocator.getRegistry(); for(const p of registry.getByTag(Tag.PLAYER)) { playerEntity = p; break; } } catch { return; }
    if (!playerEntity) return;

    const transform = playerEntity.getComponent<TransformData>(ComponentType.Transform);
    const render = playerEntity.getComponent<RenderData>(ComponentType.Render);
    
    // Check BOTH Player Health AND System Integrity
    const isPlayerDead = useGameStore.getState().playerHealth <= 0; 
    const isSystemFailure = useGameStore.getState().systemIntegrity <= 0;
    const isDeadState = isPlayerDead || isSystemFailure;

    if (transform) containerRef.current.position.set(transform.x, transform.y, 0);
    if (render && reticleRef.current && centerDotRef.current && ambientGlowRef.current) {
        if (isDeadState && interactState !== 'REBOOTING') reticleRef.current.rotation.z = Math.PI * 0.25; 
        else reticleRef.current.rotation.z = -render.visualRotation;
        
        let targetColor = isDeadState ? COL_DEAD : (interactState === 'HEALING' ? COL_REPAIR : (interactState === 'REBOOTING' ? COL_REBOOT : COL_BASE));
        tempColor.current.lerp(targetColor, 0.2); 
        
        if (isDeadState) reticleColor.current.lerp(COL_DEAD_DARK, 0.2);
        else if (interactState === 'HEALING') reticleColor.current.lerp(COL_RETICLE_HEAL, 0.1);
        else reticleColor.current.lerp(tempColor.current, 0.2);

        if (hitFlash.current > 0.01) { tempColor.current.lerp(COL_HIT, hitFlash.current); reticleColor.current.lerp(COL_HIT, hitFlash.current); }
        (reticleRef.current.material as THREE.MeshBasicMaterial).color.copy(reticleColor.current);
        (centerDotRef.current.material as THREE.MeshBasicMaterial).color.copy(tempColor.current);
        
        ambientMaterial.uniforms.uColor.value.copy(tempColor.current);
        backingMaterial.uniforms.uColor.value.copy(tempColor.current);
        
        containerRef.current.scale.setScalar(render.visualScale * animScale.current);
        centerDotRef.current.geometry = centerGeo;
        (centerDotRef.current.material as THREE.MeshBasicMaterial).wireframe = isDeadState; 
    }
  });

  return (
    <group ref={containerRef}>
      <mesh ref={centerDotRef} renderOrder={3}><bufferGeometry /><meshBasicMaterial color={GAME_THEME.turret.base} /></mesh>
      <mesh ref={reticleRef} geometry={reticleGeo} rotation={[0, 0, Math.PI / 12]} renderOrder={2}><meshBasicMaterial color={GAME_THEME.turret.base} transparent opacity={0.8} /></mesh>
      <mesh ref={backingCircleRef} material={backingMaterial} geometry={glowPlaneGeo} scale={[1.3, 1.3, 1]} renderOrder={1} />
      <mesh ref={ambientGlowRef} material={ambientMaterial} geometry={glowPlaneGeo} scale={[6, 6, 1]} renderOrder={0} />
    </group>
  );
};


=====================================
FILE: ./src/ui/sim/actors/UniversalActor.tsx
=====================================
import { useMemo } from 'react';
import { InstancedActor } from './InstancedActor';
import { AssetService } from '@/ui/sim/assets/AssetService';
import { ARCHETYPES } from '@/engine/config/Archetypes';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { RenderData } from '@/engine/ecs/components/RenderData';
import { Tag } from '@/engine/ecs/types';
import * as THREE from 'three';

interface RenderGroup {
  key: string;
  geometryId: string;
  materialId: string;
  geometry: THREE.BufferGeometry;
  material: THREE.Material;
}

export const UniversalActor = () => {
  const groups = useMemo(() => {
    const uniqueGroups = new Map<string, RenderGroup>();

    Object.values(ARCHETYPES).forEach(blueprint => {
      // 1. Only process Enemy tags
      if (!blueprint.tags.includes(Tag.ENEMY)) return;

      // 2. Resolve IDs (Check new 'assets' field, then fallback to component data)
      let geometryId = blueprint.assets?.geometry;
      let materialId = blueprint.assets?.material;

      if (!geometryId || !materialId) {
          const renderDef = blueprint.components.find(c => c.type === ComponentType.Render);
          if (renderDef?.data) {
              geometryId = geometryId || renderDef.data.geometryId;
              materialId = materialId || renderDef.data.materialId;
          }
      }

      if (!geometryId || !materialId) return;

      const key = `${geometryId}|${materialId}`;
      if (!uniqueGroups.has(key)) {
        try { 
            uniqueGroups.set(key, { 
                key, 
                geometryId, 
                materialId, 
                geometry: AssetService.get(geometryId), 
                material: AssetService.get(materialId) 
            }); 
        } catch (e) {
            console.warn(`[UniversalActor] Failed to load assets for group: ${key}`, e);
        }
      }
    });

    return Array.from(uniqueGroups.values());
  }, []);

  return (
    <>
      {groups.map(group => (
        <InstancedActor
          key={group.key} 
          tag={Tag.ENEMY} 
          geometry={group.geometry} 
          material={group.material} 
          maxCount={500}
          interactive={true}
          filter={(entity) => { 
              const render = entity.getComponent<RenderData>(ComponentType.Render); 
              return render?.geometryId === group.geometryId && render?.materialId === group.materialId; 
          }}
        />
      ))}
    </>
  );
};


=====================================
FILE: ./src/ui/sim/actors/ProjectileRenderer.tsx
=====================================
import { useRef, useLayoutEffect, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { RenderData } from '@/engine/ecs/components/RenderData';
import { ProjectileData } from '@/engine/ecs/components/ProjectileData';
import { MotionData } from '@/engine/ecs/components/MotionData';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { PROJECTILE_CONFIG, GeometryType } from '@/engine/config/ProjectileConfig';
import { applyRotation } from '@/engine/math/RenderUtils';

const MAX_PER_TYPE = 1000;
const tempObj = new THREE.Object3D();
const tempColor = new THREE.Color();
const neonMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, toneMapped: false });
const STRETCH_FACTOR = 0.08; 
const SQUASH_FACTOR = 0.04;
const MAX_STRETCH = 4.0;

export const ProjectileRenderer = () => {
  const sphereRef = useRef<THREE.InstancedMesh>(null);
  const capsuleRef = useRef<THREE.InstancedMesh>(null);
  const diamondRef = useRef<THREE.InstancedMesh>(null);
  const pyramidRef = useRef<THREE.InstancedMesh>(null);
  const ringRef = useRef<THREE.InstancedMesh>(null);
  const arrowRef = useRef<THREE.InstancedMesh>(null);

  const geos = useMemo(() => ({
      SPHERE: new THREE.IcosahedronGeometry(1, 1),
      CAPSULE: new THREE.CylinderGeometry(0.5, 0.5, 1, 6),
      DIAMOND: new THREE.OctahedronGeometry(1, 0),
      PYRAMID: new THREE.TetrahedronGeometry(1, 0),
      RING: new THREE.TorusGeometry(0.8, 0.2, 4, 8),
      ARROW: new THREE.ConeGeometry(0.5, 1, 4)
  }), []);

  useLayoutEffect(() => {
      [sphereRef, capsuleRef, diamondRef, pyramidRef, ringRef, arrowRef].forEach(ref => {
          if (ref.current) ref.current.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(MAX_PER_TYPE * 3), 3);
      });
  }, []);

  useFrame(() => {
    let registry;
    try { registry = ServiceLocator.getRegistry(); } catch { return; }
    const counts: Record<GeometryType, number> = { SPHERE: 0, CAPSULE: 0, DIAMOND: 0, PYRAMID: 0, RING: 0, ARROW: 0 };
    const refs: Record<GeometryType, THREE.InstancedMesh | null> = { SPHERE: sphereRef.current, CAPSULE: capsuleRef.current, DIAMOND: diamondRef.current, PYRAMID: pyramidRef.current, RING: ringRef.current, ARROW: arrowRef.current };
    const entities = registry.query({ all: [ComponentType.Projectile, ComponentType.Transform] });

    for (const entity of entities) {
        if (!entity.active) continue;
        const t = entity.getComponent<TransformData>(ComponentType.Transform);
        const p = entity.getComponent<ProjectileData>(ComponentType.Projectile);
        const r = entity.getComponent<RenderData>(ComponentType.Render);
        const m = entity.getComponent<MotionData>(ComponentType.Motion);
        if (!t || !p) continue;
        const config = PROJECTILE_CONFIG[p.configId];
        if (!config) continue;

        const mesh = refs[config.geometry];
        const index = counts[config.geometry];
        if (!mesh || index >= MAX_PER_TYPE) continue;

        tempObj.position.set(t.x, t.y, 0);
        applyRotation(tempObj, r ? r.visualRotation : 0, t.rotation);

        let stretchY = 1.0; let squashXZ = 1.0; 
        if (m) {
            const speed = Math.sqrt(m.vx*m.vx + m.vy*m.vy);
            if (speed > 1.0) { stretchY = Math.min(MAX_STRETCH, 1.0 + (speed * STRETCH_FACTOR)); squashXZ = Math.max(0.4, 1.0 - (speed * SQUASH_FACTOR)); }
        }
        const vScale = r?.visualScale || 1.0;
        tempObj.scale.set(config.scale[0] * t.scale * vScale * squashXZ, config.scale[1] * t.scale * vScale * stretchY, config.scale[2] * t.scale * vScale * squashXZ);

        if (r) tempColor.setRGB(r.r, r.g, r.b);
        else tempColor.setRGB(config.color[0], config.color[1], config.color[2]);
        
        tempObj.updateMatrix();
        mesh.setMatrixAt(index, tempObj.matrix);
        mesh.setColorAt(index, tempColor);
        counts[config.geometry]++;
    }

    Object.keys(refs).forEach((k) => {
        const mesh = refs[k as GeometryType];
        if (mesh) { mesh.count = counts[k as GeometryType]; if (mesh.instanceMatrix) mesh.instanceMatrix.needsUpdate = true; if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true; }
    });
  });

  return (
    <>
        <instancedMesh ref={sphereRef} args={[geos.SPHERE, neonMaterial, MAX_PER_TYPE]} renderOrder={5} />
        <instancedMesh ref={capsuleRef} args={[geos.CAPSULE, neonMaterial, MAX_PER_TYPE]} renderOrder={5} />
        <instancedMesh ref={diamondRef} args={[geos.DIAMOND, neonMaterial, MAX_PER_TYPE]} renderOrder={5} />
        <instancedMesh ref={pyramidRef} args={[geos.PYRAMID, neonMaterial, MAX_PER_TYPE]} renderOrder={5} />
        <instancedMesh ref={ringRef} args={[geos.RING, neonMaterial, MAX_PER_TYPE]} renderOrder={5} />
        <instancedMesh ref={arrowRef} args={[geos.ARROW, neonMaterial, MAX_PER_TYPE]} renderOrder={5} />
    </>
  );
};


=====================================
FILE: ./src/ui/sim/actors/DaemonActor.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { Tag } from '@/engine/ecs/types';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { IdentityData } from '@/engine/ecs/components/IdentityData';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { AIStateData } from '@/engine/ecs/components/AIStateData';
import { ComponentType } from '@/engine/ecs/ComponentType';

const MAX_DAEMONS = 5;
const SQUISH_SCALE_Y = 0.4;
const FULL_SCALE_Y = 1.3;
const WIDTH_SCALE = 1.2;
const SPIN_SPEED = 2.0;

export const DaemonActor = () => {
  const groupRef = useRef<THREE.Group>(null);
  const pool = useMemo(() => {
      const items: { root: THREE.Group, cage: THREE.Mesh, orb: THREE.Mesh }[] = [];
      const cageGeo = new THREE.OctahedronGeometry(0.7, 0); 
      const orbGeo = new THREE.IcosahedronGeometry(0.25, 1);
      const cageMat = new THREE.MeshBasicMaterial({ color: '#00F0FF', wireframe: true, transparent: true, opacity: 0.5, toneMapped: false });
      const orbMat = new THREE.MeshBasicMaterial({ color: '#00F0FF', toneMapped: false });

      for(let i=0; i<MAX_DAEMONS; i++) {
          const root = new THREE.Group();
          const cage = new THREE.Mesh(cageGeo, cageMat);
          const orb = new THREE.Mesh(orbGeo, orbMat);
          root.add(cage); root.add(orb);
          root.visible = false;
          items.push({ root, cage, orb });
      }
      return items;
  }, []);

  useFrame((state, delta) => {
      if (!groupRef.current) return;
      const registry = ServiceLocator.getRegistry();
      const entities = Array.from(registry.getByTag(Tag.PLAYER)).filter(e => {
          const id = e.getComponent<IdentityData>(ComponentType.Identity);
          return id?.variant === EnemyTypes.DAEMON && e.active;
      });

      for (let i = 0; i < MAX_DAEMONS; i++) {
          const item = pool[i];
          const entity = entities[i]; 

          if (!entity) { item.root.visible = false; continue; }
          item.root.visible = true;
          
          const transform = entity.getComponent<TransformData>(ComponentType.Transform);
          const ai = entity.getComponent<AIStateData>(ComponentType.State);

          if (transform && ai) {
              item.root.position.set(transform.x, transform.y, 0);
              const charge = ai.data.chargeProgress || 0;
              const currentScaleY = THREE.MathUtils.lerp(SQUISH_SCALE_Y, FULL_SCALE_Y, charge);
              const currentScaleXZ = THREE.MathUtils.lerp(WIDTH_SCALE, 1.0, charge);
              item.cage.scale.set(currentScaleXZ, currentScaleY, currentScaleXZ);
              item.cage.rotation.y += delta * SPIN_SPEED;
              item.cage.rotation.z = Math.sin(state.clock.elapsedTime * 0.5) * 0.1;
              const orbScale = THREE.MathUtils.lerp(0, 1, charge);
              item.orb.scale.setScalar(orbScale);
              if (charge >= 1.0) item.orb.scale.multiplyScalar(1.0 + Math.sin(state.clock.elapsedTime * 10) * 0.1);
          }
      }
  });

  return (
    <group ref={groupRef}>
        {pool.map((item, i) => (
            <primitive key={i} object={item.root} />
        ))}
    </group>
  );
};


=====================================
FILE: ./src/ui/sim/actors/InstancedActor.tsx
=====================================
import { useRef, useLayoutEffect, useMemo } from 'react';
import { useFrame, ThreeEvent } from '@react-three/fiber';
import * as THREE from 'three';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { RenderData } from '@/engine/ecs/components/RenderData';
import { Entity } from '@/engine/ecs/Entity';
import { TransformStore } from '@/engine/ecs/TransformStore';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { applyRotation } from '@/engine/math/RenderUtils';

const tempObj = new THREE.Object3D();
const tempColor = new THREE.Color();
const STRIDE = 4;
const SPAWN_Y_OFFSET = 3.5;

interface InstancedActorProps {
  tag: string;
  geometry: THREE.BufferGeometry;
  material: THREE.Material;
  maxCount: number;
  updateEntity?: (entity: Entity, obj: THREE.Object3D, color: THREE.Color, delta: number) => void;
  filter?: (entity: Entity) => boolean;
  baseColor?: string;
  interactive?: boolean; 
  z?: number;
}

export const InstancedActor = ({ tag, geometry, material, maxCount, updateEntity, filter, baseColor = '#FFFFFF', interactive = false, z = 0 }: InstancedActorProps) => {
  const meshRef = useRef<THREE.InstancedMesh>(null);
  const instanceMap = useMemo(() => new Int32Array(maxCount).fill(-1), [maxCount]);
  const defaultColor = useMemo(() => new THREE.Color(baseColor), [baseColor]);

  useLayoutEffect(() => {
    if (meshRef.current) {
        meshRef.current.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxCount * 3), 3);
        
        meshRef.current.geometry.setAttribute(
            'spawnProgress', 
            new THREE.InstancedBufferAttribute(new Float32Array(maxCount), 1)
        );
    }
  }, [maxCount]);

  useFrame((state, delta) => {
    if (!meshRef.current) return;
    let registry;
    try { registry = ServiceLocator.getRegistry(); } catch { return; }

    const entities = registry.getByTag(tag);
    let count = 0;
    const transformData = TransformStore.data;
    
    const spawnAttr = meshRef.current.geometry.getAttribute('spawnProgress') as THREE.InstancedBufferAttribute;

    for (const entity of entities) {
      if (count >= maxCount) break;
      if (filter && !filter(entity)) continue;

      const transform = entity.getComponent<TransformData>(ComponentType.Transform);
      if (!transform) continue;
      if (interactive) instanceMap[count] = entity.id as number;

      const idx = transform.index * STRIDE;
      const x = transformData[idx];
      const y = transformData[idx + 1];
      const rot = transformData[idx + 2];
      const scale = transformData[idx + 3];

      tempObj.position.set(x, y, z);
      
      const render = entity.getComponent<RenderData>(ComponentType.Render);
      let finalScale = scale;
      let visualRot = 0;
      let spawnVal = 1.0;

      if (render) {
          finalScale *= render.visualScale;
          visualRot = render.visualRotation;
          tempColor.setRGB(render.r, render.g, render.b);
          spawnVal = render.spawnProgress;

          // --- VISUAL OFFSET LOGIC ---
          if (spawnVal < 1.0) {
              const t = spawnVal;
              const ease = 1 - Math.pow(1 - t, 3); 
              const yOffset = -SPAWN_Y_OFFSET * (1.0 - ease);
              tempObj.position.y += yOffset;
          }

          // --- SHUDDER LOGIC ---
          if (render.shudder > 0) {
              const shake = render.shudder * 0.2; 
              tempObj.position.x += (Math.random() - 0.5) * shake;
              tempObj.position.y += (Math.random() - 0.5) * shake;
          }
      } else {
          tempColor.copy(defaultColor);
      }

      applyRotation(tempObj, visualRot, rot);
      tempObj.scale.setScalar(finalScale);

      if (updateEntity) updateEntity(entity, tempObj, tempColor, delta);

      tempObj.updateMatrix();
      meshRef.current.setMatrixAt(count, tempObj.matrix);
      if (meshRef.current.instanceColor) meshRef.current.setColorAt(count, tempColor);
      
      spawnAttr.setX(count, spawnVal);
      
      count++;
    }

    meshRef.current.count = count;
    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor) meshRef.current.instanceColor.needsUpdate = true;
    spawnAttr.needsUpdate = true;
  });

  const handlePointerDown = (e: ThreeEvent<PointerEvent>) => {
      if (!interactive || e.instanceId === undefined) return;
      e.stopPropagation();
      const entityId = instanceMap[e.instanceId];
      if (entityId !== -1) GameEventBus.emit(GameEvents.ENEMY_DAMAGED, { id: entityId, damage: 9999, type: 'TAP' });
  };

  return (
    <instancedMesh 
      ref={meshRef} 
      args={[geometry, material, maxCount]} 
      frustumCulled={false}
      onPointerDown={interactive ? handlePointerDown : undefined}
    />
  );
};


=====================================
FILE: ./src/ui/sim/registry/RenderCatalog.ts
=====================================
import { RenderRegistry } from './RenderRegistry';

// Core Actors (Still specialized)
import { PlayerActor } from '../actors/PlayerActor';
import { ParticleActor } from '../actors/ParticleActor';
import { ProjectileRenderer } from '../actors/ProjectileRenderer';
import { DaemonActor } from '../actors/DaemonActor';

// The New Generic System
import { UniversalActor } from '../actors/UniversalActor';

export const registerAllRenderers = () => {
  // 1. Opaque / Depth-Writing Geometry (Draw First)
  RenderRegistry.register(UniversalActor); // Enemies
  RenderRegistry.register(DaemonActor); 
  
  // 2. Transparent / Additive Geometry (Draw Last)
  RenderRegistry.register(PlayerActor);
  RenderRegistry.register(ProjectileRenderer);
  
  // Particles must be absolutely last to composite correctly over everything
  RenderRegistry.register(ParticleActor);
  
  console.log('[RenderCatalog] Visual Components Registered.');
};


=====================================
FILE: ./src/ui/sim/registry/RenderRegistry.ts
=====================================
import { ComponentType } from 'react';

type RendererComponent = ComponentType<any>;

class RenderRegistryController {
  private renderers = new Set<RendererComponent>();

  public register(component: RendererComponent) {
    this.renderers.add(component);
  }

  public getAll(): RendererComponent[] {
    return Array.from(this.renderers);
  }
}

export const RenderRegistry = new RenderRegistryController();


=====================================
FILE: ./src/ui/sim/GameDirector.tsx
=====================================
import { useFrame, useThree } from '@react-three/fiber';
import { useEffect, useRef, memo } from 'react';
import { GameBootstrapper } from '@/engine/services/GameBootstrapper';
import { GameEngineCore } from '@/engine/services/GameEngine';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { InputSystem } from '@/engine/systems/InputSystem';
import { IPanelSystem } from '@/engine/interfaces';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { useStore } from '@/engine/state/global/useStore';

export const GameDirector = memo(() => {
  const { viewport, size } = useThree();
  const engineRef = useRef<GameEngineCore | null>(null);
  const isMobileRef = useRef(false);
  const initialClickPos = useStore(state => state.initialClickPos);

  useEffect(() => {
    const checkMobile = () => {
        isMobileRef.current = window.matchMedia('(pointer: coarse)').matches || 
                              ('ontouchstart' in window) || 
                              (navigator.maxTouchPoints > 0);
    };
    checkMobile();
    window.addEventListener('resize', checkMobile);

    const engine = GameBootstrapper();
    engineRef.current = engine;
    engine.updateViewport(viewport.width, viewport.height, size.width, size.height);
    
    const refreshInterval = setInterval(() => {
        try {
            const panelSys = ServiceLocator.getSystem<IPanelSystem>('PanelRegistrySystem');
            panelSys.refreshAll();
        } catch {}
    }, 500);

    let initialPolls = 0;
    const fastPoll = setInterval(() => {
        try {
            const panelSys = ServiceLocator.getSystem<IPanelSystem>('PanelRegistrySystem');
            panelSys.refreshAll();
        } catch {}
        initialPolls++;
        if (initialPolls > 20) clearInterval(fastPoll); 
    }, 100);

    return () => {
      window.removeEventListener('resize', checkMobile);
      clearInterval(refreshInterval);
      clearInterval(fastPoll);
      engine.teardown();
      engineRef.current = null;
    };
  }, []); 

  useEffect(() => {
      if (!initialClickPos || isMobileRef.current || !engineRef.current) return;
      try {
          const input = ServiceLocator.getSystem<InputSystem>('InputSystem');
          input.updateBounds(viewport.width, viewport.height);
          const wx = (initialClickPos.x / size.width) * viewport.width - (viewport.width / 2);
          const wy = -((initialClickPos.y / size.height) * viewport.height - (viewport.height / 2));
          input.updateCursor(wx, wy);
      } catch {}
  }, [initialClickPos, viewport, size]);

  useEffect(() => {
    if (engineRef.current) {
      engineRef.current.updateViewport(viewport.width, viewport.height, size.width, size.height);
      try {
        const input = ServiceLocator.getSystem<InputSystem>('InputSystem');
        input.updateBounds(viewport.width, viewport.height);
      } catch {}
    }
  }, [viewport, size]);

  useFrame((state, delta) => {
    if (engineRef.current) {
      try {
          const input = ServiceLocator.getSystem<InputSystem>('InputSystem');
          if (!isMobileRef.current) {
              const x = (state.pointer.x * viewport.width) / 2;
              const y = (state.pointer.y * viewport.height) / 2;
              input.updateCursor(x, y);
          }
          engineRef.current.update(delta, state.clock.elapsedTime);
      } catch (e: any) {
          console.error("Game Loop Critical Failure:", e);
          GameEventBus.emit(GameEvents.LOG_DEBUG, { msg: `CRITICAL LOOP FAIL: ${e.message}`, source: 'GameDirector' });
      }
    }
  });

  return null;
});

GameDirector.displayName = 'GameDirector';


=====================================
FILE: ./src/ui/sim/GameCanvas.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { GameDirector } from './GameDirector';
import { CameraRig } from './vfx/CameraRig';
import { GalleryStage } from './stages/GalleryStage';
import { LabStage } from './stages/LabStage';
import { RenderDirector } from './RenderDirector';
import { VirtualJoystick } from '@/ui/kit/atoms/VirtualJoystick';
import { ActionButton } from '@/ui/kit/atoms/ActionButton';
import { useStore } from '@/engine/state/global/useStore';
import { useEffect, useState, useLayoutEffect } from 'react';
import { registerAllAssets } from '@/ui/sim/assets/AssetCatalog';

export const GameOverlay = () => {
  const { bootState, sandboxView } = useStore();
  const isGallery = bootState === 'sandbox' && sandboxView === 'gallery';
  const isLab = bootState === 'sandbox' && sandboxView === 'lab';
  
  const [isMobile, setIsMobile] = useState(false);
  const [mounted, setMounted] = useState(false);
  const [assetsReady, setAssetsReady] = useState(false);

  useLayoutEffect(() => {
      registerAllAssets();
      setAssetsReady(true);
  }, []);

  useEffect(() => {
      setMounted(true);
      const checkMobile = () => {
        const isCoarse = window.matchMedia('(pointer: coarse)').matches;
        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        setIsMobile(isCoarse || isTouch);
      };
      
      checkMobile();
      window.addEventListener('resize', checkMobile);
      return () => window.removeEventListener('resize', checkMobile);
  }, []);

  if (!mounted || !assetsReady) return null;

  return (
    <>
        <div className="fixed inset-0 z-[60] w-full h-full pointer-events-none overflow-hidden">
          <Canvas
            orthographic={!isGallery && !isLab}
            camera={
                isGallery ? { position: [5, 5, 10], fov: 45 } : 
                isLab ? { position: [0, 0, 10], fov: 50 } :
                { zoom: 40, position: [0, 0, 100] }
            }
            gl={{ 
              alpha: true, 
              antialias: true,
              stencil: false,
              powerPreference: "high-performance"
            }}
            eventSource={document.body}
            eventPrefix="client"
          >
            {isLab ? (
                <LabStage />
            ) : isGallery ? (
                <GalleryStage />
            ) : (
                <>
                    <GameDirector />
                    <CameraRig />
                    <RenderDirector />
                </>
            )}
          </Canvas>
        </div>
        
        {isMobile && !isGallery && !isLab && (
            <>
                <VirtualJoystick />
                <ActionButton />
            </>
        )}
    </>
  );
};


=====================================
FILE: ./src/ui/sim/assets/AssetService.ts
=====================================
import * as THREE from 'three';
import { GeometryKey, MaterialKey } from '@/engine/config/AssetKeys';

export type AssetKey = GeometryKey | MaterialKey | string;

class AssetServiceController {
  private cache = new Map<string, any>();
  private generators = new Map<string, () => any>();
  
  private worker: Worker | null = null;
  private pendingRequests = new Map<string, (data: any) => void>();

  public init() {
    if (typeof window !== 'undefined' && !this.worker) {
        this.worker = new Worker(new URL('../../../engine/handlers/workers/GeometryWorker.ts', import.meta.url));
        this.worker.onmessage = (e) => {
            const { id, success, positions, barycentric } = e.data;
            if (this.pendingRequests.has(id)) {
                this.pendingRequests.get(id)!({ success, positions, barycentric });
                this.pendingRequests.delete(id);
            }
        };
    }
  }

  public registerGenerator(key: AssetKey, generator: () => any) {
    this.generators.set(key, generator);
  }

  public get<T>(key: AssetKey): T {
    if (this.cache.has(key)) {
      return this.cache.get(key) as T;
    }

    const generator = this.generators.get(key);
    if (!generator) {
      throw new Error('[AssetService] No generator registered for asset: ' + key);
    }

    const asset = generator();
    this.cache.set(key, asset);
    return asset as T;
  }

  public generateAsyncGeometry(key: GeometryKey, taskName: string, placeholderGeo: THREE.BufferGeometry) {
    if (this.cache.has(key)) return; 

    this.cache.set(key, placeholderGeo);

    if (!this.worker) this.init();

    if (this.worker) {
        this.worker.postMessage({ id: key, task: taskName });
        
        this.pendingRequests.set(key, (data) => {
            if (data.success) {
                console.log('[AssetService] Worker finished: ' + key);
                
                placeholderGeo.setAttribute('position', new THREE.BufferAttribute(data.positions, 3));
                placeholderGeo.setAttribute('barycentric', new THREE.BufferAttribute(data.barycentric, 3));
                
                placeholderGeo.computeVertexNormals();
                placeholderGeo.computeBoundingSphere();
                
                placeholderGeo.attributes.position.needsUpdate = true;
            }
        });
    }
  }
}

export const AssetService = new AssetServiceController();


=====================================
FILE: ./src/ui/sim/assets/AssetCatalog.ts
=====================================
import * as THREE from 'three';
import { AssetService } from './AssetService';
import { addBarycentricCoordinates } from '@/engine/math/GeometryUtils';
import { MODEL_CONFIG } from '@/engine/config/ModelConfig';
import { MaterialFactory } from '@/engine/graphics/MaterialFactory';
import { ShaderLib } from '@/engine/graphics/ShaderLib';

export const registerAllAssets = () => {
  // --- MATERIALS ---
  
  AssetService.registerGenerator('MAT_ENEMY_BASE', () => {
    return MaterialFactory.create('MAT_ENEMY_BASE', ShaderLib.presets.enemy);
  });

  AssetService.registerGenerator('MAT_PARTICLE', () => {
    const mat = MaterialFactory.create('MAT_PARTICLE', ShaderLib.presets.particle);
    mat.blending = THREE.AdditiveBlending;
    mat.depthWrite = false;
    return mat;
  });

  AssetService.registerGenerator('PLAYER_MAT', () => new THREE.MeshBasicMaterial({ color: 0xffffff }));

  // --- GEOMETRY ---

  // Async Hunter Placeholder
  const hunterPlaceholder = addBarycentricCoordinates(new THREE.ConeGeometry(0.5, 2, 4));
  AssetService.generateAsyncGeometry('GEO_HUNTER', 'GEO_HUNTER', hunterPlaceholder);

  // Procedural Geometries
  AssetService.registerGenerator('GEO_DRILLER', () => addBarycentricCoordinates(new THREE.ConeGeometry(0.5, MODEL_CONFIG.DRILLER.height, MODEL_CONFIG.DRILLER.segments)));
  
  // UPDATED: Now uses MODEL_CONFIG
  AssetService.registerGenerator('GEO_KAMIKAZE', () => addBarycentricCoordinates(new THREE.IcosahedronGeometry(MODEL_CONFIG.KAMIKAZE.radius, 0)));
  
  AssetService.registerGenerator('GEO_DAEMON', () => new THREE.OctahedronGeometry(0.6, 0));
  AssetService.registerGenerator('GEO_PARTICLE', () => new THREE.PlaneGeometry(0.3, 0.3));
  AssetService.registerGenerator('GEO_BULLET', () => new THREE.CylinderGeometry(0.1, 0.1, 1.0, 6));
  AssetService.registerGenerator('PLAYER_GEO', () => new THREE.BoxGeometry(1, 1, 1));
};


=====================================
FILE: ./src/app/layout.tsx
=====================================
import type { Metadata, Viewport } from 'next';
import { Montserrat, JetBrains_Mono } from 'next/font/google';
import '@/styles/globals.css';

const montserrat = Montserrat({ 
  subsets: ['latin'],
  weight: ['400', '700', '900'], 
  variable: '--font-montserrat',
  display: 'swap',
});

const jetbrains = JetBrains_Mono({
  subsets: ['latin'],
  weight: ['400', '700'],
  variable: '--font-jetbrains',
  display: 'swap',
});

export const metadata: Metadata = {
  title: 'MESOELFY // LATENT SPACE BANDIT',
  description: 'The official digital HQ of Mesoelfy. Art, Lore, and Neural Network Injections.',
  openGraph: {
    title: 'MESOELFY_OS',
    description: 'Access the terminal. View the art. Breach the firewall.',
    url: 'https://mesoelfy.github.io',
    siteName: 'MESOELFY',
    images: [
      {
        url: 'https://mesoelfy.github.io/assets/images/social-card.jpg',
        width: 1200,
        height: 630,
      },
    ],
    locale: 'en_US',
    type: 'website',
  },
  twitter: {
    card: 'summary_large_image',
    title: 'MESOELFY // LATENT SPACE BANDIT',
    description: 'Access the terminal. View the art. Breach the firewall.',
    images: ['https://mesoelfy.github.io/assets/images/social-card.jpg'],
  },
};

export const viewport: Viewport = {
  themeColor: '#000000',
  colorScheme: 'dark',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" className={`${montserrat.variable} ${jetbrains.variable}`}>
      <body 
        className="bg-black text-primary-green selection:bg-primary-green selection:text-black font-mono"
        style={{ backgroundColor: '#000000' }} 
      >
        <div className="relative w-full h-full">
          {children}
        </div>
      </body>
    </html>
  );
}


=====================================
FILE: ./src/app/page.tsx
=====================================
'use client';

import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { SceneCanvas } from '@/ui/sim/SceneCanvas';
import { GlassPanel } from '@/ui/kit/atoms/GlassPanel';
import { SocialRow } from '@/ui/kit/molecules/SocialRow';
import { LiveArtGrid } from '@/ui/kit/molecules/LiveArtGrid';
import { HoloCommLog } from '@/ui/kit/molecules/HoloCommLog';
import { IdentityHUD } from '@/ui/kit/molecules/IdentityHUD';
import { Header } from '@/ui/os/desktop/Header';
import { Footer } from '@/ui/os/desktop/Footer';
import { AboutModal } from '@/ui/os/apps/identity/AboutModal';
import { FeedModal } from '@/ui/os/apps/feed/FeedModal';
import { GalleryModal } from '@/ui/os/apps/gallery/GalleryModal';
import { ContactModal } from '@/ui/os/apps/contact/ContactModal';
import { SettingsModal } from '@/ui/os/apps/settings/SettingsModal';
import { MatrixBootSequence } from '@/ui/os/boot/MatrixBootSequence';
import { MobileExperience } from '@/ui/os/apps/mobile/MobileExperience'; 
import { GameOverlay } from '@/ui/sim/GameCanvas';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { CustomCursor } from '@/ui/kit/atoms/CustomCursor';
import { ZenBomb } from '@/ui/kit/atoms/ZenBomb';
import { DebugOverlay } from '@/ui/os/apps/debug/DebugOverlay';
import { SimulationHUD } from '@/ui/os/apps/sandbox/SimulationHUD';
import { WebGLErrorBoundary } from '@/ui/os/overlays/ErrorBoundary';
import { GlobalBackdrop } from '@/ui/os/overlays/GlobalBackdrop'; 
import { MetaManager } from '@/ui/os/system/MetaManager'; 
import { RotationLock } from '@/ui/os/overlays/RotationLock';
import { FeedAccessTerminal } from '@/ui/kit/molecules/FeedAccessTerminal'; 
import { HoloBackground } from '@/ui/os/apps/sandbox/layout/HoloBackground';
import { GameProvider } from '@/engine/state/GameContext';
import { clsx } from 'clsx';

export default function Home() {
  const { 
    openModal, 
    setIntroDone, 
    bootState, 
    setBootState, 
    isBreaching, 
    startBreach, 
    activeModal, 
    isDebugOpen, 
    isDebugMinimized,
    setSimulationPaused,
    sandboxView,
    sessionId 
  } = useStore(); 
  
  const startGame = useGameStore(s => s.startGame);
  const systemIntegrity = useGameStore(s => s.systemIntegrity);
  const isZenMode = useGameStore(s => s.isZenMode);
  
  const isGameOver = systemIntegrity <= 0;
  const isSandbox = bootState === 'sandbox';
  const isMobileLockdown = bootState === 'mobile_lockdown'; 

  const showHoloBackground = isSandbox && (sandboxView === 'lab' || sandboxView === 'audio');

  const [dashboardScale, setDashboardScale] = useState(1);
  const contentRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    let timeoutId: NodeJS.Timeout;

    const handleResize = () => {
        if (!contentRef.current) return;
        if (window.innerWidth >= 1024) {
            const HEADER_H = 48;
            const FOOTER_H = 32;
            const PADDING_Y = 48; 
            const availableHeight = window.innerHeight - HEADER_H - FOOTER_H;
            const naturalHeight = contentRef.current.scrollHeight + PADDING_Y;
            const ratio = Math.min(1, availableHeight / naturalHeight);
            setDashboardScale(Math.floor(ratio * 1000) / 1000);
        } else {
            setDashboardScale(1);
        }
    };

    const debouncedResize = () => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(handleResize, 100);
    };

    handleResize();
    const observer = new ResizeObserver(debouncedResize);
    if (contentRef.current) observer.observe(contentRef.current);
    window.addEventListener('resize', debouncedResize);
    
    return () => {
        window.removeEventListener('resize', debouncedResize);
        observer.disconnect();
        clearTimeout(timeoutId);
    };
  }, [bootState]); 

  useEffect(() => {
    if (bootState !== 'active') return;

    const checkPauseState = () => {
        const isMenuOpen = activeModal !== 'none';
        const isDebugActive = isDebugOpen && !isDebugMinimized;
        const isPortrait = window.matchMedia("(orientation: portrait)").matches;
        const isSmallScreen = window.innerWidth < 768;
        const isRotationLocked = isPortrait && isSmallScreen;

        if (isMenuOpen || isDebugActive || isRotationLocked) {
            setSimulationPaused(true);
        } else {
            setSimulationPaused(false);
        }
    };

    checkPauseState();
    window.addEventListener('resize', checkPauseState);
    return () => window.removeEventListener('resize', checkPauseState);
  }, [bootState, activeModal, isDebugOpen, isDebugMinimized, setSimulationPaused]);

  useEffect(() => {
      AudioSystem.init();
  }, []);

  const handleBreachStart = () => {
    AudioSystem.playSound('initialize_impact');
    startBreach();
  };

  const handleBootComplete = () => {
    setTimeout(() => {
      setBootState('active');
      setIntroDone(true);
      AudioSystem.startMusic(); 
      startGame();
    }, 200);
  };

  const isSceneVisible = bootState !== 'standby' || isBreaching;

  return (
    <GameProvider>
      <div id="global-app-root" className="relative w-full h-screen overflow-hidden cursor-none bg-black">
        
        <MetaManager />
        {!isMobileLockdown && <RotationLock />}
        <CustomCursor />
        <GlobalBackdrop />
        <DebugOverlay />

        <main className="relative w-full h-full flex flex-col overflow-hidden text-primary-green selection:bg-primary-green selection:text-black font-mono">
          
          {/* --- SANDBOX BACKGROUND LAYER (Z-50) --- */}
          <AnimatePresence>
              {showHoloBackground && (
                  <motion.div
                      initial={{ opacity: 0 }}
                      animate={{ opacity: 1 }}
                      exit={{ opacity: 0 }}
                      transition={{ duration: 0.5 }}
                  >
                      <HoloBackground />
                  </motion.div>
              )}
          </AnimatePresence>

          <WebGLErrorBoundary key={sessionId}>
              <SceneCanvas className={clsx("blur-0 transition-opacity duration-[2000ms]", isSceneVisible ? "opacity-100" : "opacity-0")} />
              
              {!isMobileLockdown && (
                  <div className={clsx("absolute inset-0 z-[60] transition-opacity duration-[2000ms] pointer-events-none", isSceneVisible ? "opacity-100" : "opacity-0")}>
                      <GameOverlay />
                  </div>
              )}
          </WebGLErrorBoundary>

          {isSandbox && <SimulationHUD />}

          {!isSandbox && !isMobileLockdown && (
              <>
                  <AboutModal />
                  <FeedModal />
                  <GalleryModal />
                  <ContactModal />
                  <SettingsModal />
                  <ZenBomb />
              </>
          )}

          {bootState === 'standby' && (
            <MatrixBootSequence 
               onComplete={handleBootComplete} 
               onBreachStart={handleBreachStart} 
            />
          )}

          {isMobileLockdown && <MobileExperience />}

          {!isSandbox && !isMobileLockdown && (
              <div className={`relative z-10 flex-1 flex flex-col h-full transition-all duration-1000 ease-in-out ${bootState === 'active' ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-4'}`}>
                <Header />

                <div className="flex-1 min-h-0 relative w-full overflow-hidden">
                  <div 
                      className="w-full origin-top transition-transform duration-300 ease-out"
                      style={{ 
                          transform: `scale(${dashboardScale})`,
                          marginBottom: `-${(1 - dashboardScale) * 100}%` 
                      }}
                  >
                      <div ref={contentRef} className="w-full max-w-[1600px] mx-auto p-4 md:p-6">
                      <AnimatePresence>
                          {!isZenMode && (
                          <motion.div 
                              className="grid grid-cols-1 md:grid-cols-12 gap-4 md:gap-6 w-full pb-8"
                              initial="hidden"
                              animate="visible"
                              exit={{ opacity: 0, scale: 0.95, transition: { duration: 0.5 } }}
                              variants={{
                              hidden: { opacity: 0 },
                              visible: { 
                                  opacity: 1, 
                                  transition: { 
                                  staggerChildren: 0.05,
                                  delayChildren: 0.0
                                  } 
                              }
                              }}
                          >
                              <div className="md:col-span-4 flex flex-col gap-4 md:gap-6 h-auto">
                              <GlassPanel title="IDENTITY_CORE" className="h-auto min-h-[400px]" gameId="identity">
                                  <IdentityHUD />
                              </GlassPanel>

                              <GlassPanel title="SOCIAL_UPLINK" className="h-52 shrink-0" gameId="social">
                                  <SocialRow />
                              </GlassPanel>
                              </div>

                              <div className="md:col-span-8 flex flex-col gap-4 md:gap-6 h-auto">
                              <GlassPanel title="LATEST_LOGS" className="h-[30vh] min-h-[150px] shrink-0" gameId="feed">
                                  <FeedAccessTerminal />
                              </GlassPanel>

                              <div className="flex flex-col md:flex-row gap-4 md:gap-6 items-start w-full">
                                  <GlassPanel title="ART_DB" className="flex-1 h-auto" gameId="art">
                                  <LiveArtGrid />
                                  </GlassPanel>

                                  <GlassPanel title="HOLO_COMM" className="w-full md:w-[45%] shrink-0 h-auto" gameId="video">
                                  <HoloCommLog />
                                  </GlassPanel>
                              </div>
                              </div>
                          </motion.div>
                          )}
                      </AnimatePresence>
                      </div>
                  </div>
                </div>
                
                <Footer />
              </div>
          )}
        </main>
      </div>
    </GameProvider>
  );
}


=====================================
FILE: ./src/styles/globals.css
=====================================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 255, 65;
  --shake-x: 0px;
  --shake-y: 0px;
  --shake-r: 0rad;
}

html, body {
  background-color: #000000;
  overscroll-behavior: none; 
  touch-action: none; 
  cursor: none !important;
}

* {
  cursor: none !important;
}

body {
  color: #78F654;
  overflow: hidden; 
  font-family: 'Courier New', monospace;
  height: 100dvh; 
  width: 100vw;
}

#global-app-root {
  height: 100dvh;
  transform: translate3d(var(--shake-x), var(--shake-y), 0) rotate(var(--shake-r));
  will-change: transform; 
}

::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #050505; 
  border-left: 1px solid #15530A;
}

::-webkit-scrollbar-thumb {
  background: #0BD426; 
  border: 1px solid #000;
  border-radius: 2px;
}

::-webkit-scrollbar-thumb:hover {
  background: #78F654;
}

.glitch-text {
  text-shadow: 2px 0 #ff003c, -2px 0 #008f11;
}

.clip-corner-btn {
  clip-path: polygon(0 0, 100% 0, 100% 70%, 90% 100%, 0 100%);
}

@keyframes marching {
  0% { background-position: 0 0, 0 100%, 0 0, 100% 0; }
  100% { background-position: 20px 0, -20px 100%, 0 -20px, 100% 20px; }
}

.marching-ants {
  background-image: 
    linear-gradient(to right, var(--ant-color) 50%, transparent 50%),
    linear-gradient(to right, var(--ant-color) 50%, transparent 50%),
    linear-gradient(to bottom, var(--ant-color) 50%, transparent 50%),
    linear-gradient(to bottom, var(--ant-color) 50%, transparent 50%);
  background-size: 20px 1px, 20px 1px, 1px 20px, 1px 20px;
  background-repeat: repeat-x, repeat-x, repeat-y, repeat-y;
  animation: marching 1s linear infinite;
  border: none !important; 
}

body > div[data-nextjs-toast],
body > div[data-nextjs-dialog-overlay],
#next-route-announcer,
[class*="nextjs-toast"],
[class*="build-activity"],
[class*="static-route-indicator"] {
  display: none !important;
  opacity: 0 !important;
  pointer-events: none !important;
  visibility: hidden !important;
}


=====================================
FILE: ./src/engine/types/game.types.ts
=====================================
export interface RegisteredPanel {
  id: string;
  element: HTMLElement;
  health: number;
  isDestroyed: boolean;
}

export type UpgradeOption = 
  | 'OVERCLOCK'      // Attack Speed
  | 'EXECUTE'        // Damage
  | 'FORK'           // Multishot
  | 'SNIFFER'        // Homing
  | 'BACKDOOR'       // Rear Guard
  | 'DAEMON'         // Summon Ally
  | 'REPAIR_NANITES' // Heal
  | 'RESTORE'        // System Op
  | 'PURGE';         // System Op

export interface GameState {
  isPlaying: boolean;
  score: number;
  threatLevel: number;
  panels: Record<string, RegisteredPanel>;
  
  startGame: () => void;
  stopGame: () => void;
  registerPanel: (id: string, element: HTMLElement) => void;
  unregisterPanel: (id: string) => void;
  damagePanel: (id: string, amount: number) => void;
  healPanel: (id: string, amount: number) => void;
}

export interface Entity {
  id: number;
  x: number;
  y: number;
  radius: number;
  active: boolean;
  spawnTime: number; 
}


=====================================
FILE: ./src/engine/config/AIConfig.ts
=====================================
export const AI_CONFIG = {
  HUNTER: {
    ORBIT_SPEED: 0.5,
    TARGET_RADIUS: 10.0,
    AIM_LERP: 0.05,
    CHARGE_LERP: 0.15,
    SPIN_SPEED_IDLE: 2.0,
    SPIN_SPEED_CHARGE: -8.0,
    PROJECTILE_SPEED: 25,
    OFFSET_DIST: 1.6,
    RECOIL_FORCE: 2.0
  },
  KAMIKAZE: {
    ROTATION_SPEED: 10.0,
    ENGAGEMENT_DIST: 0.1
  },
  DRILLER: {
    SNAP_THRESHOLD: 0.1,
    TIP_OFFSET: 0.4, // Based on Model Height
    AUDIO_INTERVAL: 0.25
  },
  DAEMON: {
    SHIELD_CHARGE_TIME: 2.0,
    COOLDOWN_TIME: 0.5,
    RECOVERY_TIME: 2.0,
    ORBIT_RADIUS: 4.0,
    ORBIT_SPEED_MIN: 1.5,
    ROTATION_SPEED: {
      CHARGING: 15.0,
      READY: 3.0,
      FIRE: 20.0,
      COOLDOWN: -5.0,
      BROKEN: 30.0
    }
  }
};


=====================================
FILE: ./src/engine/config/ProjectileConfig.ts
=====================================
import { PALETTE } from './Palette';

export const ProjectileGeometry = {
  SPHERE: 'SPHERE',
  CAPSULE: 'CAPSULE',
  DIAMOND: 'DIAMOND',
  PYRAMID: 'PYRAMID',
  RING: 'RING',
  ARROW: 'ARROW'
} as const;

export type GeometryType = keyof typeof ProjectileGeometry;

export interface ProjectileDef {
  geometry: GeometryType;
  color: [number, number, number];
  scale: [number, number, number];
  spinSpeed: number;  
  pulseSpeed: number; 
  faceVelocity: boolean; 
}

const neon = (hex: string, intensity: number): [number, number, number] => {
  const c = parseInt(hex.replace('#', ''), 16);
  const r = ((c >> 16) & 255) / 255;
  const g = ((c >> 8) & 255) / 255;
  const b = (c & 255) / 255;
  return [r * intensity, g * intensity, b * intensity];
};

export const PROJECTILE_CONFIG: Record<string, ProjectileDef> = {
  'PLAYER_STANDARD': {
    geometry: 'CAPSULE',
    color: neon(PALETTE.GREEN.PRIMARY, 4.0),
    scale: [0.15, 0.6, 0.15],
    spinSpeed: 0, pulseSpeed: 0, faceVelocity: true
  },
  'PLAYER_FORK': {
    geometry: 'PYRAMID',
    color: neon(PALETTE.YELLOW.SOFT, 3.0),
    scale: [0.4, 0.4, 0.4],
    spinSpeed: 5.0, pulseSpeed: 0, faceVelocity: true
  },
  'PLAYER_SNIFFER': {
    geometry: 'DIAMOND',
    color: neon(PALETTE.CYAN.PRIMARY, 5.0),
    scale: [0.3, 0.3, 0.3],
    spinSpeed: 15.0, pulseSpeed: 0, faceVelocity: false
  },
  'PLAYER_BACKDOOR': {
    geometry: 'RING',
    color: neon(PALETTE.RED.LIGHT, 3.0),
    scale: [0.4, 0.4, 0.4],
    spinSpeed: -2.0, pulseSpeed: 2.0, faceVelocity: false
  },
  'PLAYER_PURGE': {
    geometry: 'DIAMOND',
    color: [10, 10, 10],
    scale: [0.6, 0.6, 0.6],
    spinSpeed: 20.0, pulseSpeed: 0, faceVelocity: false
  },
  'ENEMY_HUNTER': {
    geometry: 'ARROW',
    color: neon(PALETTE.YELLOW.ORANGE, 6.0),
    scale: [0.3, 1.0, 0.3],
    spinSpeed: 0, pulseSpeed: 0, faceVelocity: true
  },
  'DAEMON_ORB': {
    geometry: 'SPHERE',
    color: neon('#0088FF', 5.0), 
    scale: [0.5, 0.5, 0.5],
    spinSpeed: 1.0, pulseSpeed: 4.0, faceVelocity: false
  }
};


=====================================
FILE: ./src/engine/config/ModelConfig.ts
=====================================
export const MODEL_CONFIG = {
  DRILLER: {
    height: 0.64, // Reduced by 20% (was 0.8)
    radius: 0.24, // Reduced by 20% (was 0.3)
    segments: 4
  },
  KAMIKAZE: {
    radius: 0.69, // Increased by 15% (was 0.6)
    detail: 0
  },
  HUNTER: {
    scale: 2.1
  }
};


=====================================
FILE: ./src/engine/config/PlayerConfig.ts
=====================================
export const PLAYER_CONFIG = {
  maxHealth: 20,       // Was 100
  fireRate: 0.15, 
  bulletSpeed: 45,
  bulletRadius: 0.2,
  bulletLife: 1.5,
  
  // Scoring & Progression (FASTER LEVELING)
  scoreMultiplier: 1,
  baseXpRequirement: 20, // Was 100. First level up is quick.
  xpScalingFactor: 1.2,  // Was 1.5. Curve is much flatter now.
};


=====================================
FILE: ./src/engine/config/VFXConfig.ts
=====================================
import { COLOR_SETS } from './Palette';

export type VFXPattern = 'RADIAL' | 'DIRECTIONAL';

export interface VFXRecipe {
  pattern: VFXPattern;
  colors: string[];
  count: [number, number];
  speed: [number, number];
  life: [number, number];
  spread?: number;
  size?: [number, number];
  shape?: number; 
  omniChance?: number; 
}

// --- FACTORY ---
const createExplosion = (
    colors: string[], 
    isDirectional: boolean,
    counts: [number, number],
    speeds: [number, number]
): VFXRecipe => {
  if (isDirectional) {
    return {
      pattern: 'DIRECTIONAL',
      colors: colors,
      count: counts,
      speed: speeds,
      life: [0.5, 0.9],
      spread: 1.6,
      omniChance: 0.15
    };
  }
  return {
    pattern: 'RADIAL',
    colors: colors,
    count: [Math.floor(counts[0] * 0.75), Math.floor(counts[1] * 0.75)],
    speed: speeds,
    life: [0.4, 0.8]
  };
};

// --- RECIPES ---
export const VFX_RECIPES: Record<string, VFXRecipe> = {
  // Driller: Medium Count, Medium Speed
  'EXPLOSION_PURPLE':     createExplosion(COLOR_SETS.PURPLE, false, [20, 30], [5, 10]),
  'EXPLOSION_PURPLE_DIR': createExplosion(COLOR_SETS.PURPLE, true,  [20, 30], [5, 10]),
  
  // Hunter: Lower Count, Higher Speed (Snappy)
  'EXPLOSION_YELLOW':     createExplosion(COLOR_SETS.YELLOW, false, [15, 25], [10, 18]),
  'EXPLOSION_YELLOW_DIR': createExplosion(COLOR_SETS.YELLOW, true,  [15, 25], [10, 18]),
  
  // Kamikaze: Max Count, Max Speed (Violent)
  'EXPLOSION_RED':        createExplosion(COLOR_SETS.RED, false, [20, 35], [12, 22]),
  'EXPLOSION_RED_DIR':    createExplosion(COLOR_SETS.RED, true,  [20, 35], [12, 22]),

  // Custom / Unique FX
  'IMPACT_WHITE': { pattern: 'RADIAL', colors: COLOR_SETS.WHITE, count: [3, 5], speed: [2, 5], life: [0.1, 0.2] },
  'IMPACT_RED':   { pattern: 'RADIAL', colors: COLOR_SETS.RED, count: [4, 7], speed: [3, 8], life: [0.2, 0.4] },
  'CLASH_YELLOW': { pattern: 'RADIAL', colors: COLOR_SETS.YELLOW, count: [5, 8], speed: [5, 10], life: [0.2, 0.4] },
  
  'DRILL_SPARKS':  { 
      pattern: 'DIRECTIONAL', 
      colors: COLOR_SETS.PURPLE, 
      count: [3, 6], 
      speed: [10, 10], 
      life: [0.1, 0.2], // Reduced by 50% (Was 0.2, 0.4)
      spread: 0.7, 
      size: [0.5, 0.5],
      shape: 1 
  },
  
  'HUNTER_RECOIL': { pattern: 'DIRECTIONAL', colors: COLOR_SETS.YELLOW, count: [8, 12], speed: [10, 18], life: [0.3, 0.6], spread: 0.5 },
  
  'ENGINE_FLARE': { 
    pattern: 'DIRECTIONAL', 
    colors: [COLOR_SETS.YELLOW[0], COLOR_SETS.WHITE[0]], 
    count: [3, 5], 
    speed: [15, 25], 
    life: [0.1, 0.2], 
    spread: 0.05 
  },
  
  'REBOOT_HEAL': { pattern: 'RADIAL', colors: COLOR_SETS.CYAN, count: [8, 12], speed: [2, 5], life: [0.5, 1.0] },
  'PURGE_BLAST': { pattern: 'RADIAL', colors: ['#FFFFFF', '#FF003C'], count: [50, 50], speed: [10, 30], life: [1.5, 2.5] }
};


=====================================
FILE: ./src/engine/config/TextAssets.ts
=====================================
// Used for the 3D Intro UI (Block Style)
export const ASCII_TITLE = `
 â–ˆâ–ˆâ–ˆâ–„ â–„â–ˆâ–ˆâ–ˆâ–“â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–“      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–“â–ˆâ–ˆ   â–ˆâ–ˆâ–“
â–“â–ˆâ–ˆâ–’â–€â–ˆâ–€ â–ˆâ–ˆâ–’â–“â–ˆ   â–€â–’â–ˆâ–ˆ    â–’ â–’â–ˆâ–ˆâ–’  â–ˆâ–ˆâ–’â–“â–ˆ   â–€ â–“â–ˆâ–ˆâ–’    â–’â–“â–ˆ   â–’  â–’â–ˆâ–ˆ  â–ˆâ–ˆâ–’
â–“â–ˆâ–ˆ    â–“â–ˆâ–ˆâ–‘â–’â–ˆâ–ˆâ–ˆ  â–‘ â–“â–ˆâ–ˆâ–„   â–’â–ˆâ–ˆâ–‘  â–ˆâ–ˆâ–’â–’â–ˆâ–ˆâ–ˆ   â–’â–ˆâ–ˆâ–‘    â–’â–“â–ˆâ–ˆâ–ˆ â–‘   â–’â–ˆâ–ˆ â–ˆâ–ˆâ–‘
â–’â–ˆâ–ˆ    â–’â–ˆâ–ˆ â–’â–“â–ˆ  â–„  â–’   â–ˆâ–ˆâ–’â–’â–ˆâ–ˆ   â–ˆâ–ˆâ–‘â–’â–“â–ˆ  â–„ â–’â–ˆâ–ˆâ–‘    â–‘â–“â–ˆâ–’  â–‘   â–‘ â–â–ˆâ–ˆâ–‘â–‘
â–’â–ˆâ–ˆâ–’   â–‘â–ˆâ–ˆâ–’â–‘â–’â–ˆâ–ˆâ–ˆâ–ˆâ–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–‘ â–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–ˆâ–ˆâ–ˆâ–ˆâ–’â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–‘â–’â–ˆâ–‘      â–‘ â–ˆâ–ˆâ–’â–‘â–‘
â–‘ â–’â–‘   â–‘  â–‘â–‘â–‘ â–’â–‘ â–‘ â–’â–‘â–’  â–‘ â–‘ â–’â–‘â–’â–‘â–’â–‘ â–‘â–‘ â–’â–‘ â–‘â–‘ â–’â–‘â–’  â–‘ â–’ â–‘       â–ˆâ–ˆâ–’â–’â–’
â–‘  â–‘      â–‘ â–‘ â–‘  â–‘ â–‘ â–’  â–‘   â–‘ â–’ â–’â–‘  â–‘ â–‘  â–‘â–‘ â–‘ â–’  â–‘ â–‘       â–“â–ˆâ–ˆ â–‘â–’â–‘ 
â–‘      â–‘      â–‘    â–‘ â–‘    â–‘ â–‘ â–‘ â–’     â–‘     â–‘ â–‘    â–‘ â–‘     â–’ â–’ â–‘â–‘  
       â–‘      â–‘  â–‘   â–‘  â–‘     â–‘ â–‘     â–‘  â–‘    â–‘  â–‘         â–‘ â–‘     
`;

// Stylized Header for Console
export const ASCII_CONSOLE = `
   __  __  ____  ____  ____  ____  __    ____  _  _ 
  (  \\/  )(  __)/ ___)/  _ \\(  __)(  )  (  __)( \\/ )
   )    (  ) _) \\___ \\  (_) )) _) / (_/\\ ) _)  \\  / 
  (_/\\/\\_)(____)(____/\\____/(____)\\____/(_)    (__) 
`;

const BASE_STYLE = 'font-family: "Courier New", monospace; font-weight: bold; font-size: 10px; line-height: 12px;';

export const CONSOLE_STYLES = {
  GREEN:  `${BASE_STYLE} color: #78F654; background: #050505;`,
  PURPLE: `${BASE_STYLE} color: #9E4EA5; background: #050505;`,
  CYAN:   `${BASE_STYLE} color: #00F0FF; background: #050505;`,
  TAG:    `font-family: monospace; font-size: 9px; background: #9E4EA5; color: #000; padding: 2px 4px; border-radius: 2px; font-weight: bold;`,
  STATUS: `font-family: monospace; font-size: 9px; background: #78F654; color: #000; padding: 2px 4px; border-radius: 2px; font-weight: bold;`
};


=====================================
FILE: ./src/engine/config/Palette.ts
=====================================
export const PALETTE = {
  // Core Identity
  GREEN: {
    PRIMARY: '#78F654',
    DIM: '#1bb930',
    DARK: '#217e10',
    GLOW: '#C2FE9A'
  },
  PURPLE: {
    PRIMARY: '#9E4EA5',
    LIGHT: '#BC86BA',
    DEEP: '#350E3A',
    DIM: '#822B8A'
  },
  RED: {
    CRITICAL: '#FF003C',
    DIM: '#800010',
    LIGHT: '#FF4D6D'
  },
  YELLOW: {
    ALERT: '#eae747',
    SOFT: '#F7D277',
    ORANGE: '#FF8C00'
  },
  CYAN: {
    PRIMARY: '#00F0FF',
    DIM: '#008ba3'
  },
  MONO: {
    BLACK: '#050505',
    WHITE: '#FFFFFF',
    GRAY: '#27282A'
  }
} as const;

// Collections for Procedural Generation
export const COLOR_SETS = {
  PURPLE: [PALETTE.PURPLE.PRIMARY, '#D0A3D8', '#E0B0FF', '#7A2F8F', '#B57EDC'],
  YELLOW: [PALETTE.YELLOW.SOFT, '#FFE5A0', '#FFA500', PALETTE.MONO.WHITE],
  RED:    [PALETTE.RED.CRITICAL, PALETTE.RED.LIGHT, PALETTE.RED.DIM],
  CYAN:   [PALETTE.CYAN.PRIMARY, PALETTE.CYAN.DIM, PALETTE.MONO.WHITE],
  WHITE:  [PALETTE.MONO.WHITE]
};


=====================================
FILE: ./src/engine/config/SoundMetadata.ts
=====================================
import { AUDIO_CONFIG } from './AudioConfig';

export type SoundCategory = 'UI' | 'COMBAT' | 'AMBIENCE' | 'UNUSED';

export interface SoundMeta {
  key: string;
  label: string;
  description: string;
  category: SoundCategory;
  usage: string;
}

export const SOUND_METADATA: Record<string, SoundMeta> = {
  'ui_click': { key: 'ui_click', label: 'Click', description: 'Standard interaction', category: 'UI', usage: 'Buttons, Toggles' },
  'ui_hover': { key: 'ui_hover', label: 'Hover', description: 'High frequency blip', category: 'UI', usage: 'Pointer over interactive elements' },
  'ui_menu_open': { key: 'ui_menu_open', label: 'Menu Open', description: 'Ascending slide', category: 'UI', usage: 'Modal/Debug open' },
  'ui_menu_close': { key: 'ui_menu_close', label: 'Menu Close', description: 'Descending slide', category: 'UI', usage: 'Modal/Debug close' },
  'ui_optimal': { key: 'ui_optimal', label: 'Optimal', description: 'Positive chime', category: 'UI', usage: 'Settings: High Quality, Health Full' },
  'ui_error': { key: 'ui_error', label: 'Error', description: 'Negative buzz', category: 'UI', usage: 'Settings: Potato, Mobile Rejection' },
  'ui_chirp': { key: 'ui_chirp', label: 'Chirp', description: 'Data process sound', category: 'UI', usage: 'Mobile Scan Step' },

  'fx_player_fire': { key: 'fx_player_fire', label: 'Plasma Shot', description: 'Player primary fire', category: 'COMBAT', usage: 'PlayerSystem: Auto-fire' },
  'fx_enemy_fire': { key: 'fx_enemy_fire', label: 'Enemy Shot', description: 'Enemy return fire', category: 'COMBAT', usage: 'Unused (Enemies currently silent on fire)' },
  'fx_impact_light': { key: 'fx_impact_light', label: 'Light Hit', description: 'Small explosion', category: 'COMBAT', usage: 'Enemy death (Small), Mobile Tap Kill' },
  'fx_impact_heavy': { key: 'fx_impact_heavy', label: 'Heavy Hit', description: 'Large explosion', category: 'COMBAT', usage: 'Player Hit, Panel Destroyed, Kamikaze Death' },
  'fx_boot_sequence': { key: 'fx_boot_sequence', label: 'Boot Up', description: 'Heavy startup thrum', category: 'AMBIENCE', usage: 'Intro Sequence Start' },
  'fx_player_death': { key: 'fx_player_death', label: 'Flatline', description: 'System failure noise', category: 'COMBAT', usage: 'GameState: Player Health <= 0' },
  'fx_level_up': { key: 'fx_level_up', label: 'Level Up', description: 'Ascending chord', category: 'COMBAT', usage: 'Upgrade Menu Open' },
  'fx_reboot_success': { key: 'fx_reboot_success', label: 'Reboot', description: 'System restore chime', category: 'COMBAT', usage: 'Player/Panel Revival' },
  'fx_teleport': { key: 'fx_teleport', label: 'Teleport', description: 'Phase shift', category: 'COMBAT', usage: 'Unused' },
  
  'fx_exhaust_sizzle': { key: 'fx_exhaust_sizzle', label: 'Sizzle', description: 'Burning fuse', category: 'COMBAT', usage: 'Hunter: Exhaust trail' },

  'loop_heal': { key: 'loop_heal', label: 'Repair Loop', description: 'Healing hum', category: 'AMBIENCE', usage: 'InteractionSystem: Healing Panel' },
  'loop_reboot': { key: 'loop_reboot', label: 'Reboot Loop', description: 'Power build-up', category: 'AMBIENCE', usage: 'InteractionSystem: Rebooting Panel' },
  'loop_warning': { key: 'loop_warning', label: 'Low Health', description: 'Heartbeat alarm', category: 'AMBIENCE', usage: 'GameState: Health < 30%' },
  'loop_drill': { key: 'loop_drill', label: 'Drill Grind', description: 'Mechanical grinding', category: 'COMBAT', usage: 'DrillerLogic: Contact with Panel' },
  'ambience_core': { key: 'ambience_core', label: 'Core Hum', description: 'Background Brown Noise', category: 'AMBIENCE', usage: 'Global Background Track' },

  'syn_fm_scream': { key: 'syn_fm_scream', label: 'FM Scream', description: 'Aggressive mod', category: 'UNUSED', usage: 'Prototype' },
  'syn_data_burst': { key: 'syn_data_burst', label: 'Data Burst', description: 'Square wave packet', category: 'UNUSED', usage: 'Prototype' },
  'syn_bass_drop': { key: 'syn_bass_drop', label: 'Bass Drop', description: 'Sub frequency dive', category: 'UNUSED', usage: 'Prototype' },
  'syn_alarm_chirp': { key: 'syn_alarm_chirp', label: 'Alarm Chirp', description: 'High pitch alert', category: 'UNUSED', usage: 'Prototype' },
  'syn_static_burst': { key: 'syn_static_burst', label: 'Static', description: 'White noise burst', category: 'UNUSED', usage: 'Prototype' },
  'syn_wobble_bass': { key: 'syn_wobble_bass', label: 'Wobble', description: 'LFO Bass', category: 'UNUSED', usage: 'Prototype' },
  'syn_grind_loop': { key: 'syn_grind_loop', label: 'Grind Loop', description: 'Industrial texture', category: 'UNUSED', usage: 'Prototype' },
  'syn_insect_swarm': { key: 'syn_insect_swarm', label: 'Swarm', description: 'High freq jitter', category: 'UNUSED', usage: 'Prototype' },
  'syn_interference': { key: 'syn_interference', label: 'Interference', description: 'Radio static', category: 'UNUSED', usage: 'Prototype' },
  'syn_wind_howl': { key: 'syn_wind_howl', label: 'Wind', description: 'Filtered noise', category: 'UNUSED', usage: 'Prototype' },
  'syn_robot_chatter': { key: 'syn_robot_chatter', label: 'Bot Chatter', description: 'S&H Randomness', category: 'UNUSED', usage: 'Prototype' },
  'syn_deep_hum': { key: 'syn_deep_hum', label: 'Deep Hum', description: 'Low rumble', category: 'UNUSED', usage: 'Prototype' },
  'syn_sine_rise': { key: 'syn_sine_rise', label: 'Sine Rise', description: 'Pitch up', category: 'UNUSED', usage: 'Prototype' },
  'syn_saw_rise': { key: 'syn_saw_rise', label: 'Saw Rise', description: 'Aggressive pitch up', category: 'UNUSED', usage: 'Prototype' },
  'syn_sqr_rise': { key: 'syn_sqr_rise', label: 'Square Rise', description: '8-bit pitch up', category: 'UNUSED', usage: 'Prototype' },
  'syn_siren_wail': { key: 'syn_siren_wail', label: 'Siren', description: 'Slow LFO', category: 'UNUSED', usage: 'Prototype' },
  'syn_alert_pulse': { key: 'syn_alert_pulse', label: 'Alert Pulse', description: 'Fast LFO', category: 'UNUSED', usage: 'Prototype' },
  'syn_static_wash': { key: 'syn_static_wash', label: 'Wash', description: 'Ocean-like noise', category: 'UNUSED', usage: 'Prototype' },
};

export const getUnlistedSounds = () => {
    const configKeys = Object.keys(AUDIO_CONFIG);
    const metaKeys = Object.keys(SOUND_METADATA);
    return configKeys.filter(k => !metaKeys.includes(k));
};


=====================================
FILE: ./src/engine/config/static/waves.json
=====================================
[
  { "at": 0,     "type": "driller", "count": 4, "interval": 0.1 },
  { "at": 1.5,   "type": "hunter",  "count": 2, "interval": 0.2 },
  { "at": 3.5,   "type": "driller", "count": 8, "interval": 0.15 },
  { "at": 5.5,   "type": "kamikaze", "count": 4, "interval": 0.5 },
  { "at": 8.0,   "type": "driller", "count": 12, "interval": 0.1 },
  { "at": 10.5,  "type": "hunter",  "count": 4, "interval": 0.8 },
  { "at": 14.0,  "type": "kamikaze", "count": 6, "interval": 0.3 },
  { "at": 18.0,  "type": "driller", "count": 15, "interval": 0.05 },
  { "at": 22.0,  "type": "hunter",  "count": 5, "interval": 0.5 },
  { "at": 26.0,  "type": "kamikaze", "count": 8, "interval": 0.2 }
]


=====================================
FILE: ./src/engine/config/static/gallery.json
=====================================
[
  {
    "id": "art_001",
    "title": "ELFY_GENESIS",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#78F654"
  },
  {
    "id": "art_002",
    "title": "NEON_HEIST",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#9E4EA5"
  },
  {
    "id": "art_003",
    "title": "VOID_WALKER",
    "url": "https://x.com/mesoelfy",
    "category": "ROGUES",
    "color": "#FF003C"
  },
  {
    "id": "art_004",
    "title": "LATENT_GHOST",
    "url": "https://x.com/mesoelfy",
    "category": "COLLEAGUES",
    "color": "#F7D277"
  },
  {
    "id": "art_005",
    "title": "ZERO_DAY",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#78F654"
  },
  {
    "id": "art_006",
    "title": "SYSTEM_CRASH",
    "url": "https://x.com/mesoelfy",
    "category": "ROGUES",
    "color": "#FF003C"
  }
]


=====================================
FILE: ./src/engine/config/static/identity.json
=====================================
{
  "name": "Elfy",
  "class": "Latent Space Bandit",
  "abilities": ["Green Flame", "Digital Heist", "Prompt Craft"],
  "stats": {
    "STR": "ERROR",
    "INT": 9001,
    "CHA": 50
  },
  "bio": "I manifest art from the void. My mission: Create cool s**t and annoy the haters."
}


=====================================
FILE: ./src/engine/config/static/socials.json
=====================================
[
  { "name": "X / Twitter", "url": "https://x.com/mesoelfy", "icon": "twitter", "color": "#1DA1F2" },
  { "name": "YouTube", "url": "https://youtube.com/@mesoelfy", "icon": "youtube", "color": "#FF0000" },
  { "name": "TikTok", "url": "https://tiktok.com/@mesoelfy", "icon": "video", "color": "#00f2ea" },
  { "name": "GitHub", "url": "https://github.com/mesoelfy", "icon": "github", "color": "#ffffff" },
  { "name": "Newgrounds", "url": "https://mesoelfy.newgrounds.com/", "icon": "crosshair", "color": "#ffa500" },
  { "name": "DeviantArt", "url": "https://www.deviantart.com/mesoelfy", "icon": "image", "color": "#05cc47" }
]


=====================================
FILE: ./src/engine/config/static/feed.json
=====================================
[
  {
    "id": 1,
    "date": "2023-10-27",
    "title": "Elfy vs. RoboGhoul",
    "desc": "The final showdown. Green flame algorithm engaged.",
    "link": "https://x.com/mesoelfy/status/123456"
  },
  {
    "id": 2,
    "date": "2023-10-20",
    "title": "Latent Space Update",
    "desc": "Exploring the void. Found some weird artifacts.",
    "link": "https://x.com/mesoelfy/status/789012"
  }
]


=====================================
FILE: ./src/engine/config/AudioConfig.ts
=====================================
export type SoundType = 'oscillator' | 'noise';

export interface SoundRecipe {
  type: SoundType;
  wave?: OscillatorType; 
  frequency: [number, number]; 
  duration: number; 
  volume: number; 
  pitchVariance: number; 
  filter?: [number, number]; 
  distortion?: number; 
  attack?: number; 
  fm?: {
    modFreq: number; 
    modIndex: number; 
    modType: OscillatorType;
  };
  tremolo?: {
    rate: number; 
    depth: number; 
    wave?: OscillatorType;
  };
}

export const AUDIO_CONFIG: Record<string, SoundRecipe> = {
  'ui_click': { type: 'oscillator', wave: 'square', frequency: [400, 400], duration: 0.05, volume: 0.1, pitchVariance: 0 },
  'ui_hover': { type: 'oscillator', wave: 'sine', frequency: [800, 800], duration: 0.03, volume: 0.05, pitchVariance: 50 },
  'ui_menu_open': { type: 'oscillator', wave: 'sine', frequency: [440, 660], duration: 0.15, volume: 0.1, pitchVariance: 0, attack: 0.02 },
  'ui_menu_close': { type: 'oscillator', wave: 'sine', frequency: [660, 440], duration: 0.15, volume: 0.1, pitchVariance: 0, attack: 0.02 },
  'ui_optimal': { type: 'oscillator', wave: 'sine', frequency: [1200, 1200], duration: 0.4, volume: 0.15, pitchVariance: 0, attack: 0.01 },
  'ui_error': { type: 'oscillator', wave: 'sawtooth', frequency: [150, 50], duration: 0.2, volume: 0.2, pitchVariance: 0, distortion: 50 },
  'ui_chirp': { type: 'oscillator', wave: 'triangle', frequency: [400, 600], duration: 0.1, volume: 0.1, pitchVariance: 0 },
  'fx_player_fire': { type: 'oscillator', wave: 'sawtooth', frequency: [880, 110], duration: 0.15, volume: 0.35, pitchVariance: 100, attack: 0.005 },
  'fx_enemy_fire': { type: 'oscillator', wave: 'square', frequency: [440, 220], duration: 0.2, volume: 0.15, pitchVariance: 50 },
  'fx_impact_light': { type: 'noise', frequency: [0, 0], filter: [1000, 100], duration: 0.4, volume: 0.3, pitchVariance: 200, distortion: 20 },
  'fx_impact_heavy': { type: 'noise', frequency: [0, 0], filter: [600, 50], duration: 1.5, volume: 0.5, pitchVariance: 0, distortion: 50 },
  'fx_boot_sequence': { type: 'noise', frequency: [0, 0], filter: [1500, 50], duration: 2.0, volume: 0.6, pitchVariance: 0, distortion: 30 },
  'fx_player_death': { type: 'noise', frequency: [0,0], filter: [500, 500], duration: 2.0, volume: 0.6, pitchVariance: 0, distortion: 200, tremolo: { rate: 12, depth: 1.0, wave: 'square' } },
  'fx_level_up': { type: 'oscillator', wave: 'triangle', frequency: [440, 880], duration: 0.4, volume: 0.2, pitchVariance: 0 },
  'fx_reboot_success': { type: 'oscillator', wave: 'triangle', frequency: [440, 880], duration: 0.3, volume: 0.3, pitchVariance: 0, attack: 0.01, tremolo: { rate: 10, depth: 1.0, wave: 'square' } },
  'fx_teleport': { type: 'oscillator', wave: 'sine', frequency: [100, 1500], duration: 0.3, volume: 0.2, pitchVariance: 0 },
  // NEW: Roman Candle Effect
  'fx_exhaust_sizzle': { 
      type: 'noise', 
      frequency: [0, 0], 
      filter: [4000, 2000], 
      duration: 0.3, 
      volume: 0.1, 
      pitchVariance: 0, 
      distortion: 10,
      tremolo: { rate: 20, depth: 0.6, wave: 'sawtooth' } 
  },
  'loop_heal': { type: 'oscillator', wave: 'sine', frequency: [300, 600], duration: 0.2, volume: 0.1, pitchVariance: 0 },
  'loop_reboot': { type: 'oscillator', wave: 'sine', frequency: [100, 200], duration: 0.2, volume: 0.2, pitchVariance: 0 },
  'loop_warning': { type: 'oscillator', wave: 'sine', frequency: [55, 55], duration: 0.8, volume: 0.7, pitchVariance: 0, attack: 0.03, fm: { modType: 'sine', modFreq: 10, modIndex: 25 } },
  'loop_drill': { type: 'noise', frequency: [0,0], filter: [300, 50], duration: 0.25, volume: 0.5, pitchVariance: 50, distortion: 60 },
  'ambience_core': { type: 'noise', frequency: [0,0], filter: [800, 800], duration: 40.0, volume: 0.24, pitchVariance: 0 },
  'syn_fm_scream': { type: 'oscillator', wave: 'sawtooth', frequency: [800, 1200], duration: 0.5, volume: 0.15, pitchVariance: 50, fm: { modType: 'sine', modFreq: 150, modIndex: 300 } },
  'syn_data_burst': { type: 'oscillator', wave: 'square', frequency: [25, 20], duration: 0.4, volume: 0.4, pitchVariance: 0, distortion: 50 },
  'syn_bass_drop': { type: 'oscillator', wave: 'triangle', frequency: [150, 100], duration: 0.6, volume: 0.3, pitchVariance: 20, fm: { modType: 'square', modFreq: 57, modIndex: 1000 } },
  'syn_alarm_chirp': { type: 'oscillator', wave: 'sawtooth', frequency: [400, 50], duration: 0.3, volume: 0.3, pitchVariance: 50, distortion: 100 },
  'syn_static_burst': { type: 'noise', frequency: [0, 0], filter: [800, 2000], duration: 0.4, volume: 0.3, pitchVariance: 0, distortion: 400 },
  'syn_wobble_bass': { type: 'oscillator', wave: 'sine', frequency: [50, 50], duration: 0.5, volume: 0.6, pitchVariance: 0, fm: { modType: 'sine', modFreq: 10, modIndex: 50 } },
  'syn_grind_loop': { type: 'noise', frequency: [0,0], filter: [200, 100], duration: 3.0, volume: 0.5, pitchVariance: 0, distortion: 50, tremolo: { rate: 2, depth: 0.8, wave: 'sine' } },
  'syn_insect_swarm': { type: 'noise', frequency: [0,0], filter: [1500, 800], duration: 3.0, volume: 0.3, pitchVariance: 0, distortion: 10, tremolo: { rate: 12, depth: 1.0, wave: 'sawtooth' } },
  'syn_interference': { type: 'noise', frequency: [0,0], filter: [800, 400], duration: 3.0, volume: 0.4, pitchVariance: 0, distortion: 100, tremolo: { rate: 6, depth: 0.6, wave: 'square' } },
  'syn_wind_howl': { type: 'noise', frequency: [0,0], filter: [100, 1000], duration: 3.0, volume: 0.4, pitchVariance: 0, distortion: 20, tremolo: { rate: 15, depth: 0.5, wave: 'sine' } },
  'syn_robot_chatter': { type: 'noise', frequency: [0,0], filter: [500, 500], duration: 3.0, volume: 0.5, pitchVariance: 0, distortion: 200, tremolo: { rate: 8, depth: 1.0, wave: 'square' } },
  'syn_deep_hum': { type: 'noise', frequency: [0,0], filter: [80, 40], duration: 3.0, volume: 0.8, pitchVariance: 0, distortion: 20, tremolo: { rate: 0.5, depth: 0.9, wave: 'sine' } },
  'syn_sine_rise': { type: 'oscillator', wave: 'sine', frequency: [200, 400], duration: 1.0, volume: 0.3, pitchVariance: 0 },
  'syn_saw_rise': { type: 'oscillator', wave: 'sawtooth', frequency: [100, 800], duration: 1.0, volume: 0.2, pitchVariance: 0, fm: { modType: 'sine', modFreq: 50, modIndex: 200 } },
  'syn_sqr_rise': { type: 'oscillator', wave: 'square', frequency: [60, 60], duration: 1.0, volume: 0.2, pitchVariance: 0, fm: { modType: 'triangle', modFreq: 15, modIndex: 100 } },
  'syn_siren_wail': { type: 'oscillator', wave: 'sine', frequency: [60, 20], duration: 2.5, volume: 0.6, pitchVariance: 0, distortion: 20 },
  'syn_alert_pulse': { type: 'oscillator', wave: 'square', frequency: [400, 350], duration: 1.0, volume: 0.3, pitchVariance: 0, fm: { modType: 'square', modFreq: 8, modIndex: 50 } },
  'syn_static_wash': { type: 'noise', frequency: [0, 0], filter: [2000, 200], duration: 1.5, volume: 0.4, pitchVariance: 0, distortion: 100 },
};


=====================================
FILE: ./src/engine/config/Identifiers.ts
=====================================
import { GameEvents as Events } from '@/engine/signals/GameEvents';

export const EnemyTypes = {
  DRILLER: 'driller',
  KAMIKAZE: 'kamikaze',
  HUNTER: 'hunter',
  DAEMON: 'daemon',
} as const;

export const ArchetypeIDs = {
  PLAYER: 'PLAYER',
  BULLET_PLAYER: 'BULLET_PLAYER',
  BULLET_ENEMY: 'BULLET_ENEMY',
  ...EnemyTypes
} as const;

export type EnemyType = typeof EnemyTypes[keyof typeof EnemyTypes];
export type ArchetypeID = typeof ArchetypeIDs[keyof typeof ArchetypeIDs] | string;

// Direct re-export for cleaner imports
export const GameEvents = Events;


=====================================
FILE: ./src/engine/config/WaveConfig.ts
=====================================
export const WAVE_CONFIG = {
  baseSpawnInterval: 0.8,
  difficultyScaler: 1.0 
};


=====================================
FILE: ./src/engine/config/PhysicsConfig.ts
=====================================
export const CollisionLayers = {
  NONE: 0,
  PLAYER: 1,
  ENEMY: 2,
  PLAYER_PROJECTILE: 4,
  ENEMY_PROJECTILE: 8,
  PANEL: 16,
  PICKUP: 32
} as const;

export const PhysicsConfig = {
  HITBOX: {
    PLAYER: 0.6,
    DRILLER: 0.4, // Reduced (was 0.5)
    KAMIKAZE: 0.7, // Increased (was 0.6)
    HUNTER: 0.74, 
    BULLET: 0.25,
    HUNTER_BULLET: 0.4
  },
  MASKS: {
    PLAYER: 42,
    ENEMY: 5,
    PLAYER_PROJECTILE: 10,
    ENEMY_PROJECTILE: 1
  }
};


=====================================
FILE: ./src/engine/config/Archetypes.ts
=====================================
import { PLAYER_CONFIG } from './PlayerConfig';
import { PhysicsConfig, CollisionLayers } from './PhysicsConfig';
import { ArchetypeIDs } from './Identifiers';
import { Tag } from '@/engine/ecs/types';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { GAME_THEME } from '@/ui/sim/config/theme';

const parseHex = (hex: string) => {
    const c = parseInt(hex.replace('#', ''), 16);
    return { 
        r: ((c >> 16) & 255) / 255, 
        g: ((c >> 8) & 255) / 255, 
        b: (c & 255) / 255 
    };
};

export interface EntityBlueprint {
  id: string;
  tags: Tag[];
  aiLogic?: string;
  assets?: {
      geometry: string;
      material: string;
  };
  components: { type: ComponentType; data?: any }[];
}

export const ARCHETYPES: Record<string, EntityBlueprint> = {
  [ArchetypeIDs.PLAYER]: {
    id: ArchetypeIDs.PLAYER,
    tags: [Tag.PLAYER],
    components: [
      { type: ComponentType.Identity, data: { variant: 'PLAYER' } },
      { type: ComponentType.Transform, data: { x: 0, y: 0, rotation: 0, scale: 1 } },
      { type: ComponentType.Motion, data: { friction: 0.9 } },
      { type: ComponentType.Health, data: { max: PLAYER_CONFIG.maxHealth } },
      { type: ComponentType.State, data: { current: 'IDLE' } },
      { type: ComponentType.Collider, data: { 
          radius: PhysicsConfig.HITBOX.PLAYER, 
          layer: CollisionLayers.PLAYER, 
          mask: PhysicsConfig.MASKS.PLAYER 
      }},
      { type: ComponentType.Render, data: { ...parseHex(GAME_THEME.turret.base), visualScale: 1.0, geometryId: 'PLAYER_GEO', materialId: 'PLAYER_MAT' } }
    ]
  },
  [ArchetypeIDs.BULLET_PLAYER]: {
    id: ArchetypeIDs.BULLET_PLAYER,
    tags: [Tag.BULLET, Tag.PLAYER],
    components: [
      { type: ComponentType.Transform, data: { scale: 1.0 } },
      { type: ComponentType.Motion, data: { friction: 0 } },
      { type: ComponentType.Lifetime, data: { remaining: 1.5, total: 1.5 } },
      { type: ComponentType.Combat, data: { damage: 1 } },
      { type: ComponentType.Health, data: { max: 1 } },
      { type: ComponentType.Collider, data: { 
          radius: PhysicsConfig.HITBOX.BULLET, 
          layer: CollisionLayers.PLAYER_PROJECTILE, 
          mask: PhysicsConfig.MASKS.PLAYER_PROJECTILE 
      }},
      { type: ComponentType.Render, data: { visualScale: 1.0 } },
      { type: ComponentType.Projectile, data: { configId: 'PLAYER_STANDARD', state: 'FLIGHT' } }
    ]
  },
  [ArchetypeIDs.BULLET_ENEMY]: {
    id: ArchetypeIDs.BULLET_ENEMY,
    tags: [Tag.BULLET, Tag.ENEMY],
    components: [
      { type: ComponentType.Transform, data: { scale: 1.0 } },
      { type: ComponentType.Motion, data: { friction: 0 } },
      { type: ComponentType.Lifetime, data: { remaining: 3.0, total: 3.0 } },
      { type: ComponentType.Combat, data: { damage: 10 } },
      { type: ComponentType.Health, data: { max: 1 } },
      { type: ComponentType.Collider, data: { 
          radius: PhysicsConfig.HITBOX.HUNTER_BULLET, 
          layer: CollisionLayers.ENEMY_PROJECTILE, 
          mask: PhysicsConfig.MASKS.ENEMY_PROJECTILE 
      }},
      { type: ComponentType.Render, data: { visualScale: 1.0 } },
      { type: ComponentType.Projectile, data: { configId: 'ENEMY_HUNTER', state: 'FLIGHT' } }
    ]
  },
  [ArchetypeIDs.DRILLER]: {
    id: ArchetypeIDs.DRILLER,
    tags: [Tag.ENEMY, Tag.OBSTACLE],
    aiLogic: 'driller',
    assets: { geometry: 'GEO_DRILLER', material: 'MAT_ENEMY_BASE' },
    components: [
      { type: ComponentType.Identity, data: { variant: ArchetypeIDs.DRILLER } },
      { type: ComponentType.Transform, data: { scale: 1.0 } }, 
      { type: ComponentType.Health, data: { max: 1 } }, 
      { type: ComponentType.Motion, data: { friction: 0 } },
      { type: ComponentType.Combat, data: { damage: 1 } },
      { type: ComponentType.Collider, data: { radius: PhysicsConfig.HITBOX.DRILLER, layer: CollisionLayers.ENEMY, mask: PhysicsConfig.MASKS.ENEMY } },
      { type: ComponentType.State, data: { current: 'SPAWN', timers: { spawn: 1.5 } } },
      { type: ComponentType.Target, data: { type: 'PANEL' } },
      { type: ComponentType.Render, data: { ...parseHex(GAME_THEME.enemy.muncher) } }
    ]
  },
  [ArchetypeIDs.KAMIKAZE]: {
    id: ArchetypeIDs.KAMIKAZE,
    tags: [Tag.ENEMY, Tag.OBSTACLE],
    aiLogic: 'kamikaze',
    assets: { geometry: 'GEO_KAMIKAZE', material: 'MAT_ENEMY_BASE' },
    components: [
      { type: ComponentType.Identity, data: { variant: ArchetypeIDs.KAMIKAZE } },
      { type: ComponentType.Transform, data: { scale: 1.0 } }, 
      { type: ComponentType.Health, data: { max: 2 } }, 
      { type: ComponentType.Motion, data: { friction: 0 } },
      { type: ComponentType.Combat, data: { damage: 3 } },
      { type: ComponentType.Collider, data: { radius: PhysicsConfig.HITBOX.KAMIKAZE, layer: CollisionLayers.ENEMY, mask: PhysicsConfig.MASKS.ENEMY } },
      { type: ComponentType.State, data: { current: 'SPAWN', timers: { spawn: 1.5 } } },
      { type: ComponentType.Target, data: { type: 'PLAYER' } },
      { type: ComponentType.Render, data: { ...parseHex(GAME_THEME.enemy.kamikaze) } }
    ]
  },
  [ArchetypeIDs.HUNTER]: {
    id: ArchetypeIDs.HUNTER,
    tags: [Tag.ENEMY, Tag.OBSTACLE],
    aiLogic: 'hunter',
    assets: { geometry: 'GEO_HUNTER', material: 'MAT_ENEMY_BASE' },
    components: [
      { type: ComponentType.Identity, data: { variant: ArchetypeIDs.HUNTER } },
      { type: ComponentType.Transform, data: { scale: 1.0 } }, 
      { type: ComponentType.Health, data: { max: 3 } }, 
      { type: ComponentType.Motion, data: { friction: 0 } },
      { type: ComponentType.Combat, data: { damage: 10 } }, 
      { type: ComponentType.Collider, data: { radius: PhysicsConfig.HITBOX.HUNTER, layer: CollisionLayers.ENEMY, mask: PhysicsConfig.MASKS.ENEMY } },
      { type: ComponentType.State, data: { current: 'SPAWN', timers: { spawn: 1.5 } } },
      { type: ComponentType.Target, data: { type: 'PLAYER' } },
      { type: ComponentType.Render, data: { ...parseHex(GAME_THEME.enemy.hunter) } }
    ]
  },
  [ArchetypeIDs.DAEMON]: {
    id: ArchetypeIDs.DAEMON,
    tags: [Tag.PLAYER],
    aiLogic: 'daemon',
    assets: { geometry: 'GEO_DAEMON', material: 'MAT_ENEMY_BASE' },
    components: [
      { type: ComponentType.Identity, data: { variant: ArchetypeIDs.DAEMON } },
      { type: ComponentType.Transform, data: { scale: 1.0 } },
      { type: ComponentType.Health, data: { max: 100 } }, 
      { type: ComponentType.Orbital, data: { radius: 4.0, speed: 1.5, angle: 0 } },
      { type: ComponentType.Target, data: { type: 'ENEMY' } }, 
      { type: ComponentType.Collider, data: { radius: 0.6, layer: CollisionLayers.PLAYER, mask: PhysicsConfig.MASKS.PLAYER } },
      { type: ComponentType.State, data: { current: 'ORBIT' } },
      { type: ComponentType.Render, data: { ...parseHex('#00F0FF') } }
    ]
  }
};


=====================================
FILE: ./src/engine/config/AssetKeys.ts
=====================================
import { AUDIO_CONFIG } from './AudioConfig';
import { VFX_RECIPES } from './VFXConfig';

// 1. AUDIO KEYS (Derived from Config)
export type AudioKey = keyof typeof AUDIO_CONFIG;

// 2. VFX KEYS (Derived from Config)
export type VFXKey = keyof typeof VFX_RECIPES;

// 3. GEOMETRY KEYS (Manually Synced with AssetCatalog)
export type GeometryKey = 
  | 'GEO_DRILLER' 
  | 'GEO_KAMIKAZE' 
  | 'GEO_HUNTER' 
  | 'GEO_DAEMON'
  | 'GEO_PARTICLE' 
  | 'GEO_BULLET' 
  | 'PLAYER_GEO' 
  | 'DEFAULT_GEO';

// 4. MATERIAL KEYS (Manually Synced with AssetCatalog)
export type MaterialKey = 
  | 'MAT_ENEMY_BASE' 
  | 'MAT_PARTICLE' 
  | 'PLAYER_MAT' 
  | 'MAT_GLITCH'
  | 'MAT_PLAYER_AMBIENT' 
  | 'MAT_PLAYER_BACKING'
  | 'MAT_GALLERY_BODY'
  | 'DEFAULT_MAT';


=====================================
FILE: ./src/engine/config/WorldConfig.ts
=====================================
export const WorldConfig = {
  bounds: {
    width: 32, // World Units
    height: 18,
    depth: 5
  },
  physics: {
    friction: 0.95,
    maxVelocity: 20
  },
  time: {
    fixedDelta: 1 / 60, // Logic runs at 60hz (0.0166s per tick)
    maxAccumulator: 0.1 // Prevent "Spiral of Death" if CPU lags hard
  }
};


=====================================
FILE: ./src/engine/input/VirtualJoystickService.ts
=====================================
export class VirtualJoystickServiceController {
  private _vector = { x: 0, y: 0 };
  private _isActive = false;

  public setVector(x: number, y: number) {
    this._vector.x = x;
    this._vector.y = y;
    this._isActive = (x !== 0 || y !== 0);
  }

  public getVector() {
    return this._vector;
  }

  public get isActive() {
    return this._isActive;
  }
}

export const VirtualJoystickService = new VirtualJoystickServiceController();


=====================================
FILE: ./src/engine/signals/GameEvents.ts
=====================================
export enum GameEvents {
  PLAYER_FIRED = 'PLAYER_FIRED',
  PLAYER_HIT = 'PLAYER_HIT',
  ENEMY_SPAWNED = 'ENEMY_SPAWNED',
  ENEMY_DAMAGED = 'ENEMY_DAMAGED',
  ENEMY_DESTROYED = 'ENEMY_DESTROYED',
  PROJECTILE_CLASH = 'PROJECTILE_CLASH',
  PANEL_DAMAGED = 'PANEL_DAMAGED',
  PANEL_HEALED = 'PANEL_HEALED',
  PANEL_RESTORED = 'PANEL_RESTORED',
  PANEL_DESTROYED = 'PANEL_DESTROYED',
  GAME_START = 'GAME_START',
  GAME_OVER = 'GAME_OVER',
  THREAT_LEVEL_UP = 'THREAT_LEVEL_UP',
  UPGRADE_SELECTED = 'UPGRADE_SELECTED',
  ZEN_MODE_ENABLED = 'ZEN_MODE_ENABLED',
  DEBUG_SPAWN = 'DEBUG_SPAWN',
  TRAUMA_ADDED = 'TRAUMA_ADDED',
  SCENE_READY = 'SCENE_READY',
  SPAWN_FX = 'SPAWN_FX',
  SPAWN_DAEMON = 'SPAWN_DAEMON',
  HEARTBEAT = 'HEARTBEAT',
  LOG_DEBUG = 'LOG_DEBUG',
  BOOT_LOG = 'BOOT_LOG',
  PLAYER_REBOOT_TICK = 'PLAYER_REBOOT_TICK',
  PLAYER_REBOOT_DECAY = 'PLAYER_REBOOT_DECAY'
}

export type FXVariant = 
  | 'EXPLOSION_PURPLE' 
  | 'EXPLOSION_YELLOW' 
  | 'EXPLOSION_RED'
  | 'IMPACT_WHITE'
  | 'IMPACT_RED'
  | 'IMPACT_YELLOW'
  | 'DRILL_SPARKS'
  | 'HUNTER_RECOIL'
  | 'CLASH_YELLOW'
  | 'REBOOT_HEAL'
  | 'PURGE_BLAST'
  | 'ENGINE_FLARE'
  | 'EXPLOSION_PURPLE_DIR'
  | 'EXPLOSION_YELLOW_DIR'
  | 'EXPLOSION_RED_DIR';

export interface GameEventPayloads {
  [GameEvents.PLAYER_FIRED]: { x: number; y: number };
  [GameEvents.PLAYER_HIT]: { damage: number };
  [GameEvents.ENEMY_SPAWNED]: { type: string; id: number };
  [GameEvents.ENEMY_DAMAGED]: { id: number; damage: number; type: string };
  [GameEvents.ENEMY_DESTROYED]: { id: number; type: string; x: number; y: number };
  [GameEvents.PROJECTILE_CLASH]: { x: number; y: number };
  // UPDATED: Added source coordinates
  [GameEvents.PANEL_DAMAGED]: { id: string; amount: number; currentHealth: number; sourceX?: number; sourceY?: number };
  [GameEvents.PANEL_HEALED]: { id: string; amount: number };
  [GameEvents.PANEL_RESTORED]: { id: string; x?: number }; 
  [GameEvents.PANEL_DESTROYED]: { id: string };
  [GameEvents.GAME_START]: null;
  [GameEvents.GAME_OVER]: { score: number };
  [GameEvents.THREAT_LEVEL_UP]: { level: number };
  [GameEvents.UPGRADE_SELECTED]: { option: string };
  [GameEvents.ZEN_MODE_ENABLED]: null;
  [GameEvents.DEBUG_SPAWN]: { type: string; count: number };
  [GameEvents.TRAUMA_ADDED]: { amount: number };
  [GameEvents.SCENE_READY]: null;
  [GameEvents.SPAWN_FX]: { type: FXVariant; x: number; y: number; angle?: number; count?: number; };
  [GameEvents.SPAWN_DAEMON]: null;
  [GameEvents.HEARTBEAT]: { urgency: number };
  [GameEvents.LOG_DEBUG]: { msg: string; source?: string };
  [GameEvents.BOOT_LOG]: { message: string };
  [GameEvents.PLAYER_REBOOT_TICK]: { amount: number };
  [GameEvents.PLAYER_REBOOT_DECAY]: { amount: number };
}


=====================================
FILE: ./src/engine/signals/EventReader.ts
=====================================
import { IFastEventService } from '@/engine/interfaces';
import { ServiceLocator } from '@/engine/services/ServiceLocator';

type FastEventHandler = (type: number, a1: number, a2: number, a3: number, a4: number) => void;

export class EventReader {
  private cursor: number;
  private bus: IFastEventService;

  constructor(bus?: IFastEventService) {
    // If no bus provided (e.g. in tests), try ServiceLocator, otherwise fallback constitutes a crash or mock needs
    this.bus = bus || ServiceLocator.getFastEventBus();
    this.cursor = this.bus.getCursor();
  }

  public process(handler: FastEventHandler) {
    // The bus implementation handles the looping and buffer wrapping.
    // We just update our local cursor to match where the bus says we stopped reading.
    this.cursor = this.bus.readEvents(this.cursor, handler);
  }
}


=====================================
FILE: ./src/engine/signals/GameEventBus.ts
=====================================
import { GameEvents, GameEventPayloads } from './GameEvents';
import { IGameEventService } from '@/engine/interfaces';
import { ServiceLocator } from '@/engine/services/ServiceLocator';

type Handler<T extends GameEvents> = (payload: GameEventPayloads[T]) => void;

export class GameEventService implements IGameEventService {
  private listeners: { [K in GameEvents]?: Handler<K>[] } = {};
  private history: { event: string; payload: any; timestamp: number }[] = [];
  private readonly MAX_HISTORY = 50;

  public subscribe<T extends GameEvents>(event: T, handler: Handler<T>): () => void {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    (this.listeners[event] as Handler<T>[]).push(handler);

    return () => {
      if (!this.listeners[event]) return;
      this.listeners[event] = (this.listeners[event] as Handler<T>[]).filter(h => h !== handler) as any;
    };
  }

  public emit<T extends GameEvents>(event: T, payload: GameEventPayloads[T]): void {
    if (process.env.NODE_ENV === 'development') {
        this.history.push({ event, payload, timestamp: Date.now() });
        if (this.history.length > this.MAX_HISTORY) this.history.shift();
    }

    const handlers = this.listeners[event];
    if (handlers) {
        handlers.forEach(handler => handler(payload));
    }
  }

  public clear(): void {
    this.listeners = {};
    this.history = [];
  }
}

/**
 * STATIC FACADE (Compatibility Adapter)
 * Routes calls to the ServiceLocator's registered EventService.
 */
class GameEventBusFacade {
  private get service(): IGameEventService {
    try {
        return ServiceLocator.getGameEventBus();
    } catch {
        // Lazy-load if accessed before Engine Boot
        const impl = new GameEventService();
        ServiceLocator.register('GameEventService', impl);
        return impl;
    }
  }

  public subscribe<T extends GameEvents>(event: T, handler: Handler<T>) { 
      return this.service.subscribe(event, handler); 
  }
  
  public emit<T extends GameEvents>(event: T, payload: GameEventPayloads[T]) { 
      this.service.emit(event, payload); 
  }
  
  public clear() { this.service.clear(); }
}

export const GameEventBus = new GameEventBusFacade();


=====================================
FILE: ./src/engine/signals/FastEventBus.ts
=====================================
import { IFastEventService } from '@/engine/interfaces';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { EnemyTypes } from '@/engine/config/Identifiers';

const BUFFER_SIZE = 4096; // Doubled buffer size for safety with high traffic
const MASK = BUFFER_SIZE - 1;
const STRIDE = 5; 

export const FastEvents = {
  SPAWN_FX: 1,
  TRAUMA: 2,
  PLAY_SOUND: 3,
  SPAWN_IMPACT: 4,
  // --- NEW EVENTS ---
  PLAYER_FIRED: 10,
  PLAYER_HIT: 11,
  ENEMY_DAMAGED: 12,
  ENEMY_DESTROYED: 13,
  PROJECTILE_CLASH: 14
} as const;

export const FX_IDS: Record<string, number> = {
  'EXPLOSION_PURPLE': 1,
  'EXPLOSION_YELLOW': 2,
  'EXPLOSION_RED': 3,
  'IMPACT_WHITE': 4,
  'IMPACT_RED': 5,
  'CLASH_YELLOW': 6,
  'DRILL_SPARKS': 7,
  'HUNTER_RECOIL': 8,
  'REBOOT_HEAL': 9,
  'PURGE_BLAST': 10,
  'ENGINE_FLARE': 11,
  'EXPLOSION_PURPLE_DIR': 12,
  'EXPLOSION_YELLOW_DIR': 13,
  'EXPLOSION_RED_DIR': 14,
  'FX_PLAYER_FIRE': 50,
  'FX_IMPACT_HEAVY': 51,
  'FX_IMPACT_LIGHT': 52
};

// Reverse map for FX
export const FX_ID_MAP = Object.entries(FX_IDS).reduce((acc, [k, v]) => {
  acc[v] = k;
  return acc;
}, {} as Record<number, string>);

// Map Enemy Strings to Integers for the Buffer
export const ENEMY_ID_MAP: Record<string, number> = {
  [EnemyTypes.DRILLER]: 1,
  [EnemyTypes.KAMIKAZE]: 2,
  [EnemyTypes.HUNTER]: 3,
  [EnemyTypes.DAEMON]: 4,
  'UNKNOWN': 0
};

export class FastEventService implements IFastEventService {
  private buffer = new Float32Array(BUFFER_SIZE * STRIDE);
  private writeCursor = 0;

  public emit(eventId: number, arg1: number = 0, arg2: number = 0, arg3: number = 0, arg4: number = 0) {
    // Safety check for NaN to prevent logic bomb downstream
    if (Number.isNaN(arg1)) arg1 = 0;
    
    const ptr = (this.writeCursor & MASK) * STRIDE;
    this.buffer[ptr] = eventId;
    this.buffer[ptr + 1] = arg1;
    this.buffer[ptr + 2] = arg2;
    this.buffer[ptr + 3] = arg3;
    this.buffer[ptr + 4] = arg4;
    this.writeCursor++;
  }

  public readEvents(fromCursor: number, handler: (eventId: number, a1: number, a2: number, a3: number, a4: number) => void): number {
    let current = fromCursor;
    // If reader fell too far behind, jump ahead to prevent reading wrapped/stale data incorrectly
    // (Though simple ring buffer reading usually handles wrap, jumping ensures we don't process > buffer size)
    if (this.writeCursor - current > BUFFER_SIZE) {
        current = this.writeCursor - BUFFER_SIZE;
    }
    
    while (current < this.writeCursor) {
      const ptr = (current & MASK) * STRIDE;
      handler(this.buffer[ptr], this.buffer[ptr + 1], this.buffer[ptr + 2], this.buffer[ptr + 3], this.buffer[ptr + 4]);
      current++;
    }
    return current;
  }
  
  public getCursor() { return this.writeCursor; }
}

class FastEventBusFacade {
  private get service(): IFastEventService {
    try {
        return ServiceLocator.getFastEventBus();
    } catch {
        const impl = new FastEventService();
        ServiceLocator.register('FastEventService', impl);
        return impl;
    }
  }

  public emit(eventId: number, a1?: number, a2?: number, a3?: number, a4?: number) { 
      this.service.emit(eventId, a1, a2, a3, a4); 
  }
  public readEvents(cursor: number, handler: any) { return this.service.readEvents(cursor, handler); }
  public getCursor() { return this.service.getCursor(); }
}

export const FastEventBus = new FastEventBusFacade();


=====================================
FILE: ./src/engine/ecs/Component.ts
=====================================
import { ComponentType } from './ComponentType';

export abstract class Component {
  abstract readonly _type: ComponentType;
}


=====================================
FILE: ./src/engine/ecs/ComponentType.ts
=====================================
export enum ComponentType {
  Transform = 'Transform',
  Motion = 'Motion',
  Health = 'Health',
  Identity = 'Identity',
  Lifetime = 'Lifetime',
  Combat = 'Combat',
  State = 'State',
  Collider = 'Collider',
  Target = 'Target',
  Orbital = 'Orbital',
  Render = 'Render',
  Projectile = 'Projectile'
}


=====================================
FILE: ./src/engine/ecs/ObjectPool.ts
=====================================
type FactoryFn<T> = () => T;
type ResetFn<T> = (item: T) => void;

export class ObjectPool<T> {
  private available: T[] = [];
  private factory: FactoryFn<T>;
  private resetFn: ResetFn<T>;
  private _totalCreated = 0;

  constructor(factory: FactoryFn<T>, resetFn: ResetFn<T>, initialSize: number = 100) {
    this.factory = factory;
    this.resetFn = resetFn;
    this.expand(initialSize);
  }

  private expand(amount: number) {
    for (let i = 0; i < amount; i++) {
      this.available.push(this.factory());
    }
    this._totalCreated += amount;
  }

  public acquire(): T {
    if (this.available.length === 0) {
      // Dynamic expansion: Double current size or add 50
      const expandAmount = Math.max(50, Math.floor(this._totalCreated * 0.5)); 
      this.expand(expandAmount);
    }

    const item = this.available.pop()!;
    this.resetFn(item); 
    return item;
  }

  public release(item: T) {
    this.available.push(item);
  }

  public get totalSize() {
    return this._totalCreated;
  }
  
  public get availableSize() {
      return this.available.length;
  }
}


=====================================
FILE: ./src/engine/ecs/Entity.ts
=====================================
import { EntityID, Tag } from './types';
import { Component } from './Component';
import { ComponentType } from './ComponentType';
import { ComponentPoolManager } from './ComponentPoolManager';

export class Entity {
  public id: EntityID; 
  public readonly tags = new Set<Tag>();
  public active = true;
  public pooled = false;

  public components = new Map<ComponentType, Component>();

  constructor(id: EntityID) {
    this.id = id;
  }

  public addComponent(component: Component): this {
    this.components.set(component._type, component);
    return this;
  }

  public getComponent<T extends Component>(type: ComponentType): T | undefined {
    return this.components.get(type) as T;
  }
  
  public requireComponent<T extends Component>(type: ComponentType): T {
    const c = this.components.get(type);
    if (!c) throw new Error(`Entity ${this.id} missing required component: ${type}`);
    return c as T;
  }

  public hasComponent(type: ComponentType): boolean {
    return this.components.has(type);
  }

  public addTag(tag: Tag): this {
    this.tags.add(tag);
    return this;
  }

  public hasTag(tag: Tag): boolean {
    return this.tags.has(tag);
  }

  public reset(newId: EntityID) {
      this.id = newId;
      this.active = true;
      this.pooled = false;
      this.components.clear();
      this.tags.clear();
  }

  public release() {
      this.active = false;
      this.pooled = true;
      
      for (const component of this.components.values()) {
          ComponentPoolManager.release(component);
      }
      
      this.components.clear(); 
      this.tags.clear();
  }
}


=====================================
FILE: ./src/engine/ecs/TransformStore.ts
=====================================
import { MAX_ENTITIES } from './Constants';

const STRIDE = 4; // X, Y, ROTATION, SCALE

class TransformStoreController {
  public data = new Float32Array(MAX_ENTITIES * STRIDE);
  private freeIndices: number[] = [];
  private nextIndex = 0;

  public alloc(): number {
    if (this.freeIndices.length > 0) {
      return this.freeIndices.pop()!;
    }
    
    if (this.nextIndex >= MAX_ENTITIES) {
      // SAFETY: Return 0 (dummy slot) to prevent TypedArray crash.
      // In a real scenario, we might want to recycle the oldest entity, 
      // but preventing the crash is priority #1.
      console.error('[TransformStore] CRITICAL: Entity limit reached! Increase MAX_ENTITIES.');
      return 0; 
    }

    return this.nextIndex++;
  }

  public free(index: number) {
    this.freeIndices.push(index);
  }
}

export const TransformStore = new TransformStoreController();


=====================================
FILE: ./src/engine/ecs/types.ts
=====================================
// Nominal typing to prevent mixing up IDs with math numbers
export type EntityID = number & { __brand: 'EntityID' };

export const createEntityID = (id: number): EntityID => id as EntityID;

export enum Tag {
  PLAYER = 'PLAYER',
  ENEMY = 'ENEMY',
  BULLET = 'BULLET',
  PARTICLE = 'PARTICLE',
  OBSTACLE = 'OBSTACLE',
  WORLD = 'WORLD' // NEW
}


=====================================
FILE: ./src/engine/ecs/components/ProjectileData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export type ProjectileState = 'CHARGING' | 'FLIGHT' | 'IMPACT';

export class ProjectileData extends Component {
  readonly _type = ComponentType.Projectile;

  constructor(
    public configId: string = 'DEFAULT', 
    public state: ProjectileState = 'FLIGHT',
    public ownerId: number = -1
  ) {
    super();
  }

  public reset(data: Partial<ProjectileData>) {
    this.configId = data.configId ?? 'DEFAULT';
    this.state = data.state ?? 'FLIGHT';
    this.ownerId = data.ownerId ?? -1;
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/TargetData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export type TargetType = 'PLAYER' | 'PANEL' | 'LOCATION' | 'ENEMY';

export class TargetData extends Component {
  readonly _type = ComponentType.Target;

  constructor(
    public id: string | null = null, 
    public type: TargetType = 'PLAYER',
    public x: number = 0, 
    public y: number = 0,
    public locked: boolean = false 
  ) {
    super();
  }

  public reset(data: Partial<TargetData>) {
    this.id = data.id ?? null;
    this.type = data.type ?? 'PLAYER';
    this.x = data.x ?? 0;
    this.y = data.y ?? 0;
    this.locked = data.locked ?? false;
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/ColliderData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class ColliderData extends Component {
  readonly _type = ComponentType.Collider;

  constructor(
    public radius: number = 0,
    public layer: number = 0,
    public mask: number = 0
  ) {
    super();
  }

  public reset(data: Partial<ColliderData>) {
    this.radius = data.radius ?? 0;
    this.layer = data.layer ?? 0;
    this.mask = data.mask ?? 0;
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/MotionData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class MotionData extends Component {
  readonly _type = ComponentType.Motion;

  constructor(
    public vx: number = 0,
    public vy: number = 0,
    public friction: number = 0,
    public angularVelocity: number = 0
  ) {
    super();
  }

  public reset(data: Partial<MotionData>) {
    this.vx = data.vx ?? 0;
    this.vy = data.vy ?? 0;
    this.friction = data.friction ?? 0;
    this.angularVelocity = data.angularVelocity ?? 0;
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/CombatData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class CombatData extends Component {
  readonly _type = ComponentType.Combat;

  constructor(
    public damage: number = 0,
    public cooldown: number = 0,
    public range: number = 0
  ) {
    super();
  }

  public reset(data: Partial<CombatData>) {
    this.damage = data.damage ?? 0;
    this.cooldown = data.cooldown ?? 0;
    this.range = data.range ?? 0;
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/TransformData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { TransformStore } from '@/engine/ecs/TransformStore';

const STRIDE = 4;

export class TransformData extends Component {
  readonly _type = ComponentType.Transform;
  
  public index: number;

  constructor() {
    super();
    this.index = TransformStore.alloc();
    this.set(0, 0, 0, 1);
  }

  get x(): number { return TransformStore.data[this.index * STRIDE]; }
  set x(val: number) { TransformStore.data[this.index * STRIDE] = val; }

  get y(): number { return TransformStore.data[this.index * STRIDE + 1]; }
  set y(val: number) { TransformStore.data[this.index * STRIDE + 1] = val; }

  get rotation(): number { return TransformStore.data[this.index * STRIDE + 2]; }
  set rotation(val: number) { TransformStore.data[this.index * STRIDE + 2] = val; }

  get scale(): number { return TransformStore.data[this.index * STRIDE + 3]; }
  set scale(val: number) { TransformStore.data[this.index * STRIDE + 3] = val; }

  public set(x: number, y: number, rotation: number, scale: number) {
    const i = this.index * STRIDE;
    TransformStore.data[i] = x;
    TransformStore.data[i + 1] = y;
    TransformStore.data[i + 2] = rotation;
    TransformStore.data[i + 3] = scale;
  }

  public reset(data: Partial<{ x: number, y: number, rotation: number, scale: number }>) {
    this.set(
        data.x ?? 0, 
        data.y ?? 0, 
        data.rotation ?? 0, 
        data.scale ?? 1
    );
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/LifetimeData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class LifetimeData extends Component {
  readonly _type = ComponentType.Lifetime;

  constructor(public remaining: number = 0, public total: number = 0) {
    super();
  }

  public reset(data: Partial<LifetimeData>) {
    this.remaining = data.remaining ?? 0;
    this.total = data.total ?? this.remaining;
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/HealthData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class HealthData extends Component {
  readonly _type = ComponentType.Health;
  public current: number;

  constructor(public max: number = 100, public invincibilityTime: number = 0) {
    super();
    this.current = max;
  }

  public reset(data: Partial<HealthData>) {
    this.max = data.max ?? 100;
    this.current = this.max;
    this.invincibilityTime = data.invincibilityTime ?? 0;
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/RenderData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class RenderData extends Component {
  readonly _type = ComponentType.Render;

  constructor(
    public geometryId: string = 'DEFAULT_GEO',
    public materialId: string = 'DEFAULT_MAT',
    public visualRotation: number = 0,
    public visualScale: number = 1.0,
    public r: number = 1,
    public g: number = 1,
    public b: number = 1,
    public opacity: number = 1.0,
    public baseR: number = 1,
    public baseG: number = 1,
    public baseB: number = 1,
    public flash: number = 0,
    public spawnProgress: number = 1.0,
    public shudder: number = 0 // NEW: Visual vibration intensity (0.0 - 1.0)
  ) {
    super();
  }

  public reset(data: Partial<RenderData>) {
    this.geometryId = data.geometryId ?? 'DEFAULT_GEO';
    this.materialId = data.materialId ?? 'DEFAULT_MAT';
    this.visualRotation = data.visualRotation ?? 0;
    this.visualScale = data.visualScale ?? 1.0;
    this.r = data.r ?? 1;
    this.g = data.g ?? 1;
    this.b = data.b ?? 1;
    this.opacity = data.opacity ?? 1.0;
    this.flash = 0;
    this.spawnProgress = data.spawnProgress ?? 1.0;
    this.shudder = 0;
    
    this.baseR = this.r;
    this.baseG = this.g;
    this.baseB = this.b;
    return this;
  }
  
  public setColor(hex: string) {
      const c = parseInt(hex.replace('#', ''), 16);
      this.r = ((c >> 16) & 255) / 255;
      this.g = ((c >> 8) & 255) / 255;
      this.b = (c & 255) / 255;
      this.baseR = this.r;
      this.baseG = this.g;
      this.baseB = this.b;
  }
}


=====================================
FILE: ./src/engine/ecs/components/OrbitalData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class OrbitalData extends Component {
  readonly _type = ComponentType.Orbital;

  constructor(
    public parentId: number | null = null,
    public radius: number = 3.0,
    public speed: number = 2.0,
    public angle: number = 0,
    public active: boolean = true
  ) {
    super();
  }

  public reset(data: Partial<OrbitalData>) {
    this.parentId = data.parentId ?? null;
    this.radius = data.radius ?? 3.0;
    this.speed = data.speed ?? 2.0;
    this.angle = data.angle ?? 0;
    this.active = data.active ?? true;
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/IdentityData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class IdentityData extends Component {
  readonly _type = ComponentType.Identity;

  constructor(public variant: string = '') {
    super();
  }

  public reset(data: Partial<IdentityData>) {
    this.variant = data.variant ?? '';
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/AIStateData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class AIStateData extends Component {
  readonly _type = ComponentType.State;

  constructor(
    public current: string = 'IDLE',
    public timers: Record<string, number> = {},
    public data: Record<string, any> = {},
    public treeState: any = null,
    public stunTimer: number = 0 // NEW: Controls physics overrides
  ) {
    super();
  }

  public reset(data: Partial<AIStateData>) {
    this.current = data.current ?? 'IDLE';
    this.timers = data.timers ?? {};
    this.data = data.data ?? {};
    this.treeState = data.treeState ?? null;
    this.stunTimer = data.stunTimer ?? 0;
    return this;
  }
  
  public set(state: string) {
    this.current = state;
  }
}


=====================================
FILE: ./src/engine/ecs/Constants.ts
=====================================
export const MAX_ENTITIES = 30000; // Scaled for Bullet Hell capability
export const SPATIAL_GRID_SIZE = 4096; // Power of 2 for bitwise masking
export const SPATIAL_CELL_SIZE = 4; // World Units


=====================================
FILE: ./src/engine/ecs/ComponentCatalog.ts
=====================================
import { ComponentRegistry } from './ComponentRegistry';
import { ComponentType } from './ComponentType';

import { TransformData } from './components/TransformData';
import { MotionData } from './components/MotionData';
import { HealthData } from './components/HealthData';
import { IdentityData } from './components/IdentityData';
import { LifetimeData } from './components/LifetimeData';
import { CombatData } from './components/CombatData';
import { AIStateData } from './components/AIStateData';
import { ColliderData } from './components/ColliderData';
import { TargetData } from './components/TargetData';
import { OrbitalData } from './components/OrbitalData';
import { RenderData } from './components/RenderData';
import { ProjectileData } from './components/ProjectileData';

export const registerAllComponents = () => {
  ComponentRegistry.register(ComponentType.Transform, TransformData);
  ComponentRegistry.register(ComponentType.Motion, MotionData);
  ComponentRegistry.register(ComponentType.Health, HealthData);
  ComponentRegistry.register(ComponentType.Identity, IdentityData);
  ComponentRegistry.register(ComponentType.Lifetime, LifetimeData);
  ComponentRegistry.register(ComponentType.Combat, CombatData);
  ComponentRegistry.register(ComponentType.State, AIStateData);
  ComponentRegistry.register(ComponentType.Collider, ColliderData);
  ComponentRegistry.register(ComponentType.Target, TargetData);
  ComponentRegistry.register(ComponentType.Orbital, OrbitalData);
  ComponentRegistry.register(ComponentType.Render, RenderData);
  ComponentRegistry.register(ComponentType.Projectile, ProjectileData);
  
  console.log('[ComponentCatalog] Components Registered.');
};


=====================================
FILE: ./src/engine/ecs/ComponentRegistry.ts
=====================================
import { Component } from './Component';
import { ComponentType } from './ComponentType';
import { ComponentPoolManager } from './ComponentPoolManager';

type ComponentConstructor = new () => Component;

class ComponentRegistryController {
  private classes = new Map<ComponentType, ComponentConstructor>();

  public register(type: ComponentType, cls: ComponentConstructor) {
    this.classes.set(type, cls);
  }

  public create(type: ComponentType, data: any = {}): Component {
    const Cls = this.classes.get(type);
    if (!Cls) {
        throw new Error(`[ComponentRegistry] Unknown component type: ${type}`);
    }

    // Try Pool or Instantiate
    const component = ComponentPoolManager.acquire(type) || new Cls();
    
    // Generic Hydration: Assumes 'reset' accepts a data object
    if ('reset' in component && typeof (component as any).reset === 'function') {
        (component as any).reset(data);
    }
    
    return component;
  }
}

export const ComponentRegistry = new ComponentRegistryController();


=====================================
FILE: ./src/engine/ecs/ComponentPoolManager.ts
=====================================
import { Component } from './Component';
import { ComponentType } from './ComponentType';

class ComponentPoolManagerController {
  private pools = new Map<ComponentType, Component[]>();

  public acquire<T extends Component>(type: ComponentType): T | null {
    const pool = this.pools.get(type);
    if (pool && pool.length > 0) {
      return pool.pop() as T;
    }
    return null;
  }

  public release(component: Component) {
    const type = component._type;
    if (!this.pools.has(type)) {
      this.pools.set(type, []);
    }
    this.pools.get(type)!.push(component);
  }
  
  public getStats() {
      const stats: Record<string, number> = {};
      for(const [key, pool] of this.pools) {
          stats[key] = pool.length;
      }
      return stats;
  }
}

export const ComponentPoolManager = new ComponentPoolManagerController();


=====================================
FILE: ./src/engine/ecs/Query.ts
=====================================
import { Entity } from './Entity';
import { ComponentType } from './ComponentType';

export interface QueryDef {
  all?: ComponentType[];  // Must have ALL
  any?: ComponentType[];  // Must have AT LEAST ONE
  none?: ComponentType[]; // Must NOT have any
}

export class Query {
  public readonly id: string;
  public readonly def: QueryDef;

  constructor(def: QueryDef) {
    this.def = def;
    // Generate signature. Sort ensures order independence.
    this.id = `ALL:${(def.all || []).sort().join(',')}|ANY:${(def.any || []).sort().join(',')}|NONE:${(def.none || []).sort().join(',')}`;
  }

  public matches(entity: Entity): boolean {
    if (this.def.all) {
      for (const type of this.def.all) {
        if (!entity.hasComponent(type)) return false;
      }
    }

    if (this.def.none) {
      for (const type of this.def.none) {
        if (entity.hasComponent(type)) return false;
      }
    }

    if (this.def.any && this.def.any.length > 0) {
      let hasAny = false;
      for (const type of this.def.any) {
        if (entity.hasComponent(type)) {
          hasAny = true;
          break;
        }
      }
      if (!hasAny) return false;
    }

    return true;
  }
}


=====================================
FILE: ./src/engine/ecs/SpatialGrid.ts
=====================================
import { EntityID } from './types';
import { MAX_ENTITIES, SPATIAL_GRID_SIZE, SPATIAL_CELL_SIZE } from './Constants';

// Primes for Hashing
const HASH_X = 73856093;
const HASH_Y = 19349663;

export class SpatialGrid {
  // Head of the linked list for each cell
  // cellHead[cellHash] = firstEntityId (or -1 if empty)
  private cellHead = new Int32Array(SPATIAL_GRID_SIZE);

  // Next pointer for each entity
  // entityNext[entityId] = nextEntityId (or -1 if end of list)
  private entityNext = new Int32Array(MAX_ENTITIES);

  constructor() {
    this.cellHead.fill(-1);
    this.entityNext.fill(-1);
  }

  public clear() {
    // Only reset heads. entityNext is overwritten on insert.
    this.cellHead.fill(-1);
  }

  private getHash(x: number, y: number): number {
    const cx = Math.floor(x / SPATIAL_CELL_SIZE);
    const cy = Math.floor(y / SPATIAL_CELL_SIZE);
    return ((cx * HASH_X) ^ (cy * HASH_Y)) & (SPATIAL_GRID_SIZE - 1);
  }

  public insert(id: EntityID, x: number, y: number) {
    const eid = id as number;
    // Bounds check
    if (eid >= MAX_ENTITIES || eid < 0) return;

    const hash = this.getHash(x, y);

    // Prepend to linked list
    this.entityNext[eid] = this.cellHead[hash];
    this.cellHead[hash] = eid;
  }

  /**
   * Zero-GC Query
   * Writes results into 'outArray'.
   * Returns the number of results found.
   */
  public query(x: number, y: number, radius: number, outArray: Int32Array): number {
    let count = 0;
    const max = outArray.length;
    
    // Scan range
    const startX = Math.floor((x - radius) / SPATIAL_CELL_SIZE);
    const endX = Math.floor((x + radius) / SPATIAL_CELL_SIZE);
    const startY = Math.floor((y - radius) / SPATIAL_CELL_SIZE);
    const endY = Math.floor((y + radius) / SPATIAL_CELL_SIZE);

    // To prevent duplicates if an entity spans multiple cells,
    // we strictly rely on the fact that insert() puts an entity in ONE cell (center point).
    // This implies point-based spatial hashing (buckets), not bounds-based.
    // So we check all buckets the query radius touches.
    
    for (let cy = startY; cy <= endY; cy++) {
      for (let cx = startX; cx <= endX; cx++) {
        const hash = ((cx * HASH_X) ^ (cy * HASH_Y)) & (SPATIAL_GRID_SIZE - 1);
        
        let id = this.cellHead[hash];
        
        while (id !== -1) {
          if (count < max) {
            outArray[count++] = id;
          }
          id = this.entityNext[id];
        }
      }
    }
    
    return count;
  }
}


=====================================
FILE: ./src/engine/ecs/EntityRegistry.ts
=====================================
import { EntityID, createEntityID, Tag } from './types';
import { Entity } from './Entity';
import { ObjectPool } from './ObjectPool';
import { IEntityRegistry } from '../interfaces';
import { Query, QueryDef } from './Query';
import { MAX_ENTITIES } from './Constants';

export class EntityRegistry implements IEntityRegistry {
  private entities = new Map<EntityID, Entity>();
  
  // ID Management
  private nextId = 0;
  private freeIds: number[] = []; 
  
  // OPTIMIZATION: Cache Sets of Entities directly, not IDs.
  // This avoids O(N) lookups and Array allocations during getByTag()
  private tagCache = new Map<Tag, Set<Entity>>();
  private activeQueries = new Map<string, { query: Query, results: Set<Entity> }>();
  private entityPool: ObjectPool<Entity>;

  // Reusable empty set to prevent null checks in loops
  private static readonly EMPTY_SET = new Set<Entity>();

  constructor() {
      this.entityPool = new ObjectPool<Entity>(
          () => new Entity(createEntityID(0)),
          (e) => {}, 
          1000 
      );
  }

  public createEntity(): Entity {
    let idNum: number;

    if (this.freeIds.length > 0) {
        idNum = this.freeIds.pop()!;
    } else {
        idNum = ++this.nextId;
    }

    if (idNum >= MAX_ENTITIES) {
        console.warn(`[EntityRegistry] Max Entities Reached (${MAX_ENTITIES}).`);
    }

    const newId = createEntityID(idNum);
    const entity = this.entityPool.acquire();
    entity.reset(newId);
    this.entities.set(newId, entity);
    return entity;
  }

  public destroyEntity(id: number) {
    const eid = id as EntityID;
    const entity = this.entities.get(eid);
    
    if (!entity || !entity.active) return;

    entity.active = false;
    
    this.removeFromCache(entity);
    this.entities.delete(eid);
    this.freeIds.push(id);
    
    entity.release();
    this.entityPool.release(entity);
  }

  public getEntity(id: number): Entity | undefined {
    return this.entities.get(id as EntityID);
  }

  public getAll(): IterableIterator<Entity> {
    return this.entities.values();
  }

  public getByTag(tag: string): Iterable<Entity> {
    const t = tag as Tag;
    return this.tagCache.get(t) || EntityRegistry.EMPTY_SET;
  }

  public query(def: QueryDef): Iterable<Entity> {
    // We create a temporary query object to generate the ID string
    // This is lightweight compared to array allocation
    const tempQ = new Query(def);
    let cache = this.activeQueries.get(tempQ.id);
    
    if (!cache) {
        const results = new Set<Entity>();
        const q = new Query(def); 
        for (const entity of this.entities.values()) {
            if (entity.active && q.matches(entity)) {
                results.add(entity);
            }
        }
        cache = { query: q, results };
        this.activeQueries.set(q.id, cache);
    }
    return cache.results;
  }
  
  public updateCache(entity: Entity) {
      // 1. Update Tag Cache
      for (const tag of entity.tags) {
          if (!this.tagCache.has(tag)) this.tagCache.set(tag, new Set());
          this.tagCache.get(tag)!.add(entity);
      }
      
      // 2. Update Query Cache
      for (const cache of this.activeQueries.values()) {
          if (cache.query.matches(entity)) {
              cache.results.add(entity);
          } else {
              cache.results.delete(entity);
          }
      }
  }

  private removeFromCache(entity: Entity) {
      for (const tag of entity.tags) {
          if (this.tagCache.has(tag)) {
              this.tagCache.get(tag)!.delete(entity);
          }
      }
      for (const cache of this.activeQueries.values()) {
          cache.results.delete(entity);
      }
  }

  public clear() {
      for (const entity of this.entities.values()) {
          entity.release();
          this.entityPool.release(entity);
      }
      this.entities.clear();
      this.tagCache.clear();
      this.activeQueries.clear();
      
      this.nextId = 0;
      this.freeIds = [];
  }
  
  public getStats() {
      return {
          active: this.entities.size,
          pooled: this.entityPool.availableSize,
          totalAllocated: this.entityPool.totalSize
      };
  }
}


=====================================
FILE: ./src/engine/state/GameContext.tsx
=====================================
import React, { createContext, useContext, ReactNode } from 'react';
import { IAudioService, IInputService, IGameEventService } from '@/engine/interfaces';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { AudioServiceImpl } from '@/engine/audio/AudioService';
import { InputSystem } from '@/engine/systems/InputSystem';
import { GameEventService } from '@/engine/signals/GameEventBus';

interface GameContextProps {
  audio: IAudioService;
  input: IInputService;
  events: IGameEventService;
}

// Default mock to prevent crash if accessed outside provider
const defaultContext: GameContextProps = {
  audio: new AudioServiceImpl(),
  input: new InputSystem(),
  events: new GameEventService()
};

const GameContext = createContext<GameContextProps>(defaultContext);

export const GameProvider = ({ children }: { children: ReactNode }) => {
  let audio: IAudioService;
  let input: IInputService;
  let events: IGameEventService;

  try {
      audio = ServiceLocator.getAudioService();
  } catch {
      const impl = new AudioServiceImpl();
      ServiceLocator.register('AudioService', impl);
      audio = impl;
  }

  try {
      input = ServiceLocator.getInputService();
  } catch {
      const impl = new InputSystem();
      ServiceLocator.register('InputSystem', impl);
      input = impl;
  }

  try {
      events = ServiceLocator.getGameEventBus();
  } catch {
      const impl = new GameEventService();
      ServiceLocator.register('GameEventService', impl);
      events = impl;
  }

  return (
    <GameContext.Provider value={{ audio, input, events }}>
      {children}
    </GameContext.Provider>
  );
};

export const useGameContext = () => useContext(GameContext);


=====================================
FILE: ./src/engine/state/game/slices/createProgressionSlice.ts
=====================================
import { StateCreator } from 'zustand';
import { GameState } from '../useGameStore';
import { PLAYER_CONFIG } from '@/engine/config/PlayerConfig';
import { UpgradeOption } from '@/engine/types/game.types';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';

export interface ProgressionSlice {
  score: number;
  highScore: number;
  xp: number;
  level: number;
  xpToNextLevel: number;
  upgradePoints: number;
  activeUpgrades: Record<string, number>;

  // Setters (Called by ECS)
  setScore: (val: number) => void;
  setProgressionData: (data: { xp: number, level: number, nextXp: number, points: number }) => void;
  
  // UI Actions
  selectUpgrade: (option: UpgradeOption) => void;
  resetProgressionState: () => void;
}

export const createProgressionSlice: StateCreator<GameState, [], [], ProgressionSlice> = (set) => ({
  score: 0,
  highScore: 0,
  xp: 0,
  level: 1,
  xpToNextLevel: PLAYER_CONFIG.baseXpRequirement,
  upgradePoints: 0,
  activeUpgrades: { 'RAPID_FIRE': 0, 'MULTI_SHOT': 0, 'SPEED_UP': 0, 'REPAIR_NANITES': 0 },

  setScore: (val) => set((state) => {
      // High Score logic remains here as it's a persistent data concern, not gameplay simulation
      const newHigh = Math.max(state.highScore, val);
      return { score: val, highScore: newHigh };
  }),

  setProgressionData: (data) => set({
      xp: data.xp,
      level: data.level,
      xpToNextLevel: data.nextXp,
      upgradePoints: data.points
  }),

  selectUpgrade: (option) => {
    // We just emit intent. ECS handles the logic.
    // However, for immediate UI feedback, we can optimistically update?
    // No, trust ECS.
    GameEventBus.emit(GameEvents.UPGRADE_SELECTED, { option });
  },

  resetProgressionState: () => set({
      score: 0,
      xp: 0,
      level: 1,
      xpToNextLevel: PLAYER_CONFIG.baseXpRequirement,
      upgradePoints: 0,
      activeUpgrades: { 'RAPID_FIRE': 0, 'MULTI_SHOT': 0, 'SPEED_UP': 0, 'REPAIR_NANITES': 0 }
  })
});


=====================================
FILE: ./src/engine/state/game/slices/createCombatSlice.ts
=====================================
import { StateCreator } from 'zustand';
import { GameState } from '../useGameStore';
import { PLAYER_CONFIG } from '@/engine/config/PlayerConfig';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';

export interface CombatSlice {
  isPlaying: boolean;
  isZenMode: boolean;
  playerHealth: number;
  maxPlayerHealth: number;
  playerRebootProgress: number;
  systemIntegrity: number;

  // Actions
  setPlaying: (isPlaying: boolean) => void;
  activateZenMode: () => void;
  
  // Setters (Called by ECS)
  setPlayerHealth: (val: number) => void;
  setPlayerRebootProgress: (val: number) => void;
  setSystemIntegrity: (val: number) => void;
  
  resetCombatState: () => void;
}

export const createCombatSlice: StateCreator<GameState, [], [], CombatSlice> = (set, get) => ({
  isPlaying: false,
  isZenMode: false,
  playerHealth: PLAYER_CONFIG.maxHealth,
  maxPlayerHealth: PLAYER_CONFIG.maxHealth,
  playerRebootProgress: 0,
  systemIntegrity: 100,

  setPlaying: (isPlaying) => {
      if (isPlaying) get().resetGame();
      set({ isPlaying });
  },

  activateZenMode: () => {
    set({ isZenMode: true });
    GameEventBus.emit(GameEvents.ZEN_MODE_ENABLED, null);
  },

  // DUMB SETTERS - No Logic Allowed
  setPlayerHealth: (val) => set({ playerHealth: val }),
  setPlayerRebootProgress: (val) => set({ playerRebootProgress: val }),
  setSystemIntegrity: (val) => set({ systemIntegrity: val }),

  resetCombatState: () => set({
      isPlaying: false,
      isZenMode: false,
      playerHealth: PLAYER_CONFIG.maxHealth,
      playerRebootProgress: 0,
      systemIntegrity: 100
  })
});


=====================================
FILE: ./src/engine/state/game/slices/createUISlice.ts
=====================================
import { StateCreator } from 'zustand';
import { GameState } from '../useGameStore';
import { UpgradeOption } from '@/engine/types/game.types';

const MAX_PANEL_HEALTH = 100;

export interface UISlice {
  panels: Record<string, { id: string, health: number, isDestroyed: boolean, element?: HTMLElement }>;
  interactionTarget: string | null;
  availableUpgrades: UpgradeOption[];

  registerPanel: (id: string, element: HTMLElement) => void;
  unregisterPanel: (id: string) => void;
  
  syncPanels: (panelsData: Record<string, any>) => void;
  setInteractionTarget: (id: string | null) => void; // NEW
  
  healPanel: (id: string, amount: number) => void;
  damagePanel: (id: string, amount: number) => void;
  
  resetUIState: () => void;
}

export const createUISlice: StateCreator<GameState, [], [], UISlice> = (set, get) => ({
  panels: {},
  interactionTarget: null,
  availableUpgrades: [],

  registerPanel: (id, element) => set((state) => ({
      panels: { ...state.panels, [id]: { id, element, health: MAX_PANEL_HEALTH, isDestroyed: false } }
  })),
  
  unregisterPanel: (id) => set((state) => {
      const next = { ...state.panels };
      delete next[id];
      return { panels: next };
  }),

  syncPanels: (incomingPanels) => set((state) => {
      const merged = { ...state.panels };
      for (const key in incomingPanels) {
          const prev = merged[key];
          merged[key] = { ...(prev || {}), ...incomingPanels[key] };
      }
      return { panels: merged };
  }),

  setInteractionTarget: (id) => set({ interactionTarget: id }),

  healPanel: () => {}, 
  damagePanel: () => {}, 

  resetUIState: () => {
      const { panels } = get();
      const resetPanels = Object.fromEntries(
          Object.entries(panels).map(([k, v]) => [k, { ...v, health: MAX_PANEL_HEALTH, isDestroyed: false }])
      );
      set({ 
          panels: resetPanels,
          interactionTarget: null,
          availableUpgrades: []
      });
  }
});


=====================================
FILE: ./src/engine/state/game/useGameStore.ts
=====================================
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

// Slices
import { createCombatSlice, CombatSlice } from './slices/createCombatSlice';
import { createProgressionSlice, ProgressionSlice } from './slices/createProgressionSlice';
import { createUISlice, UISlice } from './slices/createUISlice';

export type GameState = CombatSlice & ProgressionSlice & UISlice & {
  resetGame: () => void;
  startGame: () => void;
  stopGame: () => void;
};

export const useGameStore = create<GameState>()(
  persist(
    (set, get, api) => ({
      ...createCombatSlice(set, get, api),
      ...createProgressionSlice(set, get, api),
      ...createUISlice(set, get, api),

      startGame: () => {
          get().resetGame();
          get().setPlaying(true);
      },

      stopGame: () => {
          get().setPlaying(false);
      },

      resetGame: () => {
          get().resetCombatState();
          get().resetProgressionState();
          get().resetUIState();
      },
    }),
    {
      name: 'mesoelfy-os-storage-v3', 
      partialize: (state) => ({ highScore: state.highScore }), 
    }
  )
);


=====================================
FILE: ./src/engine/state/global/useStore.ts
=====================================
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { EnemyTypes } from '@/engine/config/Identifiers';

// --- TYPES ---
interface AudioSettings {
  master: boolean;
  music: boolean;
  sfx: boolean;
  ambience: boolean;
  
  volumeMaster: number;
  volumeMusic: number;
  volumeSfx: number;
  volumeAmbience: number;
  
  ambFilter: number;   
  ambSpeed: number;    
  ambWidth: number;    
  ambModSpeed: number; 
  ambModDepth: number; 

  fxReverbMix: number; 
  fxDelayMix: number;  
  fxDelayTime: number; 
  fxDelayFeedback: number; 
}

const DEFAULT_AUDIO: AudioSettings = {
  master: true,
  music: false,
  sfx: true,
  ambience: true,
  volumeMaster: 1.0,
  volumeMusic: 1.0,
  volumeSfx: 1.0,
  volumeAmbience: 1.0,
  
  ambFilter: 0.5,
  ambSpeed: 0.5,
  ambWidth: 0.5,
  ambModSpeed: 0.5, 
  ambModDepth: 0.5, 

  fxReverbMix: 0.2,     
  fxDelayMix: 0.1,      
  fxDelayTime: 0.25,    
  fxDelayFeedback: 0.3  
};

type ModalType = 'none' | 'about' | 'gallery' | 'feed' | 'contact' | 'settings';
type BootState = 'standby' | 'active' | 'sandbox' | 'mobile_lockdown';
export type SandboxView = 'lab' | 'arena' | 'gallery' | 'audio';
type GraphicsMode = 'HIGH' | 'POTATO';
export type LabExperiment = 'NONE' | 'GLITCH';

interface DebugFlags {
  godMode: boolean;
  panelGodMode: boolean;
  peaceMode: boolean;
  showHitboxes: boolean;
  timeScale: number;
}

interface AppState {
  sessionId: number; 
  bootState: BootState;
  introDone: boolean;
  isBreaching: boolean;
  activeModal: ModalType;
  hoveredItem: string | null;
  
  isSimulationPaused: boolean;
  initialClickPos: { x: number, y: number } | null;
  
  sandboxView: SandboxView;
  labExperiment: LabExperiment;
  
  galleryTarget: string;
  galleryAction: 'IDLE' | 'ATTACK' | 'SPAWN' | 'DIE';
  
  audioSettings: AudioSettings;
  graphicsMode: GraphicsMode;
  screenShakeStrength: number; 
  
  isDebugOpen: boolean;
  isDebugMinimized: boolean;
  debugFlags: DebugFlags;
  
  setBootState: (state: BootState) => void;
  setIntroDone: (done: boolean) => void;
  startBreach: () => void;
  
  setSandboxView: (view: SandboxView) => void;
  setLabExperiment: (exp: LabExperiment) => void;
  
  setGalleryTarget: (target: string) => void;
  setGalleryAction: (action: 'IDLE' | 'ATTACK' | 'SPAWN' | 'DIE') => void;
  
  openModal: (modal: ModalType) => void;
  closeModal: () => void;
  toggleSettings: () => void;
  
  setHovered: (item: string | null) => void;
  resetApplication: () => void;
  
  toggleMaster: () => void;
  toggleMusic: () => void;
  toggleSfx: () => void;
  toggleAmbience: () => void;
  setVolume: (channel: keyof AudioSettings, value: number, max?: number) => void;
  resetAudioSettings: () => void;
  
  setGraphicsMode: (mode: GraphicsMode) => void;
  setScreenShake: (val: number) => void;
  
  toggleDebugMenu: () => void;
  toggleDebugMinimize: () => void;
  setDebugFlag: (key: keyof DebugFlags, value: any) => void;
  resetDebugFlags: () => void;
  
  setSimulationPaused: (paused: boolean) => void;
  setInitialClickPos: (pos: { x: number, y: number } | null) => void;
}

export const useStore = create<AppState>()(
  persist(
    (set, get) => ({
      sessionId: 0,
      bootState: 'standby',
      introDone: false,
      isBreaching: false,
      activeModal: 'none',
      hoveredItem: null,
      
      isSimulationPaused: false,
      initialClickPos: null,
      
      sandboxView: 'lab',
      labExperiment: 'NONE',
      galleryTarget: EnemyTypes.DRILLER,
      galleryAction: 'IDLE',
      
      audioSettings: { ...DEFAULT_AUDIO },
      graphicsMode: 'HIGH',
      
      screenShakeStrength: 1.0, 
      
      isDebugOpen: false,
      isDebugMinimized: false,
      debugFlags: {
        godMode: false,
        panelGodMode: false,
        peaceMode: false,
        showHitboxes: false,
        timeScale: 1.0,
      },

      setBootState: (bs) => set({ 
          bootState: bs,
          isBreaching: bs === 'active' || bs === 'mobile_lockdown' ? false : get().isBreaching 
      }),
      setIntroDone: (done) => set({ introDone: done }),
      startBreach: () => set({ isBreaching: true }),
      
      setSandboxView: (view) => set({ sandboxView: view }),
      setLabExperiment: (exp) => set({ labExperiment: exp }),
      
      setGalleryTarget: (target) => set({ galleryTarget: target }),
      setGalleryAction: (action) => set({ galleryAction: action }),
      
      openModal: (modal) => set({ activeModal: modal }),
      closeModal: () => set({ activeModal: 'none' }),

      toggleSettings: () => {
          const current = get().activeModal;
          if (current === 'settings') get().closeModal();
          else get().openModal('settings');
      },
      
      setHovered: (item) => set({ hoveredItem: item }),
      
      resetApplication: () => {
          AudioSystem.stopAll();
          useGameStore.getState().stopGame();
          useGameStore.getState().resetGame(); 
          set(state => ({
              sessionId: state.sessionId + 1,
              bootState: 'standby',
              introDone: false,
              isBreaching: false,
              activeModal: 'none',
              isDebugOpen: false,
              isDebugMinimized: false,
              sandboxView: 'lab',
              labExperiment: 'NONE',
              galleryTarget: EnemyTypes.DRILLER,
              galleryAction: 'IDLE',
              isSimulationPaused: false,
              initialClickPos: null
          }));
      },
      
      toggleMaster: () => {
          set(s => ({ audioSettings: { ...s.audioSettings, master: !s.audioSettings.master } }));
          AudioSystem.updateVolumes();
          if (get().audioSettings.master) AudioSystem.playClick(); 
      },
      toggleMusic: () => {
          set(s => ({ audioSettings: { ...s.audioSettings, music: !s.audioSettings.music } }));
          AudioSystem.updateVolumes();
          if (get().audioSettings.music) AudioSystem.playClick();
      },
      toggleSfx: () => {
          set(s => ({ audioSettings: { ...s.audioSettings, sfx: !s.audioSettings.sfx } }));
          AudioSystem.updateVolumes();
          if (get().audioSettings.sfx) AudioSystem.playClick();
      },
      toggleAmbience: () => {
          set(s => ({ audioSettings: { ...s.audioSettings, ambience: !s.audioSettings.ambience } }));
          AudioSystem.updateVolumes();
          if (get().audioSettings.ambience) AudioSystem.playClick();
      },
      
      setVolume: (channel, value, max = 2.0) => {
          const limit = max || 2.0;
          const clamped = Math.max(0, Math.min(limit, value));
          set(s => ({ audioSettings: { ...s.audioSettings, [channel]: clamped } }));
          AudioSystem.updateVolumes();
      },
      
      resetAudioSettings: () => {
          set({ audioSettings: { ...DEFAULT_AUDIO } });
          AudioSystem.updateVolumes();
          AudioSystem.playClick();
      },
      
      setGraphicsMode: (mode) => set({ graphicsMode: mode }),
      setScreenShake: (val) => set({ screenShakeStrength: val }),
      
      toggleDebugMenu: () => set(state => ({ isDebugOpen: !state.isDebugOpen })),
      toggleDebugMinimize: () => set(state => ({ isDebugMinimized: !state.isDebugMinimized })),
      setDebugFlag: (key, value) => set(state => ({ 
          debugFlags: { ...state.debugFlags, [key]: value } 
      })),
      resetDebugFlags: () => set({
          debugFlags: { godMode: false, panelGodMode: false, peaceMode: false, showHitboxes: false, timeScale: 1.0 }
      }),
      
      setSimulationPaused: (paused) => set({ isSimulationPaused: paused }),
      setInitialClickPos: (pos) => set({ initialClickPos: pos })
    }),
    {
      name: 'mesoelfy-ui-settings-v3',
      partialize: (state) => ({ 
          audioSettings: state.audioSettings,
          screenShakeStrength: state.screenShakeStrength,
          graphicsMode: state.graphicsMode,
          introDone: state.introDone
      }), 
    }
  )
);


=====================================
FILE: ./src/engine/math/RenderUtils.ts
=====================================
import * as THREE from 'three';

// Zero-allocation reusable objects for the render loop
export const axisY = new THREE.Vector3(0, 1, 0); // Model Axis (Up)
export const axisZ = new THREE.Vector3(0, 0, 1); // World Axis (Forward/Screen)
export const qSpin = new THREE.Quaternion();
export const qAim = new THREE.Quaternion();

/**
 * Applies a local Y-axis spin and a global Z-axis aim to an object.
 */
export const applyRotation = (obj: THREE.Object3D, spin: number, aim: number) => {
  // 1. Spin around Local Y (Model Axis)
  qSpin.setFromAxisAngle(axisY, spin);
  
  // 2. Aim around World Z
  // Offset by -PI/2 because model points Up, but 0 radians is Right.
  qAim.setFromAxisAngle(axisZ, aim - Math.PI/2);
  
  // 3. Combine: Aim * Spin
  qAim.multiply(qSpin);
  
  obj.quaternion.copy(qAim);
};


=====================================
FILE: ./src/engine/math/Noise.ts
=====================================
// Simple 1D Gradient Noise
// Returns value between -1 and 1 based on input 'x'
export function noise(x: number): number {
  const i = Math.floor(x);
  const f = x - i;
  const u = f * f * (3.0 - 2.0 * f); // Cubic smoothing
  return mix(hash(i), hash(i + 1), u);
}

function hash(n: number): number {
  return (Math.sin(n) * 43758.5453) % 1.0;
}

function mix(a: number, b: number, t: number): number {
  return a * (1 - t) + b * t;
}


=====================================
FILE: ./src/engine/math/ViewportHelper.ts
=====================================
export interface WorldRect {
  id: string;
  x: number;
  y: number;
  width: number;
  height: number;
  left: number;
  right: number;
  top: number;
  bottom: number;
}

export class ViewportHelperCore {
  public viewport = { width: 1, height: 1 }; // R3F Viewport units
  public screenSize = { width: 1, height: 1 }; // Window Pixels

  public update(vpW: number, vpH: number, screenW: number, screenH: number) {
    this.viewport = { width: vpW, height: vpH };
    this.screenSize = { width: screenW, height: screenH };
  }

  // Pure Math: Converts Pixel Rect -> World Rect
  public domToWorld(id: string, domRect: DOMRect): WorldRect {
    const sw = this.screenSize.width || 1;
    const sh = this.screenSize.height || 1;
    
    const vw = this.viewport.width;
    const vh = this.viewport.height;
    
    const cx = domRect.left + domRect.width / 2;
    const cy = domRect.top + domRect.height / 2;
    
    // Screen (Pixels) -> World (Orthographic Units)
    // 0,0 is center of screen in World
    const wx = (cx / sw) * vw - (vw / 2);
    const wy = -((cy / sh) * vh - (vh / 2));
    
    const wWidth = (domRect.width / sw) * vw;
    const wHeight = (domRect.height / sh) * vh;

    return {
      id: id,
      x: wx, y: wy,
      width: wWidth, height: wHeight,
      left: wx - wWidth / 2, right: wx + wWidth / 2,
      top: wy + wHeight / 2, bottom: wy - wHeight / 2,
    };
  }
}

export const ViewportHelper = new ViewportHelperCore();


=====================================
FILE: ./src/engine/math/GeometryUtils.ts
=====================================
import * as THREE from 'three';

export const addBarycentricCoordinates = (bufferGeometry: THREE.BufferGeometry) => {
  // Only convert if it's indexed to avoid Three.js console warnings
  const geometry = bufferGeometry.index ? bufferGeometry.toNonIndexed() : bufferGeometry.clone();
  
  const count = geometry.attributes.position.count;
  const centers = new Float32Array(count * 3);

  for (let i = 0; i < count; i += 3) {
    centers[i * 3] = 1;
    centers[i * 3 + 1] = 0;
    centers[i * 3 + 2] = 0;

    centers[i * 3 + 3] = 0;
    centers[i * 3 + 4] = 1;
    centers[i * 3 + 5] = 0;

    centers[i * 3 + 6] = 0;
    centers[i * 3 + 7] = 0;
    centers[i * 3 + 8] = 1;
  }

  geometry.setAttribute('barycentric', new THREE.BufferAttribute(centers, 3));
  return geometry;
};

export const createHunterSpear = () => {
  const positions: number[] = [];
  const numWings = 3;
  const length = 1.2;
  const wingWidth = 0.4;
  const wingThickness = 0.05;

  for(let i=0; i<numWings; i++) {
      const angle = (i / numWings) * Math.PI * 2;
      const tipY = length / 2;
      const baseY = -length / 2;
      const pTip = [0, tipY, 0];
      const pBaseOut = [wingWidth, baseY, 0];
      const pBaseInBack = [0, baseY, -wingThickness];
      const pBaseInFront = [0, baseY, wingThickness];
      
      const rotateY = (p: number[], rad: number) => [
          p[0] * Math.cos(rad) - p[2] * Math.sin(rad),
          p[1],
          p[0] * Math.sin(rad) + p[2] * Math.cos(rad)
      ];

      let v1 = rotateY(pTip, angle);
      let v2 = rotateY(pBaseOut, angle);
      let v3 = rotateY(pBaseInFront, angle);
      positions.push(...v1, ...v2, ...v3);
      
      v1 = rotateY(pTip, angle);
      v2 = rotateY(pBaseInBack, angle);
      v3 = rotateY(pBaseOut, angle);
      positions.push(...v1, ...v2, ...v3);
  }
  
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  geometry.computeVertexNormals();
  return addBarycentricCoordinates(geometry);
};


=====================================
FILE: ./src/engine/math/coords.ts
=====================================
// Camera Zoom level defined in GameOverlay
const ZOOM = 40; 

export const screenToWorld = (screenX: number, screenY: number, screenW: number, screenH: number) => {
  // DOM: 0,0 is Top-Left. +Y is Down.
  // THREE: 0,0 is Center. +Y is Up.
  
  const worldX = (screenX - screenW / 2) / ZOOM;
  const worldY = -(screenY - screenH / 2) / ZOOM; // Invert Y
  
  return { x: worldX, y: worldY };
};

export const domRectToWorldRect = (rect: { x: number, y: number, width: number, height: number }, screenW: number, screenH: number) => {
  // Get center of DOM element
  const centerX = rect.x + rect.width / 2;
  const centerY = rect.y + rect.height / 2;
  
  const centerWorld = screenToWorld(centerX, centerY, screenW, screenH);
  
  return {
    x: centerWorld.x,
    y: centerWorld.y,
    width: rect.width / ZOOM,
    height: rect.height / ZOOM,
    left: centerWorld.x - (rect.width / ZOOM / 2),
    right: centerWorld.x + (rect.width / ZOOM / 2),
    top: centerWorld.y + (rect.height / ZOOM / 2),
    bottom: centerWorld.y - (rect.height / ZOOM / 2),
  };
};


=====================================
FILE: ./src/engine/audio/AudioService.ts
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { AUDIO_CONFIG } from '@/engine/config/AudioConfig';
import { IAudioService } from '@/engine/interfaces';
import { AudioContextManager } from './modules/AudioContextManager';
import { AudioSynthesizer } from './modules/AudioSynthesizer';
import { AudioMixer } from './modules/AudioMixer';
import { SoundBank } from './modules/SoundBank';
import { VoiceManager } from './modules/VoiceManager';
import { AudioKey } from '@/engine/config/AssetKeys';

export class AudioServiceImpl implements IAudioService {
  private ctxManager = new AudioContextManager();
  private mixer = new AudioMixer(this.ctxManager);
  private bank = new SoundBank();
  private voices = new VoiceManager(this.ctxManager, this.bank, this.mixer);
  
  public isReady = false;
  private hasInteracted = false; 

  public async init() {
    if (this.isReady) { this.ctxManager.resume(); return; }
    const ctx = this.ctxManager.init();
    if (!ctx) return;

    this.mixer.init();
    this.updateVolumes();
    await this.generateAllSounds();
    this.setupGlobalInteraction();
    this.isReady = true;
  }

  private async generateAllSounds() {
      const promises = Object.entries(AUDIO_CONFIG).map(([key, recipe]) => {
          return AudioSynthesizer.generate(recipe).then(buffer => {
              if (buffer) this.bank.add(key, buffer);
          });
      });
      await Promise.all(promises);
  }

  private setupGlobalInteraction() {
      const wakeUp = () => {
          if (this.hasInteracted) return;
          this.hasInteracted = true; 
          this.ctxManager.resume();
          // Auto-start core ambience on first interaction
          this.playAmbience('ambience_core');
          window.removeEventListener('pointerdown', wakeUp);
          window.removeEventListener('keydown', wakeUp);
      };
      window.addEventListener('pointerdown', wakeUp);
      window.addEventListener('keydown', wakeUp);
  }

  public updateVolumes() {
      this.mixer.updateVolumes(useStore.getState().audioSettings);
  }

  public playSound(key: AudioKey, pan: number = 0) {
      this.voices.playSFX(key, pan);
  }

  public playAmbience(key: AudioKey) {
      this.voices.playAmbience(key);
  }

  public startMusic() {
    this.ctxManager.resume();
    if (this.isReady) {
        this.playAmbience('ambience_core');
        this.voices.startMusic('/assets/audio/bg_music_placeholder.mp3');
    }
  }
  
  public duckMusic(intensity: number, duration: number) { 
      this.mixer.duckMusic(intensity, duration); 
  }
  
  public getFrequencyData(array: Uint8Array) { 
      this.mixer.getByteFrequencyData(array); 
  }
  
  public stopAll() {
      this.voices.stopAll();
  }

  public playClick(pan: number = 0) { this.playSound('ui_click', pan); }
  public playHover(pan: number = 0) { this.playSound('ui_hover', pan); }
  public playBootSequence() { this.playSound('fx_boot_sequence'); } 
  public playDrillSound() { this.playSound('loop_drill'); }
  public playRebootZap() { this.playSound('loop_reboot'); }
}


=====================================
FILE: ./src/engine/audio/AudioUtils.ts
=====================================
import { MouseEvent as ReactMouseEvent } from 'react';

/**
 * Calculates stereo pan value (-1.0 to 1.0) based on mouse X position.
 * Handles both React Synthetic Events and Native DOM Events.
 */
export const getPan = (e: ReactMouseEvent | MouseEvent | TouchEvent): number => {
  if (typeof window === 'undefined') return 0;
  
  let clientX = 0;
  
  if ('touches' in e && e.touches.length > 0) {
      clientX = e.touches[0].clientX;
  } else if ('clientX' in e) {
      clientX = (e as MouseEvent).clientX;
  } else {
      return 0;
  }

  const width = window.innerWidth;
  if (width === 0) return 0;

  // Normalize: 0 to 1
  const normalized = clientX / width;
  
  // Map: -1 to 1
  const pan = (normalized * 2) - 1;
  
  // Clamp for safety
  return Math.max(-1, Math.min(1, pan));
};


=====================================
FILE: ./src/engine/audio/AudioMath.ts
=====================================
/**
 * AUDIO MATH LIBRARY
 */

export const getAmbienceFilterHz = (val: number): number => {
  return 300 * Math.pow(10, (val - 0.5) * 2);
};

export const getAmbiencePanFreq = (val: number): number => {
  return 0.05 * Math.pow(20, (val - 0.5) * 2);
};

export const getAmbienceModFreq = (val: number): number => {
  return 0.2 * Math.pow(30, (val - 0.5) * 2);
};

export const getAmbienceModDepth = (val: number): number => {
  return 10 * Math.pow(20, (val - 0.5) * 2);
};

export const getAmbienceStereoGain = (val: number): number => {
  return Math.pow(val, 3) * 0.8;
};

export const getAmbienceDistortion = (val: number): number => {
  return val * 400;
};

/**
 * Generates a synthetic impulse response for reverb.
 * Creates a "Metallic/Digital" decay sound.
 */
export const generateImpulseResponse = (ctx: AudioContext, duration: number = 2.0, decay: number = 2.0, reverse: boolean = false): AudioBuffer => {
  const sampleRate = ctx.sampleRate;
  const length = sampleRate * duration;
  const impulse = ctx.createBuffer(2, length, sampleRate);
  
  const left = impulse.getChannelData(0);
  const right = impulse.getChannelData(1);

  for (let i = 0; i < length; i++) {
    const n = reverse ? length - i : i;
    // Exponential decay
    const e = Math.pow(1 - n / length, decay);
    
    // Noise burst
    left[i] = (Math.random() * 2 - 1) * e;
    right[i] = (Math.random() * 2 - 1) * e;
  }

  return impulse;
};


=====================================
FILE: ./src/engine/audio/AudioSystem.ts
=====================================
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { IAudioService } from '@/engine/interfaces';
import { AudioServiceImpl } from './AudioService';

class AudioSystemFacade implements IAudioService {
  
  private get service(): IAudioService {
    try {
      return ServiceLocator.getAudioService();
    } catch (e) {
      // Lazy Initialization
      const impl = new AudioServiceImpl();
      ServiceLocator.register('AudioService', impl);
      return impl;
    }
  }

  public async init() { return this.service.init(); }
  public startMusic() { this.service.startMusic(); }
  public stopAll() { this.service.stopAll(); }
  public updateVolumes() { this.service.updateVolumes(); }
  
  public playSound(key: string, pan?: number) { this.service.playSound(key, pan); }
  public playAmbience(key: string) { this.service.playAmbience(key); }
  public duckMusic(intensity: number, duration: number) { this.service.duckMusic(intensity, duration); }
  public getFrequencyData(array: Uint8Array) { this.service.getFrequencyData(array); }
  
  public playClick(pan?: number) { this.service.playClick(pan); }
  public playHover(pan?: number) { this.service.playHover(pan); }
  public playBootSequence() { this.service.playBootSequence(); }
  public playDrillSound() { this.service.playDrillSound(); }
  public playRebootZap() { this.service.playRebootZap(); }
}

export const AudioSystem = new AudioSystemFacade();


=====================================
FILE: ./src/engine/audio/hooks/useAudioVisualizer.ts
=====================================
import { useEffect, useRef } from 'react';
import { AudioSystem } from '../AudioSystem';

/**
 * Hooks into the AnalyserNode and returns a ref to the data buffer.
 * It does NOT trigger re-renders. Use requestAnimationFrame in your component to read it.
 */
export const useAudioVisualizer = (fftSize: number = 32) => {
  const dataRef = useRef(new Uint8Array(fftSize));
  const active = useRef(true);

  useEffect(() => {
    active.current = true;
    
    const loop = () => {
      if (!active.current) return;
      AudioSystem.getFrequencyData(dataRef.current);
      requestAnimationFrame(loop);
    };
    
    loop();

    return () => {
      active.current = false;
    };
  }, []);

  // Return the buffer itself so components can read it
  return dataRef;
};


=====================================
FILE: ./src/engine/audio/AudioDirector.ts
=====================================
import { IGameSystem, IPanelSystem, IGameEventService, IFastEventService, IAudioService } from '@/engine/interfaces';
import { GameEvents } from '@/engine/signals/GameEvents';
import { FastEvents, FX_ID_MAP, ENEMY_ID_MAP } from '@/engine/signals/FastEventBus';
import { ViewportHelper } from '@/engine/math/ViewportHelper';
import { EventReader } from '@/engine/signals/EventReader';
import { AudioKey } from '@/engine/config/AssetKeys';

export class AudioDirector implements IGameSystem {
  private logTimer = 0;
  private reader: EventReader;
  
  constructor(
    private panelSystem: IPanelSystem,
    private events: IGameEventService,
    fastEvents: IFastEventService,
    private audio: IAudioService
  ) {
    this.reader = new EventReader(fastEvents);
    this.setupEventListeners();
  }

  update(delta: number, time: number): void {
    this.logTimer += delta;

    this.reader.process((id, a1, a2, a3, a4) => {
        // 1. Explicit Play Sound Command
        if (id === FastEvents.PLAY_SOUND) {
            const key = FX_ID_MAP[a1];
            if (key) {
                // Key from map is uppercase 'FX_FOO', audio config is 'fx_foo'
                this.audio.playSound(key.toLowerCase() as AudioKey, this.calculatePan(a2));
            }
        }
        
        // 2. Player Fired
        else if (id === FastEvents.PLAYER_FIRED) {
            // a1 = x
            this.audio.playSound('fx_player_fire', this.calculatePan(a1));
        }

        // 3. Enemy Destroyed
        else if (id === FastEvents.ENEMY_DESTROYED) {
            // a2=x, a4=typeId
            const pan = this.calculatePan(a2);
            if (a4 === ENEMY_ID_MAP['kamikaze']) {
                this.audio.playSound('fx_impact_heavy', pan);
            } else {
                this.audio.playSound('fx_impact_light', pan);
            }
        }

        // 4. Player Hit
        else if (id === FastEvents.PLAYER_HIT) {
            this.audio.playSound('fx_impact_heavy', 0);
            this.audio.duckMusic(0.7, 1.0);
        }
    });
  }

  private setupEventListeners() {
    this.events.subscribe(GameEvents.PANEL_HEALED, (p) => {
        const pan = this.getPanelPan(p.id);
        this.audio.playSound('loop_heal', pan);
    });

    this.events.subscribe(GameEvents.PANEL_RESTORED, (p) => {
        const pan = p.x !== undefined ? this.calculatePan(p.x) : this.getPanelPan(p.id);
        this.audio.playSound('fx_reboot_success', pan);
    });

    this.events.subscribe(GameEvents.PANEL_DESTROYED, (p) => {
        const pan = this.getPanelPan(p.id);
        this.audio.playSound('fx_impact_heavy', pan); 
        this.audio.duckMusic(0.8, 1.5);
    });

    this.events.subscribe(GameEvents.GAME_OVER, () => {
        this.audio.playSound('fx_impact_heavy');
        this.audio.duckMusic(1.0, 3.0);
    });

    this.events.subscribe(GameEvents.UPGRADE_SELECTED, () => {
        this.audio.playSound('fx_level_up');
    });
  }

  private calculatePan(worldX: number): number {
      const halfWidth = ViewportHelper.viewport.width / 2;
      if (halfWidth === 0) return 0;
      return Math.max(-1, Math.min(1, worldX / halfWidth));
  }

  private getPanelPan(panelId: string): number {
      const rect = this.panelSystem.getPanelRect(panelId);
      if (!rect) return 0;
      return this.calculatePan(rect.x);
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/audio/modules/AudioMixer.ts
=====================================
import { AudioContextManager } from './AudioContextManager';
import { 
  getAmbienceFilterHz, getAmbiencePanFreq, getAmbienceModFreq, 
  getAmbienceModDepth, getAmbienceStereoGain, generateImpulseResponse
} from '../AudioMath';

export class AudioMixer {
  public masterGain!: GainNode;
  public sfxGain!: GainNode;
  public musicGain!: GainNode;
  public ambienceGain!: GainNode;
  public compressor!: DynamicsCompressorNode;
  public analyser!: AnalyserNode;

  private reverbNode!: ConvolverNode;
  private reverbSend!: GainNode;
  private delayNode!: DelayNode;
  private delayFeedback!: GainNode;
  private delaySend!: GainNode;
  private ambiencePanner!: StereoPannerNode;
  private ambiencePanConstraint!: GainNode;
  private ambienceLFO!: OscillatorNode;
  private ambienceFilter!: BiquadFilterNode;
  private ambienceDepthLFO!: OscillatorNode;
  private ambienceDepthGain!: GainNode;

  private ctxManager: AudioContextManager;
  private _targetMusicVol: number = 0;
  private _isMusicMuted: boolean = true;

  constructor(manager: AudioContextManager) {
    this.ctxManager = manager;
  }

  public init() {
    const ctx = this.ctxManager.ctx;
    if (!ctx) return;

    this.masterGain = ctx.createGain();
    this.sfxGain = ctx.createGain();
    this.musicGain = ctx.createGain();
    this.ambienceGain = ctx.createGain();
    this.compressor = ctx.createDynamicsCompressor();
    this.analyser = ctx.createAnalyser();

    this.compressor.threshold.value = -12; this.compressor.knee.value = 30;       
    this.compressor.ratio.value = 12; this.compressor.attack.value = 0.003;  
    this.compressor.release.value = 0.25; this.analyser.fftSize = 64; 
    this.analyser.smoothingTimeConstant = 0.8;

    this.reverbNode = ctx.createConvolver();
    this.reverbNode.buffer = generateImpulseResponse(ctx, 1.5, 2.0);
    this.reverbSend = ctx.createGain(); 
    this.delayNode = ctx.createDelay(1.0);
    this.delayFeedback = ctx.createGain();
    this.delaySend = ctx.createGain(); 

    this.delayNode.connect(this.delayFeedback);
    this.delayFeedback.connect(this.delayNode);
    this.delayNode.connect(this.masterGain);
    this.reverbNode.connect(this.masterGain);

    this.musicGain.connect(this.masterGain);
    this.sfxGain.connect(this.masterGain);
    this.sfxGain.connect(this.reverbSend);
    this.sfxGain.connect(this.delaySend);
    this.reverbSend.connect(this.reverbNode);
    this.delaySend.connect(this.delayNode);
    this.masterGain.connect(this.compressor);
    this.compressor.connect(this.analyser);
    this.analyser.connect(ctx.destination);

    this.ambiencePanner = ctx.createStereoPanner();
    this.ambienceFilter = ctx.createBiquadFilter();
    this.ambienceLFO = ctx.createOscillator();
    this.ambiencePanConstraint = ctx.createGain();
    this.ambienceDepthLFO = ctx.createOscillator();
    this.ambienceDepthGain = ctx.createGain();

    this.ambienceGain.connect(this.ambienceFilter);
    this.ambienceFilter.connect(this.ambiencePanner); 
    this.ambiencePanner.connect(this.masterGain);
    this.ambienceLFO.type = 'sine';
    this.ambienceLFO.connect(this.ambiencePanConstraint);
    this.ambiencePanConstraint.connect(this.ambiencePanner.pan);
    this.ambienceFilter.type = 'lowpass';
    this.ambienceDepthLFO.type = 'sine';
    this.ambienceDepthLFO.connect(this.ambienceDepthGain);
    this.ambienceDepthGain.connect(this.ambienceFilter.frequency);
    this.ambienceLFO.start(); this.ambienceDepthLFO.start();
  }

  public updateVolumes(settings: any) {
    if (!this.masterGain) return;
    this._isMusicMuted = !settings.music;
    this._targetMusicVol = this._isMusicMuted ? 0 : (settings.volumeMusic * 0.4);
    this.masterGain.gain.value = settings.master ? (settings.volumeMaster * 0.5) : 0;
    this.musicGain.gain.cancelScheduledValues(this.ctxManager.ctx!.currentTime);
    this.musicGain.gain.value = this._targetMusicVol;
    this.sfxGain.gain.value = settings.sfx ? (settings.volumeSfx * 0.8) : 0;
    this.ambienceGain.gain.value = settings.ambience ? settings.volumeAmbience : 0.0;

    this.ambienceFilter.frequency.value = getAmbienceFilterHz(settings.ambFilter ?? 0.5);
    this.ambienceLFO.frequency.value = getAmbiencePanFreq(settings.ambSpeed ?? 0.5);
    this.ambiencePanConstraint.gain.value = getAmbienceStereoGain(settings.ambWidth ?? 0.5);
    this.ambienceDepthLFO.frequency.value = getAmbienceModFreq(settings.ambModSpeed ?? 0.5);
    this.ambienceDepthGain.gain.value = getAmbienceModDepth(settings.ambModDepth ?? 0.5);

    if (this.reverbSend) {
        this.reverbSend.gain.value = settings.fxReverbMix ?? 0.2;
        this.delaySend.gain.value = settings.fxDelayMix ?? 0.1;
        this.delayNode.delayTime.value = 0.1 + ((Number.isFinite(settings.fxDelayTime) ? settings.fxDelayTime : 0.25) * 0.9);
        this.delayFeedback.gain.value = settings.fxDelayFeedback ?? 0.3;
    }
  }

  public duckMusic(intensity: number, duration: number) {
    if (!this.musicGain || this._isMusicMuted) return;
    const ctx = this.ctxManager.ctx;
    const baseVol = this._targetMusicVol;
    if (!ctx || baseVol < 0.001) return;
    const now = ctx.currentTime;
    const targetVol = Math.max(0, baseVol * (1.0 - intensity));
    this.musicGain.gain.cancelScheduledValues(now);
    this.musicGain.gain.setValueAtTime(this.musicGain.gain.value, now);
    this.musicGain.gain.linearRampToValueAtTime(targetVol, now + 0.05);
    this.musicGain.gain.exponentialRampToValueAtTime(baseVol, now + duration);
  }
  
  public getByteFrequencyData(array: Uint8Array) { if (this.analyser) this.analyser.getByteFrequencyData(array); }
}


=====================================
FILE: ./src/engine/audio/modules/VoiceManager.ts
=====================================
import { AudioContextManager } from './AudioContextManager';
import { SoundBank } from './SoundBank';
import { AudioMixer } from './AudioMixer';
import { AudioKey } from '@/engine/config/AssetKeys';
import { AUDIO_CONFIG } from '@/engine/config/AudioConfig';

// Increased buffer to handle bullet hell density
const MAX_POLYPHONY = 100;

export class VoiceManager {
  private activeCount = 0;
  
  // Ambience State
  private currentAmbienceNode: AudioBufferSourceNode | null = null;
  private currentAmbienceGain: GainNode | null = null; 
  private currentAmbienceKey: string | null = null;
  
  // Music State
  private musicElement: HTMLAudioElement | null = null;

  constructor(
    private ctxManager: AudioContextManager,
    private bank: SoundBank,
    private mixer: AudioMixer
  ) {}

  public playSFX(key: AudioKey, pan: number = 0) {
    // 1. Polyphony Check
    if (this.activeCount >= MAX_POLYPHONY) return;

    const ctx = this.ctxManager.ctx;
    const buffer = this.bank.get(key);
    const recipe = AUDIO_CONFIG[key];
    
    if (!ctx || !this.mixer.sfxGain || !buffer || !recipe) return;

    // 2. Node Creation
    const source = ctx.createBufferSource();
    source.buffer = buffer;
    
    // Pitch Variance
    if (recipe.pitchVariance > 0) {
        source.detune.value = (Math.random() * recipe.pitchVariance * 2) - recipe.pitchVariance;
    }

    // 3. Routing
    const panner = ctx.createStereoPanner();
    panner.pan.value = Math.max(-1, Math.min(1, Number.isFinite(pan) ? pan : 0));

    source.connect(panner);
    panner.connect(this.mixer.sfxGain);

    // 4. Execution & Cleanup
    source.onended = () => {
        this.activeCount--;
    };
    
    this.activeCount++;
    source.start();
  }

  public playAmbience(key: AudioKey) {
    const ctx = this.ctxManager.ctx;
    if (!ctx || !this.mixer.ambienceGain) return;
    
    // Dedup check
    if (this.currentAmbienceKey === key && this.currentAmbienceNode) return;

    // Fade Out Old
    if (this.currentAmbienceNode && this.currentAmbienceGain) {
        const oldGain = this.currentAmbienceGain;
        const oldNode = this.currentAmbienceNode;
        
        // Ramp down
        try {
            oldGain.gain.cancelScheduledValues(ctx.currentTime);
            oldGain.gain.setValueAtTime(oldGain.gain.value, ctx.currentTime);
            oldGain.gain.linearRampToValueAtTime(0, ctx.currentTime + 1.0);
            oldNode.stop(ctx.currentTime + 1.1);
        } catch {}
    }

    const buffer = this.bank.get(key);
    if (!buffer) return;

    // Create New
    const source = ctx.createBufferSource();
    source.buffer = buffer; 
    source.loop = true;
    
    const fadeGain = ctx.createGain();
    fadeGain.gain.setValueAtTime(0, ctx.currentTime);
    fadeGain.gain.linearRampToValueAtTime(1.0, ctx.currentTime + 2.0); 
    
    source.connect(fadeGain); 
    fadeGain.connect(this.mixer.ambienceGain); 
    source.start();
    
    this.currentAmbienceNode = source; 
    this.currentAmbienceGain = fadeGain; 
    this.currentAmbienceKey = key;
  }

  public startMusic(url: string) {
    const ctx = this.ctxManager.ctx;
    if (!ctx || !this.mixer.musicGain || this.musicElement) return;

    this.musicElement = new Audio(url);
    this.musicElement.loop = true; 
    this.musicElement.crossOrigin = "anonymous";
    
    const source = ctx.createMediaElementSource(this.musicElement);
    source.connect(this.mixer.musicGain);
    
    this.musicElement.play().catch(() => console.warn("[Audio] Autoplay blocked"));
  }

  public stopAll() {
    if (this.musicElement) { 
        this.musicElement.pause(); 
        this.musicElement.currentTime = 0; 
    }
    
    if (this.currentAmbienceNode) { 
        try { this.currentAmbienceNode.stop(); } catch {} 
        this.currentAmbienceNode = null; 
        this.currentAmbienceGain = null;
        this.currentAmbienceKey = null; 
    }
    
    this.activeCount = 0;
  }
}


=====================================
FILE: ./src/engine/audio/modules/AudioSynthesizer.ts
=====================================
import { SoundRecipe } from '@/engine/config/AudioConfig';

export class AudioSynthesizer {
  
  public static async generate(recipe: SoundRecipe): Promise<AudioBuffer | null> {
    // Requires window to be present for OfflineAudioContext
    if (typeof window === 'undefined') return null;

    // Standard AudioContext or Webkit prefix
    const AudioContextClass = (window as any).AudioContext || (window as any).webkitAudioContext;
    if (!AudioContextClass) return null;

    // Use OfflineContext for rendering
    const OfflineContextClass = (window as any).OfflineAudioContext || (window as any).webkitOfflineAudioContext;
    if (!OfflineContextClass) return null;

    const sampleRate = 44100;
    // Ensure integer length
    const length = Math.ceil(sampleRate * recipe.duration);
    
    if (length <= 0) return null;

    const offline = new OfflineContextClass(1, length, sampleRate);

    const mainGain = offline.createGain();
    mainGain.connect(offline.destination);
    
    const attack = recipe.attack || 0.005; 
    
    // Envelope: Attack
    mainGain.gain.setValueAtTime(0, 0);
    mainGain.gain.linearRampToValueAtTime(recipe.volume, attack);
    
    // Envelope: Decay/Sustain
    if (recipe.duration < 10.0) {
        mainGain.gain.exponentialRampToValueAtTime(0.01, recipe.duration);
    } else {
        mainGain.gain.setValueAtTime(recipe.volume, recipe.duration);
    }

    let outputNode: AudioNode = mainGain;

    // 1. Distortion
    if (recipe.distortion) {
        const shaper = offline.createWaveShaper();
        shaper.curve = this.makeDistortionCurve(recipe.distortion);
        shaper.connect(outputNode);
        outputNode = shaper; 
    }

    // 2. Tremolo
    if (recipe.tremolo) {
        const tremoloNode = offline.createGain();
        tremoloNode.connect(outputNode);
        outputNode = tremoloNode;

        const lfo = offline.createOscillator();
        lfo.type = recipe.tremolo.wave || 'sine';
        lfo.frequency.value = recipe.tremolo.rate;
        
        const lfoGain = offline.createGain();
        lfoGain.gain.value = recipe.tremolo.depth; 
        
        tremoloNode.gain.value = 1.0 - (recipe.tremolo.depth / 2);
        lfo.connect(lfoGain);
        lfoGain.connect(tremoloNode.gain);
        
        lfo.start();
    }

    // 3. Source Generation
    if (recipe.type === 'oscillator') {
        const osc = offline.createOscillator();
        osc.type = recipe.wave || 'sine';
        osc.frequency.setValueAtTime(recipe.frequency[0], 0);
        if (recipe.frequency[1] !== recipe.frequency[0]) {
            osc.frequency.exponentialRampToValueAtTime(recipe.frequency[1], recipe.duration);
        }

        if (recipe.fm) {
           const modOsc = offline.createOscillator();
           const modGain = offline.createGain();
           modOsc.type = recipe.fm.modType;
           modOsc.frequency.value = recipe.fm.modFreq;
           modGain.gain.value = recipe.fm.modIndex;
           modOsc.connect(modGain);
           modGain.connect(osc.frequency); 
           modOsc.start();
        }

        osc.connect(outputNode);
        osc.start();
    } 
    else if (recipe.type === 'noise') {
        const bufferSize = length;
        const noiseBuffer = offline.createBuffer(1, bufferSize, sampleRate);
        const data = noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = offline.createBufferSource();
        noise.buffer = noiseBuffer;

        if (recipe.filter) {
            const filter = offline.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(recipe.filter[0], 0);
            filter.frequency.exponentialRampToValueAtTime(recipe.filter[1], recipe.duration);
            noise.connect(filter);
            filter.connect(outputNode);
        } else {
            noise.connect(outputNode);
        }
        noise.start();
    }

    return await offline.startRendering();
  }

  private static makeDistortionCurve(amount: number) {
    const k = typeof amount === 'number' ? amount : 50;
    const n_samples = 44100;
    const curve = new Float32Array(n_samples);
    const deg = Math.PI / 180;
    for (let i = 0; i < n_samples; ++i) {
      const x = (i * 2) / n_samples - 1;
      curve[i] = ((3 + k) * x * 20 * deg) / (Math.PI + k * Math.abs(x));
    }
    return curve;
  }
}


=====================================
FILE: ./src/engine/audio/modules/SoundBank.ts
=====================================
export class SoundBank {
  private buffers = new Map<string, AudioBuffer>();

  public add(key: string, buffer: AudioBuffer) {
    this.buffers.set(key, buffer);
  }

  public get(key: string): AudioBuffer | undefined {
    return this.buffers.get(key);
  }

  public has(key: string): boolean {
    return this.buffers.has(key);
  }
}


=====================================
FILE: ./src/engine/audio/modules/AudioContextManager.ts
=====================================
export class AudioContextManager {
  private _ctx: AudioContext | null = null;

  public get ctx(): AudioContext | null {
    return this._ctx;
  }

  public init(): AudioContext | null {
    if (this._ctx) return this._ctx;
    
    if (typeof window === 'undefined') return null;

    const AudioContextClass = (window as any).AudioContext || (window as any).webkitAudioContext;
    if (!AudioContextClass) return null;

    this._ctx = new AudioContextClass();
    return this._ctx;
  }

  public async resume() {
    if (this._ctx && this._ctx.state === 'suspended') {
      try {
        await this._ctx.resume();
      } catch (e) {
        console.warn('[AudioContext] Resume failed:', e);
      }
    }
  }

  public get currentTime(): number {
    return this._ctx ? this._ctx.currentTime : 0;
  }
}


=====================================
FILE: ./src/engine/ai/behavior/decorators.ts
=====================================
import { BTNode, NodeState } from './types';
import { Entity } from '@/engine/ecs/Entity';
import { AIContext } from '@/engine/handlers/ai/types';

export class Inverter extends BTNode {
  constructor(private child: BTNode) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const status = this.child.tick(entity, context);
    if (status === NodeState.SUCCESS) return NodeState.FAILURE;
    if (status === NodeState.FAILURE) return NodeState.SUCCESS;
    return NodeState.RUNNING;
  }
}

export class Succeeder extends BTNode {
  constructor(private child: BTNode) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const status = this.child.tick(entity, context);
    if (status === NodeState.RUNNING) return NodeState.RUNNING;
    return NodeState.SUCCESS;
  }
}


=====================================
FILE: ./src/engine/ai/behavior/types.ts
=====================================
import { Entity } from '@/engine/ecs/Entity';
import { AIContext } from '@/engine/handlers/ai/types';

export enum NodeState {
  SUCCESS = 'SUCCESS',
  FAILURE = 'FAILURE',
  RUNNING = 'RUNNING'
}

export abstract class BTNode {
  abstract tick(entity: Entity, context: AIContext): NodeState;
}


=====================================
FILE: ./src/engine/ai/behavior/composites.ts
=====================================
import { BTNode, NodeState } from './types';
import { Entity } from '@/engine/ecs/Entity';
import { AIContext } from '@/engine/handlers/ai/types';

/**
 * Runs children in order. 
 * Returns RUNNING if a child is running.
 * Returns FAILURE if a child fails (and stops).
 * Returns SUCCESS if all children succeed.
 */
export class Sequence extends BTNode {
  constructor(private children: BTNode[]) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    for (const child of this.children) {
      const status = child.tick(entity, context);
      if (status !== NodeState.SUCCESS) {
        return status;
      }
    }
    return NodeState.SUCCESS;
  }
}

/**
 * Runs children in order.
 * Returns SUCCESS if a child succeeds (and stops).
 * Returns RUNNING if a child is running.
 * Returns FAILURE if all children fail.
 */
export class Selector extends BTNode {
  constructor(private children: BTNode[]) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    for (const child of this.children) {
      const status = child.tick(entity, context);
      if (status !== NodeState.FAILURE) {
        return status;
      }
    }
    return NodeState.FAILURE;
  }
}

/**
 * Runs ALL children every tick.
 * Returns FAILURE if any child fails.
 * Returns RUNNING if any child is running.
 * Returns SUCCESS if all children succeed.
 */
export class Parallel extends BTNode {
  constructor(private children: BTNode[]) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    let anyRunning = false;

    for (const child of this.children) {
      const status = child.tick(entity, context);
      
      if (status === NodeState.FAILURE) {
        return NodeState.FAILURE;
      }
      
      if (status === NodeState.RUNNING) {
        anyRunning = true;
      }
    }

    return anyRunning ? NodeState.RUNNING : NodeState.SUCCESS;
  }
}

/**
 * Stateful Sequence (Memory Sequence).
 * Remembers the running child index and resumes from there.
 * Resets index to 0 only when the whole sequence Succeeds or Fails.
 */
export class MemSequence extends BTNode {
  constructor(private children: BTNode[], private id: string) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const state = entity.getComponent<any>('State'); // Generic access
    if (!state) return NodeState.FAILURE;

    // Initialize Tree State if missing
    if (!state.treeState) state.treeState = {};
    
    // Get running index (default 0)
    let startIndex = state.treeState[this.id] || 0;

    for (let i = startIndex; i < this.children.length; i++) {
      const child = this.children[i];
      const status = child.tick(entity, context);

      if (status === NodeState.RUNNING) {
        state.treeState[this.id] = i; // Remember this child is running
        return NodeState.RUNNING;
      }

      if (status === NodeState.FAILURE) {
        state.treeState[this.id] = 0; // Reset on failure
        return NodeState.FAILURE;
      }
    }

    // All children succeeded
    state.treeState[this.id] = 0; // Reset on success
    return NodeState.SUCCESS;
  }
}


=====================================
FILE: ./src/engine/ai/StateMachine.ts
=====================================
import { Entity } from '@/engine/ecs/Entity';

export interface State {
  name: string;
  enter?: (entity: Entity, data?: any) => void;
  update?: (entity: Entity, delta: number, time: number, data?: any) => void;
  exit?: (entity: Entity, data?: any) => void;
}

export class StateMachine {
  private states = new Map<string, State>();
  private currentState: State | null = null;

  public addState(state: State) {
    this.states.set(state.name, state);
    return this;
  }

  public setState(name: string, entity: Entity, data?: any) {
    if (this.currentState && this.currentState.name === name) return;

    if (this.currentState && this.currentState.exit) {
      this.currentState.exit(entity, data);
    }

    this.currentState = this.states.get(name) || null;

    if (this.currentState && this.currentState.enter) {
      this.currentState.enter(entity, data);
    }
  }

  public update(entity: Entity, delta: number, time: number, data?: any) {
    if (this.currentState && this.currentState.update) {
      this.currentState.update(entity, delta, time, data);
    }
  }

  public getCurrentState() {
    return this.currentState?.name || null;
  }
}


=====================================
FILE: ./src/engine/ai/nodes/hunterNodes.ts
=====================================
import { BTNode, NodeState } from '@/engine/ai/behavior/types';
import { Entity } from '@/engine/ecs/Entity';
import { AIContext } from '@/engine/handlers/ai/types';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { MotionData } from '@/engine/ecs/components/MotionData';
import { TargetData } from '@/engine/ecs/components/TargetData';
import { AIStateData } from '@/engine/ecs/components/AIStateData';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class HoverDrift extends BTNode {
  constructor(private minRange: number, private maxRange: number, private duration: number) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const transform = entity.getComponent<TransformData>(ComponentType.Transform);
    const motion = entity.getComponent<MotionData>(ComponentType.Motion);
    const target = entity.getComponent<TargetData>(ComponentType.Target);
    const state = entity.getComponent<AIStateData>(ComponentType.State);

    if (!transform || !motion || !target || !state) return NodeState.FAILURE;

    // --- STUN LOGIC ---
    if (state.stunTimer > 0) {
        state.stunTimer -= context.delta;
        return NodeState.RUNNING;
    }

    if (!state.timers) state.timers = {};
    if (!state.data) state.data = {};

    if (!state.timers.hover) {
        state.timers.hover = this.duration;
        state.data.driftX = (Math.random() - 0.5) * 4;
        state.data.driftY = (Math.random() - 0.5) * 4;
    }

    state.timers.hover -= context.delta;
    if (state.timers.hover <= 0) {
        state.timers.hover = undefined;
        return NodeState.SUCCESS;
    }

    const dx = target.x - transform.x;
    const dy = target.y - transform.y;
    const distSq = dx*dx + dy*dy;
    const dist = Math.sqrt(distSq);
    
    if (dist < 0.001) {
        motion.vx *= 0.9;
        motion.vy *= 0.9;
        return NodeState.RUNNING;
    }

    const angleToTarget = Math.atan2(dy, dx);

    let tx = state.data.driftX || 0;
    let ty = state.data.driftY || 0;

    if (dist < this.minRange) {
        tx -= dx * 0.5; 
        ty -= dy * 0.5;
    } else if (dist > this.maxRange) {
        tx += dx * 0.5; 
        ty += dy * 0.5;
    }

    motion.vx += (tx - motion.vx) * context.delta * 2.0;
    motion.vy += (ty - motion.vy) * context.delta * 2.0;
    
    transform.rotation = angleToTarget;

    return NodeState.RUNNING;
  }
}

export class FaceTarget extends BTNode {
  tick(entity: Entity, context: AIContext): NodeState {
    const transform = entity.getComponent<TransformData>(ComponentType.Transform);
    const target = entity.getComponent<TargetData>(ComponentType.Target);
    const motion = entity.getComponent<MotionData>(ComponentType.Motion);

    if (!transform || !target) return NodeState.FAILURE;

    // We let them rotate even if stunned? 
    // No, freeze rotation too for "Impact Feel"
    // But since FaceTarget sets Success instantly, we skip this logic for now or implement rotation logic elsewhere.
    // For now, let's keep rotation active during stun to prevent weird snapping.

    if (motion) {
        motion.vx *= 0.9;
        motion.vy *= 0.9;
    }

    const dx = target.x - transform.x;
    const dy = target.y - transform.y;
    transform.rotation = Math.atan2(dy, dx);

    return NodeState.SUCCESS;
  }
}

export class FireProjectile extends BTNode {
  constructor(private speed: number, private configId: string) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const transform = entity.getComponent<TransformData>(ComponentType.Transform);
    
    if (!transform) return NodeState.FAILURE;

    const dirX = Math.cos(transform.rotation);
    const dirY = Math.sin(transform.rotation);

    context.spawnProjectile(
        transform.x + dirX * 1.5, 
        transform.y + dirY * 1.5, 
        dirX * this.speed, 
        dirY * this.speed, 
        undefined, 
        this.configId, 
        entity.id as number
    );

    context.playSound('fx_enemy_fire', transform.x);
    
    const motion = entity.getComponent<MotionData>(ComponentType.Motion);
    if (motion) {
        motion.vx = -dirX * 5.0;
        motion.vy = -dirY * 5.0;
    }

    context.spawnLaunchSparks(transform.x + dirX, transform.y + dirY, transform.rotation);

    return NodeState.SUCCESS;
  }
}

export class ExhaustFX extends BTNode {
  tick(entity: Entity, context: AIContext): NodeState {
    const transform = entity.getComponent<TransformData>(ComponentType.Transform);
    const state = entity.getComponent<AIStateData>(ComponentType.State);
    if (!transform || !state) return NodeState.FAILURE;

    if (!state.timers.sizzle || state.timers.sizzle <= 0) {
        context.playSound('fx_exhaust_sizzle', transform.x);
        state.timers.sizzle = 0.15;
    } else {
        state.timers.sizzle -= context.delta;
    }

    const rearAngle = transform.rotation + Math.PI;
    const offset = 0.5;
    const spreadAngle = 0.2; 
    const density = 2; 

    for (let i = 0; i < density; i++) {
        const spread = (Math.random() - 0.5) * spreadAngle;
        const angle = rearAngle + spread;
        const speed = 15.0 + (Math.random() * 10.0);
        
        const px = transform.x + Math.cos(rearAngle) * offset;
        const py = transform.y + Math.sin(rearAngle) * offset;
        
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        
        context.spawnParticle(px, py, '#F7D277', vx, vy, 0.3 + (Math.random() * 0.2), 1.0);
    }

    return NodeState.SUCCESS;
  }
}


=====================================
FILE: ./src/engine/ai/nodes/daemonNodes.ts
=====================================
import { BTNode, NodeState } from '@/engine/ai/behavior/types';
import { Entity } from '@/engine/ecs/Entity';
import { AIContext } from '@/engine/handlers/ai/types';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { AIStateData } from '@/engine/ecs/components/AIStateData';
import { TargetData } from '@/engine/ecs/components/TargetData';
import { OrbitalData } from '@/engine/ecs/components/OrbitalData';
import { RenderData } from '@/engine/ecs/components/RenderData';
import { ComponentType } from '@/engine/ecs/ComponentType';

// --- ACTIONS ---

export class OrbitControl extends BTNode {
  constructor(private active: boolean) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const orbital = entity.getComponent<OrbitalData>(ComponentType.Orbital);
    if (!orbital) return NodeState.FAILURE;
    orbital.active = this.active;
    return NodeState.SUCCESS;
  }
}

export class ChargeMechanic extends BTNode {
  constructor(private duration: number) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const state = entity.getComponent<AIStateData>(ComponentType.State);
    if (!state) return NodeState.FAILURE;

    // Init
    if (typeof state.data.chargeProgress === 'undefined') {
        state.data.chargeProgress = 0;
    }

    // Charge
    if (state.data.chargeProgress < 1.0) {
        state.data.chargeProgress += context.delta / this.duration;
        
        // Clamp
        if (state.data.chargeProgress >= 1.0) {
            state.data.chargeProgress = 1.0;
            context.playSound('ui_optimal', 0); // Audio feedback when full
            return NodeState.SUCCESS;
        }
        return NodeState.RUNNING;
    }

    return NodeState.SUCCESS;
  }
}

export class FireDaemonShot extends BTNode {
  constructor(private speed: number, private damage: number) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const transform = entity.getComponent<TransformData>(ComponentType.Transform);
    const target = entity.getComponent<TargetData>(ComponentType.Target);
    const state = entity.getComponent<AIStateData>(ComponentType.State);

    if (!transform || !target || !state) return NodeState.FAILURE;

    // Calculate Direction to Target
    const dx = target.x - transform.x;
    const dy = target.y - transform.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    // Default to forward if no target (safety)
    let dirX = 1, dirY = 0;
    
    if (dist > 0.001) {
        dirX = dx / dist;
        dirY = dy / dist;
    }

    // Spawn
    context.spawnProjectile(
        transform.x + (dirX * 0.5), 
        transform.y + (dirY * 0.5), 
        dirX * this.speed, 
        dirY * this.speed, 
        this.damage, 
        'DAEMON_ORB', 
        entity.id as number
    );

    // FX
    context.spawnFX('IMPACT_WHITE', transform.x, transform.y);
    context.playSound('fx_teleport', transform.x);

    // Reset Charge
    state.data.chargeProgress = 0;
    state.data.lastFireTime = context.time;

    return NodeState.SUCCESS;
  }
}

export class DaemonAim extends BTNode {
  private readonly TURN_SPEED = 5.0;

  tick(entity: Entity, context: AIContext): NodeState {
    const transform = entity.getComponent<TransformData>(ComponentType.Transform);
    const target = entity.getComponent<TargetData>(ComponentType.Target);
    const state = entity.getComponent<AIStateData>(ComponentType.State);
    const render = entity.getComponent<RenderData>(ComponentType.Render);

    if (!transform || !target || !state || !render) return NodeState.FAILURE;

    // 1. Determine Target Angle
    let targetAngle = 0;
    const isCharged = state.data.chargeProgress >= 1.0;
    const hasEnemy = target.id !== null && target.id !== undefined;

    if (isCharged && hasEnemy) {
        // Face Enemy
        const dx = target.x - transform.x;
        const dy = target.y - transform.y;
        targetAngle = Math.atan2(dy, dx);
    } else {
        // Face Player (Center 0,0 relative to self)
        // Since Daemon orbits 0,0, facing center is just atan2(-y, -x)
        targetAngle = Math.atan2(-transform.y, -transform.x);
    }

    // 2. Smooth Rotation
    let diff = targetAngle - transform.rotation;
    while (diff > Math.PI) diff -= Math.PI * 2;
    while (diff < -Math.PI) diff += Math.PI * 2;
    
    transform.rotation += diff * this.TURN_SPEED * context.delta;

    // 3. Update Render Spin (Visual Flair)
    render.visualRotation += context.delta * 2.0;

    return NodeState.SUCCESS;
  }
}

// --- CONDITIONS ---

export class HasTargetLock extends BTNode {
  tick(entity: Entity, context: AIContext): NodeState {
    const target = entity.getComponent<TargetData>(ComponentType.Target);
    // TargetingSystem sets id to 'ENEMY_LOCKED' when it finds a valid enemy
    if (target && target.id) {
        return NodeState.SUCCESS;
    }
    return NodeState.FAILURE;
  }
}


=====================================
FILE: ./src/engine/ai/nodes/drillerNodes.ts
=====================================
import { BTNode, NodeState } from '@/engine/ai/behavior/types';
import { Entity } from '@/engine/ecs/Entity';
import { AIContext } from '@/engine/handlers/ai/types';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { TargetData } from '@/engine/ecs/components/TargetData';
import { MotionData } from '@/engine/ecs/components/MotionData';
import { CombatData } from '@/engine/ecs/components/CombatData';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { MODEL_CONFIG } from '@/engine/config/ModelConfig';

export class DrillAttack extends BTNode {
  // Dynamic calculation based on model height to ensure tip touches wall exactly
  private readonly TIP_OFFSET = MODEL_CONFIG.DRILLER.height / 2; 

  constructor(private interval: number) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const target = entity.getComponent<TargetData>(ComponentType.Target);
    const state = entity.getComponent<any>(ComponentType.State);
    const transform = entity.getComponent<TransformData>(ComponentType.Transform);
    const motion = entity.getComponent<MotionData>(ComponentType.Motion);
    const combat = entity.getComponent<CombatData>(ComponentType.Combat);

    if (!target || !state || !transform) return NodeState.FAILURE;

    let destX = target.x;
    let destY = target.y;

    if (target.type === 'PANEL' && target.id) {
        const rect = context.getPanelRect(target.id);
        if (rect) {
            destX = Math.max(rect.left, Math.min(transform.x, rect.right));
            destY = Math.max(rect.bottom, Math.min(transform.y, rect.top));
        }
    }

    const dx = destX - transform.x;
    const dy = destY - transform.y;
    const angle = Math.atan2(dy, dx);
    const dist = Math.sqrt(dx*dx + dy*dy);

    // Snap to wall
    if (dist > 0.001) {
        const normX = dx / dist;
        const normY = dy / dist;
        
        transform.x = destX - (normX * this.TIP_OFFSET);
        transform.y = destY - (normY * this.TIP_OFFSET);
        transform.rotation = angle;
    }

    if (motion) {
        motion.vx = 0;
        motion.vy = 0;
    }

    context.spawnDrillSparks(destX, destY, transform.rotation);

    if (!state.timers.drillAudio || state.timers.drillAudio <= 0) {
        context.playSound('loop_drill', transform.x);
        state.timers.drillAudio = 0.25;
    } else {
        state.timers.drillAudio -= context.delta;
    }

    if (!state.timers.drillDmg || state.timers.drillDmg <= 0) {
        const damage = combat ? combat.damage : 1;
        
        if (target.type === 'PANEL' && target.id) {
            // UPDATED: Pass transform coordinates as source
            context.damagePanel(target.id, damage, transform.x, transform.y);
            state.timers.drillDmg = this.interval;
        } else {
            state.timers.drillDmg = this.interval;
        }
    } else {
        state.timers.drillDmg -= context.delta;
    }

    return NodeState.RUNNING;
  }
}


=====================================
FILE: ./src/engine/ai/nodes/conditions.ts
=====================================
import { BTNode, NodeState } from '@/engine/ai/behavior/types';
import { Entity } from '@/engine/ecs/Entity';
import { AIContext } from '@/engine/handlers/ai/types';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { TargetData } from '@/engine/ecs/components/TargetData';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class IsTargetInRange extends BTNode {
  constructor(private range: number) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const transform = entity.getComponent<TransformData>(ComponentType.Transform);
    const target = entity.getComponent<TargetData>(ComponentType.Target);
    
    if (!transform || !target) return NodeState.FAILURE;

    let tx = target.x;
    let ty = target.y;

    // Logic: If target is a Panel, clamp destination to the panel edges
    if (target.type === 'PANEL' && target.id) {
        const rect = context.getPanelRect(target.id);
        if (rect) {
            tx = Math.max(rect.left, Math.min(transform.x, rect.right));
            ty = Math.max(rect.bottom, Math.min(transform.y, rect.top));
        }
    }

    const dx = tx - transform.x;
    const dy = ty - transform.y;
    const distSq = dx*dx + dy*dy;

    return distSq <= (this.range * this.range) ? NodeState.SUCCESS : NodeState.FAILURE;
  }
}


=====================================
FILE: ./src/engine/ai/nodes/logic.ts
=====================================
import { BTNode, NodeState } from '@/engine/ai/behavior/types';
import { Entity } from '@/engine/ecs/Entity';
import { AIContext } from '@/engine/handlers/ai/types';
import { AIStateData } from '@/engine/ecs/components/AIStateData';
import { RenderData } from '@/engine/ecs/components/RenderData';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { TargetData } from '@/engine/ecs/components/TargetData';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class SpawnPhase extends BTNode {
  constructor(private duration: number) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const state = entity.getComponent<AIStateData>(ComponentType.State);
    const render = entity.getComponent<RenderData>(ComponentType.Render);
    const transform = entity.getComponent<TransformData>(ComponentType.Transform);
    const target = entity.getComponent<TargetData>(ComponentType.Target);
    
    if (!state) return NodeState.SUCCESS;

    if (state.timers.spawn === undefined) {
        state.timers.spawn = this.duration;
        state.current = 'SPAWN';
        if (render) {
            render.spawnProgress = 0.0;
            // Initial random rotation, or face target immediately?
            // Random feels more "chaotic materialize", but facing target feels "locked on".
            // Let's rely on the update loop below to align them.
        }
    }

    if (state.timers.spawn > 0) {
        state.timers.spawn -= context.delta;
        
        // --- ORIENTATION LOGIC ---
        // Automatically face the target defined in TargetData
        if (transform && target) {
            // Target coordinates are updated by TargetingSystem every frame (LOGIC phase)
            // So this will track moving targets (Player) or static ones (Panel Edges)
            const dx = target.x - transform.x;
            const dy = target.y - transform.y;
            // Only rotate if we have a valid vector
            if (Math.abs(dx) > 0.01 || Math.abs(dy) > 0.01) {
                const targetAngle = Math.atan2(dy, dx);
                // Lerp rotation for smoothness or snap? 
                // Since they are spawning, snapping is fine, the spin effect covers it.
                transform.rotation = targetAngle;
            }
        }

        if (render) {
            const t = 1.0 - (state.timers.spawn / this.duration);
            
            render.spawnProgress = Math.max(0, Math.min(1, t));
            
            if (t < 0.8) {
                render.visualScale = t / 0.8; 
            } else {
                const popT = (t - 0.8) / 0.2; 
                render.visualScale = 1.0 + (Math.sin(popT * Math.PI) * 0.25);
            }

            render.visualRotation += (1.0 - t) * 15.0 * context.delta;
        }

        return NodeState.RUNNING;
    }

    if (state.current === 'SPAWN') {
        state.current = 'ACTIVE';
        if (render) {
            render.spawnProgress = 1.0;
            render.visualScale = 1.0;
            render.flash = 0.6; 
        }
    }

    return NodeState.SUCCESS;
  }
}


=====================================
FILE: ./src/engine/ai/nodes/actions.ts
=====================================
import { BTNode, NodeState } from '@/engine/ai/behavior/types';
import { Entity } from '@/engine/ecs/Entity';
import { AIContext } from '@/engine/handlers/ai/types';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { MotionData } from '@/engine/ecs/components/MotionData';
import { TargetData } from '@/engine/ecs/components/TargetData';
import { RenderData } from '@/engine/ecs/components/RenderData';
import { AIStateData } from '@/engine/ecs/components/AIStateData';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class MoveToTarget extends BTNode {
  constructor(private speed: number, private stopDistance: number = 0) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const transform = entity.getComponent<TransformData>(ComponentType.Transform);
    const motion = entity.getComponent<MotionData>(ComponentType.Motion);
    const target = entity.getComponent<TargetData>(ComponentType.Target);
    const state = entity.getComponent<AIStateData>(ComponentType.State);

    if (!transform || !motion || !target) return NodeState.FAILURE;

    // --- STUN LOGIC ---
    // If stunned, skip velocity update to let physics impulse take over
    if (state && state.stunTimer > 0) {
        state.stunTimer -= context.delta;
        return NodeState.RUNNING;
    }

    let tx = target.x;
    let ty = target.y;

    if (target.type === 'PANEL' && target.id) {
        const rect = context.getPanelRect(target.id);
        if (rect) {
            tx = Math.max(rect.left, Math.min(transform.x, rect.right));
            ty = Math.max(rect.bottom, Math.min(transform.y, rect.top));
        }
    }

    const dx = tx - transform.x;
    const dy = ty - transform.y;
    const dist = Math.sqrt(dx*dx + dy*dy);

    if (dist <= this.stopDistance) {
        motion.vx = 0;
        motion.vy = 0;
        return NodeState.SUCCESS;
    }

    const nx = dx / dist;
    const ny = dy / dist;

    motion.vx = nx * this.speed;
    motion.vy = ny * this.speed;
    transform.rotation = Math.atan2(dy, dx);

    return NodeState.RUNNING;
  }
}

export class Wait extends BTNode {
  constructor(private duration: number) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const state = entity.getComponent<any>(ComponentType.State);
    if (!state) return NodeState.FAILURE;

    if (state.timers.wait === undefined) {
        state.timers.wait = this.duration;
    }

    state.timers.wait -= context.delta;
    
    if (state.timers.wait <= 0) {
        state.timers.wait = undefined; 
        return NodeState.SUCCESS;
    }

    return NodeState.RUNNING;
  }
}

export class SpinVisual extends BTNode {
  constructor(private speed: number) { super(); }
  
  tick(entity: Entity, context: AIContext): NodeState {
      const render = entity.getComponent<RenderData>(ComponentType.Render);
      if (render) {
          render.visualRotation += context.delta * this.speed;
      }
      return NodeState.SUCCESS;
  }
}


=====================================
FILE: ./src/engine/graphics/gpgpu/GPGPUManager.ts
=====================================
import { GPUComputationRenderer, Variable } from 'three/examples/jsm/misc/GPUComputationRenderer';
import * as THREE from 'three';

export class GPGPUManager {
  private gpuCompute: GPUComputationRenderer;
  private variables = new Map<string, Variable>();

  constructor(renderer: THREE.WebGLRenderer, size: number) {
    this.gpuCompute = new GPUComputationRenderer(size, size, renderer);
    
    // Check support
    const status = this.gpuCompute.init();
    if (status !== null) {
        console.error("GPGPU Init Failed:", status);
    }
  }

  public createVariable(name: string, shader: string, initialData: THREE.DataTexture) {
    const variable = this.gpuCompute.addVariable(`texture${name}`, shader, initialData);
    variable.wrapS = THREE.RepeatWrapping;
    variable.wrapT = THREE.RepeatWrapping;
    this.variables.set(name, variable);
    
    // Resolve dependencies automatically (self-referential for simulation)
    this.gpuCompute.setVariableDependencies(variable, [variable]);
    
    return variable;
  }

  public init() {
    const error = this.gpuCompute.init();
    if (error !== null) {
        console.error(error);
    }
  }

  public update() {
    this.gpuCompute.compute();
  }

  public getTexture(name: string) {
    const v = this.variables.get(name);
    if (!v) return null;
    return this.gpuCompute.getCurrentRenderTarget(v).texture;
  }
}


=====================================
FILE: ./src/engine/graphics/ShaderLib.ts
=====================================
import { chunk_noise } from './glsl/noise';
import { chunk_math } from './glsl/math';

export const ShaderLib = {
  chunks: {
    noise: chunk_noise,
    math: chunk_math,
    
    vertexHeader: `
      #ifndef USE_INSTANCING_COLOR
      attribute vec3 instanceColor;
      #endif
      attribute vec3 barycentric;
      attribute float spawnProgress;
      
      varying vec3 vColor;
      varying vec3 vBarycentric;
      varying vec2 vUv;
      varying vec3 vPos;
      varying float vSpawn;
      
      uniform float uTime;
    `,

    fragmentHeader: `
      varying vec3 vColor;
      varying vec3 vBarycentric;
      varying vec2 vUv;
      varying vec3 vPos;
      varying float vSpawn;
      
      uniform float uTime;
    `,
  },

  presets: {
    enemy: {
      vertex: `
        void main() {
          vColor = instanceColor;
          vBarycentric = barycentric;
          vUv = uv;
          vPos = position;
          vSpawn = spawnProgress;
          
          gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
        }
      `,
      fragment: `
        void main() {
          // --- SPAWN DISSOLVE LOGIC ---
          float noise = snoise(vPos * 3.0 + vec3(0.0, uTime * 0.5, 0.0)) * 0.5 + 0.5;
          float threshold = (1.0 - vSpawn) * 1.4 - 0.2;
          
          if (noise < threshold) discard;

          float edgeWidth = 0.1;
          float burn = smoothstep(threshold, threshold + edgeWidth, noise);
          float edgeIntensity = 1.0 - burn; 
          
          // --- COLOR LOGIC ---
          float width = 1.5;
          float wireEdge = edgeFactor(vBarycentric, width);
          
          // 'glow' represents how close we are to the wireframe line (1.0 = on line, 0.0 = face center)
          float glow = pow(1.0 - wireEdge, 0.4);
          
          vec3 coreColor = vColor;
          float intensity = max(max(vColor.r, vColor.g), vColor.b);
          
          // Determine if we are in "High Intensity" (Flash) mode
          // 0.0 = Normal, 1.0 = Flash
          float isFlash = smoothstep(1.0, 3.0, intensity);
          
          // Normal: Edges are White. Flash: Edges are colored (to prevent pink/pastel look).
          vec3 wireColor = mix(vec3(1.0), vColor, isFlash);
          
          // Mix: Face -> Wireframe
          vec3 finalColor = mix(coreColor, wireColor, glow);

          // Apply Burn Edge (Blue/White Dissolve Line)
          vec3 burnColor = vec3(0.8, 1.0, 1.0) * 4.0; 
          finalColor += burnColor * edgeIntensity;

          gl_FragColor = vec4(finalColor, 1.0);
        }
      `
    },

    particle: {
      vertex: `
        attribute float shapeID;
        varying float vShape;
        void main() {
          vUv = uv;
          vColor = instanceColor;
          vShape = shapeID;
          gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
        }
      `,
      fragment: `
        varying float vShape;
        void main() {
          float alpha = 0.0;
          if (vShape < 0.5) {
            vec2 d = abs(vUv - 0.5) * 2.0;
            float shape = max(d.x, d.y);
            alpha = 1.0 - smoothstep(0.8, 1.0, shape);
          } else {
            float T = vUv.x; 
            float distY = abs(vUv.y - 0.5) * 2.0;
            alpha = 1.0 - smoothstep(sqrt(T) - 0.2, sqrt(T), distY);
            if (T < 0.01) alpha = 0.0;
          }
          if (alpha < 0.01) discard;
          gl_FragColor = vec4(vColor, alpha);
        }
      `
    },

    glitch: {
      vertex: `
        uniform float uIntensity;
        uniform float uFrequency;
        uniform float uSpeed;

        void main() {
          vUv = uv;
          vColor = vec3(0.0, 1.0, 0.4); 
          vBarycentric = barycentric;
          vPos = position; 
          
          float noiseVal = snoise(vec3(position * uFrequency + uTime * uSpeed));
          vec3 displaced = position + normal * noiseVal * uIntensity;
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
        }
      `,
      fragment: `
        void main() {
          float width = 1.0; 
          float edge = edgeFactor(vBarycentric, width);
          float scan = sin(vPos.y * 20.0 - uTime * 5.0) * 0.5 + 0.5;
          float alpha = 0.1 + (1.0 - edge) * 0.9 + (scan * 0.3);
          gl_FragColor = vec4(vColor, alpha);
        }
      `
    },

    playerAmbient: {
      vertex: `
        void main() { 
          vUv = uv; 
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); 
        }
      `,
      fragment: `
        uniform vec3 uColor; uniform float uOpacity; uniform float uEnergy;
        
        void main() {
          vec2 pos = vUv - 0.5;
          float angle = atan(pos.y, pos.x);
          float warble = (0.005 + 0.015 * uEnergy) * sin(angle * 10.0 + uTime * 2.0);
          float dist = length(pos) + warble;
          float alphaBase = pow(1.0 - smoothstep(0.0, 0.5, dist), 3.5);
          float ringsIdle = 0.6 + 0.4 * sin(dist * 80.0 - uTime * 1.5);
          float ringsActive = 0.5 + 0.5 * sin(dist * 30.0 - uTime * 8.0);
          float ringMix = mix(ringsIdle, ringsActive, uEnergy);
          float scan = 0.85 + 0.15 * sin(dist * 150.0 - uTime * 5.0);
          float finalAlpha = alphaBase * ringMix * scan * uOpacity * (1.0 + (uEnergy * 2.5));
          if (finalAlpha < 0.01) discard;
          gl_FragColor = vec4(uColor, finalAlpha);
        }
      `
    },

    playerBacking: {
      vertex: `
        void main() { 
          vUv = uv; 
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); 
        }
      `,
      fragment: `
        uniform vec3 uColor; uniform float uOpacity; 
        void main() { 
          float dist = distance(vUv, vec2(0.5)); 
          float alpha = 1.0 - smoothstep(0.25, 0.5, dist); 
          if (alpha < 0.01) discard; 
          gl_FragColor = vec4(uColor, alpha * uOpacity); 
        }
      `
    },

    galleryBody: {
      vertex: `
        void main() {
          vBarycentric = barycentric;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragment: `
        uniform vec3 uColor;
        uniform float uGlow;
        uniform float uDissolve;
        
        void main() {
          if (uDissolve > 0.0) {
              float stripes = sin(gl_FragCoord.y * 0.1 + gl_FragCoord.x * 0.1);
              if (stripes < (uDissolve * 2.0 - 1.0)) discard;
          }

          float width = 1.0; 
          float edge = edgeFactor(vBarycentric, width);
          float glow = 1.0 - edge;
          glow = pow(glow, 0.4) + uGlow; 
          
          vec3 coreColor = uColor;
          vec3 edgeColor = vec3(1.0);
          vec3 finalColor = mix(coreColor, edgeColor, 1.0 - smoothstep(0.0, 0.1, edge));
          finalColor += coreColor * uGlow * 0.5;

          gl_FragColor = vec4(finalColor, 1.0);
        }
      `
    }
  }
};


=====================================
FILE: ./src/engine/graphics/glsl/math.ts
=====================================
export const chunk_math = `
  // --- BARYCENTRIC WIREFRAME LOGIC ---
  float edgeFactor(vec3 bary, float width) {
    vec3 d = fwidth(bary);
    vec3 a3 = smoothstep(vec3(0.0), d * width, bary);
    return min(min(a3.x, a3.y), a3.z);
  }

  // --- UTILITY ---
  float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
  }
`;


=====================================
FILE: ./src/engine/graphics/glsl/noise.ts
=====================================
export const chunk_noise = `
  // --- 3D NOISE ---
  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
  vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

  float snoise(vec3 v) {
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 = v - i + dot(i, C.xxx) ;

    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );

    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy;
    vec3 x3 = x0 - D.yyy;

    i = mod289(i);
    vec4 p = permute( permute( permute(
              i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

    float n_ = 0.142857142857;
    vec3  ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );

    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );

    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);

    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                  dot(p2,x2), dot(p3,x3) ) );
  }
`;


=====================================
FILE: ./src/engine/graphics/MaterialFactory.ts
=====================================
import * as THREE from 'three';
import { ShaderLib } from './ShaderLib';

class MaterialFactoryController {
  private materials = new Map<string, THREE.ShaderMaterial>();

  public create(id: string, definition: { vertex: string; fragment: string; uniforms?: Record<string, any> }) {
    // DEV MODE: Always recreate material for 'MAT_GLITCH' to allow live shader editing
    if (id === 'MAT_GLITCH' || !this.materials.has(id)) {
        
        // Inject chunks automatically
        const vertexHeader = ShaderLib.chunks.vertexHeader;
        const fragmentHeader = ShaderLib.chunks.fragmentHeader;
        const math = ShaderLib.chunks.math;
        const noise = ShaderLib.chunks.noise;

        const fullVertex = `
          ${vertexHeader}
          ${noise}
          ${definition.vertex}
        `;

        const fullFragment = `
          ${fragmentHeader}
          ${math}
          ${noise}
          ${definition.fragment}
        `;

        const mat = new THREE.ShaderMaterial({
          vertexShader: fullVertex,
          fragmentShader: fullFragment,
          uniforms: {
            uTime: { value: 0 },
            ...(definition.uniforms || {})
          },
          vertexColors: true,
          side: THREE.DoubleSide,
          transparent: true,
          depthWrite: true
        });

        this.materials.set(id, mat);
        return mat;
    }
    
    return this.materials.get(id)!;
  }

  public updateUniforms(time: number) {
    for (const mat of this.materials.values()) {
        if (mat.uniforms.uTime) {
            mat.uniforms.uTime.value = time;
        }
    }
  }
}

export const MaterialFactory = new MaterialFactoryController();


=====================================
FILE: ./src/engine/systems/CollisionSystem.ts
=====================================
import { IGameSystem, IPhysicsSystem, ICombatSystem, IEntityRegistry } from '@/engine/interfaces';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { AIStateData } from '@/engine/ecs/components/AIStateData';
import { ColliderData } from '@/engine/ecs/components/ColliderData';
import { ComponentType } from '@/engine/ecs/ComponentType';

const MAX_COLLISION_RESULTS = 1024;

export class CollisionSystem implements IGameSystem {
  private queryBuffer = new Int32Array(MAX_COLLISION_RESULTS);
  private handledPairs = new Set<number>(); 

  constructor(
    private physicsSystem: IPhysicsSystem,
    private combatSystem: ICombatSystem,
    private registry: IEntityRegistry
  ) {}

  update(delta: number, time: number): void {
    const spatial = this.physicsSystem.spatialGrid;
    const collidables = this.registry.query({ all: [ComponentType.Collider, ComponentType.Transform] });
    this.handledPairs.clear();

    for (const entity of collidables) {
        if (!entity.active) continue;
        const collider = entity.getComponent<ColliderData>(ComponentType.Collider);
        const transform = entity.getComponent<TransformData>(ComponentType.Transform);
        if (!collider || collider.mask === 0 || !transform) continue;

        const state = entity.getComponent<AIStateData>(ComponentType.State);
        if (state && state.current === 'SPAWN') continue;

        const count = spatial.query(transform.x, transform.y, collider.radius + 1.0, this.queryBuffer);

        for (let i = 0; i < count; i++) {
            const otherId = this.queryBuffer[i];
            if (otherId === entity.id) continue;

            const idA = entity.id as number;
            const idB = otherId;
            const pairKey = (Math.min(idA, idB) << 16) | Math.max(idA, idB);
            if (this.handledPairs.has(pairKey)) continue;
            this.handledPairs.add(pairKey);

            const other = this.registry.getEntity(otherId);
            if (!other || !other.active) continue;

            const otherCollider = other.getComponent<ColliderData>(ComponentType.Collider);
            if (!otherCollider) continue;

            const aHitsB = (collider.mask & otherCollider.layer) !== 0;
            const bHitsA = (otherCollider.mask & collider.layer) !== 0;
            if (!aHitsB && !bHitsA) continue;

            const otherTransform = other.getComponent<TransformData>(ComponentType.Transform);
            if (!otherTransform) continue;

            const dx = transform.x - otherTransform.x;
            const dy = transform.y - otherTransform.y;
            const radiusSum = collider.radius + otherCollider.radius;

            if (dx * dx + dy * dy < radiusSum * radiusSum) {
                this.combatSystem.resolveCollision(entity, other);
            }
        }
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/HealthSystem.ts
=====================================
import { IGameSystem, IGameEventService, IAudioService, IPanelSystem, IFastEventService } from '@/engine/interfaces';
import { GameEvents } from '@/engine/signals/GameEvents';
import { PLAYER_CONFIG } from '@/engine/config/PlayerConfig';
import { useStore } from '@/engine/state/global/useStore';
import { FastEvents } from '@/engine/signals/FastEventBus';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { TransientDOMService } from '@/engine/services/TransientDOMService';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { EventReader } from '@/engine/signals/EventReader';

export class HealthSystem implements IGameSystem {
  public playerHealth: number = PLAYER_CONFIG.maxHealth;
  public maxPlayerHealth: number = PLAYER_CONFIG.maxHealth;
  public playerRebootProgress: number = 0;
  public isGameOver: boolean = false;
  
  private reader: EventReader;

  constructor(
    private events: IGameEventService,
    private audio: IAudioService,
    private panelSystem: IPanelSystem
  ) {
    this.reader = new EventReader(ServiceLocator.getFastEventBus());
    this.reset();
    
    this.events.subscribe(GameEvents.PLAYER_REBOOT_TICK, (p) => {
        this.tickReboot(p.amount);
    });

    this.events.subscribe(GameEvents.PLAYER_REBOOT_DECAY, (p) => {
        this.decayReboot(p.amount);
    });
  }

  update(delta: number, time: number): void {
    // Process Fast Events via Reader
    this.reader.process((id, a1) => {
        if (id === FastEvents.PLAYER_HIT) {
            this.damagePlayer(a1); // a1 = damage amount
            this.events.emit(GameEvents.PLAYER_HIT, { damage: a1 });
        }
    });

    if (this.isGameOver) return;
    
    if (this.panelSystem.systemIntegrity <= 0) {
        this.isGameOver = true;
        this.events.emit(GameEvents.GAME_OVER, { score: 0 });
        this.events.emit(GameEvents.TRAUMA_ADDED, { amount: 1.0 });
        useGameStore.setState({ systemIntegrity: 0 });
    }
  }

  public damagePlayer(amount: number) {
    if (this.isGameOver) return;
    const { godMode } = useStore.getState().debugFlags;
    if (godMode) return;
    
    if (this.playerHealth > 0) {
        this.playerHealth = Math.max(0, this.playerHealth - amount);
        this.updateVisuals();
        
        if (this.playerHealth <= 0) {
            this.audio.playSound('fx_player_death');
            useGameStore.setState({ playerHealth: 0 }); 
        }
    } else {
        this.playerRebootProgress = Math.max(0, this.playerRebootProgress - (amount * 2));
    }
  }

  public healPlayer(amount: number) {
    this.playerHealth = Math.min(this.maxPlayerHealth, this.playerHealth + amount);
    this.updateVisuals();
    if (this.playerHealth > 0 && useGameStore.getState().playerHealth <= 0) {
        useGameStore.setState({ playerHealth: this.playerHealth });
    }
  }

  public tickReboot(amount: number) {
    if (this.playerHealth > 0) return;
    this.playerRebootProgress = Math.max(0, Math.min(100, this.playerRebootProgress + amount));
    useGameStore.setState({ playerRebootProgress: this.playerRebootProgress });
    
    if (this.playerRebootProgress >= 100) {
        this.playerHealth = this.maxPlayerHealth; 
        this.playerRebootProgress = 0;
        this.audio.playSound('fx_reboot_success');
        this.updateVisuals();
        useGameStore.setState({ playerHealth: this.playerHealth, playerRebootProgress: 0 });
    }
  }

  public decayReboot(amount: number) {
      if (this.playerHealth > 0) return; 
      this.playerRebootProgress = Math.max(0, this.playerRebootProgress - amount);
      if (Math.random() > 0.5) useGameStore.setState({ playerRebootProgress: this.playerRebootProgress });
  }

  private updateVisuals() {
      const hpPercent = this.playerHealth / this.maxPlayerHealth;
      TransientDOMService.update('hp-progress', hpPercent);
      
      let hpColor = '#78F654'; 
      if (hpPercent < 0.3) hpColor = '#FF003C'; 
      else if (hpPercent < 0.6) hpColor = '#eae747'; 
      if (this.playerHealth <= 0) hpColor = '#eae747';

      TransientDOMService.update('hp-color', hpColor);
  }

  public reset() {
      this.playerHealth = this.maxPlayerHealth;
      this.playerRebootProgress = 0;
      this.isGameOver = false;
      this.updateVisuals();
      
      useGameStore.setState({ 
          playerHealth: this.maxPlayerHealth,
          playerRebootProgress: 0,
          systemIntegrity: 100 
      });
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/AtmosphereSystem.ts
=====================================
import { IGameSystem, IPanelSystem, IEntityRegistry } from '@/engine/interfaces';
import { useStore } from '@/engine/state/global/useStore'; 
import { RenderData } from '@/engine/ecs/components/RenderData';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { Tag } from '@/engine/ecs/types';
import * as THREE from 'three';

const COL_SAFE = new THREE.Color("#00FF41");
const COL_WARN = new THREE.Color("#FFD700");
const COL_CRIT = new THREE.Color("#FF003C");
const COL_SBX  = new THREE.Color("#00FFFF");

export class AtmosphereSystem implements IGameSystem {
  private targetColor = new THREE.Color();
  private currentColor = new THREE.Color();

  constructor(
    private panelSystem: IPanelSystem,
    private registry: IEntityRegistry
  ) {}

  update(delta: number, time: number): void {
    const integrity = this.panelSystem.systemIntegrity;
    const worldEntities = this.registry.getByTag(Tag.WORLD);
    
    for (const world of worldEntities) {
        const render = world.getComponent<RenderData>(ComponentType.Render);
        if (render) {
            const bootState = useStore.getState().bootState;
            
            // 1. Determine Target Color
            if (bootState === 'sandbox') this.targetColor.copy(COL_SBX);
            else if (integrity < 30) this.targetColor.copy(COL_CRIT);
            else if (integrity < 60) this.targetColor.copy(COL_WARN);
            else this.targetColor.copy(COL_SAFE);

            // 2. Smooth Lerp
            this.currentColor.setRGB(render.r, render.g, render.b);
            this.currentColor.lerp(this.targetColor, delta * 2.0);
            
            render.r = this.currentColor.r;
            render.g = this.currentColor.g;
            render.b = this.currentColor.b;
            
            // 3. World Spin
            render.visualRotation += 0.5 * delta; 
        }
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/InteractionSystem.ts
=====================================
import { IInteractionSystem, IEntitySpawner, IGameStateSystem, IPanelSystem, IInputService, IGameEventService } from '@/engine/interfaces';
import { GameEvents } from '@/engine/signals/GameEvents';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { useGameStore } from '@/engine/state/game/useGameStore';

export type RepairState = 'IDLE' | 'HEALING' | 'REBOOTING';

export class InteractionSystem implements IInteractionSystem {
  public repairState: RepairState = 'IDLE';
  public hoveringPanelId: string | null = null;
  
  private lastRepairTime = 0;
  private readonly REPAIR_RATE = 0.05;
  
  // Track previous ID to prevent store thrashing
  private previousHoverId: string | null = null;

  constructor(
    private input: IInputService,
    private spawner: IEntitySpawner,
    private gameSystem: IGameStateSystem,
    private panelSystem: IPanelSystem,
    private events: IGameEventService
  ) {}

  update(delta: number, time: number): void {
    this.repairState = 'IDLE';
    this.hoveringPanelId = null;
    
    if (this.gameSystem.isGameOver) {
        this.syncInteractionState();
        return; 
    }
    
    const cursor = this.input.getCursor();
    
    if (this.gameSystem.playerHealth <= 0) {
        this.handleRevival(cursor, time);
        
        if (this.repairState !== 'REBOOTING' && this.gameSystem.playerRebootProgress > 0) {
            this.events.emit(GameEvents.PLAYER_REBOOT_DECAY, { amount: delta * 15 });
        }
    } else {
        this.handlePanelRepair(cursor, time);
    }

    this.syncInteractionState();
  }

  private syncInteractionState() {
      // Only push to store if the target actually changed
      if (this.hoveringPanelId !== this.previousHoverId) {
          useGameStore.getState().setInteractionTarget(this.hoveringPanelId);
          this.previousHoverId = this.hoveringPanelId;
      }
  }

  teardown(): void {
      useGameStore.getState().setInteractionTarget(null);
  }

  private handleRevival(cursor: {x: number, y: number}, time: number) {
    const rect = this.panelSystem.getPanelRect('identity');
    if (!rect) return;
    
    const padding = 0.1; 
    
    const isHovering = 
        cursor.x >= rect.left - padding && 
        cursor.x <= rect.right + padding && 
        cursor.y >= rect.bottom - padding && 
        cursor.y <= rect.top + padding;

    if (isHovering) {
        this.hoveringPanelId = 'identity';
        this.repairState = 'REBOOTING';
        if (time > this.lastRepairTime + this.REPAIR_RATE) {
            this.events.emit(GameEvents.PLAYER_REBOOT_TICK, { amount: 4.0 });
            
            this.lastRepairTime = time;
            AudioSystem.playSound('loop_reboot'); 

            if (Math.random() > 0.3) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 2;
                this.spawner.spawnParticle(cursor.x, cursor.y, '#9E4EA5', Math.cos(angle)*speed, Math.sin(angle)*speed, 0.5);
            }
        }
    }
  }

  private handlePanelRepair(cursor: {x: number, y: number}, time: number) {
    const panels = this.panelSystem.getAllPanels();
    for (const p of panels) {
      if (cursor.x >= p.left && cursor.x <= p.right && cursor.y >= p.bottom && cursor.y <= p.top) {
        this.hoveringPanelId = p.id;
        
        if (!p.isDestroyed && p.health >= 100) continue;

        this.repairState = p.isDestroyed ? 'REBOOTING' : 'HEALING';

        if (time > this.lastRepairTime + this.REPAIR_RATE) {
            this.panelSystem.healPanel(p.id, 2.8, cursor.x); 
            this.lastRepairTime = time;
            
            if (p.isDestroyed) {
                AudioSystem.playSound('loop_reboot');
            } else {
                this.events.emit(GameEvents.PANEL_HEALED, { id: p.id, amount: 4 });
            }

            if (Math.random() > 0.3) {
                const color = p.isDestroyed ? '#9E4EA5' : '#00F0FF'; 
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 2;
                this.spawner.spawnParticle(cursor.x, cursor.y, color, Math.cos(angle)*speed, Math.sin(angle)*speed, 0.5);
            }
        }
        break; 
      }
    }
  }
}


=====================================
FILE: ./src/engine/systems/ProjectileSystem.ts
=====================================
import { IGameSystem, IEntityRegistry } from '@/engine/interfaces';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { ProjectileData } from '@/engine/ecs/components/ProjectileData';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { MotionData } from '@/engine/ecs/components/MotionData';
import { RenderData } from '@/engine/ecs/components/RenderData';
import { PROJECTILE_CONFIG } from '@/engine/config/ProjectileConfig';

export class ProjectileSystem implements IGameSystem {
  constructor(private registry: IEntityRegistry) {}

  update(delta: number, time: number): void {
    const entities = this.registry.query({ all: [ComponentType.Projectile, ComponentType.Transform] });

    for (const entity of entities) {
        if (!entity.active) continue;

        const proj = entity.getComponent<ProjectileData>(ComponentType.Projectile);
        const transform = entity.getComponent<TransformData>(ComponentType.Transform);
        const render = entity.getComponent<RenderData>(ComponentType.Render);
        const motion = entity.getComponent<MotionData>(ComponentType.Motion);
        
        if (!proj || !transform) continue;

        const config = PROJECTILE_CONFIG[proj.configId];
        if (!config) continue;

        // --- STATE: CHARGING (Stuck to Owner) ---
        if (proj.state === 'CHARGING' && proj.ownerId !== -1) {
            const owner = this.registry.getEntity(proj.ownerId);
            
            if (!owner || !owner.active) {
                this.registry.destroyEntity(entity.id);
                continue;
            }

            const ownerTransform = owner.getComponent<TransformData>(ComponentType.Transform);
            if (ownerTransform) {
                const offsetDist = 1.6; 
                
                const cos = Math.cos(ownerTransform.rotation);
                const sin = Math.sin(ownerTransform.rotation);
                
                transform.x = ownerTransform.x + (cos * offsetDist);
                transform.y = ownerTransform.y + (sin * offsetDist);
                transform.rotation = ownerTransform.rotation;
                
                if (motion) {
                    motion.vx = 0;
                    motion.vy = 0;
                }
            }
        }
        
        // --- STATE: FLIGHT (Visual Physics) ---
        else if (proj.state === 'FLIGHT' && render) {
            // Apply Spin
            if (!config.faceVelocity && config.spinSpeed !== 0) {
                render.visualRotation += delta * config.spinSpeed;
            }

            // Apply Pulse
            if (config.pulseSpeed > 0) {
                render.visualScale = 1.0 + Math.sin(time * config.pulseSpeed) * 0.2;
            }
        }
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/VFXSystem.ts
=====================================
import { IGameSystem, IParticleSystem, IGameEventService, IFastEventService } from '@/engine/interfaces';
import { GameEvents } from '@/engine/signals/GameEvents';
import { ShakeSystem } from './ShakeSystem';
import { VFX_RECIPES } from '@/engine/config/VFXConfig';
import { FastEvents, FX_ID_MAP } from '@/engine/signals/FastEventBus';
import { useStore } from '@/engine/state/global/useStore';
import { EventReader } from '@/engine/signals/EventReader';

export class VFXSystem implements IGameSystem {
  private reader: EventReader;

  constructor(
    private particleSystem: IParticleSystem,
    private shakeSystem: ShakeSystem,
    private events: IGameEventService,
    fastEvents: IFastEventService
  ) {
    this.reader = new EventReader(fastEvents);
    this.setupListeners();
  }

  update(delta: number, time: number): void {
    this.reader.process((id, a1, a2, a3, a4) => {
        if (id === FastEvents.SPAWN_FX) {
            const key = FX_ID_MAP[a1];
            if (key) this.executeRecipe(key, a2, a3, a4);
        }
        else if (id === FastEvents.TRAUMA) {
            this.addTrauma(a1);
        }
        else if (id === FastEvents.SPAWN_IMPACT) {
            // a1=x, a2=y, a3=packedColor, a4=angle
            this.spawnDynamicImpact(a1, a2, a3, a4); 
        }
    });
  }

  teardown(): void {}

  private setupListeners() {
    this.events.subscribe(GameEvents.PLAYER_HIT, (p) => {
        const isBig = p.damage > 10;
        if (isBig) this.triggerHitStop(0.05);
    });

    this.events.subscribe(GameEvents.PANEL_DESTROYED, () => {
        this.addTrauma(0.75); 
        this.triggerHitStop(0.1); 
    });

    this.events.subscribe(GameEvents.GAME_OVER, () => {
        this.addTrauma(1.0);
        this.triggerHitStop(0.5); 
    });
    
    this.events.subscribe(GameEvents.ZEN_MODE_ENABLED, () => {
        this.executeRecipe('PURGE_BLAST', 0, 0);
    });
  }

  private spawnDynamicImpact(x: number, y: number, packedColor: number, impactAngle: number) {
      const r = ((packedColor >> 16) & 255) / 255;
      const g = ((packedColor >> 8) & 255) / 255;
      const b = (packedColor & 255) / 255;
      
      const toHex = (n: number) => Math.floor(n * 255).toString(16).padStart(2, '0');
      const hex = `#${toHex(r)}${toHex(g)}${toHex(b)}`;
      
      const count = this.randomRange(2, 3);
      
      for(let i=0; i<count; i++) {
          const side = Math.random() > 0.5 ? 1 : -1;
          const deflection = 0.6 + (Math.random() * 1.2);
          const angle = impactAngle + (side * deflection);
          
          const speed = this.randomRange(10, 22); 
          const vx = Math.cos(angle) * speed;
          const vy = Math.sin(angle) * speed;
          const life = this.randomRange(0.1, 0.3);
          
          this.particleSystem.spawn(x, y, hex, vx, vy, life, 1.0); 
      }
  }

  private executeRecipe(key: string, x: number, y: number, angle: number = 0) {
      const recipe = VFX_RECIPES[key];
      if (!recipe) return;

      const graphicsMode = useStore.getState().graphicsMode;
      const isPotato = graphicsMode === 'POTATO';
      const multiplier = isPotato ? 0.3 : 1.0;

      const rawCount = this.randomRange(recipe.count[0], recipe.count[1]);
      let count = Math.floor(rawCount * multiplier);
      if (rawCount > 0 && count === 0) count = 1;

      for (let i = 0; i < count; i++) {
          const color = recipe.colors[Math.floor(Math.random() * recipe.colors.length)];
          const speed = this.randomRange(recipe.speed[0], recipe.speed[1]);
          const life = this.randomRange(recipe.life[0], recipe.life[1]);
          
          let size = 1.0;
          if (recipe.size) {
              size = this.randomRange(recipe.size[0], recipe.size[1]);
          }
          
          let vx = 0;
          let vy = 0;

          const isBackblast = recipe.omniChance && Math.random() < recipe.omniChance;
          const isDirectional = recipe.pattern === 'DIRECTIONAL';
          
          const finalSpeed = (isDirectional && isBackblast) ? speed * 0.5 : speed;
          const finalLife = (isDirectional && isBackblast) ? life * 0.8 : life;

          if (recipe.pattern === 'RADIAL') {
              const a = Math.random() * Math.PI * 2;
              vx = Math.cos(a) * finalSpeed;
              vy = Math.sin(a) * finalSpeed;
          } 
          else if (isDirectional) {
              let dir = angle + Math.PI; 
              let spread = recipe.spread || 0.5;

              if (isBackblast) {
                  dir += Math.PI; 
                  spread *= 1.5; 
              }

              const a = dir + (Math.random() - 0.5) * spread;
              vx = Math.cos(a) * finalSpeed;
              vy = Math.sin(a) * finalSpeed;
          }

          const shape = recipe.shape || 0;
          this.particleSystem.spawn(x, y, color, vx, vy, finalLife, size, shape);
      }
  }

  private randomRange(min: number, max: number) {
      return min + Math.random() * (max - min);
  }

  private addTrauma(amount: number) {
      this.shakeSystem.addTrauma(amount);
  }

  private triggerHitStop(duration: number) {}
}


=====================================
FILE: ./src/engine/systems/PlayerMovementSystem.ts
=====================================
import { IGameSystem, IInputService, IEntityRegistry, IInteractionSystem, IGameStateSystem } from '@/engine/interfaces';
import { Tag } from '@/engine/ecs/types';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { AIStateData } from '@/engine/ecs/components/AIStateData';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class PlayerMovementSystem implements IGameSystem {
  constructor(
    private input: IInputService,
    private registry: IEntityRegistry,
    private interaction: IInteractionSystem,
    private gameSystem: IGameStateSystem
  ) {}

  update(delta: number, time: number): void {
    let playerEntity = null;
    for (const p of this.registry.getByTag(Tag.PLAYER)) { playerEntity = p; break; }
    if (!playerEntity) return;

    const transform = playerEntity.getComponent<TransformData>(ComponentType.Transform);
    const cursor = this.input.getCursor();
    
    // 1. Position Sync
    if (transform) { 
        transform.x = cursor.x; 
        transform.y = cursor.y; 
    }

    if (this.gameSystem.isGameOver || this.gameSystem.playerHealth <= 0) return;

    // 2. Logic State Sync
    const stateComp = playerEntity.getComponent<AIStateData>(ComponentType.State);
    if (stateComp) {
        stateComp.current = this.interaction.repairState !== 'IDLE' ? 'REBOOTING' : 'ACTIVE';
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/StructureSystem.ts
=====================================
import { IGameSystem, IPanelSystem } from '@/engine/interfaces';

export class StructureSystem implements IGameSystem {
  private decayTimer = 0;
  private readonly DECAY_INTERVAL = 0.1; 
  private readonly DECAY_AMOUNT = 2; 

  constructor(private panelSystem: IPanelSystem) {}

  update(delta: number, time: number): void {
    this.decayTimer += delta;
    
    if (this.decayTimer >= this.DECAY_INTERVAL) {
        this.processDecay();
        this.decayTimer = 0;
    }
  }

  private processDecay() {
      const panels = this.panelSystem.getAllPanels();
      for (const p of panels) {
          if (p.isDestroyed && p.health > 0) {
               this.panelSystem.decayPanel(p.id, this.DECAY_AMOUNT);
          }
      }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/ParticleSystem.ts
=====================================
import { IGameSystem, IParticleSystem } from '@/engine/interfaces';
import * as THREE from 'three';

// UPDATED: Increased capacity to prevent starvation during chaotic scenes
const MAX_PARTICLES = 20000;

export class ParticleSystem implements IParticleSystem {
  public count = 0;

  // Data Oriented Design (Structure of Arrays)
  public x = new Float32Array(MAX_PARTICLES);
  public y = new Float32Array(MAX_PARTICLES);
  public vx = new Float32Array(MAX_PARTICLES);
  public vy = new Float32Array(MAX_PARTICLES);
  public life = new Float32Array(MAX_PARTICLES);
  public maxLife = new Float32Array(MAX_PARTICLES);
  public size = new Float32Array(MAX_PARTICLES);
  public shape = new Float32Array(MAX_PARTICLES); // 0=Square, 1=Teardrop
  
  public r = new Float32Array(MAX_PARTICLES);
  public g = new Float32Array(MAX_PARTICLES);
  public b = new Float32Array(MAX_PARTICLES);

  // Helper for hex parsing
  private tempColor = new THREE.Color();

  constructor() {
    this.count = 0;
  }

  update(delta: number, time: number): void {
    if (this.count === 0) return;

    let i = 0;
    while (i < this.count) {
      this.life[i] -= delta;

      if (this.life[i] <= 0) {
        this.swap(i, this.count - 1);
        this.count--;
        continue;
      }

      this.x[i] += this.vx[i] * delta;
      this.y[i] += this.vy[i] * delta;
      
      this.vx[i] *= 0.95;
      this.vy[i] *= 0.95;

      i++;
    }
  }

  public spawn(
      x: number, y: number, 
      colorHex: string, 
      vx: number, vy: number, 
      life: number, 
      size: number = 1.0, 
      shape: number = 0
  ) {
    if (this.count >= MAX_PARTICLES) return;

    const idx = this.count;
    this.x[idx] = x;
    this.y[idx] = y;
    this.vx[idx] = vx;
    this.vy[idx] = vy;
    this.life[idx] = life;
    this.maxLife[idx] = life;
    this.size[idx] = size;
    this.shape[idx] = shape;

    this.tempColor.set(colorHex);
    this.r[idx] = this.tempColor.r;
    this.g[idx] = this.tempColor.g;
    this.b[idx] = this.tempColor.b;

    this.count++;
  }

  private swap(a: number, b: number) {
    if (a === b) return;
    
    this.x[a] = this.x[b];
    this.y[a] = this.y[b];
    this.vx[a] = this.vx[b];
    this.vy[a] = this.vy[b];
    this.life[a] = this.life[b];
    this.maxLife[a] = this.maxLife[b];
    this.size[a] = this.size[b];
    this.shape[a] = this.shape[b];
    this.r[a] = this.r[b];
    this.g[a] = this.g[b];
    this.b[a] = this.b[b];
  }

  public getCount() { return this.count; }

  public getData() {
    return {
        x: this.x,
        y: this.y,
        life: this.life,
        maxLife: this.maxLife,
        color: this.r 
    };
  }

  teardown(): void {
    this.count = 0;
  }
}


=====================================
FILE: ./src/engine/systems/OrbitalSystem.ts
=====================================
import { IGameSystem, IEntityRegistry } from '@/engine/interfaces';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { OrbitalData } from '@/engine/ecs/components/OrbitalData';
import { Tag } from '@/engine/ecs/types';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class OrbitalSystem implements IGameSystem {
  constructor(private registry: IEntityRegistry) {}

  update(delta: number, time: number): void {
    const orbitals = this.registry.getAll();
    let player = null;
    const players = this.registry.getByTag(Tag.PLAYER);
    for (const p of players) {
        player = p;
        break; 
    }

    if (!player) return;
    
    const pPos = player.getComponent<TransformData>(ComponentType.Transform);
    if (!pPos) return;

    for (const entity of orbitals) {
        if (!entity.active) continue;
        
        const orb = entity.getComponent<OrbitalData>(ComponentType.Orbital);
        const transform = entity.getComponent<TransformData>(ComponentType.Transform);

        if (!orb || !transform) continue;

        if (orb.active) {
            orb.angle += orb.speed * delta;
        }

        transform.x = pPos.x + Math.cos(orb.angle) * orb.radius;
        transform.y = pPos.y + Math.sin(orb.angle) * orb.radius;
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/TimeSystem.ts
=====================================
import { IGameSystem } from '@/engine/interfaces';

export class TimeSystem implements IGameSystem {
  public timeScale: number = 1.0;
  public elapsedTime: number = 0; // Game World Time
  
  private freezeTimer: number = 0; // Real World Time duration

  // FPS Counting
  public fps: number = 60;
  private frames: number = 0;
  private lastFpsTime: number = 0;

  constructor() {
    this.reset();
  }

  // Called by GameEngine every render frame (Variable Interval)
  public tickRealTime(dt: number) {
      // 1. Handle Freeze Timer (Real Time)
      if (this.freezeTimer > 0) {
          this.freezeTimer -= dt;
          if (this.freezeTimer < 0) this.freezeTimer = 0;
      }

      // 2. FPS Calculation (Real Time)
      const now = performance.now() / 1000;
      this.frames++;
      if (now >= this.lastFpsTime + 1.0) {
          this.fps = this.frames;
          this.frames = 0;
          this.lastFpsTime = now;
      }
  }

  // Called by GameEngine only during simulation steps (Fixed Interval)
  update(delta: number, time: number): void {
    // This delta is always 0.0166 (Fixed Step)
    this.elapsedTime += delta;
  }

  teardown(): void {
    this.reset();
  }

  private reset() {
    this.timeScale = 1.0;
    this.elapsedTime = 0;
    this.freezeTimer = 0;
    this.frames = 0;
    this.lastFpsTime = 0;
    this.fps = 60;
  }
  
  public setScale(scale: number, duration?: number) {
    this.timeScale = scale;
    if (duration) {
      setTimeout(() => {
        this.timeScale = 1.0;
      }, duration * 1000);
    }
  }

  public freeze(duration: number) {
      this.freezeTimer = duration;
  }

  public isFrozen(): boolean {
      return this.freezeTimer > 0;
  }
}


=====================================
FILE: ./src/engine/systems/WeaponSystem.ts
=====================================
import { IGameSystem, IEntitySpawner, IGameStateSystem, IEntityRegistry, IGameEventService } from '@/engine/interfaces';
import { Tag } from '@/engine/ecs/types';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { AIStateData } from '@/engine/ecs/components/AIStateData';
import { TargetData } from '@/engine/ecs/components/TargetData';
import { RenderData } from '@/engine/ecs/components/RenderData';
import { GameEvents } from '@/engine/signals/GameEvents';
import { ConfigService } from '@/engine/services/ConfigService';
import { FastEventBus, FastEvents, FX_IDS } from '@/engine/signals/FastEventBus';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { calculatePlayerShots } from '@/engine/handlers/weapons/WeaponLogic';

export class WeaponSystem implements IGameSystem {
  private lastFireTime = 0;
  private unsubPurge: () => void;

  constructor(
    private spawner: IEntitySpawner,
    private registry: IEntityRegistry,
    private gameSystem: IGameStateSystem,
    private events: IGameEventService,
    private config: typeof ConfigService
  ) {
    this.unsubPurge = this.events.subscribe(GameEvents.UPGRADE_SELECTED, (p) => {
        if (p.option === 'PURGE') this.triggerPurge();
    });
  }

  update(delta: number, time: number): void {
    if (this.gameSystem.isGameOver || this.gameSystem.playerHealth <= 0) return;

    let playerEntity = null;
    for (const p of this.registry.getByTag(Tag.PLAYER)) { playerEntity = p; break; }
    if (!playerEntity) return;

    const stateComp = playerEntity.getComponent<AIStateData>(ComponentType.State);
    if (!stateComp || (stateComp.current !== 'ACTIVE' && stateComp.current !== 'REBOOTING')) return;

    const upgrades = this.gameSystem.activeUpgrades;
    const currentFireRate = this.config.player.fireRate / Math.pow(1.5, upgrades['OVERCLOCK'] || 0);

    if (time > this.lastFireTime + currentFireRate) {
        const transform = playerEntity.getComponent<TransformData>(ComponentType.Transform);
        const render = playerEntity.getComponent<RenderData>(ComponentType.Render);
        if (transform) {
            this.attemptAutoFire(time, transform, upgrades, render);
        }
    }
  }

  private triggerPurge() {
      const player = Array.from(this.registry.getByTag(Tag.PLAYER))[0];
      if (!player) return;
      const t = player.getComponent<TransformData>(ComponentType.Transform);
      if (!t) return;

      const count = 360; const speed = 45; const damage = 100;
      FastEventBus.emit(FastEvents.SPAWN_FX, FX_IDS['EXPLOSION_YELLOW'], t.x, t.y);
      FastEventBus.emit(FastEvents.TRAUMA, 1.0); 

      for (let i = 0; i < count; i++) {
          const angle = (Math.PI * 2 * i) / count;
          this.spawner.spawnBullet(t.x, t.y, Math.cos(angle) * speed, Math.sin(angle) * speed, false, 2.0, damage, 'PLAYER_PURGE');
      }
  }

  private attemptAutoFire(time: number, pPos: TransformData, upgrades: Record<string, number>, pRender?: RenderData) {
    const enemies = this.registry.getByTag(Tag.ENEMY);
    let nearestDist = Infinity; let targetEnemy = null;

    for (const e of enemies) {
      if (!e.active || e.hasTag(Tag.BULLET)) continue;
      const state = e.getComponent<AIStateData>(ComponentType.State);
      if (state && state.current === 'SPAWN') continue;
      const t = e.getComponent<TransformData>(ComponentType.Transform);
      if (!t) continue;
      const dist = (t.x - pPos.x)**2 + (t.y - pPos.y)**2; 
      if (dist < 196 && dist < nearestDist) { nearestDist = dist; targetEnemy = e; }
    }

    if (!targetEnemy) return;

    const tPos = targetEnemy.getComponent<TransformData>(ComponentType.Transform)!;
    const shots = calculatePlayerShots({ x: pPos.x, y: pPos.y }, { x: tPos.x, y: tPos.y }, upgrades);

    shots.forEach(shot => {
        const bullet = this.spawner.spawnBullet(shot.x, shot.y, shot.vx, shot.vy, false, shot.life, shot.damage, shot.configId);
        if (pRender) {
            const bRender = bullet.getComponent<RenderData>(ComponentType.Render);
            if (bRender) { bRender.r = pRender.r * 4; bRender.g = pRender.g * 4; bRender.b = pRender.b * 4; }
        }
        if (shot.isHoming) bullet.addComponent(new TargetData(null, 'ENEMY'));
    });

    FastEventBus.emit(FastEvents.PLAYER_FIRED, pPos.x, pPos.y);
    this.lastFireTime = time;
  }

  teardown(): void {
    this.unsubPurge();
  }
}


=====================================
FILE: ./src/engine/systems/ShakeSystem.ts
=====================================
import { IGameSystem, IGameEventService } from '@/engine/interfaces';
import { GameEvents } from '@/engine/signals/GameEvents';
import { noise } from '@/engine/math/Noise';
import { useStore } from '@/engine/state/global/useStore';

export class ShakeSystem implements IGameSystem {
  private trauma = 0;
  private time = 0;
  public currentOffset = { x: 0, y: 0, r: 0 };

  private readonly DECAY_RATE = 2.0; 
  private readonly MAX_OFFSET_X = 0.5; 
  private readonly MAX_OFFSET_Y = 0.3; 
  private readonly MAX_ROTATION = 0.04; 
  private readonly BASE_SPEED = 15.0; 
  private readonly TRAUMA_SPEED_BOOST = 65.0; 
  private readonly PIXELS_PER_UNIT = 40; 
  
  private cleanupListeners: (() => void) | null = null;

  constructor(private events: IGameEventService) {
    const unsub1 = this.events.subscribe(GameEvents.TRAUMA_ADDED, (p) => this.addTrauma(p.amount));
    const unsub2 = this.events.subscribe(GameEvents.PLAYER_HIT, (p) => {
        const amount = p.damage > 10 ? 0.45 : 0.2;
        this.addTrauma(amount);
    });
    
    this.cleanupListeners = () => {
        unsub1();
        unsub2();
    };
  }

  update(delta: number, time: number): void {
    const strength = useStore.getState().screenShakeStrength;
    
    if (this.trauma > 0) {
      this.trauma = Math.max(0, this.trauma - (delta * this.DECAY_RATE));
    }

    const shake = (this.trauma * this.trauma) * strength;
    
    if (shake > 0.001) {
        const currentSpeed = this.BASE_SPEED + (this.trauma * this.TRAUMA_SPEED_BOOST);
        this.time += delta * currentSpeed;
        
        const x = this.MAX_OFFSET_X * shake * noise(this.time);
        const y = this.MAX_OFFSET_Y * shake * noise(this.time + 100);
        const r = this.MAX_ROTATION * shake * noise(this.time + 200);
        
        this.currentOffset = { x, y, r };

        const domX = -x * this.PIXELS_PER_UNIT;
        const domY = -y * this.PIXELS_PER_UNIT; 
        
        const root = document.documentElement;
        root.style.setProperty('--shake-x', `${domX.toFixed(2)}px`);
        root.style.setProperty('--shake-y', `${-domY.toFixed(2)}px`);
        root.style.setProperty('--shake-r', `${r.toFixed(4)}rad`);
    } else {
        if (this.currentOffset.x !== 0) {
            this.resetDOM();
        }
    }
  }

  public addTrauma(amount: number) {
    this.trauma = Math.min(1.0, this.trauma + amount);
  }

  private resetDOM() {
      this.currentOffset = { x: 0, y: 0, r: 0 };
      const root = document.documentElement;
      root.style.setProperty('--shake-x', '0px');
      root.style.setProperty('--shake-y', '0px');
      root.style.setProperty('--shake-r', '0rad');
  }

  teardown(): void {
    if (this.cleanupListeners) this.cleanupListeners();
    this.resetDOM();
  }
}


=====================================
FILE: ./src/engine/systems/RenderSystem.ts
=====================================
import { IGameSystem, IEntityRegistry, IGameStateSystem, IInteractionSystem } from '@/engine/interfaces';
import { RenderData } from '@/engine/ecs/components/RenderData';
import { IdentityData } from '@/engine/ecs/components/IdentityData';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { Tag } from '@/engine/ecs/types';
import { GAME_THEME } from '@/ui/sim/config/theme';
import { MaterialFactory } from '@/engine/graphics/MaterialFactory';
import { FastEvents } from '@/engine/signals/FastEventBus';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { EventReader } from '@/engine/signals/EventReader';
import * as THREE from 'three';

const COL_BASE = new THREE.Color(GAME_THEME.turret.base);
const COL_REPAIR = new THREE.Color(GAME_THEME.turret.repair);
const COL_REBOOT = new THREE.Color('#9E4EA5');
const COL_DEAD = new THREE.Color('#FF003C');

const FLASH_COLOR = { r: 4.0, g: 0.0, b: 0.2 }; 

export class RenderSystem implements IGameSystem {
  private tempColor = new THREE.Color();
  private readonly FLASH_DECAY = 6.0; 
  private readonly SHUDDER_DECAY = 15.0; // Fast vibrational decay
  private reader: EventReader;

  constructor(
    private registry: IEntityRegistry,
    private gameSystem: IGameStateSystem,
    private interactionSystem: IInteractionSystem
  ) {
    this.reader = new EventReader(ServiceLocator.getFastEventBus());
  }

  update(delta: number, time: number): void {
    MaterialFactory.updateUniforms(time);

    this.reader.process((id, a1) => {
        if (id === FastEvents.ENEMY_DAMAGED) {
            const entity = this.registry.getEntity(a1);
            if (entity) {
                const render = entity.getComponent<RenderData>(ComponentType.Render);
                if (render) {
                    render.flash = 1.0; 
                }
            }
        }
    });

    const renderables = this.registry.query({ all: [ComponentType.Render] });
    const interactState = this.interactionSystem.repairState;
    const isDead = this.gameSystem.playerHealth <= 0;

    for (const entity of renderables) {
        if (!entity.active) continue;
        
        const render = entity.getComponent<RenderData>(ComponentType.Render);
        const identity = entity.getComponent<IdentityData>(ComponentType.Identity);
        
        if (!render) continue;

        const isPlayer = entity.hasTag(Tag.PLAYER) && (!identity || identity.variant === 'PLAYER');
        
        if (isPlayer) {
            this.updatePlayerVisuals(render, delta, interactState, isDead);
        }
        else {
            // SHUDDER DECAY
            if (render.shudder > 0) {
                render.shudder = Math.max(0, render.shudder - (delta * this.SHUDDER_DECAY));
            }

            // ENEMY 2-STAGE FLASH LOGIC
            if (render.flash > 0) {
                render.flash = Math.max(0, render.flash - (delta * this.FLASH_DECAY));
                
                const heatR = (render.baseR * 2.0) + 0.5;
                const heatG = (render.baseG * 2.0) + 0.5;
                const heatB = (render.baseB * 2.0) + 0.5;

                let targetR, targetG, targetB;

                if (render.flash > 0.4) {
                    const t = (render.flash - 0.4) / 0.6;
                    const ease = t * (2 - t); 
                    
                    targetR = this.lerp(heatR, FLASH_COLOR.r, ease);
                    targetG = this.lerp(heatG, FLASH_COLOR.g, ease);
                    targetB = this.lerp(heatB, FLASH_COLOR.b, ease);
                } else {
                    const t = render.flash / 0.4;
                    const ease = t * t; 

                    targetR = this.lerp(render.baseR, heatR, ease);
                    targetG = this.lerp(render.baseG, heatG, ease);
                    targetB = this.lerp(render.baseB, heatB, ease);
                }
                
                render.r = targetR;
                render.g = targetG;
                render.b = targetB;
                
                render.visualScale = 1.0 + (render.flash * 0.25); 
            } else {
                if (render.r !== render.baseR) render.r = render.baseR;
                if (render.g !== render.baseG) render.g = render.baseG;
                if (render.b !== render.baseB) render.b = render.baseB;
                if (render.visualScale !== 1.0) render.visualScale = 1.0;
            }
        }
    }
  }

  private updatePlayerVisuals(render: RenderData, delta: number, interactState: string, isDead: boolean) {
      let targetCol = COL_BASE;
      let spinSpeed = 0.02; 

      if (isDead) {
          targetCol = COL_DEAD;
          if (interactState === 'REBOOTING') {
              targetCol = COL_REBOOT;
              spinSpeed = -0.3; 
          } else {
              spinSpeed = 1.5; 
          }
      } else {
          if (interactState === 'HEALING') {
              targetCol = COL_REPAIR;
              spinSpeed = -0.24;
          } else if (interactState === 'REBOOTING') {
              targetCol = COL_REBOOT;
              spinSpeed = -0.24;
          }
      }

      this.tempColor.setRGB(render.r, render.g, render.b);
      this.tempColor.lerp(targetCol, delta * 3.0);
      render.r = this.tempColor.r;
      render.g = this.tempColor.g;
      render.b = this.tempColor.b;
      
      render.visualRotation += spinSpeed;
      render.visualScale = 1.0;
  }

  private lerp(start: number, end: number, t: number) {
      return start + (end - start) * t;
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/GuidanceSystem.ts
=====================================
import { IGameSystem, IEntityRegistry } from '@/engine/interfaces';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { MotionData } from '@/engine/ecs/components/MotionData';
import { TargetData } from '@/engine/ecs/components/TargetData';
import { Tag } from '@/engine/ecs/types';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class GuidanceSystem implements IGameSystem {
  constructor(private registry: IEntityRegistry) {}

  update(delta: number, time: number): void {
    const bullets = this.registry.getByTag(Tag.BULLET);

    for (const b of bullets) {
        if (!b.active) continue;
        
        const target = b.getComponent<TargetData>(ComponentType.Target);
        const motion = b.getComponent<MotionData>(ComponentType.Motion);
        const transform = b.getComponent<TransformData>(ComponentType.Transform);

        if (!target || !motion || !transform || !target.id) continue;

        const dx = target.x - transform.x;
        const dy = target.y - transform.y;
        
        const desiredAngle = Math.atan2(dy, dx);
        const currentAngle = Math.atan2(motion.vy, motion.vx);
        
        let diff = desiredAngle - currentAngle;
        while (diff > Math.PI) diff -= Math.PI * 2;
        while (diff < -Math.PI) diff += Math.PI * 2;

        const turnSpeed = 4.0; 
        
        const maxTurn = turnSpeed * delta;
        const actualTurn = Math.max(-maxTurn, Math.min(maxTurn, diff));
        const newAngle = currentAngle + actualTurn;
        
        const speed = Math.sqrt(motion.vx * motion.vx + motion.vy * motion.vy);
        motion.vx = Math.cos(newAngle) * speed;
        motion.vy = Math.sin(newAngle) * speed;
        
        transform.rotation = newAngle;
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/CombatSystem.ts
=====================================
import { IGameSystem, IEntityRegistry, IGameEventService, IFastEventService, IAudioService } from '@/engine/interfaces';
import { Entity } from '@/engine/ecs/Entity';
import { ColliderData } from '@/engine/ecs/components/ColliderData';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { CollisionMatrix } from '@/engine/handlers/combat/CollisionMatrix';
import { CombatContext } from '@/engine/handlers/combat/types';
import { FastEvents, FX_IDS, ENEMY_ID_MAP } from '@/engine/signals/FastEventBus';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { IdentityData } from '@/engine/ecs/components/IdentityData';

export class CombatSystem implements IGameSystem {
  constructor(
    private registry: IEntityRegistry,
    private events: IGameEventService,
    private fastEvents: IFastEventService,
    private audio: IAudioService
  ) {}

  update(delta: number, time: number): void {}

  public resolveCollision(e1: Entity, e2: Entity) {
      const col1 = e1.getComponent<ColliderData>(ComponentType.Collider);
      const col2 = e2.getComponent<ColliderData>(ComponentType.Collider);
      if (!col1 || !col2) return;

      const handler = CollisionMatrix.getHandler(col1.layer, col2.layer);
      if (!handler) return;

      let a = e1, b = e2;
      if (col1.layer > col2.layer) {
          a = e2; b = e1;
      }

      const context: CombatContext = {
          damagePlayer: (amount) => {
              this.fastEvents.emit(FastEvents.PLAYER_HIT, amount);
          },
          destroyEntity: (entity, fx, angle) => this.destroyEntity(entity, fx, angle),
          spawnFX: (type, x, y) => {
              const id = FX_IDS[type];
              if (id) this.fastEvents.emit(FastEvents.SPAWN_FX, id, x, y);
          },
          spawnImpact: (x, y, r, g, b, angle) => {
              const cr = Math.min(1, Math.max(0, r));
              const cg = Math.min(1, Math.max(0, g));
              const cb = Math.min(1, Math.max(0, b));
              const packed = (Math.floor(cr * 255) << 16) | (Math.floor(cg * 255) << 8) | Math.floor(cb * 255);
              this.fastEvents.emit(FastEvents.SPAWN_IMPACT, x, y, packed, angle);
          },
          playAudio: (key) => this.audio.playSound(key),
          playSpatialAudio: (key, x) => {
              const idKey = key.toUpperCase();
              const soundId = FX_IDS[idKey];
              if (soundId) {
                  this.fastEvents.emit(FastEvents.PLAY_SOUND, soundId, x);
              } else {
                  this.audio.playSound(key);
              }
          },
          addTrauma: (amount) => {
              this.fastEvents.emit(FastEvents.TRAUMA, amount);
          },
          flashEntity: (id) => {
              this.fastEvents.emit(FastEvents.ENEMY_DAMAGED, id);
          }
      };

      handler(a, b, context);
  }

  private destroyEntity(entity: Entity, fx?: string, impactAngle?: number) {
      const transform = entity.getComponent<TransformData>(ComponentType.Transform);
      const identity = entity.getComponent<IdentityData>(ComponentType.Identity);
      
      if (identity && transform) {
          const isEnemy = Object.values(EnemyTypes).includes(identity.variant as any);
          if (isEnemy && identity.variant !== EnemyTypes.DAEMON) {
              const typeId = ENEMY_ID_MAP[identity.variant] || 0;
              this.fastEvents.emit(FastEvents.ENEMY_DESTROYED, entity.id as number, transform.x, transform.y, typeId);
          }
      }

      this.registry.destroyEntity(entity.id);
      
      if (fx && transform) {
          let finalFX = fx;
          let angleToUse = impactAngle || 0;
          
          if (identity?.variant === EnemyTypes.HUNTER) {
              finalFX = impactAngle !== undefined ? 'EXPLOSION_YELLOW_DIR' : 'EXPLOSION_YELLOW';
          }
          else if (identity?.variant === EnemyTypes.KAMIKAZE) {
              finalFX = impactAngle !== undefined ? 'EXPLOSION_RED_DIR' : 'EXPLOSION_RED';
          }
          else if (identity?.variant === EnemyTypes.DRILLER) {
              finalFX = impactAngle !== undefined ? 'EXPLOSION_PURPLE_DIR' : 'EXPLOSION_PURPLE';
          }
          
          const id = FX_IDS[finalFX];
          if (id) {
              this.fastEvents.emit(FastEvents.SPAWN_FX, id, transform.x, transform.y, angleToUse);
          }
      }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/AudioDirector.ts
=====================================
import { IGameSystem, IPanelSystem, IGameEventService, IFastEventService, IAudioService } from '@/engine/interfaces';
import { GameEvents } from '@/engine/signals/GameEvents';
import { FastEvents, FX_ID_MAP } from '@/engine/signals/FastEventBus';
import { ViewportHelper } from '@/engine/math/ViewportHelper';

export class AudioDirector implements IGameSystem {
  private logTimer = 0;
  private readCursor = 0;
  
  constructor(
    private panelSystem: IPanelSystem,
    private events: IGameEventService,
    private fastEvents: IFastEventService,
    private audio: IAudioService
  ) {
    this.readCursor = this.fastEvents.getCursor();
    this.setupEventListeners();
  }

  update(delta: number, time: number): void {
    this.logTimer += delta;

    this.readCursor = this.fastEvents.readEvents(this.readCursor, (id, a1, a2, a3, a4) => {
        if (id === FastEvents.PLAY_SOUND) {
            const key = FX_ID_MAP[a1];
            
            if (this.logTimer > 1.0) {
                // this.events.emit(GameEvents.LOG_DEBUG, ...); // Optional logging
                this.logTimer = 0;
            }

            if (key) {
                const audioKey = key.toLowerCase();
                const pan = this.calculatePan(a2); 
                this.audio.playSound(audioKey, pan);
            }
        }
    });
  }

  private setupEventListeners() {
    this.events.subscribe(GameEvents.PLAYER_HIT, (p) => {
        this.audio.playSound('fx_impact_heavy', 0);
        this.audio.duckMusic(0.7, 1.0);
    });

    this.events.subscribe(GameEvents.ENEMY_DESTROYED, (p) => { 
        const pan = this.calculatePan(p.x);
        if (p.type === 'kamikaze') this.audio.playSound('fx_impact_heavy', pan);
        else this.audio.playSound('fx_impact_light', pan);
    });

    this.events.subscribe(GameEvents.PANEL_HEALED, (p) => {
        const pan = this.getPanelPan(p.id);
        this.audio.playSound('loop_heal', pan);
    });

    this.events.subscribe(GameEvents.PANEL_RESTORED, (p) => {
        const pan = p.x !== undefined ? this.calculatePan(p.x) : this.getPanelPan(p.id);
        this.audio.playSound('fx_reboot_success', pan);
    });

    this.events.subscribe(GameEvents.PANEL_DESTROYED, (p) => {
        const pan = this.getPanelPan(p.id);
        this.audio.playSound('fx_impact_heavy', pan); 
        this.audio.duckMusic(0.8, 1.5);
    });

    this.events.subscribe(GameEvents.GAME_OVER, () => {
        this.audio.playSound('fx_impact_heavy');
        this.audio.duckMusic(1.0, 3.0);
    });

    this.events.subscribe(GameEvents.UPGRADE_SELECTED, () => {
        this.audio.playSound('fx_level_up');
    });
  }

  private calculatePan(worldX: number): number {
      const halfWidth = ViewportHelper.viewport.width / 2;
      if (halfWidth === 0) return 0;
      return Math.max(-1, Math.min(1, worldX / halfWidth));
  }

  private getPanelPan(panelId: string): number {
      const rect = this.panelSystem.getPanelRect(panelId);
      if (!rect) return 0;
      return this.calculatePan(rect.x);
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/InputSystem.ts
=====================================
import { IGameSystem, IInputService } from '@/engine/interfaces';
import { VirtualJoystickService } from '@/engine/input/VirtualJoystickService';

export class InputSystem implements IGameSystem, IInputService {
  private _cursor = { x: 0, y: 0 };
  
  // Bounds for clamping (updated by GameEngine/ViewportHelper)
  private _bounds = { width: 30, height: 20 }; 

  update(delta: number, time: number): void {
    // Poll Providers
    if (VirtualJoystickService.isActive) {
        const joyVector = VirtualJoystickService.getVector();
        const speed = 30.0; // Virtual cursor speed
        
        this._cursor.x += joyVector.x * speed * delta;
        this._cursor.y += joyVector.y * speed * delta;

        // Clamp to logical world bounds
        const halfW = this._bounds.width / 2;
        const halfH = this._bounds.height / 2;
        
        this._cursor.x = Math.max(-halfW, Math.min(halfW, this._cursor.x));
        this._cursor.y = Math.max(-halfH, Math.min(halfH, this._cursor.y));
    }
  }

  teardown(): void {}

  // --- IInputService Implementation ---
  
  public updateCursor(x: number, y: number) {
    // Mouse movement takes precedence over joystick relative motion
    if (!VirtualJoystickService.isActive) {
        this._cursor.x = x;
        this._cursor.y = y;
    }
  }
  
  public updateBounds(width: number, height: number) {
      this._bounds.width = width;
      this._bounds.height = height;
  }

  public getCursor() {
    return this._cursor;
  }

  public isPressed(action: string): boolean {
    return false;
  }
}


=====================================
FILE: ./src/engine/systems/PanelRegistrySystem.ts
=====================================
import { IPanelSystem, IGameEventService, IAudioService } from '@/engine/interfaces';
import { GameEvents } from '@/engine/signals/GameEvents';
import { WorldRect } from '@/engine/math/ViewportHelper';
import { DOMSpatialService } from '@/engine/services/DOMSpatialService';
import { StructureHealthService } from '@/engine/services/StructureHealthService';

export class PanelRegistrySystem implements IPanelSystem {
  
  public get systemIntegrity() {
      return StructureHealthService.systemIntegrity;
  }

  constructor(
    private events: IGameEventService,
    private audio: IAudioService
  ) {
    StructureHealthService.reset();
    DOMSpatialService.refreshAll();
    
    this.events.subscribe(GameEvents.UPGRADE_SELECTED, (p) => {
        if (p.option === 'RESTORE') {
            const restoredCount = StructureHealthService.restoreAll();
            
            if (restoredCount > 0) {
                this.events.emit(GameEvents.TRAUMA_ADDED, { amount: 0.3 }); 
                this.audio.playSound('fx_reboot_success'); 
            }
        }
    });
  }

  update(delta: number, time: number): void {
  }

  teardown(): void {}

  public register(id: string, element: HTMLElement) {
      DOMSpatialService.register(id, element);
      StructureHealthService.register(id);
  }

  public unregister(id: string) {
      DOMSpatialService.unregister(id);
      StructureHealthService.unregister(id);
  }

  public refreshAll() { DOMSpatialService.refreshAll(); }
  public refreshSingle(id: string) { DOMSpatialService.refreshSingle(id); }

  public damagePanel(id: string, amount: number, silent: boolean = false, sourceX?: number, sourceY?: number) {
      StructureHealthService.damage(id, amount, silent, sourceX, sourceY);
  }

  public healPanel(id: string, amount: number, sourceX?: number) {
      StructureHealthService.heal(id, amount, sourceX);
  }
  
  public decayPanel(id: string, amount: number) {
      StructureHealthService.decay(id, amount);
  }

  public destroyAll() { StructureHealthService.destroyAll(); }

  public getPanelRect(id: string): WorldRect | undefined {
      return DOMSpatialService.getRect(id);
  }

  public getPanelState(id: string) {
      return StructureHealthService.getState(id);
  }
  
  public getAllPanels() {
      const results = [];
      const rects = DOMSpatialService.getAllRects();
      const states = StructureHealthService.getAllStates();
      
      for(const [id, rect] of rects) {
          const state = states.get(id) || { health: 0, isDestroyed: true };
          results.push({ ...rect, ...state });
      }
      return results;
  }
}


=====================================
FILE: ./src/engine/systems/index.ts
=====================================
export * from './BehaviorSystem';
export * from './CameraSystem';
export * from './CollisionSystem';
export * from './FXManager';
export * from './GameStateSystem';
export * from './InputSystem';
export * from './InteractionSystem';
export * from './LifeCycleSystem';
export * from './PanelRegistrySystem';
export * from './PhysicsSystem';
export * from './PlayerSystem';
export * from './TimeSystem';
export * from './UISyncSystem';
export * from './WaveSystem';


=====================================
FILE: ./src/engine/systems/ProgressionSystem.ts
=====================================
import { IGameSystem, IGameEventService } from '@/engine/interfaces';
import { GameEvents } from '@/engine/signals/GameEvents';
import { FastEvents } from '@/engine/signals/FastEventBus';
import { PLAYER_CONFIG } from '@/engine/config/PlayerConfig';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { TransientDOMService } from '@/engine/services/TransientDOMService';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { EventReader } from '@/engine/signals/EventReader';

export class ProgressionSystem implements IGameSystem {
  public score: number = 0;
  public xp: number = 0;
  public level: number = 1;
  public xpToNextLevel: number = PLAYER_CONFIG.baseXpRequirement;
  public upgradePoints: number = 0;
  public activeUpgrades: Record<string, number> = {
    'OVERCLOCK': 0, 'EXECUTE': 0, 'FORK': 0,
    'SNIFFER': 0, 'BACKDOOR': 0, 'REPAIR_NANITES': 0
  };

  private reader: EventReader;

  constructor(private events: IGameEventService) {
    this.reader = new EventReader(ServiceLocator.getFastEventBus());

    this.events.subscribe(GameEvents.UPGRADE_SELECTED, (p) => {
        this.applyUpgrade(p.option);
    });
    
    this.reset();
  }

  update(delta: number, time: number): void {
      this.reader.process((id, a1, a2, a3, a4) => {
          if (id === FastEvents.ENEMY_DESTROYED) {
              // a1=id, a2=x, a3=y, a4=typeId
              this.addScore(1);
              this.addXp(10);
          }
      });
  }

  public addScore(amount: number) {
    this.score += amount;
    TransientDOMService.update('score-display', this.score.toString().padStart(4, '0'));
  }

  public addXp(amount: number) {
    this.xp += amount;
    while (this.xp >= this.xpToNextLevel) {
        this.xp -= this.xpToNextLevel;
        this.level++;
        this.upgradePoints++;
        this.xpToNextLevel = Math.floor(this.xpToNextLevel * PLAYER_CONFIG.xpScalingFactor);
        
        this.events.emit(GameEvents.THREAT_LEVEL_UP, { level: this.level });
        this.syncStore();
    }
    
    const xpPercent = this.xpToNextLevel > 0 ? (this.xp / this.xpToNextLevel) : 0;
    TransientDOMService.update('xp-progress', xpPercent);
  }

  public applyUpgrade(option: string) {
      if (this.upgradePoints > 0) {
          this.upgradePoints--;
          if (option === 'PURGE' || option === 'RESTORE' || option === 'DAEMON') {
              this.syncStore(); 
              return;
          }
          this.activeUpgrades[option] = (this.activeUpgrades[option] || 0) + 1;
          this.syncStore();
      }
  }

  private syncStore() {
      useGameStore.getState().setProgressionData({
          xp: this.xp,
          level: this.level,
          nextXp: this.xpToNextLevel,
          points: this.upgradePoints
      });
  }

  public reset() {
      this.score = 0;
      this.xp = 0;
      this.level = 1;
      this.xpToNextLevel = PLAYER_CONFIG.baseXpRequirement;
      this.upgradePoints = 0;
      this.activeUpgrades = { 
        'OVERCLOCK': 0, 'EXECUTE': 0, 'FORK': 0,
        'SNIFFER': 0, 'BACKDOOR': 0, 'REPAIR_NANITES': 0
      };
      
      TransientDOMService.update('score-display', "0000");
      TransientDOMService.update('xp-progress', 0);
      TransientDOMService.update('player-lvl-text', "LVL_01");
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/GameStateSystem.ts
=====================================
import { IGameSystem, IGameStateSystem, IPanelSystem, IGameEventService, IAudioService } from '@/engine/interfaces';
import { GameEvents } from '@/engine/signals/GameEvents';
import { HealthSystem } from './HealthSystem';
import { ProgressionSystem } from './ProgressionSystem';

export class GameStateSystem implements IGameStateSystem {
  private heartbeatTimer: number = 0;

  constructor(
    private healthSys: HealthSystem,
    private progSys: ProgressionSystem,
    private panelSystem: IPanelSystem,
    private events: IGameEventService,
    private audio: IAudioService
  ) {
    this.events.subscribe(GameEvents.UPGRADE_SELECTED, (p) => {
        if (p.option === 'REPAIR_NANITES') {
            this.healthSys.healPlayer(this.healthSys.maxPlayerHealth * 0.2);
        } else if (p.option === 'DAEMON') {
            this.events.emit(GameEvents.SPAWN_DAEMON, null);
        }
    });
  }

  update(delta: number, time: number): void {
      if (this.isGameOver) return;

      const integrity = this.panelSystem.systemIntegrity;
      
      // Process Low Health Heartbeat FX
      if (integrity < 30 && integrity > 0) {
          this.heartbeatTimer -= delta;
          if (this.heartbeatTimer <= 0) {
              const urgency = 1.0 - (integrity / 30);
              this.audio.playSound('loop_warning');
              this.events.emit(GameEvents.HEARTBEAT, { urgency });
              this.heartbeatTimer = 1.4 - (urgency * 1.05); 
          }
      } else {
          this.heartbeatTimer = 0;
      }
  }

  teardown(): void {
      this.healthSys.reset();
      this.progSys.reset();
  }

  // Bridged Vitals Properties
  get playerHealth() { return this.healthSys.playerHealth; }
  get maxPlayerHealth() { return this.healthSys.maxPlayerHealth; }
  get playerRebootProgress() { return this.healthSys.playerRebootProgress; }
  get isGameOver() { return this.healthSys.isGameOver; }
  set isGameOver(v: boolean) { this.healthSys.isGameOver = v; }

  // Bridged Progression Properties
  get score() { return this.progSys.score; }
  get xp() { return this.progSys.xp; }
  get level() { return this.progSys.level; }
  get xpToNextLevel() { return this.progSys.xpToNextLevel; }
  get upgradePoints() { return this.progSys.upgradePoints; }
  get activeUpgrades() { return this.progSys.activeUpgrades; }

  // Bridged Methods
  damagePlayer(amount: number) { this.healthSys.damagePlayer(amount); }
  healPlayer(amount: number) { this.healthSys.healPlayer(amount); }
  tickReboot(amount: number) { this.healthSys.tickReboot(amount); }
  decayReboot(amount: number) { this.healthSys.decayReboot(amount); }
  addScore(amount: number) { this.progSys.addScore(amount); }
  addXp(amount: number) { this.progSys.addXp(amount); }
}


=====================================
FILE: ./src/engine/systems/MobileWaveSystem.ts
=====================================
import { IGameSystem, IEntitySpawner } from '@/engine/interfaces';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { ViewportHelper } from '@/engine/math/ViewportHelper';

export class MobileWaveSystem implements IGameSystem {
  private time = 0;
  private nextSpawn = 0;
  
  // Difficulty Config
  private readonly START_INTERVAL = 1.2;
  private readonly MIN_INTERVAL = 0.4;
  private readonly RAMP_DURATION = 60.0;

  constructor(private spawner: IEntitySpawner) {}

  update(delta: number, time: number): void {
    this.time += delta;

    if (this.time >= this.nextSpawn) {
        this.spawnDriller();
        
        // Difficulty Ramp
        const progress = Math.min(1.0, this.time / this.RAMP_DURATION);
        const currentInterval = this.START_INTERVAL - (progress * (this.START_INTERVAL - this.MIN_INTERVAL));
        
        this.nextSpawn = this.time + currentInterval;
    }
  }

  private spawnDriller() {
      const { width, height } = ViewportHelper.viewport;
      const pad = 3.0; // Spawn further out
      
      // RESTRICT TO TOP AND BOTTOM ONLY
      const isTop = Math.random() > 0.5;
      
      let x = (Math.random() - 0.5) * (width * 0.6); // Keep them somewhat central horizontally
      let y = 0;

      if (isTop) { 
          y = (height / 2) + pad;
      } else { 
          y = -(height / 2) - pad;
      }

      this.spawner.spawnEnemy(EnemyTypes.DRILLER, x, y);
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/TargetingSystem.ts
=====================================
import { IGameSystem, IPanelSystem, IEntityRegistry } from '@/engine/interfaces';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { TargetData } from '@/engine/ecs/components/TargetData';
import { Tag } from '@/engine/ecs/types';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class TargetingSystem implements IGameSystem {
  private playerCache: { x: number, y: number } | null = null;

  constructor(
    private registry: IEntityRegistry,
    private panelSystem: IPanelSystem
  ) {}

  update(delta: number, time: number): void {
    this.updatePlayerCache();

    const entities = this.registry.getAll();
    
    for (const entity of entities) {
        if (!entity.active) continue;

        const target = entity.getComponent<TargetData>(ComponentType.Target);
        if (!target) continue;

        const transform = entity.getComponent<TransformData>(ComponentType.Transform);
        if (!transform) continue;

        // 1. UPDATE EXISTING LOCK
        if (target.locked && target.id) {
            if (target.type === 'PANEL') {
                const panel = this.panelSystem.getPanelState(target.id);
                if (!panel || panel.isDestroyed) {
                    target.locked = false;
                    target.id = null;
                } else {
                    const rect = this.panelSystem.getPanelRect(target.id);
                    if (rect) {
                        // CLAMP TO EDGE: Drillers want to go to the surface, not the center
                        target.x = Math.max(rect.left, Math.min(transform.x, rect.right));
                        target.y = Math.max(rect.bottom, Math.min(transform.y, rect.top));
                    }
                }
            }
            else if (target.type === 'ENEMY') {
                // Enemies don't typically track other enemies persistently in this game logic yet
                target.locked = false; 
            }
            else if (target.type === 'PLAYER' && this.playerCache) {
                target.x = this.playerCache.x;
                target.y = this.playerCache.y;
            }
            
            if (target.locked) continue; 
        }

        // 2. ACQUIRE NEW TARGET
        if (target.type === 'PLAYER') {
            if (this.playerCache) {
                target.x = this.playerCache.x;
                target.y = this.playerCache.y;
                target.id = 'PLAYER';
                // Player target is implicitly "locked" as it updates every frame above
            }
        }
        else if (target.type === 'PANEL') {
            const bestPanel = this.findNearestPanel(transform.x, transform.y);
            if (bestPanel) {
                target.id = bestPanel.id;
                // Initial Clamp
                target.x = Math.max(bestPanel.left, Math.min(transform.x, bestPanel.right));
                target.y = Math.max(bestPanel.bottom, Math.min(transform.y, bestPanel.top));
                target.locked = true; 
            } else {
                // Fallback to Player if no panels alive (rare)
                if (this.playerCache) {
                    target.x = this.playerCache.x;
                    target.y = this.playerCache.y;
                    target.id = 'PLAYER';
                }
            }
        }
        else if (target.type === 'ENEMY') {
            const bestEnemy = this.findNearestEnemy(transform.x, transform.y);
            if (bestEnemy) {
                target.x = bestEnemy.x;
                target.y = bestEnemy.y;
                target.id = 'ENEMY_LOCKED';
            } else {
                target.id = null; 
            }
        }
    }
  }

  private updatePlayerCache() {
      const players = this.registry.getByTag(Tag.PLAYER);
      for (const p of players) {
          const t = p.getComponent<TransformData>(ComponentType.Transform);
          if (t) {
              this.playerCache = { x: t.x, y: t.y };
              return;
          }
      }
      this.playerCache = null;
  }

  private findNearestPanel(x: number, y: number) {
      const panels = this.panelSystem.getAllPanels();
      let nearest: any = null;
      let minDist = Infinity;

      for (const p of panels) {
          if (p.isDestroyed) continue;
          
          // Calculate distance to the NEAREST POINT on the rect, not center
          const clampedX = Math.max(p.left, Math.min(x, p.right));
          const clampedY = Math.max(p.bottom, Math.min(y, p.top));
          
          const dx = clampedX - x;
          const dy = clampedY - y;
          const distSq = dx*dx + dy*dy;
          
          if (distSq < minDist) {
              minDist = distSq;
              nearest = p;
          }
      }
      return nearest;
  }

  private findNearestEnemy(x: number, y: number) {
      const enemies = this.registry.getByTag(Tag.ENEMY);
      let nearest: { x: number, y: number } | null = null;
      let minDist = Infinity;
      const MAX_RANGE_SQ = 15 * 15; 

      for (const e of enemies) {
          if (!e.active) continue;
          if (e.hasTag(Tag.BULLET)) continue;

          const t = e.getComponent<TransformData>(ComponentType.Transform);
          if (!t) continue;
          
          const dx = t.x - x;
          const dy = t.y - y;
          const distSq = dx*dx + dy*dy;
          
          if (distSq < minDist && distSq < MAX_RANGE_SQ) {
              minDist = distSq;
              nearest = { x: t.x, y: t.y };
          }
      }
      return nearest;
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/BehaviorSystem.ts
=====================================
import { IGameSystem, IEntitySpawner, IPanelSystem, IParticleSystem, IEntityRegistry, IAudioService } from '@/engine/interfaces';
import { IdentityData } from '@/engine/ecs/components/IdentityData';
import { ProjectileData } from '@/engine/ecs/components/ProjectileData';
import { OrbitalData } from '@/engine/ecs/components/OrbitalData';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { GameEventBus } from '@/engine/signals/GameEventBus'; 
import { GameEvents } from '@/engine/signals/GameEvents'; 
import { useGameStore } from '@/engine/state/game/useGameStore';
import { ConfigService } from '@/engine/services/ConfigService';
import { FastEventBus, FastEvents, FX_IDS } from '@/engine/signals/FastEventBus';
import { ViewportHelper } from '@/engine/math/ViewportHelper';
import { AIRegistry } from '@/engine/handlers/ai/AIRegistry';
import { AIContext } from '@/engine/handlers/ai/types';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class BehaviorSystem implements IGameSystem {
  constructor(
    private registry: IEntityRegistry,
    private spawner: IEntitySpawner,
    private config: typeof ConfigService,
    private panelSystem: IPanelSystem,
    private particleSystem: IParticleSystem,
    private audio: IAudioService
  ) {
    GameEventBus.subscribe(GameEvents.SPAWN_DAEMON, () => {
        const e = this.spawner.spawnEnemy(EnemyTypes.DAEMON, 0, 0);
        const orbital = e.getComponent<OrbitalData>(ComponentType.Orbital);
        if (orbital) {
            orbital.radius = 4.0;
            orbital.speed = 1.5 + Math.random() * 1.0; 
            orbital.angle = Math.random() * Math.PI * 2;
        }
    });
  }

  update(delta: number, time: number): void {
    const upgrades = useGameStore.getState().activeUpgrades;
    const halfWidth = ViewportHelper.viewport.width / 2;

    const aiContext: AIContext = {
      delta,
      time,
      spawnProjectile: (x, y, vx, vy, damage, configId, ownerId) => {
          let bullet;
          if (damage) {
              const finalConfig = configId || 'DAEMON_ORB';
              bullet = this.spawner.spawnBullet(x, y, vx, vy, false, 2.0, damage, finalConfig);
              bullet.addComponent(new IdentityData('DAEMON_SHOT'));
          } else {
              const finalConfig = configId || 'ENEMY_HUNTER';
              bullet = this.spawner.spawnBullet(x, y, vx, vy, true, 3.0, 10, finalConfig);
          }

          if (ownerId !== undefined) {
              const proj = bullet.getComponent<ProjectileData>(ComponentType.Projectile);
              if (proj) proj.ownerId = ownerId;
          }

          return bullet;
      },
      spawnDrillSparks: (x, y, angle) => FastEventBus.emit(FastEvents.SPAWN_FX, FX_IDS['DRILL_SPARKS'], x, y, angle),
      spawnLaunchSparks: (x, y, angle) => FastEventBus.emit(FastEvents.SPAWN_FX, FX_IDS['HUNTER_RECOIL'], x, y, angle),
      spawnFX: (type, x, y) => {
          const id = FX_IDS[type];
          if (id) FastEventBus.emit(FastEvents.SPAWN_FX, id, x, y, 0);
      },
      spawnParticle: (x, y, color, vx, vy, life, size) => {
          this.particleSystem.spawn(x, y, color, vx, vy, life, size, 1);
      },
      // UPDATED: Passing Through Coordinates
      damagePanel: (id, amount, sx, sy) => this.panelSystem.damagePanel(id, amount, false, sx, sy),
      getPanelRect: (id) => this.panelSystem.getPanelRect(id),
      playSound: (key, x) => {
          const pan = x !== undefined && halfWidth > 0 
            ? Math.max(-1, Math.min(1, x / halfWidth)) 
            : 0;
          this.audio.playSound(key, pan);
      },
      getUpgradeLevel: (key) => upgrades[key] || 0,
      config: this.config
    };

    const entities = this.registry.getAll();
    for (const entity of entities) {
        if (!entity.active) continue;
        const identity = entity.getComponent<IdentityData>(ComponentType.Identity);
        if (!identity) continue;

        const behavior = AIRegistry.get(identity.variant);
        if (behavior) {
            behavior.update(entity, aiContext);
        }
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/WaveSystem.ts
=====================================
import { IGameSystem, IEntitySpawner, IPanelSystem } from '@/engine/interfaces';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { useStore } from '@/engine/state/global/useStore';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { MODEL_CONFIG } from '@/engine/config/ModelConfig';
import waves from '@/engine/config/static/waves.json';

interface WaveDef {
    at: number;
    type: string;
    count: number;
    interval: number;
}

// Dynamic offset to match Driller model
const DRILLER_OFFSET = MODEL_CONFIG.DRILLER.height / 2; 

export class WaveSystem implements IGameSystem {
  private waveTime = 0;
  private currentWaveIndex = 0;
  private spawnQueue: { type: string, time: number }[] = [];
  private loopCount = 0;
  private timeline: WaveDef[] = waves as WaveDef[];
  private scenarioInit = false;

  constructor(
    private spawner: IEntitySpawner,
    private panelSystem: IPanelSystem
  ) {
    this.reset();
  }

  private reset() {
    this.waveTime = 0;
    this.currentWaveIndex = 0;
    this.spawnQueue = [];
    this.loopCount = 0;
    this.scenarioInit = false;
  }

  update(delta: number, time: number): void {
    if (useGameStore.getState().isZenMode) return;
    if (useStore.getState().bootState === 'sandbox') return;

    if (!this.scenarioInit) {
        const panels = this.panelSystem.getAllPanels();
        const ready = panels.some(p => p.width > 0);
        
        if (ready) {
            this.runScenario(panels);
            this.scenarioInit = true;
        }
    }

    this.waveTime += delta;
    
    if (!useStore.getState().debugFlags.peaceMode) {
        this.checkTimeline();
        this.processQueue(time);
    }

    this.handleBreaches(delta);
  }

  private runScenario(panels: any[]) {
      this.panelSystem.damagePanel('art', 9999, true); 
      this.panelSystem.damagePanel('video', 85, true); 
      const videoPanel = panels.find(p => p.id === 'video');
      if (videoPanel) {
          this.spawnDrillerOn(videoPanel, 3);
      }

      const targets = panels.filter(p => p.id !== 'art' && p.id !== 'video');
      
      targets.forEach(p => {
          const dmg = 20 + Math.floor(Math.random() * 30);
          this.panelSystem.damagePanel(p.id, dmg, true); 
          const count = 1 + Math.floor(Math.random() * 3);
          this.spawnDrillerOn(p, count);
      });
  }

  private spawnDrillerOn(panel: any, count: number) {
      for(let i=0; i<count; i++) {
          const side = Math.floor(Math.random() * 4);
          let edgeX = 0, edgeY = 0; 
          let normalX = 0, normalY = 0; 
          
          const halfW = panel.width / 2;
          const halfH = panel.height / 2;
          
          switch(side) {
              case 0: // Top
                  edgeX = (Math.random() - 0.5) * panel.width;
                  edgeY = halfH;
                  normalX = 0; normalY = 1;
                  break;
              case 1: // Bottom
                  edgeX = (Math.random() - 0.5) * panel.width;
                  edgeY = -halfH;
                  normalX = 0; normalY = -1;
                  break;
              case 2: // Left
                  edgeX = -halfW;
                  edgeY = (Math.random() - 0.5) * panel.height;
                  normalX = -1; normalY = 0;
                  break;
              case 3: // Right
                  edgeX = halfW;
                  edgeY = (Math.random() - 0.5) * panel.height;
                  normalX = 1; normalY = 0;
                  break;
          }

          const spawnX = panel.x + edgeX + (normalX * DRILLER_OFFSET);
          const spawnY = panel.y + edgeY + (normalY * DRILLER_OFFSET);
          const angle = Math.atan2(-normalY, -normalX);

          this.spawner.spawn(EnemyTypes.DRILLER, {
              [ComponentType.Transform]: { 
                  x: spawnX, 
                  y: spawnY, 
                  scale: 1.0, 
                  rotation: angle 
              },
              [ComponentType.State]: { 
                  current: 'ACTIVE',
                  timers: { 
                      spawn: 0,
                      drillAudio: Math.random() * 0.2 
                  } 
              },
              [ComponentType.Render]: { 
                  visualScale: 1.0 
              }
          });
      }
  }

  private handleBreaches(delta: number) {
      const flags = useStore.getState().debugFlags;
      if (flags.panelGodMode || flags.peaceMode) return;

      const allPanels = this.panelSystem.getAllPanels();
      const deadPanels = allPanels.filter(p => p.isDestroyed && p.width > 0);
      
      if (deadPanels.length === 0) return;

      const enemiesPerSecondPerPanel = 0.2 + (this.waveTime * 0.005);
      const spawnChance = enemiesPerSecondPerPanel * delta;

      for (const p of deadPanels) {
          if (Math.random() < spawnChance) {
              this.spawnBreachEnemy(p);
          }
      }
  }

  private spawnBreachEnemy(p: any) {
      const rand = Math.random();
      let type = EnemyTypes.DRILLER;
      if (rand > 0.85) type = EnemyTypes.HUNTER;
      else if (rand > 0.60) type = EnemyTypes.KAMIKAZE;

      const safeW = p.width * 0.7; 
      const safeH = p.height * 0.7;
      
      const offsetX = (Math.random() - 0.5) * safeW;
      const offsetY = (Math.random() - 0.5) * safeH;
      
      this.spawner.spawnEnemy(type, p.x + offsetX, p.y + offsetY);
  }

  private checkTimeline() {
    if (this.currentWaveIndex >= this.timeline.length) {
        this.waveTime = 0;
        this.currentWaveIndex = 0;
        this.loopCount++;
    }

    const nextWave = this.timeline[this.currentWaveIndex];
    if (nextWave && this.waveTime >= nextWave.at) {
        this.queueSpawns(nextWave);
        this.currentWaveIndex++;
    }
  }

  private queueSpawns(wave: WaveDef) {
    const count = wave.count + (this.loopCount * 2);
    for (let i = 0; i < count; i++) {
        this.spawnQueue.push({
            type: wave.type,
            time: this.waveTime + (i * wave.interval)
        });
    }
  }

  private processQueue(currentTime: number) {
    for (let i = this.spawnQueue.length - 1; i >= 0; i--) {
        const spawn = this.spawnQueue[i];
        if (this.waveTime >= spawn.time) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 25; 
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            this.spawner.spawnEnemy(spawn.type, x, y);
            this.spawnQueue.splice(i, 1);
        }
    }
  }

  teardown(): void {
    this.reset();
  }
}


=====================================
FILE: ./src/engine/systems/LifeCycleSystem.ts
=====================================
import { IGameSystem, IEntityRegistry, IGameEventService } from '@/engine/interfaces';
import { LifetimeData } from '@/engine/ecs/components/LifetimeData';
import { HealthData } from '@/engine/ecs/components/HealthData';
import { IdentityData } from '@/engine/ecs/components/IdentityData';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { GameEvents, FXVariant } from '@/engine/signals/GameEvents';
import { FastEvents, FX_IDS } from '@/engine/signals/FastEventBus';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class LifeCycleSystem implements IGameSystem {
  constructor(
    private registry: IEntityRegistry,
    private events: IGameEventService
  ) {
    this.events.subscribe(GameEvents.ZEN_MODE_ENABLED, () => {
        this.registry.clear();
    });
  }

  update(delta: number, time: number): void {
    const mortals = this.registry.query({ any: [ComponentType.Lifetime, ComponentType.Health] });

    for (const entity of mortals) {
      if (!entity.active) continue;

      const lifetime = entity.getComponent<LifetimeData>(ComponentType.Lifetime);
      if (lifetime) {
        lifetime.remaining -= delta;
        if (lifetime.remaining <= 0) {
          this.registry.destroyEntity(entity.id);
          continue;
        }
      }

      const health = entity.getComponent<HealthData>(ComponentType.Health);
      if (health && health.current <= 0) {
          const identity = entity.getComponent<IdentityData>(ComponentType.Identity);
          const transform = entity.getComponent<TransformData>(ComponentType.Transform);
          
          if (identity && transform) {
             this.events.emit(GameEvents.ENEMY_DESTROYED, { 
                id: entity.id as number, 
                type: identity.variant, 
                x: transform.x, 
                y: transform.y 
             });
             
             let fx: FXVariant = 'EXPLOSION_PURPLE';
             if (identity.variant === EnemyTypes.HUNTER) fx = 'EXPLOSION_YELLOW';
             else if (identity.variant === EnemyTypes.KAMIKAZE) fx = 'EXPLOSION_RED';
             
             // Emitting SPAWN_FX via normal event bus for VFXSystem to pick up
             this.events.emit(GameEvents.SPAWN_FX, { type: fx, x: transform.x, y: transform.y });
          }
          
          this.registry.destroyEntity(entity.id);
      }
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/PhysicsSystem.ts
=====================================
import { IPhysicsSystem, IEntityRegistry } from '@/engine/interfaces';
import { SpatialGrid } from '@/engine/ecs/SpatialGrid';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { MotionData } from '@/engine/ecs/components/MotionData';
import { EntityRegistry } from '@/engine/ecs/EntityRegistry';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class PhysicsSystem implements IPhysicsSystem {
  public spatialGrid: SpatialGrid;
  private registry: EntityRegistry;

  constructor(registry: IEntityRegistry) {
    this.spatialGrid = new SpatialGrid();
    this.registry = registry as EntityRegistry;
    this.spatialGrid.clear();
  }

  update(delta: number, time: number): void {
    this.spatialGrid.clear();
    
    const movables = this.registry.query({ all: [ComponentType.Transform, ComponentType.Motion] });
    
    for (const entity of movables) {
      if (!entity.active) continue;

      const transform = entity.getComponent<TransformData>(ComponentType.Transform);
      const motion = entity.getComponent<MotionData>(ComponentType.Motion);
      
      if (transform && motion) {
        transform.x += motion.vx * delta;
        transform.y += motion.vy * delta;
        
        if (motion.friction > 0) {
            motion.vx *= (1 - motion.friction);
            motion.vy *= (1 - motion.friction);
        }

        this.spatialGrid.insert(entity.id, transform.x, transform.y);
      }
    }
  }

  teardown(): void {
    this.spatialGrid.clear();
  }
}


=====================================
FILE: ./src/engine/handlers/combat/CombatHandlers.ts
=====================================
import { Entity } from '@/engine/ecs/Entity';
import { CombatContext } from './types';
import { HealthData } from '@/engine/ecs/components/HealthData';
import { IdentityData } from '@/engine/ecs/components/IdentityData';
import { AIStateData } from '@/engine/ecs/components/AIStateData';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { CombatData } from '@/engine/ecs/components/CombatData';
import { RenderData } from '@/engine/ecs/components/RenderData';
import { MotionData } from '@/engine/ecs/components/MotionData';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { VFXKey } from '@/engine/config/AssetKeys';

const getHp = (e: Entity) => e.getComponent<HealthData>(ComponentType.Health);
const getId = (e: Entity) => e.getComponent<IdentityData>(ComponentType.Identity);
const getPos = (e: Entity) => e.getComponent<TransformData>(ComponentType.Transform);
const getCombat = (e: Entity) => e.getComponent<CombatData>(ComponentType.Combat);
const getRender = (e: Entity) => e.getComponent<RenderData>(ComponentType.Render);
const getMotion = (e: Entity) => e.getComponent<MotionData>(ComponentType.Motion);
const getAI = (e: Entity) => e.getComponent<AIStateData>(ComponentType.State);

const THEME_MAP: Record<string, string> = {
    [EnemyTypes.KAMIKAZE]: 'RED',
    [EnemyTypes.HUNTER]: 'YELLOW',
    [EnemyTypes.DRILLER]: 'PURPLE',
    [EnemyTypes.DAEMON]: 'PURPLE',
};

const getExplosionKey = (variant: string, directional: boolean): VFXKey => {
    const theme = THEME_MAP[variant] || 'PURPLE';
    return (directional ? `EXPLOSION_${theme}_DIR` : `EXPLOSION_${theme}`) as VFXKey;
};

const resolveImpactVisuals = (source: Entity, x: number, y: number, angle: number, ctx: CombatContext, overrideFX?: string) => {
    if (overrideFX) {
        ctx.spawnFX(overrideFX as VFXKey, x, y);
        return;
    }

    const render = getRender(source);
    if (render) {
        const maxC = Math.max(render.r, render.g, render.b, 1.0); 
        ctx.spawnImpact(x, y, render.r / maxC, render.g / maxC, render.b / maxC, angle);
    } else {
        ctx.spawnFX('IMPACT_WHITE', x, y);
    }
};

const applyKnockback = (entity: Entity, sourcePos: TransformData | undefined, force: number) => {
    const motion = getMotion(entity);
    const pos = getPos(entity);
    const ai = getAI(entity);
    const render = getRender(entity);

    if (motion && pos && sourcePos) {
        const dx = pos.x - sourcePos.x;
        const dy = pos.y - sourcePos.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dist > 0.001) {
            // Apply Impulse
            motion.vx += (dx / dist) * force;
            motion.vy += (dy / dist) * force;
            
            // Trigger Micro-Stun (Stops AI overwriting velocity)
            if (ai) ai.stunTimer = 0.15; // 150ms stun
            
            // Trigger Visual Shudder
            if (render) render.shudder = 1.0;
        }
    }
};

export const handlePlayerCrash = (player: Entity, enemy: Entity, ctx: CombatContext) => {
  const pId = getId(player);
  if (pId?.variant === EnemyTypes.DAEMON) { resolveDaemonCollision(player, enemy, ctx); return; }

  const combat = getCombat(enemy);
  const pos = getPos(enemy);
  const pPos = getPos(player);
  const damage = combat ? combat.damage : 1;

  let sprayAngle = 0;
  if (pos && pPos) sprayAngle = Math.atan2(pos.y - pPos.y, pos.x - pPos.x) + Math.PI;

  ctx.damagePlayer(damage);
  ctx.addTrauma(damage >= 3 ? 0.5 : 0.2);
  
  const variant = getId(enemy)?.variant || 'UNKNOWN';
  ctx.destroyEntity(enemy, getExplosionKey(variant, true), sprayAngle);
  
  ctx.playSpatialAudio(damage >= 3 ? 'fx_impact_heavy' : 'fx_impact_light', pos ? pos.x : 0);
};

export const handlePlayerHit = (player: Entity, bullet: Entity, ctx: CombatContext) => {
  const pId = getId(player);
  if (pId?.variant === EnemyTypes.DAEMON) { resolveDaemonCollision(player, bullet, ctx, 1); return; }

  const combat = getCombat(bullet);
  const pos = getPos(bullet);
  const damage = combat ? combat.damage : 1;

  ctx.damagePlayer(damage);
  ctx.destroyEntity(bullet, 'IMPACT_RED'); 
  ctx.playSpatialAudio('fx_impact_heavy', pos ? pos.x : 0);
};

export const handleEnemyHit = (enemy: Entity, bullet: Entity, ctx: CombatContext) => {
  const bPos = getPos(bullet);
  
  // TUNED: Reduced force from 15.0 to 3.0 for subtle impact
  applyKnockback(enemy, bPos, 3.0);
  
  handleMassExchange(enemy, bullet, ctx, undefined, bPos ? bPos.rotation + Math.PI : 0);
};

export const handleBulletClash = (bulletA: Entity, bulletB: Entity, ctx: CombatContext) => {
  handleMassExchange(bulletA, bulletB, ctx, 'CLASH_YELLOW');
};

function resolveDaemonCollision(daemon: Entity, attacker: Entity, ctx: CombatContext, fixedDamage?: number) {
  const state = daemon.getComponent<AIStateData>(ComponentType.State);
  if (!state) return;
  
  const pos = getPos(attacker);
  const incomingDamage = fixedDamage || (getCombat(attacker)?.damage || 1);
  const shield = state.data.shieldHP || 0;

  if (state.current === 'CHARGING' || state.current === 'READY') {
      if (shield > 0) {
          state.data.shieldHP = Math.max(0, shield - incomingDamage);
          state.data.wasHit = true; 
          
          const isEnemy = attacker.hasTag('ENEMY');
          const fx = isEnemy ? 'CLASH_YELLOW' : 'IMPACT_WHITE';
          
          ctx.destroyEntity(attacker, fx);
          ctx.playSpatialAudio('fx_impact_light', pos ? pos.x : 0);
          return;
      }
  }
  
  const isEnemy = attacker.hasTag('ENEMY');
  ctx.destroyEntity(attacker, isEnemy ? 'EXPLOSION_RED' : 'IMPACT_RED');
  ctx.playSpatialAudio('fx_impact_light', pos ? pos.x : 0);
}

function handleMassExchange(a: Entity, b: Entity, ctx: CombatContext, forceFX?: string, sprayAngle?: number) {
  const hpA = getHp(a); const hpB = getHp(b);
  const cA = getCombat(a); const cB = getCombat(b);
  const dmgA = cA ? cA.damage : 1; const dmgB = cB ? cB.damage : 1;

  if (hpA) {
      hpA.current = Math.max(0, hpA.current - dmgB);
      if (hpA.current > 0) ctx.flashEntity(a.id as number); 
  }
  if (hpB) {
      hpB.current = Math.max(0, hpB.current - dmgA);
      if (hpB.current > 0) ctx.flashEntity(b.id as number); 
  }

  const posA = getPos(a);
  const posB = getPos(b);
  
  if (posA) {
      const angle = posB ? Math.atan2(posB.y - posA.y, posB.x - posA.x) : 0;
      resolveImpactVisuals(b, posA.x, posA.y, angle, ctx, forceFX);
  }

  let soundKey = '';
  if (hpA && hpA.current <= 0) { ctx.destroyEntity(a, 'IMPACT_WHITE', sprayAngle); soundKey = 'fx_impact_light'; }
  if (hpB && hpB.current <= 0) { ctx.destroyEntity(b, 'IMPACT_WHITE', sprayAngle); soundKey = 'fx_impact_light'; }
  
  if (soundKey) ctx.playSpatialAudio(soundKey, posA ? posA.x : 0);
}


=====================================
FILE: ./src/engine/handlers/combat/CollisionMatrix.ts
=====================================
import { CollisionLayers } from '@/engine/config/PhysicsConfig';
import { CollisionHandler } from './types';
import * as Handlers from './CombatHandlers';

class CollisionMatrixController {
  private matrix = new Map<string, CollisionHandler>();

  constructor() {
    this.register(CollisionLayers.PLAYER, CollisionLayers.ENEMY, Handlers.handlePlayerCrash);
    this.register(CollisionLayers.PLAYER, CollisionLayers.ENEMY_PROJECTILE, Handlers.handlePlayerHit);
    this.register(CollisionLayers.ENEMY, CollisionLayers.PLAYER_PROJECTILE, Handlers.handleEnemyHit);
    this.register(CollisionLayers.PLAYER_PROJECTILE, CollisionLayers.ENEMY_PROJECTILE, Handlers.handleBulletClash);
  }

  private getKey(layerA: number, layerB: number): string {
    // Sort to ensure A:B is same as B:A
    return layerA < layerB ? `${layerA}:${layerB}` : `${layerB}:${layerA}`;
  }

  private register(layerA: number, layerB: number, handler: CollisionHandler) {
    this.matrix.set(this.getKey(layerA, layerB), handler);
  }

  public getHandler(layerA: number, layerB: number): CollisionHandler | undefined {
    return this.matrix.get(this.getKey(layerA, layerB));
  }
}

export const CollisionMatrix = new CollisionMatrixController();


=====================================
FILE: ./src/engine/handlers/combat/types.ts
=====================================
import { Entity } from '@/engine/ecs/Entity';

export interface CombatContext {
  damagePlayer: (amount: number) => void;
  destroyEntity: (entity: Entity, fx?: string, impactAngle?: number) => void;
  spawnFX: (type: string, x: number, y: number) => void;
  spawnImpact: (x: number, y: number, r: number, g: number, b: number, angle: number) => void;
  playAudio: (key: string) => void;
  playSpatialAudio: (key: string, x: number) => void;
  addTrauma: (amount: number) => void;
  // NEW: Flash visual support
  flashEntity: (id: number) => void;
}

export type CollisionHandler = (entityA: Entity, entityB: Entity, ctx: CombatContext) => void;


=====================================
FILE: ./src/engine/handlers/weapons/WeaponLogic.ts
=====================================
import { Entity } from '@/engine/ecs/Entity';
import { ConfigService } from '@/engine/services/ConfigService';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { ComponentType } from '@/engine/ecs/ComponentType';

export interface ShotDef {
  x: number;
  y: number;
  vx: number;
  vy: number;
  damage: number;
  life: number;
  configId: string;
  isHoming: boolean;
}

// VISUAL TWEAK: Push bullets out so they don't clip the player mesh when stretched
const MUZZLE_OFFSET = 1.2; 

export const calculatePlayerShots = (
  origin: { x: number, y: number },
  target: { x: number, y: number },
  upgrades: Record<string, number>
): ShotDef[] => {
  const shots: ShotDef[] = [];
  const config = ConfigService.player;

  // 1. Calculate Stats based on Upgrades
  const forkLevel = upgrades['FORK'] || 0;
  const dmgLevel = upgrades['EXECUTE'] || 0;
  const snifferLevel = upgrades['SNIFFER'] || 0;
  const backdoorLevel = upgrades['BACKDOOR'] || 0;

  const projectileCount = 1 + (forkLevel * 2);
  const damage = 1 + dmgLevel;
  const speed = config.bulletSpeed;
  const life = config.bulletLife;

  // 2. Base Targeting
  const dx = target.x - origin.x;
  const dy = target.y - origin.y;
  const baseAngle = Math.atan2(dy, dx);

  // 3. Determine Config ID (Visuals)
  let configId = 'PLAYER_STANDARD';
  if (forkLevel > 0) configId = 'PLAYER_FORK';
  
  // 4. Generate Main Frontal Arc (Fork)
  const baseSpread = 0.15;
  const spreadAngle = baseSpread; 
  const startAngle = baseAngle - ((projectileCount - 1) * spreadAngle) / 2;

  for (let i = 0; i < projectileCount; i++) {
      const angle = startAngle + (i * spreadAngle);
      
      // Offset spawn point along the firing vector
      const spawnX = origin.x + Math.cos(angle) * MUZZLE_OFFSET;
      const spawnY = origin.y + Math.sin(angle) * MUZZLE_OFFSET;

      shots.push({
          x: spawnX,
          y: spawnY,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          damage,
          life,
          configId,
          isHoming: false
      });
  }

  // 5. Generate Backdoor (Rear Shot)
  if (backdoorLevel > 0) {
      const rearAngle = baseAngle + Math.PI; 
      
      const spawnX = origin.x + Math.cos(rearAngle) * MUZZLE_OFFSET;
      const spawnY = origin.y + Math.sin(rearAngle) * MUZZLE_OFFSET;

      shots.push({
          x: spawnX,
          y: spawnY,
          vx: Math.cos(rearAngle) * speed,
          vy: Math.sin(rearAngle) * speed,
          damage,
          life,
          configId: 'PLAYER_BACKDOOR',
          isHoming: false
      });
  }

  // 6. Generate Sniffers (Homing Swarm)
  if (snifferLevel > 0) {
      const angleStep = (Math.PI * 2) / snifferLevel;
      // Offset starting angle so they don't overlap exactly with main shots
      const angleOffset = baseAngle + (Math.PI / 4); 
      
      for(let i=0; i<snifferLevel; i++) {
          const angle = angleOffset + (i * angleStep);
          
          const spawnX = origin.x + Math.cos(angle) * MUZZLE_OFFSET;
          const spawnY = origin.y + Math.sin(angle) * MUZZLE_OFFSET;

          shots.push({
              x: spawnX,
              y: spawnY,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              damage,
              life,
              configId: 'PLAYER_SNIFFER',
              isHoming: true
          });
      }
  }

  return shots;
};


=====================================
FILE: ./src/engine/handlers/ai/KamikazeLogic.ts
=====================================
import { Entity } from '@/engine/ecs/Entity';
import { EnemyLogic, AIContext } from './types';
import { Sequence, Parallel } from '@/engine/ai/behavior/composites';
import { Succeeder } from '@/engine/ai/behavior/decorators';
import { MoveToTarget, SpinVisual } from '@/engine/ai/nodes/actions';
import { SpawnPhase } from '@/engine/ai/nodes/logic';

const BASE_SPEED = 12;

let treeRoot: any = null;

const getKamikazeTree = () => {
    if (treeRoot) return treeRoot;

    treeRoot = new Sequence([
        new SpawnPhase(1.5),
        
        new Parallel([
            new Succeeder(new SpinVisual(10.0)), 
            new MoveToTarget(BASE_SPEED)
        ])
    ]);
    return treeRoot;
};

export const KamikazeLogic: EnemyLogic = {
  update: (e: Entity, ctx: AIContext) => {
    const tree = getKamikazeTree();
    tree.tick(e, ctx);
  }
};


=====================================
FILE: ./src/engine/handlers/ai/HunterLogic.ts
=====================================
import { Entity } from '@/engine/ecs/Entity';
import { EnemyLogic, AIContext } from './types';
import { Sequence, Parallel, MemSequence } from '@/engine/ai/behavior/composites';
import { Wait } from '@/engine/ai/nodes/actions';
import { SpawnPhase } from '@/engine/ai/nodes/logic';
import { HoverDrift, FaceTarget, FireProjectile, ExhaustFX } from '@/engine/ai/nodes/hunterNodes';

let treeRoot: any = null;

const getHunterTree = () => {
    if (treeRoot) return treeRoot;

    const tacticalLoop = new MemSequence([
        // INCREASED RANGE: 10-18 units (was 8-16)
        // FASTER REPOSITION: 1.5s (was 2.0s)
        new HoverDrift(10.0, 18.0, 1.5),
        new FaceTarget(),
        
        new Parallel([
            new Wait(0.5),
            new ExhaustFX()
        ]),
        
        new FireProjectile(40.0, 'ENEMY_HUNTER'),
        
        // FASTER FIRE RATE: Reduced cooldown to 0.6s (was 1.0s)
        new Wait(0.6)
    ], 'hunter_tactics');

    treeRoot = new Sequence([
        new SpawnPhase(1.5), 
        tacticalLoop
    ]);
    return treeRoot;
};

export const HunterLogic: EnemyLogic = {
  update: (e: Entity, ctx: AIContext) => {
    const tree = getHunterTree();
    tree.tick(e, ctx);
  }
};


=====================================
FILE: ./src/engine/handlers/ai/types.ts
=====================================
import { Entity } from '@/engine/ecs/Entity';
import { ConfigService } from '@/engine/services/ConfigService';
import { WorldRect } from '@/engine/math/ViewportHelper';
import { AudioKey, VFXKey } from '@/engine/config/AssetKeys';

export interface AIContext {
  delta: number;
  time: number;
  
  spawnProjectile: (
      x: number, y: number, 
      vx: number, vy: number, 
      damage?: number, 
      configId?: string, 
      ownerId?: number
  ) => Entity;

  spawnDrillSparks: (x: number, y: number, angle: number) => void; 
  spawnLaunchSparks: (x: number, y: number, angle: number) => void; 
  spawnFX: (type: VFXKey, x: number, y: number) => void;
  spawnParticle: (x: number, y: number, color: string, vx: number, vy: number, life: number, size?: number) => void;
  
  playSound: (key: AudioKey, x?: number) => void;
  
  // UPDATED: Now accepts source coordinates
  damagePanel: (id: string, amount: number, sourceX?: number, sourceY?: number) => void;
  
  getPanelRect: (id: string) => WorldRect | undefined;
  getUpgradeLevel: (key: string) => number;
  
  config: typeof ConfigService;
}

export interface EnemyLogic {
  update(entity: Entity, ctx: AIContext): void;
}


=====================================
FILE: ./src/engine/handlers/ai/DaemonLogic.ts
=====================================
import { Entity } from '@/engine/ecs/Entity';
import { EnemyLogic, AIContext } from './types';
import { Sequence, Parallel, MemSequence } from '@/engine/ai/behavior/composites';
import { Wait } from '@/engine/ai/nodes/actions';
import { SpawnPhase } from '@/engine/ai/nodes/logic';
import { OrbitControl, ChargeMechanic, FireDaemonShot, HasTargetLock } from '@/engine/ai/nodes/daemonNodes';

let treeRoot: any = null;

const getDaemonTree = () => {
    if (treeRoot) return treeRoot;

    const combatCycle = new MemSequence([
        new ChargeMechanic(2.0),
        new HasTargetLock(),
        new FireDaemonShot(35.0, 20),
        new Wait(0.5)
    ], 'daemon_cycle');

    treeRoot = new Sequence([
        new SpawnPhase(1.0),
        new Parallel([
            new OrbitControl(true),
            combatCycle
        ])
    ]);

    return treeRoot;
};

export const DaemonLogic: EnemyLogic = {
  update: (e: Entity, ctx: AIContext) => {
    const tree = getDaemonTree();
    tree.tick(e, ctx);
  }
};


=====================================
FILE: ./src/engine/handlers/ai/AIRegistry.ts
=====================================
import { EnemyLogic } from './types';

class AIRegistryController {
  private behaviors = new Map<string, EnemyLogic>();

  public register(id: string, logic: EnemyLogic) {
    if (this.behaviors.has(id)) {
        console.warn(`[AIRegistry] Overwriting behavior for ${id}`);
    }
    this.behaviors.set(id, logic);
  }

  public get(id: string): EnemyLogic | undefined {
    return this.behaviors.get(id);
  }
}

export const AIRegistry = new AIRegistryController();


=====================================
FILE: ./src/engine/handlers/ai/DrillerLogic.ts
=====================================
import { Entity } from '@/engine/ecs/Entity';
import { EnemyLogic, AIContext } from './types';
import { Sequence, Selector } from '@/engine/ai/behavior/composites';
import { Succeeder } from '@/engine/ai/behavior/decorators';
import { MoveToTarget, SpinVisual } from '@/engine/ai/nodes/actions';
import { IsTargetInRange } from '@/engine/ai/nodes/conditions';
import { DrillAttack } from '@/engine/ai/nodes/drillerNodes';
import { SpawnPhase } from '@/engine/ai/nodes/logic';

const BASE_SPEED = 8;

let treeRoot: any = null;

const getDrillerTree = () => {
    if (treeRoot) return treeRoot;

    treeRoot = new Sequence([
        new SpawnPhase(1.5), 
        
        new Sequence([
            new Succeeder(new SpinVisual(5.0)), 
            new Selector([
                new Sequence([
                    new IsTargetInRange(0.5), 
                    new Succeeder(new SpinVisual(15.0)), 
                    new DrillAttack(0.2) // Interval only
                ]),
                new MoveToTarget(BASE_SPEED)
            ])
        ])
    ]);
    return treeRoot;
};

export const DrillerLogic: EnemyLogic = {
  update: (e: Entity, ctx: AIContext) => {
    const tree = getDrillerTree();
    tree.tick(e, ctx);
  }
};


=====================================
FILE: ./src/engine/handlers/ai/BehaviorCatalog.ts
=====================================
import { AIRegistry } from './AIRegistry';
import { EnemyTypes } from '@/engine/config/Identifiers';

// Logic Implementations
import { DrillerLogic } from './DrillerLogic';
import { KamikazeLogic } from './KamikazeLogic';
import { HunterLogic } from './HunterLogic';
import { DaemonLogic } from './DaemonLogic';

export const registerAllBehaviors = () => {
  AIRegistry.register(EnemyTypes.DRILLER, DrillerLogic);
  AIRegistry.register(EnemyTypes.KAMIKAZE, KamikazeLogic);
  AIRegistry.register(EnemyTypes.HUNTER, HunterLogic);
  AIRegistry.register(EnemyTypes.DAEMON, DaemonLogic);
  
  console.log('[BehaviorCatalog] AI Behaviors Registered.');
};


=====================================
FILE: ./src/engine/handlers/workers/GeometryWorker.ts
=====================================
const computeBarycentric = (positionCount: number) => {
  const array = new Float32Array(positionCount * 3);
  for (let i = 0; i < positionCount; i += 3) {
    // 1,0,0
    array[i * 3 + 0] = 1; array[i * 3 + 1] = 0; array[i * 3 + 2] = 0;
    // 0,1,0
    array[i * 3 + 3] = 0; array[i * 3 + 4] = 1; array[i * 3 + 5] = 0;
    // 0,0,1
    array[i * 3 + 6] = 0; array[i * 3 + 7] = 0; array[i * 3 + 8] = 1;
  }
  return array;
};

const generateHunterSpear = () => {
  const positions: number[] = [];
  const numWings = 3;
  
  // Adjusted Length: 1.2 -> 1.25 (+4%)
  const length = 1.25;
  const wingWidth = 0.4;
  const wingThickness = 0.05;

  const tipY = length / 2;
  const baseY = -length / 2;

  const rotateY = (x: number, y: number, z: number, rad: number) => {
    return [
      x * Math.cos(rad) - z * Math.sin(rad),
      y,
      x * Math.sin(rad) + z * Math.cos(rad)
    ];
  };

  for(let i=0; i<numWings; i++) {
      const angle = (i / numWings) * Math.PI * 2;
      
      const pTip = [0, tipY, 0];
      const pBaseOut = [wingWidth, baseY, 0];
      const pBaseInBack = [0, baseY, -wingThickness];
      const pBaseInFront = [0, baseY, wingThickness];

      // Front Face
      positions.push(...rotateY(pTip[0], pTip[1], pTip[2], angle));
      positions.push(...rotateY(pBaseOut[0], pBaseOut[1], pBaseOut[2], angle));
      positions.push(...rotateY(pBaseInFront[0], pBaseInFront[1], pBaseInFront[2], angle));
      
      // Back Face
      positions.push(...rotateY(pTip[0], pTip[1], pTip[2], angle));
      positions.push(...rotateY(pBaseInBack[0], pBaseInBack[1], pBaseInBack[2], angle));
      positions.push(...rotateY(pBaseOut[0], pBaseOut[1], pBaseOut[2], angle));
  }

  const posArray = new Float32Array(positions);
  const baryArray = computeBarycentric(positions.length / 3);

  return { positions: posArray, barycentric: baryArray };
};

self.onmessage = (e: MessageEvent) => {
  const { id, task } = e.data;
  
  try {
    let result;
    if (task === 'GEO_HUNTER') {
        result = generateHunterSpear();
    } else {
        throw new Error('Unknown task: ' + task);
    }

    self.postMessage(
        { id, success: true, ...result }, 
        [result.positions.buffer, result.barycentric.buffer]
    );
  } catch (err: any) {
    self.postMessage({ id, success: false, error: err.message });
  }
};


=====================================
FILE: ./src/engine/services/MobileBootstrapper.ts
=====================================
import { ServiceLocator } from './ServiceLocator';
import { GameEngineCore } from '@/engine/services/GameEngine';
import { EntityRegistry } from '@/engine/ecs/EntityRegistry';
import { EntitySpawner } from '@/engine/services/EntitySpawner';
import { registerAllBehaviors } from '@/engine/handlers/ai/BehaviorCatalog';
import { registerAllAssets } from '@/ui/sim/assets/AssetCatalog';
import { registerAllComponents } from '@/engine/ecs/ComponentCatalog';
import { PanelRegistrySystem } from '@/engine/systems/PanelRegistrySystem';
import { AudioServiceImpl } from '@/engine/audio/AudioService';
import { GameEventService } from '@/engine/signals/GameEventBus';
import { FastEventService } from '@/engine/signals/FastEventBus';
import { ConfigService } from '@/engine/services/ConfigService';
import { SystemPhase } from '@/engine/interfaces';

import { TimeSystem } from '@/engine/systems/TimeSystem';
import { PhysicsSystem } from '@/engine/systems/PhysicsSystem';
import { AudioDirector } from '@/engine/audio/AudioDirector';
import { InputSystem } from '@/engine/systems/InputSystem';

import { LifeCycleSystem } from '@/engine/systems/LifeCycleSystem';
import { VFXSystem } from '@/engine/systems/VFXSystem';
import { ShakeSystem } from '@/engine/systems/ShakeSystem';
import { StructureSystem } from '@/engine/systems/StructureSystem';
import { MobileWaveSystem } from '@/engine/systems/MobileWaveSystem';
import { TargetingSystem } from '@/engine/systems/TargetingSystem';
import { BehaviorSystem } from '@/engine/systems/BehaviorSystem';
import { GameStateSystem } from '@/engine/systems/GameStateSystem';
import { RenderSystem } from '@/engine/systems/RenderSystem';
import { ProjectileSystem } from '@/engine/systems/ProjectileSystem';
import { HealthSystem } from '@/engine/systems/HealthSystem';
import { ProgressionSystem } from '@/engine/systems/ProgressionSystem';
import { ParticleSystem } from '@/engine/systems/ParticleSystem';
import { OrbitalSystem } from '@/engine/systems/OrbitalSystem';
import { GuidanceSystem } from '@/engine/systems/GuidanceSystem';
import { InteractionSystem } from '@/engine/systems/InteractionSystem';

import { IGameSystem, ICombatSystem, IGameEventService, IFastEventService, IAudioService, IEntityRegistry } from '@/engine/interfaces';
import { GameEvents } from '@/engine/signals/GameEvents';
import { Entity } from '@/engine/ecs/Entity';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { FastEvents, FX_IDS } from '@/engine/signals/FastEventBus';

class MobileCombatSystem implements IGameSystem, ICombatSystem {
    constructor(
        private registry: IEntityRegistry,
        private events: IGameEventService,
        private fastEvents: IFastEventService,
        private audio: IAudioService
    ) {
        this.events.subscribe(GameEvents.ENEMY_DAMAGED, (p) => {
            const entity = this.registry.getEntity(p.id);
            if (entity && entity.active) {
                this.kill(entity);
            }
        });
    }
    
    update() {}
    teardown() {}
    resolveCollision() {}

    private kill(entity: Entity) {
        const t = entity.getComponent<TransformData>(ComponentType.Transform);
        if (t) {
            const id = FX_IDS['EXPLOSION_PURPLE'];
            this.fastEvents.emit(FastEvents.SPAWN_FX, id, t.x, t.y);
            this.audio.playSound('fx_impact_light');
        }
        this.registry.destroyEntity(entity.id);
    }
}

export const MobileBootstrapper = () => {
  const registry = new EntityRegistry();
  const spawner = new EntitySpawner(registry);
  const engine = new GameEngineCore(registry);
  
  ServiceLocator.registerRegistry(registry);
  ServiceLocator.registerSpawner(spawner);

  let audioService;
  try { audioService = ServiceLocator.getAudioService(); } 
  catch { audioService = new AudioServiceImpl(); ServiceLocator.register('AudioService', audioService); }

  let eventService;
  try { eventService = ServiceLocator.getGameEventBus(); } 
  catch { eventService = new GameEventService(); ServiceLocator.register('GameEventService', eventService); }

  let fastEventService;
  try { fastEventService = ServiceLocator.getFastEventBus(); } 
  catch { fastEventService = new FastEventService(); ServiceLocator.register('FastEventService', fastEventService); }

  // --- REGISTRATIONS ---
  registerAllComponents();
  registerAllBehaviors();
  registerAllAssets();

  const panelSystem = new PanelRegistrySystem(eventService, audioService);
  ServiceLocator.registerSystem('PanelRegistrySystem', panelSystem);
  
  const timeSystem = new TimeSystem();
  const physicsSystem = new PhysicsSystem(registry);
  const inputSystem = new InputSystem(); 

  const healthSystem = new HealthSystem(eventService, audioService, panelSystem);
  const progressionSystem = new ProgressionSystem(eventService);
  const gameStateSystem = new GameStateSystem(
      healthSystem, progressionSystem, panelSystem, registry, eventService, audioService
  );
  
  const particleSystem = new ParticleSystem();
  const shakeSystem = new ShakeSystem(eventService);
  const audioDirector = new AudioDirector(panelSystem, eventService, fastEventService, audioService);
  const vfxSystem = new VFXSystem(particleSystem, shakeSystem, eventService, fastEventService);
  
  const mobileCombatSystem = new MobileCombatSystem(registry, eventService, fastEventService, audioService);
  const projectileSystem = new ProjectileSystem(registry);
  
  const targetingSystem = new TargetingSystem(registry, panelSystem);
  const orbitalSystem = new OrbitalSystem(registry);
  const guidanceSystem = new GuidanceSystem(registry);
  const lifeCycleSystem = new LifeCycleSystem(registry, eventService);
  
  const interactionSystem = new InteractionSystem(inputSystem, spawner, gameStateSystem, panelSystem, eventService);
  const structureSystem = new StructureSystem(panelSystem);
  const behaviorSystem = new BehaviorSystem(registry, spawner, ConfigService, panelSystem, particleSystem, audioService);
  const renderSystem = new RenderSystem(registry, gameStateSystem, interactionSystem);
  const waveSystem = new MobileWaveSystem(spawner);

  // Injection
  engine.injectCoreSystems(panelSystem, gameStateSystem, timeSystem);

  const systemMap = {
    TimeSystem: timeSystem,
    InputSystem: inputSystem,
    PhysicsSystem: physicsSystem,
    PanelRegistrySystem: panelSystem,
    HealthSystem: healthSystem,
    ProgressionSystem: progressionSystem,
    GameStateSystem: gameStateSystem,
    InteractionSystem: interaction,
    ParticleSystem: particleSystem,
    ShakeSystem: shake
  };
  Object.entries(systemMap).forEach(([id, sys]) => ServiceLocator.registerSystem(id, sys));

  // --- PHASED REGISTRATION ---
  
  // INPUT
  engine.registerSystem(timeSystem, SystemPhase.INPUT);
  engine.registerSystem(inputSystem, SystemPhase.INPUT);
  engine.registerSystem(interaction, SystemPhase.INPUT);
  
  // LOGIC
  engine.registerSystem(panelSystem, SystemPhase.LOGIC);
  engine.registerSystem(gameStateSystem, SystemPhase.LOGIC);
  engine.registerSystem(targeting, SystemPhase.LOGIC);
  engine.registerSystem(waveSystem, SystemPhase.LOGIC);
  engine.registerSystem(structure, SystemPhase.LOGIC);
  engine.registerSystem(behavior, SystemPhase.LOGIC);
  
  // PHYSICS
  engine.registerSystem(physicsSystem, SystemPhase.PHYSICS);
  engine.registerSystem(orbital, SystemPhase.PHYSICS);
  engine.registerSystem(guidance, SystemPhase.PHYSICS);
  engine.registerSystem(projectile, SystemPhase.PHYSICS);
  
  // COLLISION (Mobile uses specialized combat)
  engine.registerSystem(mobileCombatSystem, SystemPhase.COLLISION);
  
  // STATE
  engine.registerSystem(healthSystem, SystemPhase.STATE);
  engine.registerSystem(progressionSystem, SystemPhase.STATE);
  engine.registerSystem(lifeCycle, SystemPhase.STATE);
  
  // RENDER
  engine.registerSystem(renderSystem, SystemPhase.RENDER);
  engine.registerSystem(particleSystem, SystemPhase.RENDER);
  engine.registerSystem(vfxSystem, SystemPhase.RENDER);
  engine.registerSystem(shakeSystem, SystemPhase.RENDER);
  engine.registerSystem(audioDirector, SystemPhase.RENDER);

  engine.setup(ServiceLocator);
  
  return engine;
};


=====================================
FILE: ./src/engine/services/StructureHealthService.ts
=====================================
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';

const MAX_PANEL_HEALTH = 100;

export interface StructureState {
  health: number;
  isDestroyed: boolean;
}

class StructureHealthServiceController {
  private states = new Map<string, StructureState>();
  public systemIntegrity: number = 100;

  public register(id: string) {
    if (!this.states.has(id)) {
        this.states.set(id, { health: MAX_PANEL_HEALTH, isDestroyed: false });
    }
    this.calculateIntegrity();
  }

  public unregister(id: string) {
    this.states.delete(id);
    this.calculateIntegrity();
  }

  public reset() {
    for (const state of this.states.values()) {
        state.health = MAX_PANEL_HEALTH;
        state.isDestroyed = false;
    }
    this.calculateIntegrity();
    this.syncAllPanelsToStore();
  }

  // UPDATED: Added source coordinates
  public damage(id: string, amount: number, silent: boolean = false, sourceX?: number, sourceY?: number) {
    if (useStore.getState().debugFlags.panelGodMode) return;
    const state = this.states.get(id);
    if (!state || state.isDestroyed) return;
    state.health = Math.max(0, state.health - amount);
    
    if (state.health <= 0) {
        state.isDestroyed = true;
        state.health = 0;
        this.syncPanelToStore(id);
        
        if (!silent) {
            GameEventBus.emit(GameEvents.PANEL_DESTROYED, { id });
            GameEventBus.emit(GameEvents.LOG_DEBUG, { msg: `SECTOR LOST: ${id}`, source: 'StructureService' });
        }
    } else if (!silent) {
        GameEventBus.emit(GameEvents.PANEL_DAMAGED, { 
            id, 
            amount, 
            currentHealth: state.health,
            sourceX,
            sourceY
        });
        this.syncPanelToStore(id);
    }
    this.calculateIntegrity();
  }

  public heal(id: string, amount: number, sourceX?: number) {
    const state = this.states.get(id);
    if (!state) return;
    const wasDestroyed = state.isDestroyed;
    
    state.health = Math.min(MAX_PANEL_HEALTH, state.health + amount);
    
    if (wasDestroyed && state.health >= MAX_PANEL_HEALTH) {
        state.isDestroyed = false;
        state.health = MAX_PANEL_HEALTH * 0.3;
        GameEventBus.emit(GameEvents.PANEL_RESTORED, { id, x: sourceX });
        GameEventBus.emit(GameEvents.LOG_DEBUG, { msg: `SECTOR RESTORED: ${id}`, source: 'StructureService' });
    }
    
    this.syncPanelToStore(id);
    this.calculateIntegrity();
  }

  public decay(id: string, amount: number) {
      const state = this.states.get(id);
      if (!state || !state.isDestroyed) return;
      state.health = Math.max(0, state.health - amount);
  }

  public restoreAll() {
      let restored = 0;
      for (const [id, state] of this.states) {
          if (state.isDestroyed) {
              state.isDestroyed = false;
              state.health = MAX_PANEL_HEALTH * 0.3;
              GameEventBus.emit(GameEvents.PANEL_RESTORED, { id });
              restored++;
          } else if (state.health < MAX_PANEL_HEALTH) {
              state.health = MAX_PANEL_HEALTH;
          }
      }
      this.calculateIntegrity();
      this.syncAllPanelsToStore();
      return restored;
  }

  public destroyAll() {
      for (const [id, state] of this.states) {
          state.health = 0;
          state.isDestroyed = true;
          GameEventBus.emit(GameEvents.PANEL_DESTROYED, { id });
      }
      this.calculateIntegrity();
      this.syncAllPanelsToStore();
  }

  private calculateIntegrity() {
    let current = 0;
    let max = 0;
    for (const state of this.states.values()) {
        max += MAX_PANEL_HEALTH;
        if (!state.isDestroyed) current += state.health;
    }
    const newIntegrity = max > 0 ? (current / max) * 100 : 100;
    
    const shouldSync = 
        Math.abs(this.systemIntegrity - newIntegrity) > 1.0 || 
        (newIntegrity <= 1.0 && this.systemIntegrity > 1.0) ||
        newIntegrity === 0;

    if (shouldSync) {
        this.systemIntegrity = newIntegrity;
        useGameStore.getState().setSystemIntegrity(this.systemIntegrity);
    } else {
        this.systemIntegrity = newIntegrity;
    }
  }

  private syncPanelToStore(id: string) {
      const state = this.states.get(id);
      if (state) {
          useGameStore.getState().syncPanels({ 
              [id]: { id, health: state.health, isDestroyed: state.isDestroyed } 
          });
      }
  }

  private syncAllPanelsToStore() {
      const payload: Record<string, any> = {};
      for (const [id, state] of this.states) {
          payload[id] = { id, health: state.health, isDestroyed: state.isDestroyed };
      }
      useGameStore.getState().syncPanels(payload);
  }

  public getState(id: string) { return this.states.get(id); }
  public getAllStates() { return this.states; }
}

export const StructureHealthService = new StructureHealthServiceController();


=====================================
FILE: ./src/engine/services/GameBootstrapper.ts
=====================================
import { ServiceLocator } from './ServiceLocator';
import { GameEngineCore } from '@/engine/services/GameEngine';
import { EntityRegistry } from '@/engine/ecs/EntityRegistry';
import { EntitySpawner } from '@/engine/services/EntitySpawner';
import { registerAllBehaviors } from '@/engine/handlers/ai/BehaviorCatalog';
import { registerAllAssets } from '@/ui/sim/assets/AssetCatalog';
import { registerAllComponents } from '@/engine/ecs/ComponentCatalog';
import { PanelRegistrySystem } from '@/engine/systems/PanelRegistrySystem';
import { Tag } from '@/engine/ecs/types';
import { ComponentRegistry } from '@/engine/ecs/ComponentRegistry';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { AudioServiceImpl } from '@/engine/audio/AudioService';
import { GameEventService } from '@/engine/signals/GameEventBus';
import { FastEventService } from '@/engine/signals/FastEventBus';
import { ConfigService } from '@/engine/services/ConfigService';
import { SystemPhase } from '@/engine/interfaces';

import { TimeSystem } from '@/engine/systems/TimeSystem';
import { InputSystem } from '@/engine/systems/InputSystem';
import { PhysicsSystem } from '@/engine/systems/PhysicsSystem';
import { HealthSystem } from '@/engine/systems/HealthSystem';
import { ProgressionSystem } from '@/engine/systems/ProgressionSystem';
import { GameStateSystem } from '@/engine/systems/GameStateSystem';
import { AtmosphereSystem } from '@/engine/systems/AtmosphereSystem';
import { InteractionSystem } from '@/engine/systems/InteractionSystem';
import { StructureSystem } from '@/engine/systems/StructureSystem';
import { WaveSystem } from '@/engine/systems/WaveSystem';
import { ParticleSystem } from '@/engine/systems/ParticleSystem';
import { TargetingSystem } from '@/engine/systems/TargetingSystem';
import { OrbitalSystem } from '@/engine/systems/OrbitalSystem';
import { PlayerMovementSystem } from '@/engine/systems/PlayerMovementSystem';
import { WeaponSystem } from '@/engine/systems/WeaponSystem';
import { BehaviorSystem } from '@/engine/systems/BehaviorSystem';
import { GuidanceSystem } from '@/engine/systems/GuidanceSystem';
import { ProjectileSystem } from '@/engine/systems/ProjectileSystem';
import { CollisionSystem } from '@/engine/systems/CollisionSystem';
import { CombatSystem } from '@/engine/systems/CombatSystem';
import { LifeCycleSystem } from '@/engine/systems/LifeCycleSystem';
import { RenderSystem } from '@/engine/systems/RenderSystem';
import { VFXSystem } from '@/engine/systems/VFXSystem';
import { AudioDirector } from '@/engine/audio/AudioDirector';
import { ShakeSystem } from '@/engine/systems/ShakeSystem';

export const GameBootstrapper = () => {
  const registry = new EntityRegistry();
  const spawner = new EntitySpawner(registry);
  const engine = new GameEngineCore(registry);
  
  ServiceLocator.registerRegistry(registry);
  ServiceLocator.registerSpawner(spawner);

  // --- PERSISTENT SERVICES (Singletons) ---
  // These survive game restarts to prevent memory leaks and overwrites

  let eventBus;
  try { eventBus = ServiceLocator.getGameEventBus(); } 
  catch { eventBus = new GameEventService(); ServiceLocator.register('GameEventService', eventBus); }

  let fastBus;
  try { fastBus = ServiceLocator.getFastEventBus(); } 
  catch { fastBus = new FastEventService(); ServiceLocator.register('FastEventService', fastBus); }

  let audioService;
  try { audioService = ServiceLocator.getAudioService(); } 
  catch { audioService = new AudioServiceImpl(); ServiceLocator.register('AudioService', audioService); }

  let inputSystem;
  try { inputSystem = ServiceLocator.getInputService(); }
  catch { inputSystem = new InputSystem(); ServiceLocator.register('InputSystem', inputSystem); }

  // --- REGISTRATIONS ---
  registerAllComponents();
  registerAllBehaviors();
  registerAllAssets();

  const panelSystem = new PanelRegistrySystem(eventBus, audioService); 
  const healthSystem = new HealthSystem(eventBus, audioService, panelSystem);
  const progressionSystem = new ProgressionSystem(eventBus);
  
  const gameStateSystem = new GameStateSystem(healthSystem, progressionSystem, panelSystem, eventBus, audioService);
  const atmosphere = new AtmosphereSystem(panelSystem, registry);
  
  const timeSystem = new TimeSystem();
  const physicsSystem = new PhysicsSystem(registry);
  const particles = new ParticleSystem();
  const shake = new ShakeSystem(eventBus);
  const audioDirector = new AudioDirector(panelSystem, eventBus, fastBus, audioService);
  const vfx = new VFXSystem(particles, shake, eventBus, fastBus);

  const interaction = new InteractionSystem(inputSystem, spawner, gameStateSystem, panelSystem, eventBus);
  const movement = new PlayerMovementSystem(inputSystem, registry, interaction, gameStateSystem);
  const weapons = new WeaponSystem(spawner, registry, gameStateSystem, eventBus, ConfigService);
  const behavior = new BehaviorSystem(registry, spawner, ConfigService, panelSystem, particles, audioService);
  const targeting = new TargetingSystem(registry, panelSystem);
  const projectile = new ProjectileSystem(registry);
  const combat = new CombatSystem(registry, eventBus, fastBus, audioService);
  const collision = new CollisionSystem(physicsSystem, combat, registry);
  
  const orbital = new OrbitalSystem(registry);
  const guidance = new GuidanceSystem(registry);
  const lifeCycle = new LifeCycleSystem(registry, eventBus);
  const waves = new WaveSystem(spawner, panelSystem);
  const structure = new StructureSystem(panelSystem);
  const render = new RenderSystem(registry, gameStateSystem, interaction);

  // Injection
  engine.injectCoreSystems(panelSystem, gameStateSystem, timeSystem);

  const systemMap = {
    TimeSystem: timeSystem,
    PhysicsSystem: physicsSystem,
    PanelRegistrySystem: panelSystem,
    HealthSystem: healthSystem,
    ProgressionSystem: progressionSystem,
    GameStateSystem: gameStateSystem,
    AtmosphereSystem: atmosphere,
    InteractionSystem: interaction,
    CombatSystem: combat,
    ParticleSystem: particles,
    ShakeSystem: shake
  };
  Object.entries(systemMap).forEach(([id, sys]) => ServiceLocator.registerSystem(id, sys));

  // --- PHASED REGISTRATION ---
  
  // 1. INPUT
  engine.registerSystem(timeSystem, SystemPhase.INPUT);
  engine.registerSystem(inputSystem as any, SystemPhase.INPUT); // Cast as it's reused
  engine.registerSystem(interaction, SystemPhase.INPUT);
  engine.registerSystem(movement, SystemPhase.INPUT);
  
  // 2. LOGIC
  engine.registerSystem(panelSystem, SystemPhase.LOGIC);
  engine.registerSystem(gameStateSystem, SystemPhase.LOGIC);
  engine.registerSystem(targeting, SystemPhase.LOGIC);
  engine.registerSystem(waves, SystemPhase.LOGIC);
  engine.registerSystem(structure, SystemPhase.LOGIC);
  engine.registerSystem(behavior, SystemPhase.LOGIC);
  engine.registerSystem(weapons, SystemPhase.LOGIC);
  
  // 3. PHYSICS
  engine.registerSystem(physicsSystem, SystemPhase.PHYSICS);
  engine.registerSystem(orbital, SystemPhase.PHYSICS);
  engine.registerSystem(guidance, SystemPhase.PHYSICS);
  engine.registerSystem(projectile, SystemPhase.PHYSICS);
  
  // 4. COLLISION
  engine.registerSystem(collision, SystemPhase.COLLISION);
  engine.registerSystem(combat, SystemPhase.COLLISION);
  
  // 5. STATE (Post-Collision processing)
  engine.registerSystem(healthSystem, SystemPhase.STATE);
  engine.registerSystem(progressionSystem, SystemPhase.STATE);
  engine.registerSystem(lifeCycle, SystemPhase.STATE);
  
  // 6. RENDER
  engine.registerSystem(render, SystemPhase.RENDER);
  engine.registerSystem(particles, SystemPhase.RENDER);
  engine.registerSystem(vfx, SystemPhase.RENDER);
  engine.registerSystem(shake, SystemPhase.RENDER);
  engine.registerSystem(atmosphere, SystemPhase.RENDER);
  engine.registerSystem(audioDirector, SystemPhase.RENDER);

  engine.setup(ServiceLocator);
  spawner.spawnPlayer();

  const world = registry.createEntity();
  world.addTag(Tag.WORLD);
  world.addComponent(ComponentRegistry.create(ComponentType.Render, { r: 0, g: 0.2, b: 0, visualScale: 1.0, visualRotation: 0 }));
  registry.updateCache(world);

  return engine;
};


=====================================
FILE: ./src/engine/services/TransientDOMService.ts
=====================================
type UpdateType = 'text' | 'width' | 'css-var' | 'class-toggle';

interface TransientElement {
  el: HTMLElement;
  type: UpdateType;
}

class TransientDOMServiceController {
  private elements = new Map<string, TransientElement>();

  public register(id: string, el: HTMLElement, type: UpdateType) {
    this.elements.set(id, { el, type });
  }

  public unregister(id: string) {
    this.elements.delete(id);
  }

  // Value can be string, number, or boolean (for class-toggle)
  public update(id: string, value: string | number | boolean) {
    const item = this.elements.get(id);
    if (!item) return;

    if (item.type === 'text') {
        item.el.innerText = String(value);
    } 
    else if (item.type === 'width') {
        item.el.style.width = `${value}%`;
    } 
    else if (item.type === 'css-var') {
        // value is expected to be the raw value (e.g. "0.5" or "#ff0000")
        item.el.style.setProperty(`--${id}`, String(value));
    }
    else if (item.type === 'class-toggle') {
        // value is the class name to toggle based on boolean second arg? 
        // Simpler: We assume 'value' is the class name, and we just add/remove it? 
        // No, usually we want to toggle a specific state on/off.
        // Let's interpret value as boolean: true = add 'active', false = remove 'active'.
        // Or better: Let the registerer define the class? No, that's complex.
        // For now, let's assume value is "CLASS_NAME:BOOL" string? Too messy.
        
        // Let's stick to simple boolean 'active' class toggling for now, or just use CSS Vars for state.
        // CSS Vars are better: --is-critical: 1 or 0.
        // So 'css-var' covers most 'class-toggle' needs via style queries or calc().
        // I will revert 'class-toggle' addition to keep it lean. CSS Vars are superior for "Zero Latency".
    }
  }
}

export const TransientDOMService = new TransientDOMServiceController();


=====================================
FILE: ./src/engine/services/DOMSpatialService.ts
=====================================
import { ViewportHelper, WorldRect } from '@/engine/math/ViewportHelper';

class DOMSpatialServiceController {
  private observedElements = new Map<string, HTMLElement>();
  private panelRects = new Map<string, WorldRect>();
  private observer: ResizeObserver | null = null;

  private initObserver() {
    if (this.observer) return;
    if (typeof window === 'undefined') return;

    this.observer = new ResizeObserver((entries) => {
        for (const entry of entries) {
            // Find ID by element (inefficient lookup, but rare event)
            for (const [id, el] of this.observedElements) {
                if (el === entry.target) {
                    this.refreshSingle(id);
                    break;
                }
            }
        }
    });
  }

  public register(id: string, element: HTMLElement) {
    this.initObserver();
    this.observedElements.set(id, element);
    if (this.observer) {
        this.observer.observe(element);
    }
    this.refreshSingle(id);
  }

  public unregister(id: string) {
    const el = this.observedElements.get(id);
    if (el && this.observer) {
        this.observer.unobserve(el);
    }
    this.observedElements.delete(id);
    this.panelRects.delete(id);
  }

  public refreshSingle(id: string) {
    const el = this.observedElements.get(id);
    if (!el || !el.isConnected) return;
    const rect = el.getBoundingClientRect();
    if (rect.width === 0 && rect.height === 0) return;
    this.panelRects.set(id, ViewportHelper.domToWorld(id, rect));
  }

  public refreshAll() {
    for (const id of this.observedElements.keys()) {
        this.refreshSingle(id);
    }
  }

  public getRect(id: string): WorldRect | undefined {
    return this.panelRects.get(id);
  }

  public getAllRects(): Map<string, WorldRect> {
    return this.panelRects;
  }
}

export const DOMSpatialService = new DOMSpatialServiceController();


=====================================
FILE: ./src/engine/services/ConfigService.ts
=====================================
import { PLAYER_CONFIG } from '@/engine/config/PlayerConfig';
import { WAVE_CONFIG } from '@/engine/config/WaveConfig';
import { WorldConfig } from '@/engine/config/WorldConfig';
import { AI_CONFIG } from '@/engine/config/AIConfig';
import { PhysicsConfig } from '@/engine/config/PhysicsConfig';

type PlayerConfigType = typeof PLAYER_CONFIG;
type WorldConfigType = typeof WorldConfig;
type AIConfigType = typeof AI_CONFIG;
type PhysicsConfigType = typeof PhysicsConfig;
type WaveConfigType = typeof WAVE_CONFIG;

class ConfigServiceController {
  public player: PlayerConfigType = { ...PLAYER_CONFIG };
  public world: WorldConfigType = { ...WorldConfig };
  public ai: AIConfigType = JSON.parse(JSON.stringify(AI_CONFIG));
  public physics: PhysicsConfigType = { ...PhysicsConfig };
  public waves: WaveConfigType = { ...WAVE_CONFIG };

  public reset() {
    this.player = { ...PLAYER_CONFIG };
    this.world = { ...WorldConfig };
    this.ai = JSON.parse(JSON.stringify(AI_CONFIG));
    this.physics = { ...PhysicsConfig };
    this.waves = { ...WAVE_CONFIG };
  }
}

export const ConfigService = new ConfigServiceController();


=====================================
FILE: ./src/engine/services/EntitySpawner.ts
=====================================
import { IEntitySpawner, IEntityRegistry } from '@/engine/interfaces';
import { Entity } from '@/engine/ecs/Entity';
import { Tag } from '@/engine/ecs/types';
import { EntityRegistry } from '@/engine/ecs/EntityRegistry';
import { ARCHETYPES } from '@/engine/config/Archetypes';
import { ComponentRegistry } from '@/engine/ecs/ComponentRegistry';
import { ArchetypeIDs } from '@/engine/config/Identifiers';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { PROJECTILE_CONFIG } from '@/engine/config/ProjectileConfig';

export class EntitySpawner implements IEntitySpawner {
  private registry: EntityRegistry;

  constructor(registry: IEntityRegistry) {
    this.registry = registry as EntityRegistry;
  }

  public spawn(archetypeId: string, overrides: Record<string, any> = {}, extraTags: Tag[] = []): Entity {
    const blueprint = ARCHETYPES[archetypeId];
    if (!blueprint) {
        console.warn('[EntitySpawner] Unknown archetype: ' + archetypeId);
        return this.registry.createEntity();
    }

    const e = this.registry.createEntity();
    blueprint.tags.forEach(tag => e.addTag(tag));
    extraTags.forEach(tag => e.addTag(tag));

    // 1. Core Component Hydration
    for (const compDef of blueprint.components) {
        const blueprintData = JSON.parse(JSON.stringify(compDef.data || {}));
        const runtimeData = overrides[compDef.type] || {};
        const mergedData = { ...blueprintData, ...runtimeData };
        
        const component = ComponentRegistry.create(compDef.type, mergedData);
        e.addComponent(component);
    }

    // 2. Automated Visual/Asset Linking
    if (blueprint.assets) {
        const render: any = e.getComponent(ComponentType.Render);
        if (render) {
            render.geometryId = blueprint.assets.geometry;
            render.materialId = blueprint.assets.material;
        }
    }

    this.registry.updateCache(e);
    return e;
  }

  public spawnPlayer(): Entity {
    return this.spawn(ArchetypeIDs.PLAYER);
  }

  public spawnEnemy(type: string, x: number, y: number): Entity {
    return this.spawn(type, { [ComponentType.Transform]: { x, y } });
  }

  public spawnBullet(x: number, y: number, vx: number, vy: number, isEnemy: boolean, life: number, damage: number = 1, projectileId: string = 'PLAYER_STANDARD', ownerId?: number): Entity {
    const id = isEnemy ? ArchetypeIDs.BULLET_ENEMY : ArchetypeIDs.BULLET_PLAYER;
    const rotation = Math.atan2(vy, vx);
    const config = PROJECTILE_CONFIG[projectileId];
    const color = config ? config.color : [1, 1, 1];

    const overrides: Record<string, any> = {
        [ComponentType.Transform]: { x, y, rotation, scale: 1.0 }, 
        [ComponentType.Motion]: { vx, vy },
        [ComponentType.Lifetime]: { remaining: life, total: life },
        [ComponentType.Combat]: { damage },
        [ComponentType.Health]: { max: damage },
        [ComponentType.Render]: { 
            visualScale: 1.0, 
            geometryId: 'GEO_BULLET',
            r: color[0], g: color[1], b: color[2]
        },
        [ComponentType.Projectile]: { configId: projectileId, state: 'FLIGHT', ownerId: ownerId ?? -1 }
    };

    return this.spawn(id, overrides);
  }

  public spawnParticle(x: number, y: number, color: string, vx: number, vy: number, life: number, size: number = 1.0, shape: number = 0): void {
    const e = this.registry.createEntity();
    e.addTag(Tag.PARTICLE);
    e.addComponent(ComponentRegistry.create(ComponentType.Transform, { x, y, scale: size }));
    e.addComponent(ComponentRegistry.create(ComponentType.Motion, { vx, vy, friction: 0.05 }));
    e.addComponent(ComponentRegistry.create(ComponentType.Lifetime, { remaining: life, total: life }));
    e.addComponent(ComponentRegistry.create(ComponentType.Identity, { variant: color }));
    this.registry.updateCache(e);
  }
}


=====================================
FILE: ./src/engine/services/ServiceLocator.ts
=====================================
import { 
  IServiceLocator, 
  IGameSystem, 
  IAudioService, 
  IInputService, 
  IEntityRegistry, 
  IEntitySpawner, 
  IParticleSystem,
  IGameEventService,
  IFastEventService
} from '@/engine/interfaces';
import { ConfigService } from '@/engine/services/ConfigService';

class ServiceLocatorImpl implements IServiceLocator {
  private services = new Map<string, any>();

  public register<T>(id: string, instance: T): void {
    if (this.services.has(id)) {
      console.warn(`[ServiceLocator] Overwriting service: ${id}`);
    }
    this.services.set(id, instance);
  }

  public get<T>(id: string): T {
    const service = this.services.get(id);
    if (!service) {
      throw new Error(`[ServiceLocator] Service not found: ${id}`);
    }
    return service as T;
  }

  public reset(): void {
    this.services.clear();
    ConfigService.reset();
  }

  public getGameEventBus(): IGameEventService { return this.get<IGameEventService>('GameEventService'); }
  public getFastEventBus(): IFastEventService { return this.get<IFastEventService>('FastEventService'); }
  
  public getAudioService(): IAudioService { return this.get<IAudioService>('AudioService'); }
  public getInputService(): IInputService { return this.get<IInputService>('InputSystem'); }
  public getParticleSystem(): IParticleSystem { return this.get<IParticleSystem>('ParticleSystem'); }
  
  public getRegistry(): IEntityRegistry { return this.get<IEntityRegistry>('EntityRegistry'); }
  public getSpawner(): IEntitySpawner { return this.get<IEntitySpawner>('EntitySpawner'); }
  public getConfigService() { return ConfigService; }

  // Legacy Helpers
  public registerSystem(id: string, system: IGameSystem) { this.register(id, system); }
  public getSystem<T extends IGameSystem>(id: string): T { return this.get<T>(id); }
  public registerRegistry(r: IEntityRegistry) { this.register('EntityRegistry', r); }
  public registerSpawner(s: IEntitySpawner) { this.register('EntitySpawner', s); }
}

export const ServiceLocator = new ServiceLocatorImpl();


=====================================
FILE: ./src/engine/services/GameEngine.ts
=====================================
import { IGameSystem, IServiceLocator, IEntityRegistry, IPanelSystem, IGameStateSystem, SystemPhase } from '@/engine/interfaces';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { useStore } from '@/engine/state/global/useStore';
import { ViewportHelper } from '@/engine/math/ViewportHelper';
import { WorldConfig } from '@/engine/config/WorldConfig';
import { TimeSystem } from '@/engine/systems/TimeSystem';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';

export class GameEngineCore implements IGameSystem {
  // Array of Arrays for Phased Execution [Phase0[], Phase1[], ...]
  private systems: IGameSystem[][] = [[], [], [], [], [], []];
  
  public registry: IEntityRegistry; 
  private accumulator: number = 0;
  private simulationTime: number = 0;

  // Core System References (Injected)
  private panelSystem: IPanelSystem | null = null;
  private gameSystem: IGameStateSystem | null = null;
  private timeSystem: TimeSystem | null = null;

  constructor(registry: IEntityRegistry) {
      this.registry = registry;
  }

  public injectCoreSystems(panel: IPanelSystem, game: IGameStateSystem, time: TimeSystem) {
      this.panelSystem = panel;
      this.gameSystem = game;
      this.timeSystem = time;
  }

  setup(locator: IServiceLocator): void {}

  public registerSystem(system: IGameSystem, phase: SystemPhase) {
    this.systems[phase].push(system);
  }

  update(renderDelta: number, renderTime: number): void {
    const store = useStore.getState();
    const gameStore = useGameStore.getState();
    
    if (store.bootState === 'standby') return;
    if (store.activeModal === 'settings' || store.isDebugOpen) return;
    if (store.isSimulationPaused) return;

    // Game Over Logic
    if (this.gameSystem && this.panelSystem) {
        if (gameStore.isPlaying && this.panelSystem.systemIntegrity <= 0) {
            gameStore.stopGame();
            GameEventBus.emit(GameEvents.TRAUMA_ADDED, { amount: 1.0 });
            this.gameSystem.isGameOver = true; 
            return;
        }
        if (!gameStore.isPlaying) {
            this.gameSystem.isGameOver = true;
        }
    }

    // Time Management
    let timeScale = 1.0;
    if (this.timeSystem) {
        this.timeSystem.tickRealTime(renderDelta);
        if (this.timeSystem.isFrozen()) timeScale = 0.0;
        else timeScale = this.timeSystem.timeScale;
    }

    const effectiveDelta = renderDelta * timeScale * store.debugFlags.timeScale;
    this.accumulator += effectiveDelta;

    if (this.accumulator > WorldConfig.time.maxAccumulator) {
        this.accumulator = WorldConfig.time.maxAccumulator;
    }

    const fixedStep = WorldConfig.time.fixedDelta;

    while (this.accumulator >= fixedStep) {
        // Iterate Phases 0 to 5
        for (let phase = 0; phase < this.systems.length; phase++) {
            const phaseSystems = this.systems[phase];
            for (let i = 0; i < phaseSystems.length; i++) {
                try {
                    phaseSystems[i].update(fixedStep, this.simulationTime);
                } catch (e: any) {
                    console.error(`System Update Error [Phase ${phase}]:`, e);
                }
            }
        }
        this.simulationTime += fixedStep;
        this.accumulator -= fixedStep;
    }
  }

  teardown(): void {
    for (const phase of this.systems) {
        for (const sys of phase) {
            sys.teardown();
        }
    }
    this.systems = [[], [], [], [], [], []];
    this.panelSystem = null;
    this.gameSystem = null;
    this.timeSystem = null;
  }
  
  public updateViewport(vpW: number, vpH: number, screenW: number, screenH: number) {
    ViewportHelper.update(vpW, vpH, screenW, screenH);
    if (this.panelSystem) {
        this.panelSystem.refreshAll();
    }
  }
}


=====================================
FILE: ./src/engine/interfaces.ts
=====================================
import { Entity } from './ecs/Entity';
import { SpatialGrid } from './ecs/SpatialGrid';
import { WorldRect } from '@/engine/math/ViewportHelper';
import { ConfigService } from '@/engine/services/ConfigService';
import { QueryDef } from './ecs/Query';
import { Tag } from './ecs/types';
import { GameEvents, GameEventPayloads } from '@/engine/signals/GameEvents';
import { AudioKey, VFXKey, GeometryKey, MaterialKey } from '@/engine/config/AssetKeys';

export enum SystemPhase {
  INPUT = 0,
  LOGIC = 1,
  PHYSICS = 2,
  COLLISION = 3,
  STATE = 4,
  RENDER = 5
}

export interface IGameSystem {
  update(delta: number, time: number): void;
  teardown(): void;
}

export interface IServiceLocator {
  register<T>(id: string, instance: T): void;
  get<T>(id: string): T;
  getGameEventBus(): IGameEventService;
  getFastEventBus(): IFastEventService;
  getAudioService(): IAudioService;
  getInputService(): IInputService;
  getRegistry(): IEntityRegistry;
  getSpawner(): IEntitySpawner;
  getConfigService(): typeof ConfigService;
  getParticleSystem(): IParticleSystem;
  getSystem<T extends IGameSystem>(id: string): T;
  registerSystem(id: string, system: IGameSystem): void;
}

export interface IGameEventService {
  subscribe<T extends GameEvents>(event: T, handler: (payload: GameEventPayloads[T]) => void): () => void;
  emit<T extends GameEvents>(event: T, payload: GameEventPayloads[T]): void;
  clear(): void;
}

export interface IFastEventService {
  emit(eventId: number, a1?: number, a2?: number, a3?: number, a4?: number): void;
  readEvents(fromCursor: number, handler: (eventId: number, a1: number, a2: number, a3: number, a4: number) => void): number;
  getCursor(): number;
}

// --- SEGREGATED STATE INTERFACES ---

export interface IVitalsRead {
  playerHealth: number;
  maxPlayerHealth: number;
  playerRebootProgress: number;
  isGameOver: boolean;
}

export interface IProgressionRead {
  score: number;
  xp: number;
  level: number;
  xpToNextLevel: number;
  upgradePoints: number;
  activeUpgrades: Record<string, number>;
}

export interface IGameStateSystem extends IGameSystem, IVitalsRead, IProgressionRead {
  damagePlayer(amount: number): void;
  healPlayer(amount: number): void;
  addScore(amount: number): void;
  addXp(amount: number): void;
  tickReboot(amount: number): void;
  decayReboot(amount: number): void;
}

// --- END SEGREGATED INTERFACES ---

export interface IEntityRegistry {
  createEntity(): Entity;
  destroyEntity(id: number): void;
  getEntity(id: number): Entity | undefined;
  getAll(): IterableIterator<Entity>;
  getByTag(tag: string): Iterable<Entity>; 
  query(def: QueryDef): Iterable<Entity>;
  clear(): void;
  getStats(): { active: number; pooled: number; totalAllocated: number };
  updateCache(entity: Entity): void; 
}

export interface IEntitySpawner {
  spawn(archetypeId: string, overrides?: Record<string, any>, extraTags?: Tag[]): Entity;
  spawnPlayer(): Entity;
  spawnEnemy(type: string, x: number, y: number): Entity;
  spawnBullet(x: number, y: number, vx: number, vy: number, isEnemy: boolean, life: number, damage?: number, projectileId?: string, ownerId?: number): Entity;
  spawnParticle(x: number, y: number, color: string, vx: number, vy: number, life: number, size?: number, shape?: number): void;
}

export interface IAudioService {
  init(): Promise<void>;
  startMusic(): void;
  stopAll(): void;
  updateVolumes(): void;
  playSound(key: AudioKey, pan?: number): void;
  playAmbience(key: AudioKey): void;
  duckMusic(intensity: number, duration: number): void;
  getFrequencyData(array: Uint8Array): void;
  playClick(pan?: number): void;
  playHover(pan?: number): void;
  playBootSequence(): void;
  playDrillSound(): void;
  playRebootZap(): void;
}

export interface IInputService {
  getCursor(): { x: number, y: number };
  isPressed(action: string): boolean;
  updateCursor(x: number, y: number): void;
  updateBounds(width: number, height: number): void; 
}

export interface IParticleSystem extends IGameSystem {
  spawn(x: number, y: number, colorHex: string, vx: number, vy: number, life: number, size?: number, shape?: number): void;
  getCount(): number;
  getData(): { x: Float32Array; y: Float32Array; life: Float32Array; maxLife: Float32Array; color: Float32Array; };
}

export interface IPhysicsSystem extends IGameSystem {
  spatialGrid: SpatialGrid;
}

export interface ICombatSystem extends IGameSystem {
  resolveCollision(e1: Entity, e2: Entity): void;
}

export interface IInteractionSystem extends IGameSystem {
  repairState: 'IDLE' | 'HEALING' | 'REBOOTING';
  hoveringPanelId: string | null;
}

export interface IPanelSystem extends IGameSystem {
  systemIntegrity: number;
  register(id: string, element: HTMLElement): void;
  unregister(id: string): void;
  refreshAll(): void;
  refreshSingle(id: string): void;
  damagePanel(id: string, amount: number, silent?: boolean): void;
  healPanel(id: string, amount: number, sourceX?: number): void;
  decayPanel(id: string, amount: number): void;
  destroyAll(): void;
  getPanelRect(id: string): WorldRect | undefined;
  getPanelState(id: string): { health: number; isDestroyed: boolean } | undefined;
  getAllPanels(): any[]; 
}


