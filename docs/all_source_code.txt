+---------------------------------+
|      M E S O E L F Y _ O S      |
|   Next.js / R3F Source Context  |
+---------------------------------+
Generated on: Fri Dec  5 13:02:15 CST 2025

=====================================
PROJECT DIRECTORY STRUCTURE:
=====================================
.
â”œâ”€â”€ Icon\015
â”œâ”€â”€ README.md
â”œâ”€â”€ _MISC_IGNORE
â”‚Â Â  â”œâ”€â”€ 9776943-KKLCIZVI-7 copy.jpg
â”‚Â Â  â”œâ”€â”€ Generated Image September 28, 2025 - 3_04PM.png
â”‚Â Â  â”œâ”€â”€ Nintendo Game Boy Color.png
â”‚Â Â  â”œâ”€â”€ Nintendo Super Game Boy 2.png
â”‚Â Â  â”œâ”€â”€ Nintendo Super Game Boy.png
â”‚Â Â  â”œâ”€â”€ Screenshot 2023-10-28 at 10.41.26 AM copy.png
â”‚Â Â  â”œâ”€â”€ Sega Genesis.png
â”‚Â Â  â”œâ”€â”€ Sega Mega Drive.png
â”‚Â Â  â”œâ”€â”€ Sega Saturn.png
â”‚Â Â  â”œâ”€â”€ Update 2.0 - Sega Mega CD.png
â”‚Â Â  â”œâ”€â”€ background
â”‚Â Â  â”‚Â Â  â””â”€â”€ 2.jpg
â”‚Â Â  â”œâ”€â”€ cheap_cable copy.png
â”‚Â Â  â”œâ”€â”€ chrome-silver-question-mark copy.png
â”‚Â Â  â”œâ”€â”€ frosted-glass-green-triangle-render copy.png
â”‚Â Â  â””â”€â”€ https ::underkactuscard.carrd.co + three frame animations.png
â”œâ”€â”€ docs
â”‚Â Â  â”œâ”€â”€ MESOELFY_OS_AI_INSTRUCTIONS.md
â”‚Â Â  â”œâ”€â”€ TODO.md
â”‚Â Â  â””â”€â”€ all_source_code.txt
â”œâ”€â”€ next-env.d.ts
â”œâ”€â”€ next.config.js
â”œâ”€â”€ package.json
â”œâ”€â”€ postcss.config.js
â”œâ”€â”€ public
â”‚Â Â  â”œâ”€â”€ assets
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ audio
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ images
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ social-card.jpg
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ models
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ textures
â”‚Â Â  â”‚Â Â  â””â”€â”€ videos
â”‚Â Â  â””â”€â”€ favicon.ico
â”œâ”€â”€ scripts
â”‚Â Â  â””â”€â”€ create_source_context.command
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ app
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ layout.tsx
â”‚Â Â  â”‚Â Â  â””â”€â”€ page.tsx
â”‚Â Â  â”œâ”€â”€ core
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ audio
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ AudioSystem.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ hooks
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ math
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ store
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ useStore.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ utils
â”‚Â Â  â”œâ”€â”€ data
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ feed.json
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ gallery.json
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ identity.json
â”‚Â Â  â”‚Â Â  â””â”€â”€ socials.json
â”‚Â Â  â”œâ”€â”€ features
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ contact
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ ContactModal.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ effects
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ GlobalShakeManager.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ feed
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ FeedModal.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ gallery
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ GalleryModal.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ identity
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ AboutModal.tsx
â”‚Â Â  â”‚Â Â  â””â”€â”€ intro
â”‚Â Â  â”‚Â Â      â””â”€â”€ MatrixBootSequence.tsx
â”‚Â Â  â”œâ”€â”€ game
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameOverlay.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ BulletRenderer.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EffectsLayer.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EnemyBulletRenderer.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EnemyRenderer.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameDirector.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ HunterChargeRenderer.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ParticleRenderer.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PlayerAvatar.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ ScreenShaker.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ config
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EnemyConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Identifiers.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ PlayerConfig.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ core
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameEngine.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ ServiceLocator.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ events
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameEventBus.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ GameEvents.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ hooks
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ usePanelRegistry.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ logic
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ ai
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ EnemyBehaviors.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ store
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ useGameStore.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ systems
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ BreachSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CollisionSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EntitySystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ FXManager.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ InputSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ InteractionSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PlayerSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ WaveSystem.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ theme.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ types
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ game.types.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ utils
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ ViewportHelper.ts
â”‚Â Â  â”‚Â Â      â””â”€â”€ coords.ts
â”‚Â Â  â”œâ”€â”€ scene
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ canvas
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ SceneCanvas.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ effects
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ FireTransition.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ MatrixGrid.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ props
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ MiniCrystalCanvas.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ SoulCrystal.tsx
â”‚Â Â  â”‚Â Â  â””â”€â”€ shaders
â”‚Â Â  â”œâ”€â”€ styles
â”‚Â Â  â”‚Â Â  â””â”€â”€ globals.css
â”‚Â Â  â””â”€â”€ ui
â”‚Â Â      â”œâ”€â”€ atoms
â”‚Â Â      â”‚Â Â  â””â”€â”€ GlassPanel.tsx
â”‚Â Â      â”œâ”€â”€ molecules
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ HoloCommLog.tsx
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ IdentityHUD.tsx
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ LiveArtGrid.tsx
â”‚Â Â      â”‚Â Â  â””â”€â”€ SocialRow.tsx
â”‚Â Â      â”œâ”€â”€ organisms
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ Footer.tsx
â”‚Â Â      â”‚Â Â  â””â”€â”€ Header.tsx
â”‚Â Â      â””â”€â”€ overlays
â”‚Â Â          â””â”€â”€ ModalContainer.tsx
â”œâ”€â”€ tailwind.config.ts
â””â”€â”€ tsconfig.json

51 directories, 89 files

=====================================
FILE: ./next.config.js
=====================================
/** @type {import('next').NextConfig} */

let commitHash = 'DEV_BUILD';

try {
  const { execSync } = require('child_process');
  commitHash = execSync('git rev-parse --short HEAD').toString().trim();
} catch (error) {
  console.warn('Warning: Could not determine git commit hash.');
}

const nextConfig = {
  output: 'export',
  images: {
    unoptimized: true,
  },
  reactStrictMode: true,
  transpilePackages: ['three'],
  
  // Disable Indicators
  devIndicators: false,


  
  env: {
    NEXT_PUBLIC_COMMIT_HASH: commitHash,
  },
  
  typescript: {
    ignoreBuildErrors: true,
  },
  eslint: {
    ignoreDuringBuilds: true,
  },
}

module.exports = nextConfig


=====================================
FILE: ./docs/TODO.md
=====================================
# MESOELFY_OS // DEVELOPMENT ROADMAP





## ğŸŸ¢ COMPLETED 


## ğŸŸ¡ CURRENT FOCUS: VISUAL POLISH (The "Neon" Vibe)
*Since the post-processing library is incompatible with React 19, we must implement manual shaders.*
- [ ] **Manual Bloom:** Implement a custom shader pass or "Fake Glow" meshes to achieve the neon look without heavy post-processing.
- [ ] **Chromatic Aberration:** Add a glitch effect that triggers on damage/low health.
- [ ] **CRT/Scanline Effect:** Optional overlay for the retro hacker vibe.

## ğŸŸ  GAMEPLAY DEPTH
- [ ] **Player Health UI:** Visualize player HP in MESOELFY_OS header (currently hidden in logic).
- [ ] **Score System:** Display score on HUD and trigger "Level Up" events.
- [ ] **Powerups:**
    -   *Rapid Fire:* Increase fire rate temporarily.
    -   *Spread Shot:* Triple shot.
    -   *Shield:* One-hit protection.
- [ ] **Wave System:** Instead of infinite random spawns, structure waves with increasing difficulty.

## ğŸ”´ NEW ENEMIES (From Audit)
- [ ] **The Glitcher:** Teleports randomly around the screen. Hard to hit.
- [ ] **The Virus:** When destroyed, spawns 3 smaller, faster "bits" (Munchers).
- [ ] **The Boss:** A large, multi-stage entity (Reserved for later).

## ğŸ”µ SYSTEM & TECH
- [ ] **Save State:** Track high score and total deaths in `localStorage`.
- [ ] **Content Injection:** Fill JSON files with final text/links/images.
- [ ] **Mobile Controls:** Add touch controls or ensure playable on mobile.

## ğŸ› KNOWN BUGS
- [ ] **White Flash on Refresh (FOUC):** The 3D Canvas areas flash white briefly on page reload.








## THOUGHTS

- should enemies come in waves indicated in MESOELFY_OS Header?
- instead of just panel munchers (rename from seeker), what if there is also a muncher enemy that targets the elements within a panel such as each of the three video slots or each social media button, or the CONTACT and ABOUT ME buttons? What about an enemy type that enters a modal and does damage inside? Can that be coded for them to be moving around doing stuff even though we haven't instantiated the modal yet? How do we deal with the enemies on the MESOELFY_OS screen if we are inside a modal fighting some enemies? Wouldn't that have weird game logic? I need to brainstorm this with AI.
- need health for player and lives and powerups. (increase bullet size / rate of fire)
- need help seeing not obvious stuff that is missing.
- hunter enemy needs to shoot projectiles.
- Kamekazi should be bigger and slow. If it blows up on player and is inside a panel, it does damage to that panel.

- What things does Vampire Survivors do that I should implement? Game design and juice.

- Should I have a high score patron screen where people can enter their name with links to whatever they want?

=====================================
FILE: ./docs/MESOELFY_OS_AI_INSTRUCTIONS.md
=====================================
I am developing "MESOELFY_OS," a 3D interactive portfolio site with a Cyberpunk/Hacker/Demoscene aesthetic. 

I have attached "all_source_code.txt" which contains the full project tree and code. Please ingest this to understand the current architecture.

***CORE IDENTITY & AESTHETIC***
*   **Persona:** You are assisting "Elfy," a Latent Space Bandit. The vibe is Y2K Hacker, Matrix, Geometry Wars, and High-Tech Demoscene.
*   **Palette:** Electric Green (#78F654) is dominant. Deep Purple (#9E4EA5) is secondary. Red/Yellow for alerts. Black backgrounds.
*   **Current Status:** The site is live at `mesoelfy.github.io`. The "Intro Boot Sequence" and "Main Dashboard" are built and polished.

***TECHNICAL STACK***
*   **Framework:** Next.js 14 (App Router) + TypeScript.
*   **Styling:** Tailwind CSS + Framer Motion (for UI animations).
*   **3D:** React Three Fiber (R3F) + Drei.
*   **Deployment:** GitHub Pages (Static Export).

***WORKFLOW RULES (CRITICAL)***
1.  **Terminal Only:** Do not ask me to manually create files. Provide full terminal commands using `cat << 'EOF' > path/to/file` to create or overwrite files.
2.  **No Placeholders:** Unless specified, write complete, functional code.
3.  **Atomic Commits:** After a successful feature implementation, provide the specific `git add .`, `git commit -m "..."`, and `git push` commands.
4.  **Lean Ship:** Keep dependencies low. Prefer procedural generation (shaders/math) over large assets.

Working directory:
stevencasteel@Stevens-Mac-mini mesoelfy-site % 


Please acknowledge you have analyzed the codebase.

=====================================
FILE: ./next-env.d.ts
=====================================
/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


=====================================
FILE: ./README.md
=====================================
<div align="center">

```text
 â–ˆâ–ˆâ–ˆâ–„ â–„â–ˆâ–ˆâ–ˆâ–“â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–“      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–“â–ˆâ–ˆ   â–ˆâ–ˆâ–“
â–“â–ˆâ–ˆâ–’â–€â–ˆâ–€ â–ˆâ–ˆâ–’â–“â–ˆ   â–€â–’â–ˆâ–ˆ    â–’ â–’â–ˆâ–ˆâ–’  â–ˆâ–ˆâ–’â–“â–ˆ   â–€ â–“â–ˆâ–ˆâ–’    â–’â–“â–ˆ   â–’  â–’â–ˆâ–ˆ  â–ˆâ–ˆâ–’
â–“â–ˆâ–ˆ    â–“â–ˆâ–ˆâ–‘â–’â–ˆâ–ˆâ–ˆ  â–‘ â–“â–ˆâ–ˆâ–„   â–’â–ˆâ–ˆâ–‘  â–ˆâ–ˆâ–’â–’â–ˆâ–ˆâ–ˆ   â–’â–ˆâ–ˆâ–‘    â–’â–“â–ˆâ–ˆâ–ˆ â–‘   â–’â–ˆâ–ˆ â–ˆâ–ˆâ–‘
â–’â–ˆâ–ˆ    â–’â–ˆâ–ˆ â–’â–“â–ˆ  â–„  â–’   â–ˆâ–ˆâ–’â–’â–ˆâ–ˆ   â–ˆâ–ˆâ–‘â–’â–“â–ˆ  â–„ â–’â–ˆâ–ˆâ–‘    â–‘â–“â–ˆâ–’  â–‘   â–‘ â–â–ˆâ–ˆâ–‘â–‘
â–’â–ˆâ–ˆâ–’   â–‘â–ˆâ–ˆâ–’â–‘â–’â–ˆâ–ˆâ–ˆâ–ˆâ–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–‘ â–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–ˆâ–ˆâ–ˆâ–ˆâ–’â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–‘â–’â–ˆâ–‘      â–‘ â–ˆâ–ˆâ–’â–‘â–‘
â–‘ â–’â–‘   â–‘  â–‘â–‘â–‘ â–’â–‘ â–‘ â–’â–‘â–’  â–‘ â–‘ â–’â–‘â–’â–‘â–’â–‘ â–‘â–‘ â–’â–‘ â–‘â–‘ â–’â–‘â–’  â–‘ â–’ â–‘       â–ˆâ–ˆâ–’â–’â–’
â–‘  â–‘      â–‘ â–‘ â–‘  â–‘ â–‘ â–’  â–‘   â–‘ â–’ â–’â–‘  â–‘ â–‘  â–‘â–‘ â–‘ â–’  â–‘ â–‘       â–“â–ˆâ–ˆ â–‘â–’â–‘ 
â–‘      â–‘      â–‘    â–‘ â–‘    â–‘ â–‘ â–‘ â–’     â–‘     â–‘ â–‘    â–‘ â–‘     â–’ â–’ â–‘â–‘  
       â–‘      â–‘  â–‘   â–‘  â–‘     â–‘ â–‘     â–‘  â–‘    â–‘  â–‘         â–‘ â–‘     
```

### **LATENT SPACE BANDIT // DIGITAL HQ**

![System Status](https://img.shields.io/badge/SYSTEM-UNSECURE-ff003c?style=for-the-badge&logo=linux)
![Encryption](https://img.shields.io/badge/ENCRYPTION-BYPASSED-78F654?style=for-the-badge)
![Core](https://img.shields.io/badge/CORE-REACT_THREE_FIBER-9E4EA5?style=for-the-badge&logo=react)

</div>

---

### **// TRANSMISSION_LOG**

**MESOELFY_OS** is a generative 3D operating system disguised as a portfolio site. It serves as the central node for **Elfy**, a rogue entity manifesting art from the void.

The system features a custom "Latent Defense" protocol, audio-reactive interfaces, and a direct uplink to the neural network.

### **// SYSTEM_SPECS (Tech Stack)**

| MODULE | PAYLOAD |
| :--- | :--- |
| **Framework** | Next.js 14 (App Router) + TypeScript |
| **Graphics Core** | React Three Fiber (R3F) + Drei + Shaders |
| **Styling** | Tailwind CSS + Framer Motion |
| **Audio Engine** | Web Audio API (Generative Synthesis) |
| **Deployment** | GitHub Pages (Static Export) |

### **// BOOT_PROTOCOL (Installation)**

```bash
# 1. Clone the Repository
git clone https://github.com/mesoelfy/mesoelfy.github.io.git

# 2. Inject Dependencies
npm install

# 3. Initialize System (Dev Mode)
npm run dev
```

### **// IDENTITY_CORE**

*   **Class:** Latent Space Bandit
*   **Abilities:** Green Flame, Digital Heist, Prompt Craft
*   **Mission:** Create cool s**t. Annoy the haters.

---

<div align="center">
  <p><strong>âš  WARNING: TRANSMISSIONS ARE MONITORED BY THE AI OVERLORD. âš </strong></p>
  <a href="https://x.com/mesoelfy">[ TWITTER_UPLINK ]</a> â€¢ <a href="https://mesoelfy.github.io">[ LAUNCH_OS ]</a>
</div>

=====================================
FILE: ./tailwind.config.ts
=====================================
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './src/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        // --- BRAND CORE (Existing UI) ---
        elfy: {
          green: {
            light: '#7FF65F',
            DEFAULT: 'rgba(96, 196, 68, 1)',
            dim: '#1bb930ff',
            dark: '#217e10ff',
          },
          purple: {
            light: '#BC86BA',
            DEFAULT: '#9E4EA5',
            dim: '#822B8A',
            deep: '#350E3A',
          },
          yellow: {
            DEFAULT: '#eae747ff',
          },
          red: '#FF003C', 
          gray: '#27282A',
          black: '#050505',
        },
        
        // --- LATENT DEFENSE (Game Layer) ---
        // Bespoke values for fine-tuning without affecting UI
        game: {
          turret: {
            base: '#78F654', // Player color
            glow: '#C2FE9A',
          },
          bullet: {
            plasma: '#FFFFFF', 
            trail: '#78F654',
          },
          enemy: {
            seeker: '#9E4EA5', // Fast unit (Purple)
            eater: '#FF003C',  // Tank unit (Red)
            boss: '#F7D277',   // Boss unit (Yellow)
          },
          hud: {
            text: '#78F654',
            warning: '#FF003C',
          },
          vfx: {
            spark: '#FFFFFF',
            damage: '#FF003C',
          }
        }
      },
      fontFamily: {
        header: ['var(--font-montserrat)', 'sans-serif'],
        mono: ['Courier New', 'Courier', 'monospace'],
        tech: ['var(--font-jetbrains)', 'monospace'],
      },
      animation: {
        'spin-slow': 'spin 3s linear infinite',
        'spin-diamond': 'spin-diamond 3s linear infinite',
        'matrix-green': 'matrix-green 4s ease-in-out infinite',
        'matrix-purple': 'matrix-purple 2s ease-in-out infinite',
        'cursor-blink': 'cursor-blink 1.2s ease-in-out infinite',
      },
      keyframes: {
        'spin-diamond': {
          '0%': { transform: 'rotate(45deg)' },
          '100%': { transform: 'rotate(405deg)' },
        },
        'matrix-green': {
          '0%, 100%': { color: '#14630bff' },
          '50%': { color: '#0aa41cff' },
        },
        'matrix-purple': {
          '0%, 100%': { color: '#9E4EA5' }, 
          '33%': { color: '#BC86BA' },      
          '66%': { color: '#350E3A' },      
        },
        'cursor-blink': {
          '0%, 30%': { opacity: '1' }, 
          '50%': { opacity: '0' },     
          '100%': { opacity: '1' },    
        }
      }
    },
  },
  plugins: [],
}
export default config


=====================================
FILE: ./package.json
=====================================
{
  "name": "mesoelfy-site",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@react-three/drei": "^10.7.7",
    "@react-three/fiber": "^9.4.2",
    "@react-three/postprocessing": "^2.19.1",
    "clsx": "^2.1.0",
    "framer-motion": "^11.0.0",
    "lucide-react": "^0.300.0",
    "maath": "^0.10.0",
    "next": "^16.0.7",
    "react": "^19.2.1",
    "react-dom": "^19.2.1",
    "tailwind-merge": "^2.2.0",
    "three": "^0.181.2",
    "zustand": "^4.5.0"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@types/three": "^0.181.0",
    "autoprefixer": "^10.0.1",
    "eslint": "^9.39.1",
    "eslint-config-next": "^16.0.7",
    "postcss": "^8",
    "tailwindcss": "^3.3.0",
    "typescript": "^5"
  }
}


=====================================
FILE: ./tsconfig.json
=====================================
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./src/*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}


=====================================
FILE: ./postcss.config.js
=====================================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


=====================================
FILE: ./src/ui/molecules/SocialRow.tsx
=====================================
import { Twitter, Youtube, Github, Video, Crosshair, Image as ImageIcon } from 'lucide-react';
import socials from '@/data/socials.json';
import { AudioSystem } from '@/core/audio/AudioSystem';

const IconMap: Record<string, any> = {
  twitter: Twitter,
  youtube: Youtube,
  github: Github,
  video: Video,
  crosshair: Crosshair,
  image: ImageIcon,
};

export const SocialRow = () => {
  return (
    <div className="grid grid-cols-3 gap-2 h-full content-center py-2">
      {socials.map((social) => {
        const Icon = IconMap[social.icon] || Crosshair;
        return (
          <a
            key={social.name}
            href={social.url}
            target="_blank"
            rel="noopener noreferrer"
            onMouseEnter={() => AudioSystem.playHover()} // ADDED SFX
            onClick={() => AudioSystem.playClick()}      // ADDED SFX
            className="group flex flex-col items-center justify-center p-2 border border-elfy-green-dim/30 bg-black/40 hover:bg-elfy-green/10 hover:border-elfy-green transition-all duration-300"
          >
            <Icon 
              className="w-5 h-5 mb-1 text-elfy-green-dim group-hover:text-elfy-green group-hover:scale-110 transition-transform" 
              style={{ filter: 'drop-shadow(0 0 2px rgba(120,246,84,0.3))' }}
            />
            <span className="text-[10px] uppercase text-elfy-green-dim/60 group-hover:text-elfy-green tracking-wider font-mono">
              {social.name.split(' ')[0]}
            </span>
          </a>
        );
      })}
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/HoloCommLog.tsx
=====================================
import { useEffect, useState, useRef, useCallback } from 'react';
import { ExternalLink, Radio, WifiOff } from 'lucide-react';
import { useGameStore } from '@/game/store/useGameStore';

const VIDEO_POOL = [
  "oLALHbB3iXU", "A1dnxXrpN-o", "elyXcwunIYA", 
  "bHUcvHx9zlA", "Eq6EYcpWB_c", "sJyWgks1ZtA", 
  "dFlDRhvM4L0", "Ku5fgOHy1JY", "8-91y7BJ8QA"
];

// Reusable Offline Static Component
const OfflineStatic = () => (
  <div className="absolute inset-0 z-50 bg-black flex flex-col items-center justify-center border border-elfy-red/20">
    <div className="absolute inset-0 bg-[url('https://media.giphy.com/media/oEI9uBYSzLpBK/giphy.gif')] opacity-10 bg-cover mix-blend-screen pointer-events-none" />
    <WifiOff className="text-elfy-red animate-pulse w-8 h-8 mb-2" />
    <span className="text-[10px] font-mono text-elfy-red animate-pulse tracking-widest">SIGNAL_LOST</span>
  </div>
);

// Loading Placeholder (To prevent Hydration Mismatch)
const LoadingPlaceholder = () => (
  <div className="relative w-full aspect-video min-h-[140px] md:min-h-0 border border-elfy-green-dim/20 bg-black flex flex-col items-center justify-center">
    <Radio className="text-elfy-green-dim/50 animate-pulse w-6 h-6 mb-2" />
    <span className="text-[10px] font-mono text-elfy-green-dim/50 animate-pulse">INITIALIZING_FEED...</span>
  </div>
);

const VideoSlot = ({ 
  slotIndex, 
  initialVideo, 
  getNextVideo,
  isOffline 
}: { 
  slotIndex: number, 
  initialVideo: string, 
  getNextVideo: () => string,
  isOffline: boolean
}) => {
  const [videoId, setVideoId] = useState(initialVideo);
  const [isMasked, setIsMasked] = useState(true);

  // HOOK 1: Initial Mask
  useEffect(() => {
    setIsMasked(true);
    const unmaskTimer = setTimeout(() => {
      setIsMasked(false);
    }, 5000);
    return () => clearTimeout(unmaskTimer);
  }, []); 

  // HOOK 2: Video Rotation
  useEffect(() => {
    if (isOffline) return; // Logic check inside hook (Safe)

    const duration = 30000 + (Math.random() * 15000);
    const timer = setTimeout(() => {
      setIsMasked(true);
      setTimeout(() => {
        const next = getNextVideo();
        if (next) setVideoId(next);
        setTimeout(() => setIsMasked(false), 5000);
      }, 1000); 
    }, duration);
    return () => clearTimeout(timer);
  }, [videoId, getNextVideo, isOffline]);

  // Conditional Rendering Logic (Must be after all hooks)
  const content = isOffline ? (
    <>
      <OfflineStatic />
      <div className="absolute bottom-1 right-1 z-30 text-[8px] text-elfy-red font-mono bg-black/80 px-1">
         CAM_0{slotIndex + 1} [ERR]
      </div>
    </>
  ) : (
    <>
      <div className="absolute inset-0 z-30 pointer-events-none bg-[linear-gradient(rgba(0,0,0,0)_50%,rgba(0,0,0,0.25)_50%)] bg-[length:100%_4px]" />
      
      <a 
        href={`https://www.youtube.com/watch?v=${videoId}`}
        target="_blank"
        rel="noopener noreferrer"
        className="absolute inset-0 z-40 cursor-pointer flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity bg-black/40 backdrop-blur-[2px]"
      >
        <div className="flex items-center gap-2 text-elfy-red font-mono font-bold bg-black/80 px-3 py-1 border border-elfy-red rounded-sm">
          <span>OPEN_SOURCE</span>
          <ExternalLink size={12} />
        </div>
      </a>

      {/* The Loading/Mask Overlay */}
      <div 
        className={`absolute inset-0 z-20 bg-black flex flex-col items-center justify-center transition-opacity duration-500 ${isMasked ? 'opacity-100' : 'opacity-0 pointer-events-none'}`}
      >
        <Radio className="text-elfy-red animate-pulse w-6 h-6 mb-2" />
        <span className="text-[10px] font-mono text-elfy-red animate-pulse">ESTABLISHING_UPLINK...</span>
      </div>

      <div className="absolute inset-0 z-10">
        <iframe 
          width="100%" 
          height="100%" 
          src={`https://www.youtube.com/embed/${videoId}?autoplay=1&mute=1&controls=0&showinfo=0&modestbranding=1&loop=1&playlist=${videoId}&vq=small`} 
          title="HOLO_COMM" 
          frameBorder="0" 
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
          className="w-full h-full object-cover grayscale"
        />
      </div>

      <div className="absolute bottom-1 right-1 z-30 text-[8px] text-elfy-red font-mono bg-black/80 px-1">
         CAM_0{slotIndex + 1}
      </div>
    </>
  );

  return (
    <div className="relative w-full aspect-video min-h-[140px] md:min-h-0 border border-elfy-red/30 bg-black overflow-hidden group hover:border-elfy-red hover:shadow-[0_0_15px_rgba(255,0,60,0.3)] transition-all">
      {content}
    </div>
  );
};

export const HoloCommLog = () => {
  const deckRef = useRef<string[]>([...VIDEO_POOL]);
  
  // Game Store Subscription
  const panelState = useGameStore((state) => state.panels['video']);
  const isOffline = panelState ? (panelState.isDestroyed || panelState.health <= 0) : false;

  // Hydration Safe State
  const [initialVideos, setInitialVideos] = useState<string[] | null>(null);

  // Initialize Random Videos on Client Only
  useEffect(() => {
    // Reset deck
    deckRef.current = [...VIDEO_POOL];
    const init: string[] = [];
    
    // Pick 3 random videos
    for(let i=0; i<3; i++) {
      const randomIndex = Math.floor(Math.random() * deckRef.current.length);
      const vid = deckRef.current[randomIndex];
      deckRef.current.splice(randomIndex, 1); // Remove selected to avoid dupes
      init.push(vid);
    }
    setInitialVideos(init);
  }, []);

  const getNextVideo = useCallback(() => {
    if (deckRef.current.length === 0) {
      deckRef.current = [...VIDEO_POOL];
    }
    const randomIndex = Math.floor(Math.random() * deckRef.current.length);
    const selected = deckRef.current[randomIndex];
    deckRef.current.splice(randomIndex, 1);
    return selected || VIDEO_POOL[0];
  }, []);

  // If waiting for client hydration, show placeholders
  if (!initialVideos) {
    return (
      <div className="flex flex-col h-full gap-2 overflow-hidden p-1 justify-center">
        {[0, 1, 2].map((i) => <LoadingPlaceholder key={i} />)}
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full gap-2 overflow-hidden p-1 justify-center">
      {initialVideos.map((vid, i) => (
        <VideoSlot 
          key={i} 
          slotIndex={i} 
          initialVideo={vid} 
          getNextVideo={getNextVideo}
          isOffline={isOffline} 
        />
      ))}
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/LiveArtGrid.tsx
=====================================
import { useEffect, useState } from 'react';
import { useStore } from '@/core/store/useStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { motion, AnimatePresence } from 'framer-motion';

const randomId = () => Math.floor(Math.random() * 899) + 100;

export const LiveArtGrid = () => {
  const { openModal } = useStore();
  const [slots, setSlots] = useState<number[]>([]);

  useEffect(() => {
    setSlots(Array.from({ length: 12 }, randomId));

    const interval = setInterval(() => {
      setSlots(prev => {
        const newSlots = [...prev];
        const randomIndex = Math.floor(Math.random() * 12);
        newSlots[randomIndex] = randomId();
        return newSlots;
      });
    }, 800);

    return () => clearInterval(interval);
  }, []);

  return (
    <div className="grid grid-cols-3 gap-1 w-full p-2 content-start">
      <AnimatePresence mode='popLayout'>
        {slots.map((id, index) => (
          <motion.button
            key={`${index}-${id}`}
            layout
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.2 }}
            
            onClick={() => openModal('gallery')}
            onMouseEnter={() => AudioSystem.playHover()} // ADDED SFX
            
            className="w-full aspect-square relative bg-black/50 border border-elfy-green-dim/30 hover:border-elfy-yellow hover:shadow-[0_0_10px_rgba(247,210,119,0.2)] group overflow-hidden flex items-center justify-center rounded-[1px]"
          >
            <div className="absolute inset-0 bg-elfy-green/5 group-hover:bg-elfy-green/10 transition-colors" />
            
            <span className="relative z-10 text-[9px] font-mono text-elfy-green-dim group-hover:text-elfy-yellow transition-colors">
              IMG_{id}
            </span>

            <div className="absolute top-0 right-0 w-1.5 h-1.5 border-t border-r border-elfy-green-dim/50 group-hover:border-elfy-yellow" />
          </motion.button>
        ))}
      </AnimatePresence>
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/IdentityHUD.tsx
=====================================
import { MiniCrystalCanvas } from '@/scene/props/MiniCrystalCanvas';
import { useGameStore, UpgradeOption } from '@/game/store/useGameStore';
import identity from '@/data/identity.json';
import { useStore } from '@/core/store/useStore'; 
import { AudioSystem } from '@/core/audio/AudioSystem';
import { Unplug, Zap, AlertCircle } from 'lucide-react';

export const IdentityHUD = () => {
  const { openModal } = useStore();
  
  const hp = useGameStore(s => s.playerHealth);
  const maxHp = useGameStore(s => s.maxPlayerHealth);
  const xp = useGameStore(s => s.xp);
  const nextXp = useGameStore(s => s.xpToNextLevel);
  const level = useGameStore(s => s.level);
  
  const upgradePoints = useGameStore(s => s.upgradePoints);
  const selectUpgrade = useGameStore(s => s.selectUpgrade);
  const rebootProgress = useGameStore(s => s.playerRebootProgress);
  
  const panel = useGameStore(s => s.panels['identity']);
  const isPanelDead = panel ? panel.isDestroyed : false;
  const isPlayerDead = hp <= 0;

  const hpPercent = Math.max(0, (hp / maxHp) * 100);
  const xpPercent = Math.min(100, (xp / nextXp) * 100);

  const size = 160; 
  const center = size / 2;
  const radiusHp = 60;
  const radiusXp = 70;
  const stroke = 4;
  
  const circHp = 2 * Math.PI * radiusHp;
  const circXp = 2 * Math.PI * radiusXp;

  const displayHpPercent = isPlayerDead ? rebootProgress : hpPercent;
  const displayHpColor = isPlayerDead ? "#eae747" : (hpPercent < 30 ? "#FF003C" : "#78F654"); 

  const offsetHp = circHp - (displayHpPercent / 100 * circHp);
  const offsetXp = circXp - (xpPercent / 100 * circXp);

  const availableOptions: UpgradeOption[] = ['RAPID_FIRE', 'MULTI_SHOT', 'SPEED_UP', 'REPAIR_NANITES'];

  const handleUpgrade = (u: UpgradeOption) => {
      if (isPanelDead || isPlayerDead) return; 
      AudioSystem.playClick();
      selectUpgrade(u);
  };

  return (
    <div className={`flex flex-col items-center h-full w-full relative ${isPanelDead ? 'grayscale opacity-50 pointer-events-none' : ''}`}>
      
      {/* 1. THE AVATAR (Top) */}
      <div className="relative w-32 h-32 md:w-40 md:h-40 shrink-0 mt-2 group mb-6"> {/* Added margin bottom to clear badge */}
        
        {/* AVATAR LAYER */}
        <div className={`absolute inset-0 rounded-full bg-black/50 overflow-hidden transition-opacity duration-500 ${isPlayerDead ? 'opacity-60 grayscale' : 'opacity-100'}`}>
           <MiniCrystalCanvas />
        </div>

        {/* REBOOT INDICATOR (Center Text) */}
        {isPlayerDead && (
            <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                {rebootProgress > 0 ? (
                    <span className="text-2xl font-header font-black text-elfy-yellow drop-shadow-md animate-pulse">
                        {Math.floor(rebootProgress)}%
                    </span>
                ) : (
                    <div className="animate-pulse">
                        <Unplug className="text-white/50 w-8 h-8" />
                    </div>
                )}
            </div>
        )}

        {/* HUD RINGS */}
        <svg className="absolute inset-0 w-full h-full -rotate-90 pointer-events-none" viewBox={`0 0 ${size} ${size}`}>
          <circle cx={center} cy={center} r={radiusHp} stroke="#1a1a1a" strokeWidth={stroke} fill="transparent" />
          <circle cx={center} cy={center} r={radiusXp} stroke="#1a1a1a" strokeWidth={stroke} fill="transparent" strokeDasharray="4 4" />
          
          <circle 
            cx={center} cy={center} r={radiusHp} 
            stroke={displayHpColor} 
            strokeWidth={stroke} fill="transparent"
            strokeDasharray={circHp}
            strokeDashoffset={offsetHp}
            strokeLinecap="round"
            className="transition-all duration-100 ease-linear"
          />
          <circle 
            cx={center} cy={center} r={radiusXp} 
            stroke="#9E4EA5" 
            strokeWidth={stroke} fill="transparent"
            strokeDasharray={circXp}
            strokeDashoffset={offsetXp}
            strokeLinecap="round"
            className="transition-all duration-500 ease-out"
          />
        </svg>

        {/* Level Badge - MOVED LOWER (bottom: -16px) */}
        <div className="absolute -bottom-4 left-1/2 -translate-x-1/2 bg-black border border-elfy-purple text-elfy-purple px-3 py-0.5 text-[10px] font-bold font-mono rounded-full shadow-[0_0_10px_rgba(158,78,165,0.4)] z-20">
          LVL_{level}
        </div>
      </div>

      {/* 2. INFO & UPGRADES (Middle) */}
      <div className="flex-1 flex flex-col justify-center items-center w-full gap-2 py-1 min-h-0">
        
        {isPlayerDead && !isPanelDead ? (
            <div className="bg-black/80 border border-elfy-yellow/50 px-4 py-2 rounded animate-pulse text-center relative z-50">
                <div className="flex items-center justify-center gap-2 text-elfy-yellow font-bold text-xs mb-1">
                    <Zap size={14} />
                    <span>SYSTEM CRITICAL</span>
                </div>
                <p className="text-[9px] text-white font-mono">HOLD TO REBOOT</p>
                <p className="text-[8px] text-elfy-red mt-1 font-bold">TAKING DAMAGE DRAINS POWER</p>
            </div>
        ) : (
            <div className="text-center">
              <h2 className="text-2xl font-header font-black text-elfy-green tracking-wider">{identity.name}</h2>
              <div className="text-[9px] text-elfy-purple-light uppercase tracking-widest opacity-80">{identity.class}</div>
            </div>
        )}

        {/* UPGRADE MODULE (Stacking) */}
        {upgradePoints > 0 && !isPlayerDead && (
          <div className="w-full bg-elfy-purple-deep/40 border border-elfy-purple/50 p-1.5 rounded-sm pointer-events-auto z-50 animate-pulse">
            <div className="flex items-center justify-center gap-2 mb-1">
                <AlertCircle size={10} className="text-elfy-green" />
                <div className="text-[9px] text-white text-center font-bold tracking-widest">
                  UPGRADE AVAILABLE ({upgradePoints})
                </div>
            </div>
            
            <div className="grid grid-cols-2 gap-1">
              {availableOptions.map(u => (
                <button 
                  key={u}
                  className={`text-[8px] bg-elfy-purple/20 border border-elfy-purple/50 text-elfy-green font-mono py-1 transition-colors uppercase ${isPanelDead ? 'cursor-not-allowed text-gray-500' : 'hover:bg-elfy-purple hover:text-white'}`}
                  onMouseEnter={() => !isPanelDead && AudioSystem.playHover()}
                  onClick={() => handleUpgrade(u)}
                >
                  {u.replace('_', ' ')}
                </button>
              ))}
            </div>
          </div>
        )}
      </div>

      {/* 3. NAVIGATION */}
      <div className="w-full grid grid-cols-2 gap-3 mt-auto pt-2 border-t border-elfy-green-dim/10">
        <button 
          onClick={() => !isPanelDead && openModal('about')} 
          onMouseEnter={() => !isPanelDead && AudioSystem.playHover()}
          className="py-2 bg-elfy-purple-deep/20 border border-elfy-purple text-elfy-purple-light hover:bg-elfy-purple hover:text-black transition-all font-bold text-xs font-header uppercase clip-corner-btn"
        >
          About
        </button>
        <button 
          onClick={() => !isPanelDead && openModal('contact')} 
          onMouseEnter={() => !isPanelDead && AudioSystem.playHover()}
          className="py-2 bg-elfy-yellow/5 border border-elfy-yellow text-elfy-yellow hover:bg-elfy-yellow hover:text-black transition-all font-bold text-xs font-header uppercase clip-corner-btn"
        >
          Contact
        </button>
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/atoms/GlassPanel.tsx
=====================================
import { clsx } from 'clsx';
import { motion } from 'framer-motion';
import { ReactNode } from 'react';
import { usePanelRegistry } from '@/game/hooks/usePanelRegistry';
import { useGameStore } from '@/game/store/useGameStore';
import { ChevronUp, Skull } from 'lucide-react';

interface GlassPanelProps {
  children: ReactNode;
  className?: string;
  title?: string;
  gameId?: string; 
  suppressOfflineOverlay?: boolean;
}

const panelVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { 
    opacity: 1, 
    y: 0,
    transition: { duration: 0.5, ease: "easeOut" }
  },
  shattered: (custom: number) => ({
    y: 350 + (custom * 50),
    opacity: 0.8,
    rotate: custom * 15,
    transition: { 
        duration: 1.5, 
        ease: "anticipate",
        delay: Math.abs(custom) * 0.1 
    }
  })
};

const MAX_HEALTH = 1000;

// --- INFINITE SCROLL COMPONENTS ---

const ScrollingRow = ({ direction, text }: { direction: number, text: string }) => {
  return (
    // FIX: Increased opacity to 0.6 for better legibility
    <div className="flex whitespace-nowrap overflow-hidden select-none opacity-60">
      <motion.div 
        className="flex gap-4 font-header font-black text-xl md:text-2xl text-elfy-red tracking-widest uppercase py-1"
        animate={{ x: direction === 1 ? ["-50%", "0%"] : ["0%", "-50%"] }} 
        transition={{ duration: 40, repeat: Infinity, ease: "linear" }}
      >
        {Array.from({ length: 12 }).map((_, i) => (
          <span key={i} className={i % 2 === 0 ? "text-elfy-red" : "text-transparent stroke-elfy-red stroke-1"}>
             {text}
          </span>
        ))}
      </motion.div>
    </div>
  );
};

const BreachOverlay = ({ progress }: { progress: number }) => {
  return (
    <div className="absolute inset-0 z-[100] bg-black/95 flex flex-col items-center justify-center overflow-hidden">
        
        {/* BACKGROUND TAPE */}
        <div className="absolute inset-[-50%] flex flex-col justify-center rotate-[-12deg] opacity-30 pointer-events-none">
            <motion.div
               className="flex flex-col gap-8"
               animate={{ y: ["0%", "-50%"] }}
               transition={{ duration: 30, repeat: Infinity, ease: "linear" }}
            >
                {[0, 1].map((set) => (
                    <div key={set} className="flex flex-col gap-8">
                        {Array.from({ length: 6 }).map((_, i) => (
                            <ScrollingRow 
                                key={`${set}-${i}`} 
                                direction={i % 2 === 0 ? 1 : -1} 
                                text="SYSTEM BREACH // CRITICAL FAILURE // REBOOT REQUIRED //" 
                            />
                        ))}
                    </div>
                ))}
            </motion.div>
        </div>

        {/* INTERACTION UI: Bouncing Arrow */}
        {/* Uses group-hover from parent GlassPanel to trigger state changes immediately via CSS */}
        <div className="relative z-20 flex flex-col items-center justify-center gap-2 cursor-crosshair transition-all duration-100">
            
            {/* ARROW: Idle (Red Bounce) -> Hover (Purple Shake/Scale) */}
            <div className="relative">
                {/* IDLE STATE */}
                <div className="group-hover:opacity-0 transition-opacity duration-0 absolute inset-0 flex items-center justify-center">
                    <motion.div 
                        animate={{ y: [0, -10, 0] }}
                        transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }}
                        className="text-elfy-red"
                    >
                        <ChevronUp size={64} strokeWidth={3} />
                    </motion.div>
                </div>

                {/* HOVER STATE (Active Repair) */}
                <div className="opacity-0 group-hover:opacity-100 transition-opacity duration-0 flex items-center justify-center">
                    <motion.div 
                        animate={{ scale: [1, 1.2, 1], filter: ["brightness(1)", "brightness(1.5)", "brightness(1)"] }}
                        transition={{ duration: 0.2, repeat: Infinity, ease: "easeInOut" }}
                        className="text-elfy-purple drop-shadow-[0_0_15px_#9E4EA5]"
                    >
                        <ChevronUp size={64} strokeWidth={4} />
                    </motion.div>
                </div>
                
                {/* Spacer to keep layout stable since one arrow is absolute */}
                <div className="w-16 h-16 pointer-events-none opacity-0"><ChevronUp size={64} /></div>
            </div>

            <div className="flex flex-col items-center text-center">
                <span className="text-sm font-header font-black tracking-widest text-elfy-red group-hover:text-elfy-purple transition-colors duration-0">
                    HOLD TO REBOOT
                </span>
                
                {/* Progress Bar - Purple Fill */}
                <div className="w-32 bg-gray-900 h-1.5 mt-2 rounded-full overflow-hidden border border-gray-700">
                    <motion.div 
                        className="h-full bg-elfy-purple shadow-[0_0_10px_#9E4EA5]" 
                        initial={{ width: 0 }}
                        animate={{ width: `${progress}%` }}
                        transition={{ type: "tween", duration: 0.1 }}
                    />
                </div>
                
                <div className="text-[10px] font-mono text-elfy-purple font-bold mt-1 opacity-0 group-hover:opacity-100 transition-opacity">
                    INTEGRITY: {Math.floor(progress)}%
                </div>
            </div>
        </div>
    </div>
  );
};

export const GlassPanel = ({ children, className, title, gameId }: GlassPanelProps) => {
  const registryRef = gameId ? usePanelRegistry(gameId) : null;
  
  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const isGameOver = Math.floor(systemIntegrity) <= 0;

  const panelState = useGameStore((state) => 
    gameId ? state.panels[gameId] : null
  );

  const health = panelState ? panelState.health : MAX_HEALTH;
  const isDestroyed = panelState ? panelState.isDestroyed : false;
  const healthPercent = (health / MAX_HEALTH) * 100; 
  const isDamaged = health < MAX_HEALTH;
  const isCritical = !isDestroyed && health < (MAX_HEALTH * 0.3);

  let borderColor = "border-elfy-green-dim/30";
  if (isDestroyed) borderColor = "border-elfy-red animate-pulse"; 
  else if (isCritical) borderColor = "border-elfy-red/80 animate-pulse";
  else if (isDamaged) borderColor = "border-elfy-yellow/50";

  let barColor = "bg-elfy-green";
  if (isDestroyed) barColor = "bg-elfy-purple"; 
  else if (healthPercent < 30) barColor = "bg-elfy-red";
  else if (healthPercent < 60) barColor = "bg-elfy-yellow";

  const randSeed = (title?.length || 5) % 2 === 0 ? 1 : -1;
  const greenCircleClass = isDestroyed ? "border border-elfy-green" : "bg-elfy-green";
  const purpleCircleClass = isDestroyed ? "bg-elfy-purple" : "border border-elfy-purple-dim";

  return (
    <motion.div 
      ref={registryRef}
      variants={panelVariants}
      initial="hidden"
      animate={isGameOver ? "shattered" : "visible"}
      custom={randSeed}
      className={clsx(
        "relative overflow-hidden flex flex-col group", // Added group here
        "bg-black border",
        borderColor, 
        "shadow-[0_0_15px_rgba(11,212,38,0.05)]", 
        "rounded-sm",
        className
      )}
    >
      <div className="absolute inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(10,10,10,0.4)_50%)] z-0 bg-[length:100%_4px]" />
      
      {title && (
        <div className="relative flex flex-col border-b border-elfy-green-dim/30 bg-elfy-green-dark/20 shrink-0 z-10">
          <div className="flex items-center justify-between px-3 py-1">
            <span className="text-sm md:text-base font-header font-bold text-elfy-green uppercase tracking-wider drop-shadow-md">
              {title}
            </span>
            <div className="flex gap-1">
              <div className={`w-2 h-2 rounded-full ${greenCircleClass}`} />
              <div className={`w-2 h-2 rounded-full ${purpleCircleClass}`} />
            </div>
          </div>

          {gameId && (
            <div className="w-full h-1 bg-black/50">
              <motion.div 
                className={clsx("h-full transition-colors duration-200", barColor)}
                initial={{ width: "100%" }}
                animate={{ width: `${healthPercent}%` }}
                transition={{ type: "tween", ease: "easeOut", duration: 0.1 }}
              />
            </div>
          )}
        </div>
      )}

      <div className="relative z-10 p-4 h-full">
        {isDestroyed && !isGameOver && (
            <BreachOverlay progress={healthPercent} />
        )}
        
        {isGameOver && (
            <div className="absolute inset-0 z-[100] bg-black/90 flex flex-col items-center justify-center gap-4">
                <Skull className="text-elfy-red animate-pulse w-20 h-20" />
                <span className="text-elfy-red font-header font-black text-2xl tracking-widest">SYSTEM FAILURE</span>
            </div>
        )}
        
        {children}
      </div>
    </motion.div>
  );
};


=====================================
FILE: ./src/ui/overlays/ModalContainer.tsx
=====================================
import { useStore } from '@/core/store/useStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { motion, AnimatePresence } from 'framer-motion';
import { X } from 'lucide-react';

interface ModalContainerProps {
  children: React.ReactNode;
  title: string;
  type: string;
}

export const ModalContainer = ({ children, title, type }: ModalContainerProps) => {
  const { activeModal, closeModal } = useStore();
  const isOpen = activeModal === type;

  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 md:p-10">
          
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={closeModal}
            className="absolute inset-0 bg-black/80 backdrop-blur-sm cursor-pointer"
          />

          <motion.div
            initial={{ scale: 0.9, opacity: 0, y: 20 }}
            animate={{ scale: 1, opacity: 1, y: 0 }}
            exit={{ scale: 0.95, opacity: 0, y: 10 }}
            transition={{ type: "spring", bounce: 0, duration: 0.3 }}
            className="relative w-full max-w-5xl h-full max-h-[90vh] bg-black border border-elfy-green/50 shadow-[0_0_50px_rgba(0,255,65,0.1)] flex flex-col overflow-hidden"
          >
            <div className="flex items-center justify-between px-4 py-3 bg-elfy-green/10 border-b border-elfy-green/30">
              <div className="flex items-center gap-2">
                <div className="w-3 h-3 bg-elfy-red rounded-full animate-pulse" />
                <span className="font-header font-black text-elfy-green text-lg md:text-xl tracking-widest">
                  {title}
                </span>
              </div>
              <button 
                onClick={closeModal}
                onMouseEnter={() => AudioSystem.playHover()} // ADDED SFX
                className="p-1 hover:bg-elfy-red hover:text-black text-elfy-green transition-colors"
              >
                <X />
              </button>
            </div>

            <div className="flex-1 overflow-auto p-6 relative scrollbar-thin scrollbar-thumb-elfy-green scrollbar-track-black">
              <div className="absolute inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.1)_50%)] bg-[length:100%_4px] opacity-20" />
              <div className="relative z-10">
                {children}
              </div>
            </div>

            <div className="px-4 py-1 bg-black border-t border-elfy-green/30 text-xs text-elfy-green-dim font-mono text-right">
              MODE: SECURE // ENCRYPTION: ENABLED
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/organisms/Footer.tsx
=====================================
export const Footer = () => {
  const commitHash = process.env.NEXT_PUBLIC_COMMIT_HASH || 'UNKNOWN';
  const actionsUrl = "https://github.com/mesoelfy/mesoelfy.github.io/actions";

  return (
    <footer className="w-full h-10 border-t border-elfy-green-dim/30 bg-black flex items-center justify-between px-4 z-40 shrink-0 text-[10px] text-elfy-green-dim font-mono">
      <div className="flex items-center gap-2">
        {/* Static Label */}
        <span>BUILD_VER:</span>
        
        {/* Interactive Link */}
        <a 
          href={actionsUrl}
          target="_blank" 
          rel="noopener noreferrer"
          className="text-elfy-green-dim hover:text-elfy-green transition-colors cursor-pointer group"
        >
          [
          {/* Underline only applies to the internal span on hover */}
          <span className="group-hover:underline decoration-dashed decoration-elfy-green underline-offset-2">
            {commitHash}
          </span>
          ]
        </a>
        
        <span>//</span>
        
        <span className="text-elfy-red font-bold animate-pulse">STATUS: UNSAFE // MONITORING</span>
      </div>

      <div className="flex items-center gap-2">
        <span>LATENT_CORE:</span>
        <div className="w-4 h-4 flex items-center justify-center">
          {/* Yellow border/bg, Green Shadow, Custom Diamond Spin */}
          <div className="w-2.5 h-2.5 border border-elfy-yellow bg-elfy-yellow/20 animate-spin-diamond shadow-[0_0_8px_#78F654]" />
        </div>
      </div>
    </footer>
  );
};


=====================================
FILE: ./src/ui/organisms/Header.tsx
=====================================
import { Volume2, VolumeX, Radio } from 'lucide-react';
import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { useEffect, useState } from 'react';

export const Header = () => {
  const { musicEnabled, toggleMusic } = useStore();
  
  // Global System Integrity (The Footer Bar replacement)
  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const score = useGameStore(state => state.score);

  // Client-side init
  const [mounted, setMounted] = useState(false);
  useEffect(() => setMounted(true), []);

  const handleToggle = () => {
      AudioSystem.playClick();
      toggleMusic();
      AudioSystem.setMute(!musicEnabled ? false : true); 
  };

  // Integrity Bar Logic
  let integrityColor = "bg-elfy-green";
  if (systemIntegrity < 40) integrityColor = "bg-elfy-red";
  else if (systemIntegrity < 70) integrityColor = "bg-elfy-yellow";

  return (
    <header className="relative w-full h-12 bg-black/90 backdrop-blur-md flex items-center justify-between px-4 z-40 shrink-0">
      
      {/* LEFT: Identity */}
      <div className="flex items-center gap-4">
        <span className="font-header font-black text-elfy-green text-xl md:text-2xl tracking-wide drop-shadow-[0_0_5px_rgba(120,246,84,0.5)]">
          MESOELFY_OS
        </span>
        
        {mounted && (
          <div className="hidden md:flex items-center gap-2 text-xs font-mono text-elfy-green-dim border-l border-elfy-green-dim/20 pl-4">
            <span>SCORE:</span>
            <span className="text-elfy-green">{score.toString().padStart(6, '0')}</span>
          </div>
        )}
      </div>

      {/* RIGHT: Status */}
      <div className="flex items-center gap-6">
        <button 
          onClick={handleToggle}
          onMouseEnter={() => AudioSystem.playHover()}
          className="flex items-center gap-2 text-xs font-mono text-elfy-green-dim hover:text-elfy-green transition-colors pl-4 border-l border-elfy-green-dim/20"
        >
          {musicEnabled ? <Volume2 size={14} /> : <VolumeX size={14} />}
        </button>
      </div>

      {/* BOTTOM BORDER: OS INTEGRITY BAR */}
      <div className="absolute bottom-0 left-0 right-0 h-[2px] bg-gray-900">
        <div 
          className={`h-full transition-all duration-500 ease-out ${integrityColor} shadow-[0_0_10px_currentColor]`} 
          style={{ width: `${systemIntegrity}%` }}
        />
      </div>
      
      {/* Integrity Label (Floating) */}
      <div className="absolute bottom-[-14px] right-2 text-[8px] font-mono text-elfy-green-dim flex items-center gap-1">
        <Radio size={8} className={systemIntegrity < 100 ? "animate-pulse text-elfy-red" : ""} />
        <span>OS_INTEGRITY: {Math.floor(systemIntegrity)}%</span>
      </div>

    </header>
  );
};


=====================================
FILE: ./src/core/audio/AudioSystem.ts
=====================================
import { useStore } from '@/core/store/useStore';

class AudioSystemController {
  private ctx: AudioContext | null = null;
  private masterGain: GainNode | null = null;
  private isInitialized = false;

  constructor() {
    // Singleton pattern could go here, but we'll manage instance via export
  }

  // 1. WAKE UP THE ENGINE (Must be called on user click)
  public async init() {
    if (this.isInitialized) return;

    const AudioContextClass = (window as any).AudioContext || (window as any).webkitAudioContext;
    this.ctx = new AudioContextClass();
    
    // Master Volume
    this.masterGain = this.ctx!.createGain();
    this.masterGain.gain.value = 0.4; // Default volume
    this.masterGain.connect(this.ctx!.destination);

    this.isInitialized = true;
    
    // Resume context if suspended (browser policy)
    if (this.ctx?.state === 'suspended') {
      await this.ctx.resume();
    }
  }

  // 2. THE BOOT SOUND (THX Style Deep Drone)
  public playBootSequence() {
    if (!this.ctx || !this.masterGain) return;

    const t = this.ctx.currentTime;
    
    // OSC 1: Deep Bass (Sawtooth)
    const osc1 = this.ctx.createOscillator();
    const gain1 = this.ctx.createGain();
    osc1.type = 'sawtooth';
    osc1.frequency.setValueAtTime(55, t); // A1
    osc1.detune.setValueAtTime(-10, t); // Slight detune for thickness
    
    // Filter Sweep (Lowpass) - The "Opening" effect
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(0, t);
    filter.frequency.exponentialRampToValueAtTime(5000, t + 2.5); // Sweep up

    // Wiring 1
    osc1.connect(filter);
    filter.connect(gain1);
    gain1.connect(this.masterGain);

    // Envelope 1
    gain1.gain.setValueAtTime(0, t);
    gain1.gain.linearRampToValueAtTime(0.8, t + 0.1);
    gain1.gain.exponentialRampToValueAtTime(0.001, t + 4);

    // OSC 2: Mid Harmony (Square)
    const osc2 = this.ctx.createOscillator();
    const gain2 = this.ctx.createGain();
    osc2.type = 'square';
    osc2.frequency.setValueAtTime(110, t); // A2
    osc2.detune.setValueAtTime(10, t);

    // Wiring 2
    osc2.connect(filter); // Share filter
    filter.connect(gain2);
    gain2.connect(this.masterGain);

    // Envelope 2
    gain2.gain.setValueAtTime(0, t);
    gain2.gain.linearRampToValueAtTime(0.4, t + 0.5); // Enters slightly later
    gain2.gain.exponentialRampToValueAtTime(0.001, t + 4);

    // GLITCH NOISE (Digital burst)
    const bufferSize = this.ctx.sampleRate * 0.5; // 0.5 seconds
    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      data[i] = Math.random() * 2 - 1; // White noise
    }
    const noise = this.ctx.createBufferSource();
    noise.buffer = buffer;
    const noiseGain = this.ctx.createGain();
    noiseGain.gain.setValueAtTime(0.1, t);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
    
    noise.connect(noiseGain);
    noiseGain.connect(this.masterGain);

    // Start
    osc1.start(t);
    osc2.start(t);
    noise.start(t);
    
    // Stop
    osc1.stop(t + 4.5);
    osc2.stop(t + 4.5);
  }

  // 3. HOVER SOUND (High-Tech Blip)
  public playHover() {
    if (!this.ctx || !this.masterGain || useStore.getState().musicEnabled === false) return;

    const t = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();

    osc.type = 'sine';
    // Randomize pitch slightly for organic feel
    osc.frequency.setValueAtTime(800 + Math.random() * 200, t); 
    
    gain.gain.setValueAtTime(0.05, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);

    osc.connect(gain);
    gain.connect(this.masterGain);

    osc.start(t);
    osc.stop(t + 0.1);
  }

  // 4. CLICK SOUND (Mechanical Thud)
  public playClick() {
    if (!this.ctx || !this.masterGain || useStore.getState().musicEnabled === false) return;

    const t = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();

    osc.type = 'triangle';
    osc.frequency.setValueAtTime(150, t);
    osc.frequency.exponentialRampToValueAtTime(40, t + 0.1); // Pitch drop

    gain.gain.setValueAtTime(0.15, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);

    osc.connect(gain);
    gain.connect(this.masterGain);

    osc.start(t);
    osc.stop(t + 0.2);
  }
  
  // 5. TOGGLE MUTE
  public setMute(muted: boolean) {
      if (this.masterGain) {
          // If "muted" (musicEnabled = false), volume 0
          // If "unmuted" (musicEnabled = true), volume 0.4
          this.masterGain.gain.setTargetAtTime(muted ? 0 : 0.4, this.ctx!.currentTime, 0.1);
      }
  }
}

export const AudioSystem = new AudioSystemController();


=====================================
FILE: ./src/core/store/useStore.ts
=====================================
import { create } from 'zustand';
import { AudioSystem } from '@/core/audio/AudioSystem';

type ModalType = 'none' | 'about' | 'gallery' | 'feed' | 'contact';

interface AppState {
  introDone: boolean;
  activeModal: ModalType;
  hoveredItem: string | null;
  musicEnabled: boolean; // Acts as Master Audio Switch
  volume: number;
  setIntroDone: (done: boolean) => void;
  openModal: (modal: ModalType) => void;
  closeModal: () => void;
  setHovered: (item: string | null) => void;
  toggleMusic: () => void;
}

export const useStore = create<AppState>((set, get) => ({
  introDone: false,
  activeModal: 'none',
  hoveredItem: null,
  musicEnabled: true, // Default to true, but engine starts suspended
  volume: 0.5,

  setIntroDone: (done) => set({ introDone: done }),
  openModal: (modal) => {
      AudioSystem.playClick(); // Click sound on modal open
      set({ activeModal: modal });
  },
  closeModal: () => {
      AudioSystem.playClick(); // Click sound on modal close
      set({ activeModal: 'none' });
  },
  setHovered: (item) => set({ hoveredItem: item }),
  
  toggleMusic: () => {
      const newState = !get().musicEnabled;
      set({ musicEnabled: newState });
      // In web audio, we don't necessarily "mute" the context, 
      // we just stop triggering playHover/playClick, 
      // but we can also ramp master gain to 0 if we want to kill background music later.
  },
}));


=====================================
FILE: ./src/app/layout.tsx
=====================================
import type { Metadata, Viewport } from 'next';
import { Montserrat, JetBrains_Mono } from 'next/font/google';
import '@/styles/globals.css';

const montserrat = Montserrat({ 
  subsets: ['latin'],
  weight: ['400', '700', '900'], 
  variable: '--font-montserrat',
  display: 'swap',
});

const jetbrains = JetBrains_Mono({
  subsets: ['latin'],
  weight: ['400', '700'],
  variable: '--font-jetbrains',
  display: 'swap',
});

export const metadata: Metadata = {
  title: 'MESOELFY // LATENT SPACE BANDIT',
  description: 'The official digital HQ of Mesoelfy. Art, Lore, and Neural Network Injections.',
  icons: {
    icon: '/favicon.ico',
  },
  openGraph: {
    title: 'MESOELFY_OS',
    description: 'Access the terminal. View the art. Breach the firewall.',
    url: 'https://mesoelfy.github.io',
    siteName: 'MESOELFY',
    images: [
      {
        url: 'https://mesoelfy.github.io/assets/images/social-card.jpg',
        width: 1200,
        height: 630,
      },
    ],
    locale: 'en_US',
    type: 'website',
  },
  twitter: {
    card: 'summary_large_image',
    title: 'MESOELFY // LATENT SPACE BANDIT',
    description: 'Access the terminal. View the art. Breach the firewall.',
    images: ['https://mesoelfy.github.io/assets/images/social-card.jpg'],
  },
};

export const viewport: Viewport = {
  themeColor: '#000000',
  colorScheme: 'dark',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" className={`${montserrat.variable} ${jetbrains.variable}`}>
      <body 
        className="bg-black text-elfy-green selection:bg-elfy-green selection:text-black font-mono"
        style={{ backgroundColor: '#000000' }} // Hardcode black to prevent FOUC
      >
        <div className="relative w-full h-full">
          {children}
        </div>
      </body>
    </html>
  );
}


=====================================
FILE: ./src/app/page.tsx
=====================================
'use client';

import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { SceneCanvas } from '@/scene/canvas/SceneCanvas';
import { GlassPanel } from '@/ui/atoms/GlassPanel';
import { SocialRow } from '@/ui/molecules/SocialRow';
import { LiveArtGrid } from '@/ui/molecules/LiveArtGrid';
import { HoloCommLog } from '@/ui/molecules/HoloCommLog';
import { IdentityHUD } from '@/ui/molecules/IdentityHUD';
import { Header } from '@/ui/organisms/Header';
import { Footer } from '@/ui/organisms/Footer';
import { AboutModal } from '@/features/identity/AboutModal';
import { FeedModal } from '@/features/feed/FeedModal';
import { GalleryModal } from '@/features/gallery/GalleryModal';
import { ContactModal } from '@/features/contact/ContactModal';
import { MatrixBootSequence } from '@/features/intro/MatrixBootSequence';
import { GameOverlay } from '@/game/GameOverlay';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { GlobalShakeManager } from '@/features/effects/GlobalShakeManager';

export default function Home() {
  const { openModal } = useStore();
  const startGame = useGameStore(s => s.startGame);
  const recalcIntegrity = useGameStore(s => s.recalculateIntegrity);
  
  const [bootState, setBootState] = useState<'standby' | 'active'>('standby');

  const handleBootComplete = () => {
    setTimeout(() => {
      setBootState('active');
      startGame();
    }, 200);
  };

  useEffect(() => {
    if (bootState !== 'active') return;
    const interval = setInterval(recalcIntegrity, 500);
    return () => clearInterval(interval);
  }, [bootState, recalcIntegrity]);

  const playHover = () => AudioSystem.playHover();

  return (
    <div id="global-app-root" className="relative w-full h-screen overflow-hidden">
      
      <GlobalShakeManager />

      <main className="relative w-full h-full flex flex-col overflow-hidden text-elfy-green selection:bg-elfy-green selection:text-black font-mono">
        
        <SceneCanvas className="opacity-100 blur-0" />

        {bootState === 'active' && <GameOverlay />}

        <AboutModal />
        <FeedModal />
        <GalleryModal />
        <ContactModal />

        {bootState === 'standby' && (
          <MatrixBootSequence onComplete={handleBootComplete} />
        )}

        <div className={`relative z-10 flex-1 flex flex-col h-full transition-all duration-1000 ease-in-out ${bootState === 'active' ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-4'}`}>
          
          <Header />

          <motion.div 
            className="flex-1 p-4 md:p-6 grid grid-cols-1 md:grid-cols-12 gap-4 md:gap-6 overflow-y-auto md:overflow-hidden max-w-[1600px] mx-auto w-full scrollbar-thin scrollbar-thumb-elfy-green scrollbar-track-black"
            initial="hidden"
            animate={bootState === 'active' ? "visible" : "hidden"}
            variants={{
              hidden: { opacity: 0 },
              visible: { 
                opacity: 1, 
                transition: { 
                  staggerChildren: 0.3,
                  delayChildren: 0.2 
                } 
              }
            }}
          >
            <div className="md:col-span-4 flex flex-col gap-4 md:gap-6 h-auto">
              
              <GlassPanel title="IDENTITY_CORE" className="flex-1 min-h-0" gameId="identity">
                <IdentityHUD />
              </GlassPanel>

              <GlassPanel title="SOCIAL_UPLINK" className="h-auto shrink-0" gameId="social">
                 <SocialRow />
              </GlassPanel>
            </div>

            <div className="md:col-span-8 flex flex-col gap-4 md:gap-6 h-auto">
              <GlassPanel title="LATEST_LOGS" className="h-48 md:h-64 shrink-0" gameId="feed">
                <div className="flex flex-col items-center justify-center h-full text-elfy-green-dim font-mono text-sm border border-dashed border-elfy-green-dim/30 m-2 bg-black/20">
                  <p className="animate-pulse mb-4">&gt; ESTABLISHING UPLINK...</p>
                  <button 
                    onClick={() => openModal('feed')} 
                    onMouseEnter={playHover}
                    className="px-6 py-2 border border-elfy-green text-elfy-green hover:bg-elfy-green hover:text-black transition-colors uppercase tracking-wider font-header font-black text-base md:text-lg"
                  >
                    [ ACCESS TERMINAL ]
                  </button>
                </div>
              </GlassPanel>

              <div className="flex flex-col md:flex-row gap-4 md:gap-6 items-start h-auto">
                <GlassPanel title="ART_DB" className="flex-1 h-auto" gameId="art">
                   <LiveArtGrid />
                </GlassPanel>

                <GlassPanel title="HOLO_COMM" className="w-full md:w-[45%] shrink-0 h-auto" gameId="video">
                   <HoloCommLog />
                </GlassPanel>
              </div>
            </div>
          </motion.div>
          
          <Footer />
        </div>
      </main>
    </div>
  );
}


=====================================
FILE: ./src/features/contact/ContactModal.tsx
=====================================
import { ModalContainer } from '@/ui/overlays/ModalContainer';
import { Send } from 'lucide-react';

export const ContactModal = () => {
  return (
    <ModalContainer title="ENCRYPTED_UPLINK // CONTACT" type="contact">
      <div className="max-w-2xl mx-auto h-full flex flex-col justify-center">
        
        {/* Added Triangles and Font-Header for the Warning */}
        <div className="p-2 border border-elfy-yellow/30 bg-elfy-yellow/5 mb-6 text-center flex items-center justify-center gap-3">
          <span className="text-elfy-yellow animate-pulse">âš </span>
          <p className="text-xs text-elfy-yellow font-header font-bold tracking-wider">
            WARNING: TRANSMISSIONS ARE MONITORED BY THE AI OVERLORD.
          </p>
          <span className="text-elfy-yellow animate-pulse">âš </span>
        </div>

        <form 
          action="https://formspree.io/f/xkgdbkpz" 
          method="POST"
          className="space-y-6"
        >
          <div className="space-y-1">
            <label className="text-sm text-elfy-green-dim uppercase tracking-wider font-header font-bold">Codename</label>
            <input 
              type="text" 
              name="name"
              required
              placeholder="Enter your handle..."
              className="w-full bg-black border border-elfy-green-dim/50 p-3 text-elfy-green font-mono focus:border-elfy-green focus:outline-none focus:shadow-[0_0_10px_rgba(120,246,84,0.2)] transition-all"
            />
          </div>

          <div className="space-y-1">
            <label className="text-sm text-elfy-green-dim uppercase tracking-wider font-header font-bold">Frequency (Email)</label>
            <input 
              type="email" 
              name="email"
              required
              placeholder="Enter return frequency..."
              className="w-full bg-black border border-elfy-green-dim/50 p-3 text-elfy-green font-mono focus:border-elfy-green focus:outline-none focus:shadow-[0_0_10px_rgba(120,246,84,0.2)] transition-all"
            />
          </div>

          <div className="space-y-1">
            <label className="text-sm text-elfy-green-dim uppercase tracking-wider font-header font-bold">Payload</label>
            <textarea 
              name="message"
              required
              rows={5}
              placeholder="Type your message..."
              className="w-full bg-black border border-elfy-green-dim/50 p-3 text-elfy-green font-mono focus:border-elfy-green focus:outline-none focus:shadow-[0_0_10px_rgba(120,246,84,0.2)] transition-all resize-none"
            />
          </div>

          <button 
            type="submit"
            className="w-full py-4 bg-elfy-green text-black font-header font-black uppercase tracking-widest hover:bg-white transition-colors flex items-center justify-center gap-2 group"
          >
            <span>Send Transmission</span>
            <Send size={16} className="group-hover:translate-x-1 transition-transform" />
          </button>
        </form>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/features/identity/AboutModal.tsx
=====================================
import { ModalContainer } from '@/ui/overlays/ModalContainer';
import identity from '@/data/identity.json';

export const AboutModal = () => {
  return (
    <ModalContainer title="IDENTITY_DATABASE // ELFY" type="about">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-8 h-full">
        
        {/* LEFT: The Avatar Grid */}
        <div className="space-y-4">
          <div className="aspect-square w-full border border-elfy-purple-light/50 bg-elfy-purple-deep/30 relative overflow-hidden group shadow-[0_0_20px_rgba(188,134,186,0.2)]">
            <div className="absolute inset-0 flex items-center justify-center text-elfy-purple-light/50 font-bold text-2xl group-hover:text-elfy-purple-light transition-colors font-header font-black tracking-widest text-center p-4">
              [ COMPOSITE_IMAGE LOADING ]
            </div>
            <div className="absolute top-0 left-0 w-4 h-4 border-t-2 border-l-2 border-elfy-purple-light" />
            <div className="absolute bottom-0 right-0 w-4 h-4 border-b-2 border-r-2 border-elfy-purple-light" />
          </div>
          
          <div className="grid grid-cols-4 gap-2">
            {[1,2,3,4].map(i => (
              <div key={i} className="aspect-square border border-elfy-purple-dim/30 hover:bg-elfy-purple-light/20 hover:border-elfy-purple-light cursor-pointer transition-colors" />
            ))}
          </div>
        </div>

        {/* RIGHT: The Data */}
        <div className="space-y-6">
          <div>
            {/* Header: Montserrat */}
            <h2 className="text-4xl font-header font-black text-elfy-green mb-2 tracking-wide">HI, I'M ELFY.</h2>
            <div className="h-1 w-20 bg-elfy-purple-light mb-4" />
            
            {/* Body: Courier (font-mono) for ease of reading/typewriter feel */}
            <p className="text-lg text-white/90 leading-relaxed font-mono">
              {identity.bio}
            </p>
          </div>

          <div className="space-y-2">
            <h3 className="text-elfy-purple-light font-header font-bold uppercase tracking-wider text-sm">Capabilities</h3>
            <ul className="space-y-1">
              {identity.abilities.map((ability, i) => (
                 <li key={i} className="flex items-center gap-2 text-elfy-green font-mono">
                   <span className="text-elfy-purple-light">&gt;</span> {ability}
                 </li>
              ))}
            </ul>
          </div>

          <div className="p-4 border border-elfy-purple-dim/30 bg-elfy-purple-deep/20 text-sm text-elfy-purple-light font-mono">
            <p>&gt; SYSTEM NOTE: Generated via Latent Space Injection.</p>
            <p>&gt; STATUS: 100% Hype.</p>
          </div>
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/features/intro/MatrixBootSequence.tsx
=====================================
import { useEffect, useRef, useState, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { AudioSystem } from '@/core/audio/AudioSystem';

interface Props {
  onComplete: () => void;
}

const ASCII_TITLE = `
 â–ˆâ–ˆâ–ˆâ–„ â–„â–ˆâ–ˆâ–ˆâ–“â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–“      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–“â–ˆâ–ˆ   â–ˆâ–ˆâ–“
â–“â–ˆâ–ˆâ–’â–€â–ˆâ–€ â–ˆâ–ˆâ–’â–“â–ˆ   â–€â–’â–ˆâ–ˆ    â–’ â–’â–ˆâ–ˆâ–’  â–ˆâ–ˆâ–’â–“â–ˆ   â–€ â–“â–ˆâ–ˆâ–’    â–’â–“â–ˆ   â–’  â–’â–ˆâ–ˆ  â–ˆâ–ˆâ–’
â–“â–ˆâ–ˆ    â–“â–ˆâ–ˆâ–‘â–’â–ˆâ–ˆâ–ˆ  â–‘ â–“â–ˆâ–ˆâ–„   â–’â–ˆâ–ˆâ–‘  â–ˆâ–ˆâ–’â–’â–ˆâ–ˆâ–ˆ   â–’â–ˆâ–ˆâ–‘    â–’â–“â–ˆâ–ˆâ–ˆ â–‘   â–’â–ˆâ–ˆ â–ˆâ–ˆâ–‘
â–’â–ˆâ–ˆ    â–’â–ˆâ–ˆ â–’â–“â–ˆ  â–„  â–’   â–ˆâ–ˆâ–’â–’â–ˆâ–ˆ   â–ˆâ–ˆâ–‘â–’â–“â–ˆ  â–„ â–’â–ˆâ–ˆâ–‘    â–‘â–“â–ˆâ–’  â–‘   â–‘ â–â–ˆâ–ˆâ–‘â–‘
â–’â–ˆâ–ˆâ–’   â–‘â–ˆâ–ˆâ–’â–‘â–’â–ˆâ–ˆâ–ˆâ–ˆâ–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–‘ â–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–ˆâ–ˆâ–ˆâ–ˆâ–’â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–‘â–’â–ˆâ–‘      â–‘ â–ˆâ–ˆâ–’â–‘â–‘
â–‘ â–’â–‘   â–‘  â–‘â–‘â–‘ â–’â–‘ â–‘ â–’â–‘â–’  â–‘ â–‘ â–’â–‘â–’â–‘â–’â–‘ â–‘â–‘ â–’â–‘ â–‘â–‘ â–’â–‘â–’  â–‘ â–’ â–‘       â–ˆâ–ˆâ–’â–’â–’
â–‘  â–‘      â–‘ â–‘ â–‘  â–‘ â–‘ â–’  â–‘   â–‘ â–’ â–’â–‘  â–‘ â–‘  â–‘â–‘ â–‘ â–’  â–‘ â–‘       â–“â–ˆâ–ˆ â–‘â–’â–‘ 
â–‘      â–‘      â–‘    â–‘ â–‘    â–‘ â–‘ â–‘ â–’     â–‘     â–‘ â–‘    â–‘ â–‘     â–’ â–’ â–‘â–‘  
       â–‘      â–‘  â–‘   â–‘  â–‘     â–‘ â–‘     â–‘  â–‘    â–‘  â–‘         â–‘ â–‘     
                                                                 
`;

// --- ASCII COMPONENT ---
const AsciiRenderer = () => {
  const renderedChars = useMemo(() => {
    return ASCII_TITLE.split('').map((char, i) => {
      if (char === '\n') return <br key={i} />;
      if (char === ' ') return <span key={i}> </span>;

      let animClass = '';
      
      if (['â–ˆ', 'â–€', 'â–„', 'â–Œ', 'â–'].includes(char)) {
        animClass = 'animate-matrix-green text-elfy-green-dark';
      } 
      else if (['â–‘', 'â–’', 'â–“'].includes(char)) {
        animClass = 'animate-matrix-purple text-elfy-purple';
      } 
      else {
        animClass = 'text-elfy-green-dark';
      }

      const delay = Math.random() * 2 + 's';

      return (
        <span 
          key={i} 
          className={animClass} 
          style={{ animationDelay: delay }}
        >
          {char}
        </span>
      );
    });
  }, []);

  return (
    <div className="font-mono font-bold leading-[1.1] whitespace-pre text-center select-none overflow-hidden text-[9px] md:text-[11px] shrink-0">
      {renderedChars}
    </div>
  );
};

const BootHeader = () => (
  <div className="flex shrink-0 items-center justify-between border-b border-elfy-green-dim/30 bg-elfy-green/5 px-3 py-1 mb-2 select-none relative z-20">
    <span className="text-xs text-elfy-green-dim font-mono tracking-widest uppercase">BOOT_LOADER.SYS</span>
    <div className="flex gap-1 items-center">
      {[1, 2, 3].map(i => (
        <div key={i} className="w-1 bg-elfy-green/50 animate-pulse" style={{ height: `${i * 4 + 4}px`, animationDelay: `${i * 0.1}s` }} />
      ))}
    </div>
  </div>
);

const CoreHeader = () => (
  <div className="flex shrink-0 items-center justify-between border-b border-elfy-green/30 bg-elfy-green/10 px-3 py-1 mb-2 select-none">
    <span className="text-sm text-elfy-green font-mono font-bold tracking-widest uppercase">MESOELFY_CORE</span>
    <div className="relative w-3 h-3 flex items-center justify-center">
      <div className="absolute inset-0 border border-elfy-green rounded-full animate-spin-slow border-t-transparent" />
      <div className="w-1 h-1 bg-elfy-green rounded-full animate-pulse" />
    </div>
  </div>
);

const LoadingDots = ({ isFrozen }: { isFrozen: boolean }) => {
  const [dots, setDots] = useState("");
  useEffect(() => {
    if (isFrozen) {
      setDots("..."); 
      return;
    }
    const interval = setInterval(() => {
      setDots(d => d.length >= 3 ? "" : d + ".");
    }, 300);
    return () => clearInterval(interval);
  }, [isFrozen]);
  return <span>{dots}</span>;
}

const TypedLog = ({ 
  text, color, speed = 20, showDots = false, isActive = false, isPast = false 
}: { 
  text: string, color: string, speed?: number, showDots?: boolean, isActive: boolean, isPast: boolean
}) => {
  const [displayed, setDisplayed] = useState("");
  const [isDoneTyping, setIsDoneTyping] = useState(false);
  
  useEffect(() => {
    let i = 0;
    setDisplayed("");
    setIsDoneTyping(false);
    const interval = setInterval(() => {
      setDisplayed(text.substring(0, i + 1));
      i++;
      if (i >= text.length) {
        setIsDoneTyping(true);
        clearInterval(interval);
      }
    }, speed);
    return () => clearInterval(interval);
  }, [text, speed]);

  if (isPast && displayed !== text) {
    setDisplayed(text);
    setIsDoneTyping(true);
  }

  return (
    <div className={`whitespace-nowrap font-mono ${color} flex items-center shrink-0`}>
      <span>{displayed}</span>
      {isDoneTyping && showDots && <LoadingDots isFrozen={isPast} />}
      {isActive && <span className="ml-1 animate-cursor-blink text-elfy-green font-bold">_</span>}
    </div>
  );
};

const LOG_DATA = [
  { text: "> INITIALIZE NEURAL_LACE", color: "text-elfy-green-dim", speed: 40, hasDots: true },
  { text: "> CONNECTED TO LATENT_SPACE.", color: "text-elfy-green", speed: 20, hasDots: false },
  { text: "> MOUNT MESOELFY_CORE", color: "text-elfy-green-dim", speed: 40, hasDots: true },
  { text: "> âš  UNSAFE CONNECTION DETECTED âš ", color: "text-elfy-red", speed: 20, hasDots: false },
  { text: "> BYPASSING SENTINEL_NODES", color: "text-elfy-purple-light", speed: 40, hasDots: true },
  { text: "> DECRYPTED.", color: "text-elfy-green", speed: 20, hasDots: false },
  { text: "> âš  PROCEED WITH CAUTION âš ", color: "text-elfy-yellow", speed: 20, hasDots: false },
];

export const MatrixBootSequence = ({ onComplete }: Props) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [step, setStep] = useState(0); 
  const [isBreaching, setIsBreaching] = useState(false);
  const logsToShow = LOG_DATA.slice(0, step + 1);
  
  const showMatrix = step >= 1;       
  const showPayloadWindow = step >= 2; 
  const showWarningBox = step >= 3;    
  const showButton = step >= 6;        

  useEffect(() => {
    const sequence = [
      { t: 3000, step: 1 }, 
      { t: 4000, step: 2 }, 
      { t: 8000, step: 3 }, 
      { t: 9500, step: 4 }, 
      { t: 12500, step: 5 }, 
      { t: 13500, step: 6 }, 
    ];
    const timeouts = sequence.map(({ t, step: s }) => setTimeout(() => {
      if (!isBreaching) setStep(s);
    }, t));
    return () => timeouts.forEach(clearTimeout);
  }, [isBreaching]);

  useEffect(() => {
    if (!showMatrix && !isBreaching) return;
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const cols = Math.floor(canvas.width / 20);
    const ypos = Array(cols).fill(0).map(() => Math.random() * -1000);

    const matrixEffect = () => {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; 
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#0F0';
      ctx.font = '14px "Courier New"';
      ypos.forEach((y, ind) => {
        const charSet = Math.random() > 0.5 ? 0x16A0 : 0x2200; 
        const text = String.fromCharCode(charSet + Math.random() * 64);
        const x = ind * 20;
        ctx.fillText(text, x, y);
        const speed = isBreaching ? 100 : 20; 
        if (y > canvas.height + Math.random() * 10000) ypos[ind] = 0;
        else ypos[ind] = y + speed;
      });
    };
    const interval = setInterval(matrixEffect, 50);
    return () => clearInterval(interval);
  }, [showMatrix, isBreaching]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && !isBreaching) handleInitialize();
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isBreaching]);

  // AUDIO TRIGGER HERE
  const handleInitialize = async () => {
    // 1. Init Audio
    await AudioSystem.init();
    // 2. Play Boot Sound
    AudioSystem.playBootSequence();
    
    setIsBreaching(true);
    setStep(6);
    setTimeout(onComplete, 800); 
  };

  return (
    <motion.div 
      animate={{ backgroundColor: isBreaching ? "rgba(0,0,0,0)" : "rgba(0,0,0,1)" }}
      transition={{ duration: 0.5, ease: "easeInOut" }}
      className="fixed inset-0 z-[100] flex flex-col items-center justify-start pt-[20vh] md:pt-[25vh] font-mono overflow-hidden"
    >
      <canvas ref={canvasRef} className={`absolute inset-0 z-0 transition-opacity duration-300 ${showMatrix && !isBreaching ? 'opacity-30' : 'opacity-0'}`} />

      <motion.div 
        className="relative z-10 flex flex-col gap-4 items-center w-full max-w-2xl px-4"
        animate={isBreaching ? { scale: 15, opacity: 0, filter: "blur(10px)" } : { scale: 1, opacity: 1, filter: "blur(0px)" }}
        transition={{ scale: { duration: 0.8, ease: "easeIn" }, opacity: { duration: 0.2, ease: "easeIn" }, filter: { duration: 0.2 } }}
      >
        <motion.div initial={{ y: -20, opacity: 0 }} animate={{ y: 0, opacity: 1 }} className="w-full bg-black/90 border border-elfy-green-dim/50 shadow-[0_0_20px_rgba(0,255,65,0.1)] overflow-hidden shrink-0">
          <BootHeader />
          <div className="p-4 pt-2 h-40 flex flex-col justify-start text-xs md:text-sm font-mono relative z-10 leading-relaxed">
            {logsToShow.map((line, i) => (
              <TypedLog key={i} text={line.text} color={line.color} speed={line.speed} showDots={line.hasDots} isActive={i === step && !isBreaching} isPast={i < step} />
            ))}
          </div>
        </motion.div>

        <AnimatePresence>
          {showPayloadWindow && (
            <motion.div 
              initial={{ y: 50, opacity: 0, height: 0 }}
              animate={{ y: 0, opacity: 1, height: "auto" }}
              transition={{ type: "spring", stiffness: 120, damping: 20 }}
              className="w-full bg-black/90 border border-elfy-green shadow-[0_0_40px_rgba(0,255,65,0.15)] overflow-hidden shrink-0"
            >
              <CoreHeader />
              <div className="p-6 flex flex-col items-center gap-8">
                <AsciiRenderer />
                {showWarningBox && (
                  <motion.div 
                    initial={{ opacity: 0, scale: 0.9 }}
                    animate={{ 
                      opacity: 1, scale: 1,
                      boxShadow: ["0 0 10px rgba(255, 0, 60, 0.2)", "0 0 40px rgba(255, 0, 60, 0.6)", "0 0 10px rgba(255, 0, 60, 0.2)"]
                    }}
                    transition={{ opacity: { duration: 0.3 }, scale: { duration: 0.3 }, boxShadow: { duration: 2.5, repeat: Infinity, ease: "easeInOut" } }}
                    className="relative border border-elfy-red bg-elfy-red/10 w-fit mx-auto flex items-center justify-center gap-4 py-2 px-6 select-none shrink-0"
                  >
                    <motion.span animate={{ opacity: [1, 0.2, 1] }} transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }} className="text-3xl text-elfy-red">âš </motion.span>
                    <span className="text-sm font-header font-black tracking-widest text-center text-elfy-red whitespace-nowrap pb-0.5">UNSAFE CONNECTION DETECTED</span>
                    <motion.span animate={{ opacity: [1, 0.2, 1] }} transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }} className="text-3xl text-elfy-red">âš </motion.span>
                  </motion.div>
                )}
                {showButton && (
                  <motion.div initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5, ease: "easeOut" }} className="shrink-0">
                    <button 
                      onClick={handleInitialize}
                      onMouseEnter={() => AudioSystem.playHover()} // ADDED HOVER SOUND
                      className="group relative px-8 py-2 overflow-hidden border border-elfy-green transition-all hover:shadow-[0_0_30px_rgba(0,255,65,0.6)]"
                    >
                      <div className="absolute inset-0 bg-elfy-green translate-y-full group-hover:translate-y-0 transition-transform duration-300 ease-out" />
                      <span className="relative z-10 font-mono font-bold text-xl md:text-3xl text-elfy-green group-hover:text-black transition-colors block tracking-widest whitespace-nowrap">
                        [ INITIALIZE_SYSTEM.EXE ]
                      </span>
                    </button>
                  </motion.div>
                )}
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </motion.div>
    </motion.div>
  );
};


=====================================
FILE: ./src/features/gallery/GalleryModal.tsx
=====================================
import { ModalContainer } from '@/ui/overlays/ModalContainer';
import gallery from '@/data/gallery.json';
import { ExternalLink, Image as ImageIcon } from 'lucide-react';
import { useState } from 'react';

export const GalleryModal = () => {
  const [filter, setFilter] = useState('ALL');
  
  // Get unique categories
  const categories = ['ALL', ...Array.from(new Set(gallery.map(item => item.category)))];

  const filteredGallery = filter === 'ALL' 
    ? gallery 
    : gallery.filter(item => item.category === filter);

  return (
    <ModalContainer title="ART_DATABASE // VISUALS" type="gallery">
      <div className="flex flex-col h-full gap-6">
        
        {/* Category Tabs */}
        <div className="flex gap-2 overflow-x-auto pb-2 border-b border-elfy-green-dim/30">
          {categories.map(cat => (
            <button
              key={cat}
              onClick={() => setFilter(cat)}
              className={`px-4 py-1 font-mono text-sm border transition-all ${
                filter === cat 
                  ? 'bg-elfy-green text-black border-elfy-green' 
                  : 'text-elfy-green-dim border-elfy-green-dim/30 hover:text-elfy-green hover:border-elfy-green'
              }`}
            >
              [{cat}]
            </button>
          ))}
        </div>

        {/* The Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {filteredGallery.map((item) => (
            <a
              key={item.id}
              href={item.url}
              target="_blank"
              rel="noopener noreferrer"
              className="group relative aspect-video bg-black border border-elfy-green-dim/30 hover:border-elfy-green transition-all overflow-hidden"
            >
              {/* Placeholder Graphic (Since we have no images yet) */}
              <div className="absolute inset-0 flex flex-col items-center justify-center bg-elfy-green-dark/10 group-hover:bg-elfy-green-dark/20 transition-colors">
                <ImageIcon className="w-12 h-12 text-elfy-green-dim/20 group-hover:text-elfy-green group-hover:scale-110 transition-all duration-500" />
                <span className="mt-2 text-xs text-elfy-green-dim/40 font-mono">ENCRYPTED_IMG</span>
              </div>

              {/* Overlay Info */}
              <div className="absolute inset-x-0 bottom-0 p-3 bg-black/80 backdrop-blur-sm border-t border-elfy-green-dim/30 translate-y-full group-hover:translate-y-0 transition-transform duration-300">
                <h4 className="text-elfy-green font-bold text-sm">{item.title}</h4>
                <div className="flex items-center gap-1 text-[10px] text-elfy-purple-light mt-1">
                  <span>OPEN_ON_X</span>
                  <ExternalLink size={10} />
                </div>
              </div>
              
              {/* Corner accent */}
              <div className="absolute top-0 right-0 w-0 h-0 border-t-[20px] border-t-elfy-green/20 border-l-[20px] border-l-transparent" />
            </a>
          ))}
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/features/feed/FeedModal.tsx
=====================================
import { ModalContainer } from '@/ui/overlays/ModalContainer';
import feed from '@/data/feed.json';
import { ExternalLink } from 'lucide-react';

export const FeedModal = () => {
  return (
    <ModalContainer title="SYSTEM_LOGS // FEED" type="feed">
      <div className="space-y-6 font-mono">
        {feed.map((post) => (
          <div key={post.id} className="border-l-2 border-elfy-green-dim pl-4 py-2 hover:bg-elfy-green/5 transition-colors group">
            <div className="flex items-center gap-4 mb-2">
              <span className="text-xs text-elfy-green-dim bg-elfy-green-dark/30 px-2 py-1 rounded">
                [{post.date}]
              </span>
              <h3 className="text-xl font-bold text-elfy-green group-hover:text-elfy-yellow transition-colors">
                {post.title}
              </h3>
            </div>
            
            <p className="text-elfy-green-dim/80 mb-3 max-w-2xl">
              {post.desc}
            </p>

            <a 
              href={post.link}
              target="_blank"
              rel="noopener noreferrer"
              className="inline-flex items-center gap-2 text-sm text-elfy-purple-light hover:text-elfy-green underline decoration-elfy-purple-dim decoration-dashed underline-offset-4"
            >
              <span>VIEW_SOURCE</span>
              <ExternalLink size={14} />
            </a>
          </div>
        ))}
        
        {/* End of Log Marker */}
        <div className="text-center py-8 text-elfy-green-dim/30 animate-pulse">
          -- END OF STREAM --
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/features/effects/GlobalShakeManager.tsx
=====================================
import { useEffect, useRef } from 'react';
import { FXManager } from '@/game/systems/FXManager';

export const GlobalShakeManager = () => {
  const requestRef = useRef<number>();
  
  useEffect(() => {
    let lastTime = performance.now();

    const animate = (time: number) => {
      const delta = (time - lastTime) / 1000;
      lastTime = time;

      // 1. Process Decay Logic
      FXManager.decay(delta);
      const trauma = FXManager.trauma;

      // 2. Apply to Global Root
      const root = document.getElementById('global-app-root');
      
      if (root) {
        if (trauma > 0) {
          const shake = trauma * trauma;
          const maxAngle = 1.0; // Degrees
          const maxOffset = 10; // Pixels (Increased for visible HTML shake)
          
          const x = maxOffset * shake * (Math.random() * 2 - 1);
          const y = maxOffset * shake * (Math.random() * 2 - 1);
          const rot = maxAngle * shake * (Math.random() * 2 - 1);
          
          root.style.transform = `translate(${x}px, ${y}px) rotate(${rot}deg)`;
        } else {
          // Optimization: Clear transform when idle
          if (root.style.transform !== '') {
             root.style.transform = '';
          }
        }
      }

      requestRef.current = requestAnimationFrame(animate);
    };

    requestRef.current = requestAnimationFrame(animate);
    return () => cancelAnimationFrame(requestRef.current!);
  }, []);

  return null;
};


=====================================
FILE: ./src/game/types/game.types.ts
=====================================
export interface RegisteredPanel {
  id: string;
  element: HTMLElement;
  health: number;
  isDestroyed: boolean;
}

export interface GameState {
  isPlaying: boolean;
  score: number;
  threatLevel: number;
  panels: Record<string, RegisteredPanel>;
  
  startGame: () => void;
  stopGame: () => void;
  registerPanel: (id: string, element: HTMLElement) => void;
  unregisterPanel: (id: string) => void;
  damagePanel: (id: string, amount: number) => void;
  healPanel: (id: string, amount: number) => void;
}

// --- ENTITY TYPES ---

export interface Entity {
  id: number;
  x: number;
  y: number;
  radius: number;
  active: boolean;
  spawnTime: number; 
}

export interface Enemy extends Entity {
  vx: number;
  vy: number;
  hp: number;
  type: 'muncher' | 'kamikaze' | 'hunter';
  state?: 'orbit' | 'charge' | 'fire';
  stateTimer?: number;
  targetId?: string; 
  isEating?: boolean;
  orbitAngle?: number; 
}

export interface Bullet extends Entity {
  vx: number;
  vy: number;
  life: number;
  isEnemy?: boolean;
  hp: number; // NEW: Bullet durability
}

export interface Particle extends Entity {
  vx: number;
  vy: number;
  life: number;
  maxLife: number;
  color: string;
}


=====================================
FILE: ./src/game/core/ServiceLocator.ts
=====================================
import { EntitySystem } from '../systems/EntitySystem';
import { CollisionSystem } from '../systems/CollisionSystem';
import { WaveSystem } from '../systems/WaveSystem';
import { InteractionSystem } from '../systems/InteractionSystem';
import { InputSystem } from '../systems/InputSystem';
import { PlayerSystem } from '../systems/PlayerSystem';
import { BreachSystem } from '../systems/BreachSystem';
import { FXManager } from '../systems/FXManager';

class ServiceLocatorCore {
  public entitySystem: EntitySystem;
  public collisionSystem: CollisionSystem;
  public waveSystem: WaveSystem;
  public interactionSystem: InteractionSystem;
  public inputSystem: InputSystem;
  public playerSystem: PlayerSystem;
  public breachSystem: BreachSystem;
  public fxManager: typeof FXManager;

  public registerEntitySystem(sys: EntitySystem) { this.entitySystem = sys; }
  public registerCollisionSystem(sys: CollisionSystem) { this.collisionSystem = sys; }
  public registerWaveSystem(sys: WaveSystem) { this.waveSystem = sys; }
  public registerInteractionSystem(sys: InteractionSystem) { this.interactionSystem = sys; }
  public registerInputSystem(sys: InputSystem) { this.inputSystem = sys; }
  public registerPlayerSystem(sys: PlayerSystem) { this.playerSystem = sys; }
  public registerBreachSystem(sys: BreachSystem) { this.breachSystem = sys; }
  public registerFXManager(mgr: typeof FXManager) { this.fxManager = mgr; }
}

export const ServiceLocator = new ServiceLocatorCore();


=====================================
FILE: ./src/game/core/GameEngine.ts
=====================================
import { useGameStore } from '../store/useGameStore';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../config/Identifiers';
import { FXManager } from '../systems/FXManager';
import { ServiceLocator } from './ServiceLocator';
import { EntitySystem } from '../systems/EntitySystem';
import { CollisionSystem } from '../systems/CollisionSystem';
import { WaveSystem } from '../systems/WaveSystem';
import { InteractionSystem } from '../systems/InteractionSystem';
import { InputSystem } from '../systems/InputSystem';
import { PlayerSystem } from '../systems/PlayerSystem';
import { BreachSystem } from '../systems/BreachSystem';
import { ViewportHelper } from '../utils/ViewportHelper';

class GameEngineCore {
  private entitySystem: EntitySystem;
  private collisionSystem: CollisionSystem;
  private waveSystem: WaveSystem;
  private interactionSystem: InteractionSystem;
  private inputSystem: InputSystem;
  private playerSystem: PlayerSystem;
  private breachSystem: BreachSystem;
  
  public isRepairing = false;
  
  private lastDamageTime = 0; 
  private prevPanelHealth: Record<string, number> = {};

  constructor() {
    FXManager.init();
    this.entitySystem = new EntitySystem();
    this.collisionSystem = new CollisionSystem(this.entitySystem);
    this.waveSystem = new WaveSystem();
    this.interactionSystem = new InteractionSystem();
    this.inputSystem = new InputSystem();
    this.playerSystem = new PlayerSystem();
    this.breachSystem = new BreachSystem();

    ServiceLocator.registerEntitySystem(this.entitySystem);
    ServiceLocator.registerCollisionSystem(this.collisionSystem);
    ServiceLocator.registerWaveSystem(this.waveSystem);
    ServiceLocator.registerInteractionSystem(this.interactionSystem);
    ServiceLocator.registerInputSystem(this.inputSystem);
    ServiceLocator.registerPlayerSystem(this.playerSystem);
    ServiceLocator.registerBreachSystem(this.breachSystem);
    ServiceLocator.registerFXManager(FXManager);
  }

  public get enemies() { return this.entitySystem.enemies; }
  public get bullets() { return this.entitySystem.bullets; }
  public get enemyBullets() { return this.entitySystem.enemyBullets; }
  public get particles() { return this.entitySystem.particles; }

  public updateViewport(vpW: number, vpH: number, screenW: number, screenH: number) {
    ViewportHelper.update(vpW, vpH, screenW, screenH);
  }

  public update(delta: number, time: number) {
    // 0. Game Over Check
    const store = useGameStore.getState();
    if (store.isPlaying && store.systemIntegrity <= 0) {
        store.stopGame();
        // Trigger Massive Trauma
        FXManager.addTrauma(1.0);
        return;
    }

    // 1. Systems Update
    this.checkPanelStates();
    
    const { threatLevel } = store;
    const cursor = this.inputSystem.getCursorPosition();
    
    // 2. Wave Logic
    this.waveSystem.update(time, threatLevel);
    this.breachSystem.update(time); // Spawn from dead panels

    // 3. Interaction Logic
    this.isRepairing = this.interactionSystem.update(time, cursor);

    // 4. Player Logic
    this.playerSystem.update(time);

    // 5. Physics & Entities
    const doDamageTick = time > this.lastDamageTime + 0.5; 
    if (doDamageTick) this.lastDamageTime = time;

    this.entitySystem.update(delta, time, cursor, doDamageTick);
    this.collisionSystem.update(cursor);
  }

  private checkPanelStates() {
    const panels = useGameStore.getState().panels;
    for (const id in panels) {
      const currentHealth = panels[id].health;
      const prevHealth = this.prevPanelHealth[id]; 
      if (prevHealth !== undefined && prevHealth > 0 && currentHealth <= 0) {
        GameEventBus.emit(GameEvents.PANEL_DESTROYED, { id });
        // Recalculate integrity immediately on death
        useGameStore.getState().recalculateIntegrity();
      }
      this.prevPanelHealth[id] = currentHealth;
    }
  }
}

export const GameEngine = new GameEngineCore();


=====================================
FILE: ./src/game/GameOverlay.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { PlayerAvatar } from './components/PlayerAvatar';
import { GameDirector } from './components/GameDirector';
import { EnemyRenderer } from './components/EnemyRenderer';
import { BulletRenderer } from './components/BulletRenderer';
import { EnemyBulletRenderer } from './components/EnemyBulletRenderer';
import { HunterChargeRenderer } from './components/HunterChargeRenderer';
import { ParticleRenderer } from './components/ParticleRenderer';

export const GameOverlay = () => {
  return (
    <div className="fixed inset-0 z-50 w-full h-full pointer-events-none overflow-hidden">
      <Canvas
        orthographic
        camera={{ zoom: 40, position: [0, 0, 100] }}
        gl={{ 
          alpha: true, 
          antialias: true,
          stencil: false,
        }}
        eventSource={typeof document !== 'undefined' ? document.body : undefined}
        eventPrefix="client"
      >
        <GameDirector />

        <PlayerAvatar />
        
        <BulletRenderer />
        <HunterChargeRenderer /> 
        <EnemyBulletRenderer />
        <EnemyRenderer />
        <ParticleRenderer /> 
      </Canvas>
    </div>
  );
};


=====================================
FILE: ./src/game/config/PlayerConfig.ts
=====================================
export const PLAYER_CONFIG = {
  maxHealth: 100,
  fireRate: 0.15, 
  bulletSpeed: 45,
  bulletRadius: 0.2,
  bulletLife: 1.5,
  
  // Scoring & Progression
  scoreMultiplier: 1,
  baseXpRequirement: 100,
  xpScalingFactor: 1.5, // Next level = base * (scaling ^ level)
};


=====================================
FILE: ./src/game/config/EnemyConfig.ts
=====================================
import { EnemyTypes } from './Identifiers';

export const ENEMY_CONFIG = {
  [EnemyTypes.MUNCHER]: {
    hp: 2,
    baseSpeed: 8,
    radius: 0.5,
    damage: 5,
    score: 10
  },
  [EnemyTypes.KAMIKAZE]: {
    hp: 3, // TRIPLED HEALTH (Was 1)
    baseSpeed: 12,
    radius: 0.5,
    damage: 10,
    score: 20
  },
  [EnemyTypes.HUNTER]: {
    hp: 3,
    baseSpeed: 12,
    radius: 0.5,
    score: 50,
    orbitRadius: 12.5,
    orbitDuration: 2.0,
    chargeDuration: 1.0,
    fireRange: 12.0,
    offsetDistance: 1.6 
  }
};

export const WAVE_CONFIG = {
  baseSpawnInterval: 0.8,
  difficultyScaler: 1.0 
};


=====================================
FILE: ./src/game/config/Identifiers.ts
=====================================
export const EnemyTypes = {
  MUNCHER: 'muncher',
  KAMIKAZE: 'kamikaze',
  HUNTER: 'hunter',
} as const;

export type EnemyType = typeof EnemyTypes[keyof typeof EnemyTypes];

export const GameEvents = {
  ENEMY_SPAWNED: 'ENEMY_SPAWNED',
  ENEMY_DAMAGED: 'ENEMY_DAMAGED',
  ENEMY_DESTROYED: 'ENEMY_DESTROYED',
  PLAYER_HIT: 'PLAYER_HIT',
  PLAYER_FIRED: 'PLAYER_FIRED',
  PROJECTILE_CLASH: 'PROJECTILE_CLASH',
  PANEL_DAMAGED: 'PANEL_DAMAGED',
  PANEL_HEALED: 'PANEL_HEALED',
  PANEL_DESTROYED: 'PANEL_DESTROYED',
} as const;


=====================================
FILE: ./src/game/logic/ai/EnemyBehaviors.ts
=====================================
import { Enemy } from '../../core/GameEngine';
import { ENEMY_CONFIG } from '../../config/EnemyConfig';
import { EnemyTypes, GameEvents } from '../../config/Identifiers';

export interface AIContext {
  playerPos: { x: number, y: number };
  panels: any[]; 
  delta: number;
  time: number;
  doDamageTick: boolean;
  spawnProjectile: (x: number, y: number, vx: number, vy: number) => void;
  damagePanel: (id: string, amount: number) => void;
  triggerExplosion: (x: number, y: number, color: string) => void;
  emitEvent: (name: string, payload: any) => void;
}

export interface EnemyBehavior {
  update(enemy: Enemy, ctx: AIContext): void;
}

export const MuncherBehavior: EnemyBehavior = {
  update: (e, ctx) => {
    let targetX = 0;
    let targetY = 0;
    let nearestDist = Infinity;
    let bestPanel: any = null;

    const validPanels = ctx.panels; 

    for (const p of validPanels) {
      const dx = p.x - e.x;
      const dy = p.y - e.y;
      const dist = dx*dx + dy*dy;
      if (dist < nearestDist) {
        nearestDist = dist;
        bestPanel = p;
      }
    }

    if (bestPanel) {
      targetX = Math.max(bestPanel.left, Math.min(e.x, bestPanel.right));
      targetY = Math.max(bestPanel.bottom, Math.min(e.y, bestPanel.top));
      
      const dx = targetX - e.x;
      const dy = targetY - e.y;
      const distToEdge = Math.sqrt(dx*dx + dy*dy);

      if (distToEdge < 0.5) { 
        e.isEating = true;
        if (ctx.doDamageTick) {
            ctx.damagePanel(bestPanel.id, ENEMY_CONFIG[EnemyTypes.MUNCHER].damage);
            ctx.triggerExplosion(targetX, targetY, '#9E4EA5');
        }
      } else {
        e.isEating = false;
      }
    } else {
      targetX = Math.sin(ctx.time) * 5;
      targetY = Math.cos(ctx.time) * 5;
      e.isEating = false;
    }

    if (!e.isEating) {
      const dx = targetX - e.x;
      const dy = targetY - e.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      
      if (dist > 0.1) {
        e.vx = (dx / dist) * ENEMY_CONFIG[EnemyTypes.MUNCHER].baseSpeed * ctx.delta;
        e.vy = (dy / dist) * ENEMY_CONFIG[EnemyTypes.MUNCHER].baseSpeed * ctx.delta;
        e.x += e.vx;
        e.y += e.vy;
      }
    }
  }
};

export const KamikazeBehavior: EnemyBehavior = {
  update: (e, ctx) => {
    const targetX = ctx.playerPos.x;
    const targetY = ctx.playerPos.y;
    
    const dx = targetX - e.x;
    const dy = targetY - e.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    if (dist < 1.0) {
       e.active = false;
       ctx.triggerExplosion(e.x, e.y, '#FF003C');
       ctx.emitEvent(GameEvents.PLAYER_HIT, { damage: 10 });
       return; 
    }

    if (dist > 0.1) {
      e.vx = (dx / dist) * ENEMY_CONFIG[EnemyTypes.KAMIKAZE].baseSpeed * ctx.delta;
      e.vy = (dy / dist) * ENEMY_CONFIG[EnemyTypes.KAMIKAZE].baseSpeed * ctx.delta;
      e.x += e.vx;
      e.y += e.vy;
    }
  }
};

export const HunterBehavior: EnemyBehavior = {
  update: (e, ctx) => {
    if (!e.state) e.state = 'orbit';
    if (!e.stateTimer) e.stateTimer = ENEMY_CONFIG[EnemyTypes.HUNTER].orbitDuration + Math.random();

    e.stateTimer -= ctx.delta;

    let targetX = 0;
    let targetY = 0;

    if (e.state === 'orbit') {
      if (!e.orbitAngle) e.orbitAngle = Math.random() * Math.PI * 2;
      
      const speedVar = 0.7 + Math.sin(ctx.time * 0.8 + e.id) * 0.5;
      e.orbitAngle += ctx.delta * speedVar; 
      
      const breathe = Math.sin(ctx.time * 1.5 + e.id) * 5.5; 
      const orbitRadius = ENEMY_CONFIG[EnemyTypes.HUNTER].orbitRadius + breathe; 
      
      targetX = Math.cos(e.orbitAngle) * orbitRadius;
      targetY = Math.sin(e.orbitAngle) * orbitRadius;

      const maxX = 18;
      const maxY = 10;
      targetX = Math.max(-maxX, Math.min(maxX, targetX));
      targetY = Math.max(-maxY, Math.min(maxY, targetY));

      const inBoundsX = Math.abs(e.x) < 20;
      const inBoundsY = Math.abs(e.y) < 12;

      if (e.stateTimer <= 0 && inBoundsX && inBoundsY) {
        e.state = 'charge';
        e.stateTimer = ENEMY_CONFIG[EnemyTypes.HUNTER].chargeDuration; 
        e.vx = 0;
        e.vy = 0;
      }
      
      const dx = targetX - e.x;
      const dy = targetY - e.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      
      if (dist > 0.1) {
        e.vx = (dx / dist) * ENEMY_CONFIG[EnemyTypes.HUNTER].baseSpeed * ctx.delta;
        e.vy = (dy / dist) * ENEMY_CONFIG[EnemyTypes.HUNTER].baseSpeed * ctx.delta;
        e.x += e.vx;
        e.y += e.vy;
      }

    } 
    else if (e.state === 'charge') {
      if (e.stateTimer <= 0) {
        e.state = 'fire';
      }
    }
    else if (e.state === 'fire') {
      const dx = ctx.playerPos.x - e.x;
      const dy = ctx.playerPos.y - e.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const dirX = dist > 0 ? dx/dist : 0;
      const dirY = dist > 0 ? dy/dist : 1;
      
      const offset = ENEMY_CONFIG[EnemyTypes.HUNTER].offsetDistance;
      const spawnX = e.x + (dirX * offset);
      const spawnY = e.y + (dirY * offset);

      const SPEED = 25; 
      const pVx = (dirX) * SPEED;
      const pVy = (dirY) * SPEED;

      ctx.spawnProjectile(spawnX, spawnY, pVx, pVy);

      e.state = 'orbit';
      e.stateTimer = 3.0 + Math.random() * 2.0;
    }
  }
};

export const Behaviors: Record<string, EnemyBehavior> = {
  [EnemyTypes.MUNCHER]: MuncherBehavior,
  [EnemyTypes.KAMIKAZE]: KamikazeBehavior,
  [EnemyTypes.HUNTER]: HunterBehavior
};


=====================================
FILE: ./src/game/utils/ViewportHelper.ts
=====================================
export class ViewportHelperCore {
  public viewport = { width: 1, height: 1 };
  public screenSize = { width: 1, height: 1 };

  public update(vpW: number, vpH: number, screenW: number, screenH: number) {
    this.viewport = { width: vpW, height: vpH };
    this.screenSize = { width: screenW, height: screenH };
  }

  public getPanelWorldRect(panel: { id: string, element: HTMLElement }) {
    if (!panel.element) return null;
    
    const rect = panel.element.getBoundingClientRect();
    if (rect.width === 0 && rect.height === 0) return null;

    // Use stored screenSize (or fallback to window if needed, but stored is safer for R3F context)
    const sw = this.screenSize.width || window.innerWidth;
    const sh = this.screenSize.height || window.innerHeight;
    
    const vw = this.viewport.width;
    const vh = this.viewport.height;
    
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;
    
    // Screen (DOM) -> World (Three.js Orthographic)
    const wx = (cx / sw) * vw - (vw / 2);
    const wy = -((cy / sh) * vh - (vh / 2));
    
    const wWidth = (rect.width / sw) * vw;
    const wHeight = (rect.height / sh) * vh;

    return {
      id: panel.id,
      x: wx, y: wy,
      width: wWidth, height: wHeight,
      left: wx - wWidth / 2, right: wx + wWidth / 2,
      top: wy + wHeight / 2, bottom: wy - wHeight / 2,
    };
  }
}

export const ViewportHelper = new ViewportHelperCore();


=====================================
FILE: ./src/game/utils/coords.ts
=====================================
// Camera Zoom level defined in GameOverlay
const ZOOM = 40; 

export const screenToWorld = (screenX: number, screenY: number, screenW: number, screenH: number) => {
  // DOM: 0,0 is Top-Left. +Y is Down.
  // THREE: 0,0 is Center. +Y is Up.
  
  const worldX = (screenX - screenW / 2) / ZOOM;
  const worldY = -(screenY - screenH / 2) / ZOOM; // Invert Y
  
  return { x: worldX, y: worldY };
};

export const domRectToWorldRect = (rect: { x: number, y: number, width: number, height: number }, screenW: number, screenH: number) => {
  // Get center of DOM element
  const centerX = rect.x + rect.width / 2;
  const centerY = rect.y + rect.height / 2;
  
  const centerWorld = screenToWorld(centerX, centerY, screenW, screenH);
  
  return {
    x: centerWorld.x,
    y: centerWorld.y,
    width: rect.width / ZOOM,
    height: rect.height / ZOOM,
    left: centerWorld.x - (rect.width / ZOOM / 2),
    right: centerWorld.x + (rect.width / ZOOM / 2),
    top: centerWorld.y + (rect.height / ZOOM / 2),
    bottom: centerWorld.y - (rect.height / ZOOM / 2),
  };
};


=====================================
FILE: ./src/game/components/PlayerAvatar.tsx
=====================================
import { useRef } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import { GAME_THEME } from '../theme';
import { GameEngine } from '../core/GameEngine';
import { ServiceLocator } from '../core/ServiceLocator';
import { useGameStore } from '../store/useGameStore';
import * as THREE from 'three';

export const PlayerAvatar = () => {
  const groupRef = useRef<THREE.Group>(null);
  const ringRef = useRef<THREE.Mesh>(null);
  const coreRef = useRef<THREE.Mesh>(null);
  const glowRef = useRef<THREE.Sprite>(null);
  const { viewport } = useThree();

  const colorTurret = new THREE.Color(GAME_THEME.turret.base);
  const colorRepair = new THREE.Color(GAME_THEME.turret.repair);
  const colorDead = new THREE.Color('#78F654'); // Green
  const colorReboot = new THREE.Color('#eae747'); // Yellow

  const isDead = useGameStore(state => state.playerHealth <= 0);

  // Alive: Small Circle
  const aliveGeo = new THREE.CircleGeometry(0.1, 16);
  // Dead: Hollow Triangle (Ring with 3 segments)
  const deadGeo = new THREE.RingGeometry(0.15, 0.2, 3);

  useFrame((state) => {
    if (!groupRef.current) return;

    const x = (state.pointer.x * viewport.width) / 2;
    const y = (state.pointer.y * viewport.height) / 2;
    groupRef.current.position.x = x;
    groupRef.current.position.y = y;

    if (ServiceLocator.inputSystem) {
        ServiceLocator.inputSystem.updateCursor(x, y);
    }

    const isRepairing = GameEngine.isRepairing;
    
    if (ringRef.current && coreRef.current && glowRef.current) {
        if (isDead) {
            // DEAD STATE
            ringRef.current.visible = false;
            
            // Only show glow if we are actively rebooting
            glowRef.current.visible = isRepairing;
            glowRef.current.material.color.set(colorReboot);
            
            coreRef.current.geometry = deadGeo;
            coreRef.current.material.color.set(isRepairing ? colorReboot : colorDead);
            
            if (isRepairing) {
               // Revival Animation: Fast Spin & Pulse
               coreRef.current.rotation.z -= 0.5; 
               coreRef.current.scale.setScalar(1.5 + Math.sin(state.clock.elapsedTime * 30) * 0.2);
            } else {
               // Idle Dead
               coreRef.current.rotation.z = Math.PI; 
               coreRef.current.scale.setScalar(1.0);
            }
        } else {
            // ALIVE STATE
            ringRef.current.visible = true;
            glowRef.current.visible = true;
            coreRef.current.geometry = aliveGeo;
            
            if (isRepairing) {
                // Repairing Panel Animation
                ringRef.current.rotation.z += 0.4; 
                ringRef.current.material.color.lerp(colorRepair, 0.4);
                const pulse = 1.2 + Math.sin(state.clock.elapsedTime * 20) * 0.2;
                ringRef.current.scale.setScalar(pulse);
                coreRef.current.material.color.lerp(colorRepair, 0.4);
                glowRef.current.material.color.lerp(colorRepair, 0.4);
            } else {
                // Normal Combat
                ringRef.current.rotation.z -= 0.02; 
                ringRef.current.material.color.lerp(colorTurret, 0.1);
                ringRef.current.scale.setScalar(1);
                coreRef.current.material.color.lerp(colorTurret, 0.1);
                glowRef.current.material.color.lerp(colorTurret, 0.1);
            }
        }
    }
  });

  return (
    <group ref={groupRef}>
      <mesh ref={coreRef}>
        <bufferGeometry />
        <meshBasicMaterial color={GAME_THEME.turret.base} />
      </mesh>

      <mesh ref={ringRef} rotation={[0, 0, Math.PI / 4]}>
        <ringGeometry args={[0.4, 0.45, 4]} /> 
        <meshBasicMaterial color={GAME_THEME.turret.base} transparent opacity={0.8} />
      </mesh>

      <sprite ref={glowRef} scale={[2, 2, 1]}>
        <spriteMaterial 
          color={GAME_THEME.turret.glow} 
          transparent 
          opacity={0.3}
          blending={THREE.AdditiveBlending}
        />
      </sprite>
    </group>
  );
};


=====================================
FILE: ./src/game/components/BulletRenderer.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { GameEngine } from '../core/GameEngine';
import { GAME_THEME } from '../theme';

const MAX_BULLETS = 500;
const tempObj = new THREE.Object3D();

export const BulletRenderer = () => {
  const meshRef = useRef<THREE.InstancedMesh>(null);

  // Geometry: Small high-energy square
  const geometry = useMemo(() => new THREE.PlaneGeometry(0.15, 0.4), []); // Elongated slightly

  useFrame(() => {
    if (!meshRef.current) return;

    const bullets = GameEngine.bullets;
    let count = 0;

    for (let i = 0; i < bullets.length; i++) {
      const b = bullets[i];
      if (!b.active) continue;

      if (count >= MAX_BULLETS) break;

      // Position
      tempObj.position.set(b.x, b.y, 0);
      
      // Rotation (Face velocity)
      const angle = Math.atan2(b.vy, b.vx) - Math.PI / 2;
      tempObj.rotation.z = angle;

      tempObj.updateMatrix();
      meshRef.current.setMatrixAt(count, tempObj.matrix);
      count++;
    }

    meshRef.current.count = count;
    meshRef.current.instanceMatrix.needsUpdate = true;
  });

  return (
    <instancedMesh ref={meshRef} args={[geometry, undefined, MAX_BULLETS]}>
      <meshBasicMaterial color={GAME_THEME.bullet.plasma} />
    </instancedMesh>
  );
};


=====================================
FILE: ./src/game/components/ParticleRenderer.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { GameEngine } from '../core/GameEngine';

const MAX_PARTICLES = 1000;
const tempObj = new THREE.Object3D();
const tempColor = new THREE.Color();

export const ParticleRenderer = () => {
  const meshRef = useRef<THREE.InstancedMesh>(null);
  const geometry = useMemo(() => new THREE.PlaneGeometry(0.1, 0.1), []);

  useFrame(() => {
    if (!meshRef.current) return;

    const particles = GameEngine.particles;
    let count = 0;

    for (let i = 0; i < particles.length; i++) {
      const p = particles[i];
      if (!p.active) continue;
      if (count >= MAX_PARTICLES) break;

      tempObj.position.set(p.x, p.y, 0);
      const scale = p.life / p.maxLife; 
      tempObj.scale.set(scale, scale, 1);
      
      // FIXED: Apply instance color
      tempColor.set(p.color);
      
      tempObj.updateMatrix();
      meshRef.current.setMatrixAt(count, tempObj.matrix);
      meshRef.current.setColorAt(count, tempColor);
      
      count++;
    }

    meshRef.current.count = count;
    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor) meshRef.current.instanceColor.needsUpdate = true;
  });

  return (
    <instancedMesh ref={meshRef} args={[geometry, undefined, MAX_PARTICLES]}>
      <meshBasicMaterial color="white" />
    </instancedMesh>
  );
};


=====================================
FILE: ./src/game/components/EnemyBulletRenderer.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { GameEngine } from '../core/GameEngine';
import { GAME_THEME } from '../theme';

const MAX_BULLETS = 200;
const tempObj = new THREE.Object3D();

export const EnemyBulletRenderer = () => {
  const meshRef = useRef<THREE.InstancedMesh>(null);

  // 3x Size Increase (0.3 -> 0.9)
  const geometry = useMemo(() => new THREE.CircleGeometry(0.9, 16), []); 

  useFrame(() => {
    if (!meshRef.current) return;

    // Safety check: ensure array exists before reading length
    const bullets = GameEngine.enemyBullets || [];
    let count = 0;

    for (let i = 0; i < bullets.length; i++) {
      const b = bullets[i];
      if (!b.active) continue;

      if (count >= MAX_BULLETS) break;

      tempObj.position.set(b.x, b.y, 0);
      tempObj.scale.set(1, 1, 1);
      
      const angle = Math.atan2(b.vy, b.vx) - Math.PI / 2;
      tempObj.rotation.z = angle;

      tempObj.updateMatrix();
      meshRef.current.setMatrixAt(count, tempObj.matrix);
      count++;
    }

    meshRef.current.count = count;
    meshRef.current.instanceMatrix.needsUpdate = true;
  });

  return (
    <instancedMesh ref={meshRef} args={[geometry, undefined, MAX_BULLETS]}>
      <meshBasicMaterial color={GAME_THEME.bullet.hunter} />
    </instancedMesh>
  );
};


=====================================
FILE: ./src/game/components/HunterChargeRenderer.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { GameEngine } from '../core/GameEngine';
import { ServiceLocator } from '../core/ServiceLocator';
import { GAME_THEME } from '../theme';
import { EnemyTypes } from '../config/Identifiers';

const MAX_CHARGES = 50;
const tempObj = new THREE.Object3D();
const OFFSET_DISTANCE = 1.6; 

export const HunterChargeRenderer = () => {
  const meshRef = useRef<THREE.InstancedMesh>(null);
  const geometry = useMemo(() => new THREE.CircleGeometry(0.9, 16), []);

  useFrame(() => {
    if (!meshRef.current) return;

    const enemies = GameEngine.enemies;
    const cursor = ServiceLocator.inputSystem ? ServiceLocator.inputSystem.getCursorPosition() : {x:0, y:0};
    
    let count = 0;

    for (let i = 0; i < enemies.length; i++) {
      const e = enemies[i];
      if (!e.active || e.type !== EnemyTypes.HUNTER) continue;

      if (e.state === 'charge') {
        if (count >= MAX_CHARGES) break;

        const progress = Math.max(0, Math.min(1, 1.0 - (e.stateTimer || 0)));
        const scale = 1 - Math.pow(1 - progress, 3);

        const dx = cursor.x - e.x;
        const dy = cursor.y - e.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        const dirX = dist > 0 ? dx / dist : 0;
        const dirY = dist > 0 ? dy / dist : 1;

        const spawnX = e.x + (dirX * OFFSET_DISTANCE);
        const spawnY = e.y + (dirY * OFFSET_DISTANCE);

        tempObj.position.set(spawnX, spawnY, -0.1);
        tempObj.scale.set(scale, scale, 1);
        tempObj.rotation.z += 0.1;

        tempObj.updateMatrix();
        meshRef.current.setMatrixAt(count, tempObj.matrix);
        count++;
      }
    }

    meshRef.current.count = count;
    meshRef.current.instanceMatrix.needsUpdate = true;
  });

  return (
    <instancedMesh ref={meshRef} args={[geometry, undefined, MAX_CHARGES]}>
      <meshBasicMaterial 
        color={GAME_THEME.bullet.hunter} 
        transparent 
        opacity={0.9} 
      />
    </instancedMesh>
  );
};


=====================================
FILE: ./src/game/components/EnemyRenderer.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { GameEngine } from '../core/GameEngine';
import { ServiceLocator } from '../core/ServiceLocator';
import { GAME_THEME } from '../theme';
import { EnemyTypes } from '../config/Identifiers';

const MAX_ENEMIES = 1000;
const tempObj = new THREE.Object3D();
const tempColor = new THREE.Color();
const chargeColor = new THREE.Color(GAME_THEME.enemy.charge);

export const EnemyRenderer = () => {
  const muncherRef = useRef<THREE.InstancedMesh>(null);
  const kamikazeRef = useRef<THREE.InstancedMesh>(null);
  const hunterRef = useRef<THREE.InstancedMesh>(null);
  
  const muncherGeo = useMemo(() => new THREE.ConeGeometry(0.3, 0.8, 3), []);
  const kamikazeGeo = useMemo(() => new THREE.IcosahedronGeometry(0.4, 0), []);
  const hunterGeo = useMemo(() => new THREE.ConeGeometry(0.3, 0.8, 3), []);
  
  useFrame((state) => {
    if (!muncherRef.current || !kamikazeRef.current || !hunterRef.current) return;

    const enemies = GameEngine.enemies;
    const currentTime = state.clock.elapsedTime;
    const cursor = ServiceLocator.inputSystem ? ServiceLocator.inputSystem.getCursorPosition() : {x:0, y:0};
    
    let mCount = 0;
    let kCount = 0;
    let hCount = 0;

    for (let i = 0; i < enemies.length; i++) {
      const e = enemies[i];
      if (!e.active) continue;

      tempObj.position.set(e.x, e.y, 0);
      
      const age = currentTime - (e.spawnTime || 0);
      const spawnScale = Math.min(1.0, age * 3.0); 
      const elastic = spawnScale === 1 ? 1 : 1 - Math.pow(2, -10 * spawnScale) * Math.sin((spawnScale - 0.075) * (2 * Math.PI) / 0.3);

      // --- MUNCHER ---
      if (e.type === EnemyTypes.MUNCHER) {
        if (mCount >= MAX_ENEMIES) continue;
        
        const angle = Math.atan2(e.vy, e.vx) - Math.PI / 2;
        tempObj.rotation.set(0, 0, angle);
        
        const baseScale = e.isEating ? 1 + Math.sin(state.clock.elapsedTime * 20) * 0.2 : 1;
        const finalScale = baseScale * elastic;
        tempObj.scale.set(finalScale, finalScale, 1);
        
        tempColor.set(GAME_THEME.enemy.muncher);
        
        tempObj.updateMatrix();
        muncherRef.current.setMatrixAt(mCount, tempObj.matrix);
        muncherRef.current.setColorAt(mCount, tempColor);
        mCount++;
      }
      
      // --- KAMIKAZE ---
      else if (e.type === EnemyTypes.KAMIKAZE) {
        if (kCount >= MAX_ENEMIES) continue;
        
        const angle = Math.atan2(e.vy, e.vx) - Math.PI / 2;
        tempObj.rotation.set(0, 0, angle + (currentTime * 5)); // Spin
        
        const finalScale = 1.3 * elastic;
        tempObj.scale.set(finalScale, finalScale, finalScale);
        
        tempColor.set(GAME_THEME.enemy.kamikaze);
        
        tempObj.updateMatrix();
        kamikazeRef.current.setMatrixAt(kCount, tempObj.matrix);
        kamikazeRef.current.setColorAt(kCount, tempColor);
        kCount++;
      }
      
      // --- HUNTER ---
      else if (e.type === EnemyTypes.HUNTER) {
        if (hCount >= MAX_ENEMIES) continue;
        
        let angle = 0;
        let baseScale = 1.5;
        
        if (e.state === 'charge') {
            const dx = cursor.x - e.x;
            const dy = cursor.y - e.y;
            angle = Math.atan2(dy, dx) - Math.PI / 2;
            
            tempObj.position.x += (Math.random() - 0.5) * 0.1;
            tempObj.position.y += (Math.random() - 0.5) * 0.1;
            
            const t = state.clock.elapsedTime * 20;
            const alpha = (Math.sin(t) + 1) / 2;
            tempColor.set(GAME_THEME.enemy.hunter).lerp(chargeColor, alpha);
            baseScale = 1.8;
        } else {
            angle = Math.atan2(e.vy, e.vx) - Math.PI / 2;
            tempColor.set(GAME_THEME.enemy.hunter);
        }
        
        tempObj.rotation.set(0, 0, angle);
        const finalScale = baseScale * elastic;
        tempObj.scale.set(finalScale, finalScale, 1);
        
        tempObj.updateMatrix();
        hunterRef.current.setMatrixAt(hCount, tempObj.matrix);
        hunterRef.current.setColorAt(hCount, tempColor);
        hCount++;
      }
    }

    muncherRef.current.count = mCount;
    kamikazeRef.current.count = kCount;
    hunterRef.current.count = hCount;
    
    muncherRef.current.instanceMatrix.needsUpdate = true;
    // FIX: Add safety checks
    if (muncherRef.current.instanceColor) muncherRef.current.instanceColor.needsUpdate = true;
    
    kamikazeRef.current.instanceMatrix.needsUpdate = true;
    if (kamikazeRef.current.instanceColor) kamikazeRef.current.instanceColor.needsUpdate = true;
    
    hunterRef.current.instanceMatrix.needsUpdate = true;
    if (hunterRef.current.instanceColor) hunterRef.current.instanceColor.needsUpdate = true;
  });

  return (
    <group>
        <instancedMesh ref={muncherRef} args={[muncherGeo, undefined, MAX_ENEMIES]}>
            <meshBasicMaterial color="white" />
        </instancedMesh>
        <instancedMesh ref={kamikazeRef} args={[kamikazeGeo, undefined, MAX_ENEMIES]}>
            <meshBasicMaterial color="white" />
        </instancedMesh>
        <instancedMesh ref={hunterRef} args={[hunterGeo, undefined, MAX_ENEMIES]}>
            <meshBasicMaterial color="white" />
        </instancedMesh>
    </group>
  );
};


=====================================
FILE: ./src/game/components/GameDirector.tsx
=====================================
import { useFrame, useThree } from '@react-three/fiber';
import { GameEngine } from '../core/GameEngine';
import { useEffect } from 'react';

export const GameDirector = () => {
  const { viewport, size } = useThree();

  // FIXED: Using single updateViewport method
  useEffect(() => {
    GameEngine.updateViewport(viewport.width, viewport.height, size.width, size.height);
  }, [viewport, size]);

  useFrame((state, delta) => {
    GameEngine.update(delta, state.clock.elapsedTime);
  });

  return null;
};


=====================================
FILE: ./src/game/components/ScreenShaker.tsx
=====================================
import { useFrame, useThree } from '@react-three/fiber';
import { FXManager } from '../systems/FXManager';
import { MathUtils } from 'three';

export const ScreenShaker = () => {
  const { camera } = useThree();
  
  useFrame((state, delta) => {
    const trauma = FXManager.trauma;
    
    // Standard Decay
    FXManager.decay(delta);

    if (trauma > 0) {
      // "Shake" is trauma squared (Non-linear falloff)
      const shake = trauma * trauma;
      
      // Max offsets
      const maxAngle = 0.05; // Radians (~2.8 degrees)
      const maxOffset = 0.5; // World units
      
      // Perlin-ish noise using simple Math.random() for jitter
      // In a more complex setup we'd use SimplexNoise, but this is efficient
      const yaw = maxAngle * shake * (Math.random() * 2 - 1);
      const pitch = maxAngle * shake * (Math.random() * 2 - 1);
      const roll = maxAngle * shake * (Math.random() * 2 - 1);
      
      const offsetX = maxOffset * shake * (Math.random() * 2 - 1);
      const offsetY = maxOffset * shake * (Math.random() * 2 - 1);

      // Apply to Camera (Orthographic mainly cares about X/Y)
      camera.position.x = offsetX;
      camera.position.y = offsetY;
      camera.rotation.z = roll;
    } else {
      // Reset smoothly
      camera.position.x = MathUtils.lerp(camera.position.x, 0, delta * 10);
      camera.position.y = MathUtils.lerp(camera.position.y, 0, delta * 10);
      camera.rotation.z = MathUtils.lerp(camera.rotation.z, 0, delta * 10);
    }
  });

  return null;
};


=====================================
FILE: ./src/game/components/EffectsLayer.tsx
=====================================
import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';

export const EffectsLayer = () => {
  return (
    <EffectComposer disableNormalPass>
      {/* 
        BLOOM: Adds the "Neon" glow.
        luminanceThreshold: Only bright colors glow.
        intensity: How strong the glow is.
      */}
      <Bloom 
        luminanceThreshold={0.2} 
        mipmapBlur 
        intensity={1.5} 
        radius={0.4} 
      />
      
      {/* VIGNETTE: Darkens corners for focus */}
      <Vignette eskil={false} offset={0.1} darkness={0.5} />
    </EffectComposer>
  );
};


=====================================
FILE: ./src/game/hooks/usePanelRegistry.ts
=====================================
import { useEffect, useRef } from 'react';
import { useGameStore } from '../store/useGameStore';

export const usePanelRegistry = (id: string) => {
  const elementRef = useRef<HTMLDivElement>(null);
  const registerPanel = useGameStore((state) => state.registerPanel);
  const unregisterPanel = useGameStore((state) => state.unregisterPanel);

  useEffect(() => {
    const el = elementRef.current;
    if (!el) return;

    // Register the live DOM element
    registerPanel(id, el);

    return () => {
      unregisterPanel(id);
    };
  }, [id, registerPanel, unregisterPanel]);

  return elementRef;
};


=====================================
FILE: ./src/game/theme.ts
=====================================
export const GAME_THEME = {
  turret: {
    base: '#78F654',
    glow: '#C2FE9A',
    repair: '#00F0FF',
  },
  bullet: {
    plasma: '#FFFFFF',
    trail: '#78F654',
    hunter: '#F7D277', // Specific color for Hunter shots
  },
  enemy: {
    muncher: '#9E4EA5',
    kamikaze: '#FF003C',
    hunter: '#F7D277',
    charge: '#FFFFFF',  // Telegraph flash
  },
  hud: {
    text: '#78F654',
    warning: '#FF003C',
  },
  vfx: {
    spark: '#FFFFFF',
    damage: '#FF003C',
    heal: '#00F0FF',
    clash: '#F7D277',
  }
};


=====================================
FILE: ./src/game/events/GameEvents.ts
=====================================
// src/game/events/GameEvents.ts

export type GameEventType = 
  // --- COMBAT EVENTS ---
  | 'PLAYER_FIRED'           // Payload: { x: number, y: number }
  | 'PLAYER_HIT'             // Payload: { damage: number }
  | 'ENEMY_SPAWNED'          // Payload: { type: string, id: number }
  | 'ENEMY_DAMAGED'          // Payload: { id: number, damage: number, type: string }
  | 'ENEMY_DESTROYED'        // Payload: { id: number, type: string, x: number, y: number }
  | 'PROJECTILE_CLASH'       // Payload: { x: number, y: number }
  
  // --- PANEL EVENTS ---
  | 'PANEL_DAMAGED'          // Payload: { id: string, amount: number, currentHealth: number }
  | 'PANEL_HEALED'           // Payload: { id: string, amount: number }
  | 'PANEL_DESTROYED'        // Payload: { id: string }
  
  // --- SYSTEM EVENTS ---
  | 'GAME_START'             // Payload: null
  | 'GAME_OVER'              // Payload: { score: number }
  | 'THREAT_LEVEL_UP';       // Payload: { level: number }

export interface GameEventPayloads {
  PLAYER_FIRED: { x: number; y: number };
  PLAYER_HIT: { damage: number };
  ENEMY_SPAWNED: { type: string; id: number };
  ENEMY_DAMAGED: { id: number; damage: number; type: string };
  ENEMY_DESTROYED: { id: number; type: string; x: number; y: number };
  PROJECTILE_CLASH: { x: number; y: number };
  PANEL_DAMAGED: { id: string; amount: number; currentHealth: number };
  PANEL_HEALED: { id: string; amount: number };
  PANEL_DESTROYED: { id: string };
  GAME_START: null;
  GAME_OVER: { score: number };
  THREAT_LEVEL_UP: { level: number };
}


=====================================
FILE: ./src/game/events/GameEventBus.ts
=====================================
// src/game/events/GameEventBus.ts
import { GameEvents } from '../config/Identifiers';

// Re-export specific types if needed or just use strings
export type GameEventType = keyof typeof GameEvents;

class GameEventBusController {
  private listeners: Partial<Record<string, Function[]>> = {};

  public subscribe(event: string, handler: Function): () => void {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event]!.push(handler);

    return () => {
      this.listeners[event] = this.listeners[event]!.filter(h => h !== handler);
    };
  }

  public emit(event: string, payload: any): void {
    if (!this.listeners[event]) return;
    [...this.listeners[event]!].forEach(handler => handler(payload));
  }

  public clear(): void {
    this.listeners = {};
  }
}

export const GameEventBus = new GameEventBusController();


=====================================
FILE: ./src/game/systems/CollisionSystem.ts
=====================================
import { EntitySystem } from './EntitySystem';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents, EnemyTypes } from '../config/Identifiers';
import { useGameStore } from '../store/useGameStore';

export class CollisionSystem {
  private entitySystem: EntitySystem;

  constructor(entitySystem: EntitySystem) {
    this.entitySystem = entitySystem;
  }

  public update(cursor: {x: number, y: number}) {
    this.checkPlayerBulletCollisions();
    this.checkEnemyBulletCollisions(cursor);
    this.checkProjectileClash();
  }

  private checkPlayerBulletCollisions() {
    const bullets = this.entitySystem.bullets;
    const enemies = this.entitySystem.enemies;

    for (const b of bullets) {
      if (!b.active) continue;
      for (const e of enemies) {
        if (!e.active) continue;
        
        const dx = b.x - e.x;
        const dy = b.y - e.y;
        const distSq = dx*dx + dy*dy;
        const radiusSum = b.radius + e.radius;

        if (distSq < radiusSum * radiusSum) {
          e.hp--;
          b.active = false;
          GameEventBus.emit(GameEvents.ENEMY_DAMAGED, { id: e.id, damage: 1, type: e.type });

          if (e.hp <= 0) {
            e.active = false;
            const color = e.type === EnemyTypes.HUNTER ? '#F7D277' : e.type === EnemyTypes.KAMIKAZE ? '#FF003C' : '#9E4EA5';
            this.entitySystem.spawnParticle(e.x, e.y, color, 8);
            GameEventBus.emit(GameEvents.ENEMY_DESTROYED, { id: e.id, type: e.type, x: e.x, y: e.y });
          } else {
            this.entitySystem.spawnParticle(b.x, b.y, '#FFF', 2);
          }
          break;
        }
      }
    }
  }

  private checkEnemyBulletCollisions(cursor: {x: number, y: number}) {
    const bullets = this.entitySystem.enemyBullets;
    
    for (const eb of bullets) {
        if (!eb.active) continue;
        const dx = eb.x - cursor.x;
        const dy = eb.y - cursor.y;
        const distSq = dx*dx + dy*dy;
        
        if (distSq < (eb.radius + 0.5) ** 2) {
            eb.active = false;
            
            // LOGIC: If player is ALIVE, take damage.
            // If player is DEAD (Downed), take huge progress penalty.
            
            const store = useGameStore.getState();
            if (store.playerHealth > 0) {
                 GameEventBus.emit(GameEvents.PLAYER_HIT, { damage: 10 });
            } else {
                 // Player is trying to reboot
                 store.damageRebootProgress(30); // Lose 30% progress on hit
                 GameEventBus.emit(GameEvents.PLAYER_HIT, { damage: 0 }); // Visual shake only
            }
            
            this.entitySystem.spawnParticle(eb.x, eb.y, '#FF003C', 5);
        }
    }
  }

  private checkProjectileClash() {
    const pBullets = this.entitySystem.bullets;
    const eBullets = this.entitySystem.enemyBullets;

    for (const pb of pBullets) {
        if (!pb.active) continue;
        for (const eb of eBullets) {
            if (!eb.active) continue;
            
            const dx = pb.x - eb.x;
            const dy = pb.y - eb.y;
            const distSq = dx*dx + dy*dy;
            
            if (distSq < (pb.radius + eb.radius) ** 2) {
                // CLASH LOGIC
                pb.active = false; // Player bullet always dies
                
                // Enemy bullet takes damage
                eb.hp = (eb.hp || 1) - 1;
                
                if (eb.hp <= 0) {
                    eb.active = false;
                    GameEventBus.emit(GameEvents.PROJECTILE_CLASH, { x: eb.x, y: eb.y });
                    this.entitySystem.spawnParticle(eb.x, eb.y, '#F7D277', 6);
                } else {
                    // Flash or spark indicating it survived
                    this.entitySystem.spawnParticle(eb.x, eb.y, '#FFFFFF', 2);
                }
                
                break;
            }
        }
    }
  }
}


=====================================
FILE: ./src/game/systems/InteractionSystem.ts
=====================================
import { useGameStore } from '../store/useGameStore';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../config/Identifiers';
import { ServiceLocator } from '../core/ServiceLocator';
import { ViewportHelper } from '../utils/ViewportHelper';

export class InteractionSystem {
  private lastRepairTime = 0;
  private REPAIR_RATE = 0.05;
  
  public update(time: number, cursor: {x: number, y: number}): boolean {
    const store = useGameStore.getState();
    if (!store.isPlaying) return false;

    if (time < this.lastRepairTime + this.REPAIR_RATE) return false;

    const panels = store.panels;
    const healFn = store.healPanel;
    const decayFn = store.decayReboot;
    const tickReboot = store.tickPlayerReboot; 
    
    let isRepairing = false;
    let repairedPanelId = null;
    let isRebootingPlayer = false;

    // --- 1. PLAYER REVIVAL LOGIC ---
    if (store.playerHealth <= 0) {
        const identityPanel = panels['identity'];
        
        // Allow revival even if panel is destroyed
        if (identityPanel) {
            const rect = ViewportHelper.getPanelWorldRect(identityPanel);
            if (rect) {
                // Expanded Hitbox for easier revival
                const padding = 2.0; 
                
                if (
                    cursor.x >= rect.left - padding && 
                    cursor.x <= rect.right + padding && 
                    cursor.y >= rect.bottom - padding && 
                    cursor.y <= rect.top + padding
                ) {
                    // INCREASED SPEED: 2.5 per tick (approx 2s to revive)
                    tickReboot(2.5); 
                    
                    isRepairing = true;
                    isRebootingPlayer = true;
                    this.lastRepairTime = time;
                    
                    if (Math.random() > 0.5) {
                        ServiceLocator.entitySystem.spawnParticle(cursor.x, cursor.y, '#eae747', 1);
                    }
                }
            }
        }
        
        // REDUCED DECAY: -2.0 per tick (slower drain if you slip off)
        if (!isRebootingPlayer && store.playerRebootProgress > 0) {
            tickReboot(-2.0);
        }
        
        if (isRebootingPlayer) return true; 
    }

    // --- 2. PANEL REPAIR LOGIC ---
    for (const pKey in panels) {
      const p = panels[pKey];
      
      if (!p.isDestroyed && p.health >= 1000) continue;

      const r = ViewportHelper.getPanelWorldRect(p);
      if (!r) continue;

      if (
        cursor.x >= r.left && 
        cursor.x <= r.right && 
        cursor.y >= r.bottom && 
        cursor.y <= r.top
      ) {
        isRepairing = true;
        repairedPanelId = p.id;
        
        healFn(p.id, 10); 
        this.lastRepairTime = time;
        
        if (!p.isDestroyed) {
            GameEventBus.emit(GameEvents.PANEL_HEALED, { id: p.id, amount: 10 });
        }
        
        if (Math.random() > 0.6) {
            const color = p.isDestroyed ? '#9E4EA5' : '#00F0FF'; 
            ServiceLocator.entitySystem.spawnParticle(cursor.x, cursor.y, color, 1);
        }
        break; 
      }
    }

    // --- 3. DECAY LOGIC (Panels) ---
    for (const pKey in panels) {
        const p = panels[pKey];
        if (p.isDestroyed && p.id !== repairedPanelId && p.health > 0) {
            decayFn(p.id, 5); 
        }
    }
    
    return isRepairing;
  }
}


=====================================
FILE: ./src/game/systems/PlayerSystem.ts
=====================================
import { ServiceLocator } from '../core/ServiceLocator';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../config/Identifiers';
import { PLAYER_CONFIG } from '../config/PlayerConfig';
import { ENEMY_CONFIG } from '../config/EnemyConfig';
import { useGameStore } from '../store/useGameStore';

export class PlayerSystem {
  private lastFireTime = 0;

  constructor() {
    this.setupListeners();
  }

  private setupListeners() {
    // 1. Damage
    GameEventBus.subscribe(GameEvents.PLAYER_HIT, (payload: any) => {
      const { damage } = payload;
      const store = useGameStore.getState();
      store.damagePlayer(damage);
      
      if (store.playerHealth <= 0) {
        this.handlePlayerDeath();
      }
    });

    // 2. Score & XP
    GameEventBus.subscribe(GameEvents.ENEMY_DESTROYED, (payload: any) => {
      const { type } = payload;
      const config = ENEMY_CONFIG[type];
      if (config) {
        useGameStore.getState().addScore(config.score);
        useGameStore.getState().addXp(config.score);
      }
    });
  }

  private handlePlayerDeath() {
    const store = useGameStore.getState();
    const identityPanel = store.panels['identity'];

    // LOGIC CHANGE:
    // Only Game Over if the Identity Core is ALSO destroyed.
    // Otherwise, the player is just "Downed" and must reboot manually.
    if (identityPanel && identityPanel.isDestroyed) {
        store.stopGame();
    } else {
        // Optional: Trigger a "System Down" sound or visual event here
        // The store state (playerHealth <= 0) automatically triggers the UI changes.
    }
  }

  public update(time: number) {
    if (!useGameStore.getState().isPlaying) return;
    if (useGameStore.getState().playerHealth <= 0) return;

    // --- UPGRADE LOGIC: FIRE RATE ---
    const upgrades = useGameStore.getState().activeUpgrades;
    const rapidLevel = upgrades['RAPID_FIRE'] || 0;
    
    const currentFireRate = PLAYER_CONFIG.fireRate * Math.pow(0.85, rapidLevel);

    if (time > this.lastFireTime + currentFireRate) {
      this.attemptAutoFire(time);
    }
  }

  private attemptAutoFire(time: number) {
    const cursor = ServiceLocator.inputSystem.getCursorPosition();
    const enemies = ServiceLocator.entitySystem.enemies;

    let nearestDist = Infinity;
    const RANGE = 12; 
    let targetEnemy: any = null;

    for (const e of enemies) {
      if (!e.active) continue;
      const dx = e.x - cursor.x;
      const dy = e.y - cursor.y;
      const dist = dx*dx + dy*dy; 

      if (dist < (RANGE * RANGE)) {
        if (dist < nearestDist) {
          nearestDist = dist;
          targetEnemy = e;
        }
      }
    }

    if (targetEnemy) {
      const dx = targetEnemy.x - cursor.x;
      const dy = targetEnemy.y - cursor.y;
      
      const upgrades = useGameStore.getState().activeUpgrades;
      const multiLevel = upgrades['MULTI_SHOT'] || 0;
      
      const projectileCount = 1 + (multiLevel * 2);
      const spreadAngle = 0.2; 

      const baseAngle = Math.atan2(dy, dx);
      const startAngle = baseAngle - ((projectileCount - 1) * spreadAngle) / 2;

      for (let i = 0; i < projectileCount; i++) {
          const angle = startAngle + (i * spreadAngle);
          const vx = Math.cos(angle) * PLAYER_CONFIG.bulletSpeed;
          const vy = Math.sin(angle) * PLAYER_CONFIG.bulletSpeed;

          ServiceLocator.entitySystem.spawnBullet(
              cursor.x, 
              cursor.y, 
              vx, 
              vy, 
              false, 
              PLAYER_CONFIG.bulletLife, 
              PLAYER_CONFIG.bulletRadius
          );
      }
      
      GameEventBus.emit(GameEvents.PLAYER_FIRED, { x: cursor.x, y: cursor.y });
      this.lastFireTime = time;
    }
  }
}


=====================================
FILE: ./src/game/systems/EntitySystem.ts
=====================================
import { Enemy, Bullet, Particle } from '../types/game.types';
import { Behaviors, AIContext } from '../logic/ai/EnemyBehaviors';
import { ENEMY_CONFIG } from '../config/EnemyConfig';
import { GameEvents, EnemyType, EnemyTypes } from '../config/Identifiers';
import { GameEventBus } from '../events/GameEventBus';
import { useGameStore } from '../store/useGameStore';
import { ViewportHelper } from '../utils/ViewportHelper';

export class EntitySystem {
  public enemies: Enemy[] = [];
  public bullets: Bullet[] = [];
  public enemyBullets: Bullet[] = [];
  public particles: Particle[] = [];

  private idCounter = 0;
  private currentTime = 0;

  public spawnEnemy(type: EnemyType): void {
    const config = ENEMY_CONFIG[type];
    const angle = Math.random() * Math.PI * 2;
    const radius = 60; 

    const enemy: Enemy = {
      id: this.idCounter++,
      x: Math.cos(angle) * radius,
      y: Math.sin(angle) * radius,
      vx: 0, vy: 0,
      radius: config.radius,
      hp: config.hp,
      type,
      active: true,
      orbitAngle: Math.random() * Math.PI * 2,
      spawnTime: this.currentTime 
    };

    this.enemies.push(enemy);
    GameEventBus.emit(GameEvents.ENEMY_SPAWNED, { type: type, id: enemy.id });
  }

  public spawnBullet(x: number, y: number, vx: number, vy: number, isEnemy: boolean, life = 1.5, radius = 0.2): void {
    const list = isEnemy ? this.enemyBullets : this.bullets;
    
    // Hunter bullets (isEnemy=true) get 2 HP, normal bullets get 1
    const hp = isEnemy ? 2 : 1; 

    list.push({
      id: this.idCounter++,
      x, y, vx, vy,
      life,
      active: true,
      isEnemy,
      radius,
      hp, 
      spawnTime: this.currentTime
    });
  }

  public spawnParticle(x: number, y: number, color: string, count: number): void {
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = Math.random() * 10 + 5;
      this.particles.push({
        id: this.idCounter++,
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 0.5 + Math.random() * 0.5,
        maxLife: 1.0,
        active: true,
        radius: 0.1,
        color,
        spawnTime: this.currentTime
      });
    }
  }

  public update(delta: number, time: number, cursor: {x: number, y: number}, doDamageTick: boolean) {
    this.currentTime = time;
    this.updateEnemies(delta, time, cursor, doDamageTick);
    this.updateBullets(this.bullets, delta);
    this.updateBullets(this.enemyBullets, delta);
    this.updateParticles(delta);
  }

  private updateEnemies(delta: number, time: number, cursor: {x: number, y: number}, doDamageTick: boolean) {
    const panels = useGameStore.getState().panels;
    
    const worldPanels = Object.values(panels)
      .filter(p => !p.isDestroyed)
      .map(p => ViewportHelper.getPanelWorldRect(p))
      .filter(r => r !== null);

    const ctx: AIContext = {
      playerPos: cursor,
      panels: worldPanels,
      delta: delta,
      time: time,
      doDamageTick: doDamageTick,
      spawnProjectile: (x, y, vx, vy) => this.spawnBullet(x, y, vx, vy, true, 3.0, 0.9),
      triggerExplosion: (x, y, color) => this.spawnParticle(x, y, color, 20),
      emitEvent: (name, payload) => GameEventBus.emit(name as any, payload),
      damagePanel: (id, amount) => {
        useGameStore.getState().damagePanel(id, amount);
        const currentHp = panels[id].health;
        if (currentHp > 0) {
             GameEventBus.emit(GameEvents.PANEL_DAMAGED, { 
                id: id, 
                amount: amount, 
                currentHealth: currentHp - amount
             });
        }
      }
    };

    for (const e of this.enemies) {
      if (!e.active) continue;
      const behavior = Behaviors[e.type];
      if (behavior) {
        behavior.update(e, ctx);
      }
    }
    
    this.enemies = this.enemies.filter(e => e.active);
  }

  private updateBullets(list: Bullet[], delta: number) {
    for (const b of list) {
      if (!b.active) continue;
      b.x += b.vx * delta;
      b.y += b.vy * delta;
      b.life -= delta;
      if (b.life <= 0) b.active = false;
    }
    
    if (list === this.bullets) {
       this.bullets = this.bullets.filter(b => b.active);
    } else {
       this.enemyBullets = this.enemyBullets.filter(b => b.active);
    }
  }

  private updateParticles(delta: number) {
    for (const p of this.particles) {
      if (!p.active) continue;
      p.x += p.vx * delta;
      p.y += p.vy * delta;
      p.life -= delta;
      if (p.life <= 0) p.active = false;
    }
    this.particles = this.particles.filter(p => p.active);
  }
}


=====================================
FILE: ./src/game/systems/FXManager.ts
=====================================
// src/game/systems/FXManager.ts
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../config/Identifiers';

class FXManagerController {
  private initialized = false;
  
  public trauma = 0;

  public init() {
    if (this.initialized) return;
    
    // --- EVENT WIRING ---
    
    GameEventBus.subscribe(GameEvents.PANEL_DESTROYED, () => {
        this.addTrauma(0.55);
    });
    
    GameEventBus.subscribe(GameEvents.PLAYER_HIT, () => {
        this.addTrauma(0.35);
    });
    
    this.initialized = true;
  }

  public addTrauma(amount: number) {
    this.trauma = Math.min(1.0, this.trauma + amount);
  }

  public decay(delta: number) {
    if (this.trauma > 0) {
      this.trauma = Math.max(0, this.trauma - (delta * 0.8));
    }
  }
}

export const FXManager = new FXManagerController();


=====================================
FILE: ./src/game/systems/InputSystem.ts
=====================================
export class InputSystem {
  private _cursor = { x: 0, y: 0 };

  public updateCursor(x: number, y: number) {
    this._cursor.x = x;
    this._cursor.y = y;
  }

  public getCursorPosition() {
    return this._cursor;
  }
}


=====================================
FILE: ./src/game/systems/BreachSystem.ts
=====================================
import { ServiceLocator } from '../core/ServiceLocator';
import { useGameStore } from '../store/useGameStore';
import { ViewportHelper } from '../utils/ViewportHelper';
import { EnemyTypes } from '../config/Identifiers';

export class BreachSystem {
  private lastSpawnTime = 0;
  private SPAWN_INTERVAL = 3.0; // Seconds between breach waves

  public update(time: number) {
    if (!useGameStore.getState().isPlaying) return;

    if (time > this.lastSpawnTime + this.SPAWN_INTERVAL) {
      this.spawnBreachEnemies();
      this.lastSpawnTime = time;
    }
  }

  private spawnBreachEnemies() {
    const panels = useGameStore.getState().panels;
    
    // Find dead panels
    const destroyedPanels = Object.values(panels).filter(p => p.isDestroyed);
    
    if (destroyedPanels.length === 0) return;

    for (const p of destroyedPanels) {
      const rect = ViewportHelper.getPanelWorldRect(p);
      if (!rect) continue;

      // Spawn a fast Muncher or Kamikaze from the center of the dead panel
      // We manually inject the spawn via EntitySystem
      const type = Math.random() > 0.5 ? EnemyTypes.MUNCHER : EnemyTypes.KAMIKAZE;
      const sys = ServiceLocator.entitySystem;
      
      // Manually push to array to override the random position logic in spawnEnemy()
      // OR better: Add a spawnAt() method to EntitySystem. 
      // For now, we will use the internal spawn logic but modify the position immediately after.
      
      // Cleaner approach: Just instantiate data here and push to system.
      // But EntitySystem encapsulates ID logic.
      
      // Let's create a specific spawn method in EntitySystem for this or hack it.
      // Since we want to stick to patterns, let's look at EntitySystem.
      // It lacks a "SpawnAt" method. We will access the array directly for now 
      // to avoid modifying EntitySystem again in this step, but ideal refactor adds spawnAt().
      
      // Actually, let's just modify EntitySystem in the next block if needed.
      // For now, we spawn normally and move it.
      
      sys.spawnEnemy(type);
      const enemy = sys.enemies[sys.enemies.length - 1];
      if (enemy) {
        enemy.x = rect.x;
        enemy.y = rect.y;
        // Give them a little outward velocity immediately
        enemy.vx = (Math.random() - 0.5) * 10;
        enemy.vy = (Math.random() - 0.5) * 10;
      }
    }
  }
}


=====================================
FILE: ./src/game/systems/WaveSystem.ts
=====================================
import { ServiceLocator } from '../core/ServiceLocator';
import { WAVE_CONFIG } from '../config/EnemyConfig';
import { EnemyTypes, EnemyType } from '../config/Identifiers';

export class WaveSystem {
  private lastSpawnTime = 0;

  public update(time: number, threatLevel: number) {
    if (time > this.lastSpawnTime + (WAVE_CONFIG.baseSpawnInterval / threatLevel)) {
      this.spawnRandomEnemy();
      this.lastSpawnTime = time;
    }
  }

  private spawnRandomEnemy() {
    const rand = Math.random();
    let type: EnemyType = EnemyTypes.MUNCHER;
    
    // Adjusted Probabilities for "More Munchers"
    // 0.0 - 0.60: Muncher (60%)
    // 0.60 - 0.90: Kamikaze (30%)
    // 0.90 - 1.00: Hunter (10%)
    
    if (rand < 0.60) type = EnemyTypes.MUNCHER;
    else if (rand < 0.90) type = EnemyTypes.KAMIKAZE;
    else type = EnemyTypes.HUNTER;

    ServiceLocator.entitySystem.spawnEnemy(type);
  }
}


=====================================
FILE: ./src/game/store/useGameStore.ts
=====================================
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { GameState } from '../types/game.types';
import { PLAYER_CONFIG } from '../config/PlayerConfig';

const MAX_PANEL_HEALTH = 1000;

export type UpgradeOption = 'RAPID_FIRE' | 'MULTI_SHOT' | 'SPEED_UP' | 'REPAIR_NANITES';

interface ExtendedGameState extends GameState {
  playerHealth: number;
  maxPlayerHealth: number;
  playerRebootProgress: number;
  score: number;
  highScore: number;
  
  xp: number;
  xpToNextLevel: number;
  level: number;
  upgradePoints: number; // NEW: Stackable points
  activeUpgrades: Record<UpgradeOption, number>;
  
  systemIntegrity: number;
  
  damagePlayer: (amount: number) => void;
  healPlayer: (amount: number) => void;
  tickPlayerReboot: (amount: number) => void;
  damageRebootProgress: (amount: number) => void; // NEW: Penalty on hit
  healPanel: (id: string, amount: number) => void;
  decayReboot: (id: string, amount: number) => void;
  addScore: (amount: number) => void;
  addXp: (amount: number) => void;
  selectUpgrade: (option: UpgradeOption) => void;
  resetGame: () => void;
  recalculateIntegrity: () => void;
}

export const useGameStore = create<ExtendedGameState>()(
  persist(
    (set, get) => ({
      isPlaying: false,
      score: 0,
      highScore: 0,
      threatLevel: 1,
      panels: {},
      playerHealth: PLAYER_CONFIG.maxHealth,
      maxPlayerHealth: PLAYER_CONFIG.maxHealth,
      playerRebootProgress: 0,
      
      xp: 0,
      xpToNextLevel: PLAYER_CONFIG.baseXpRequirement,
      level: 1,
      upgradePoints: 0,
      activeUpgrades: {
        'RAPID_FIRE': 0,
        'MULTI_SHOT': 0,
        'SPEED_UP': 0,
        'REPAIR_NANITES': 0
      },
      
      systemIntegrity: 100,

      startGame: () => {
        if (get().isPlaying) return;
        set({ 
            isPlaying: true, 
            score: 0, 
            threatLevel: 1,
            playerHealth: PLAYER_CONFIG.maxHealth,
            playerRebootProgress: 0,
            xp: 0,
            level: 1,
            xpToNextLevel: PLAYER_CONFIG.baseXpRequirement,
            upgradePoints: 0,
            activeUpgrades: {
                'RAPID_FIRE': 0,
                'MULTI_SHOT': 0,
                'SPEED_UP': 0,
                'REPAIR_NANITES': 0
            },
            panels: Object.fromEntries(
                Object.entries(get().panels).map(([k, v]) => [k, { ...v, health: MAX_PANEL_HEALTH, isDestroyed: false }])
            )
        });
      },
      
      stopGame: () => {
        const { score, highScore } = get();
        set({ 
          isPlaying: false,
          highScore: Math.max(score, highScore)
        });
      },

      addScore: (amount) => set((state) => ({ 
        score: state.score + amount 
      })),

      addXp: (amount) => set((state) => {
        let newXp = state.xp + amount;
        let newLevel = state.level;
        let nextReq = state.xpToNextLevel;
        let newPoints = state.upgradePoints;

        // Loop to handle massive XP gains (multiple levels at once)
        while (newXp >= nextReq) {
          newXp -= nextReq;
          newLevel++;
          newPoints++; // Stack points
          nextReq = Math.floor(nextReq * PLAYER_CONFIG.xpScalingFactor);
        }

        return {
          xp: newXp,
          level: newLevel,
          xpToNextLevel: nextReq,
          upgradePoints: newPoints
        };
      }),

      selectUpgrade: (option) => set((state) => {
        if (state.upgradePoints <= 0) return state;
        const currentLevel = state.activeUpgrades[option] || 0;
        return {
            activeUpgrades: {
                ...state.activeUpgrades,
                [option]: currentLevel + 1
            },
            upgradePoints: state.upgradePoints - 1
        };
      }),

      damagePlayer: (amount) => set((state) => {
        const newHealth = Math.max(0, state.playerHealth - amount);
        return { playerHealth: newHealth };
      }),

      healPlayer: (amount) => set((state) => ({
        playerHealth: Math.min(state.maxPlayerHealth, state.playerHealth + amount)
      })),
      
      tickPlayerReboot: (amount) => set((state) => {
        if (state.playerHealth > 0) return { playerRebootProgress: 0 };
        const newProgress = Math.max(0, Math.min(100, state.playerRebootProgress + amount));
        if (newProgress >= 100) {
            return {
                playerRebootProgress: 0,
                playerHealth: state.maxPlayerHealth / 2 // Revive with 50% HP
            };
        }
        return { playerRebootProgress: newProgress };
      }),
      
      damageRebootProgress: (amount) => set((state) => {
        if (state.playerHealth > 0) return state;
        // Big penalty for getting hit while downed
        return { playerRebootProgress: Math.max(0, state.playerRebootProgress - amount) };
      }),

      resetGame: () => set({
        score: 0,
        playerHealth: PLAYER_CONFIG.maxHealth,
        isPlaying: true
      }),

      recalculateIntegrity: () => {
        const { panels } = get();
        const pKeys = Object.keys(panels);
        if (pKeys.length === 0) return;
        let currentSum = 0;
        let maxSum = pKeys.length * MAX_PANEL_HEALTH;
        for (const key of pKeys) {
          const p = panels[key];
          if (!p.isDestroyed) currentSum += p.health;
        }
        set({ systemIntegrity: (currentSum / maxSum) * 100 });
      },

      registerPanel: (id, element) => set((state) => ({
        panels: { ...state.panels, [id]: { id, element, health: MAX_PANEL_HEALTH, isDestroyed: false } }
      })),

      unregisterPanel: (id) => set((state) => {
        const newPanels = { ...state.panels };
        delete newPanels[id];
        return { panels: newPanels };
      }),

      damagePanel: (id, amount) => set((state) => {
        const panel = state.panels[id];
        if (!panel || panel.isDestroyed) return state;
        const newHealth = Math.max(0, panel.health - amount);
        return { panels: { ...state.panels, [id]: { ...panel, health: newHealth, isDestroyed: newHealth <= 0 } } };
      }),

      healPanel: (id, amount) => set((state) => {
        const panel = state.panels[id];
        if (!panel) return state;
        if (!panel.isDestroyed && panel.health >= MAX_PANEL_HEALTH) return state;
        let newHealth = Math.min(MAX_PANEL_HEALTH, panel.health + amount);
        let wasDestroyed = panel.isDestroyed;
        if (wasDestroyed && newHealth >= MAX_PANEL_HEALTH) {
            wasDestroyed = false;
            newHealth = 500;
        }
        return { panels: { ...state.panels, [id]: { ...panel, health: newHealth, isDestroyed: wasDestroyed } } };
      }),

      decayReboot: (id, amount) => set((state) => {
        const panel = state.panels[id];
        if (!panel || !panel.isDestroyed) return state;
        if (panel.health <= 0) return state;
        const newProgress = Math.max(0, panel.health - amount);
        return { panels: { ...state.panels, [id]: { ...panel, health: newProgress } } };
      }),
    }),
    {
      name: 'mesoelfy-os-storage',
      partialize: (state) => ({ highScore: state.highScore }),
    }
  )
);


=====================================
FILE: ./src/styles/globals.css
=====================================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 255, 65;
}

html {
  background-color: #000000;
}

body {
  color: #78F654;
  background-color: #000000;
  overflow: hidden; 
  font-family: 'Courier New', monospace;
}

/* --- HACKER SCROLLBAR --- */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #050505; 
  border-left: 1px solid #15530A;
}

::-webkit-scrollbar-thumb {
  background: #0BD426; 
  border: 1px solid #000;
  border-radius: 2px;
}

::-webkit-scrollbar-thumb:hover {
  background: #78F654;
}

/* Utilities */
.glitch-text {
  text-shadow: 2px 0 #ff003c, -2px 0 #008f11;
}

.clip-corner-btn {
  clip-path: polygon(
    0 0, 
    100% 0, 
    100% 70%, 
    90% 100%, 
    0 100%
  );
}

/* --- NUCLEAR OPTION: HIDE NEXT.JS INDICATORS --- */
/* Force hides the "N" button, build spinners, and static route indicators */
body > div[data-nextjs-toast],
body > div[data-nextjs-dialog-overlay],
#next-route-announcer,
[class*="nextjs-toast"],
[class*="build-activity"],
[class*="static-route-indicator"] {
  display: none !important;
  opacity: 0 !important;
  pointer-events: none !important;
  visibility: hidden !important;
}


=====================================
FILE: ./src/scene/props/MiniCrystalCanvas.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { Float, MeshDistortMaterial } from '@react-three/drei';
import { useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';

const SpinningGem = () => {
  const meshRef = useRef<THREE.Mesh>(null);

  useFrame((state) => {
    if (meshRef.current) {
      meshRef.current.rotation.y += 0.01;
      meshRef.current.rotation.z += 0.005;
    }
  });

  return (
    <Float speed={2} rotationIntensity={0.5} floatIntensity={0.5}>
      <mesh ref={meshRef} scale={1.8}>
        <octahedronGeometry args={[1, 0]} />
        <MeshDistortMaterial
          color="#78F654"
          emissive="#15530A"
          roughness={0.1}
          metalness={0.8}
          distort={0.3}
          speed={2}
          wireframe
        />
      </mesh>
    </Float>
  );
};

export const MiniCrystalCanvas = () => {
  return (
    <div className="w-full h-full bg-black">
      <Canvas 
        camera={{ position: [0, 0, 5] }} 
        gl={{ alpha: true }}
        style={{ background: '#000000' }} // <--- THE FIX: Force canvas to be black instantly
      >
        <ambientLight intensity={0.5} />
        <pointLight position={[10, 10, 10]} intensity={1} color="#C2FE9A" />
        <SpinningGem />
      </Canvas>
    </div>
  );
};


=====================================
FILE: ./src/scene/props/SoulCrystal.tsx
=====================================
import { useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import { Float, MeshDistortMaterial } from '@react-three/drei';
import * as THREE from 'three';

export const SoulCrystal = () => {
  const meshRef = useRef<THREE.Mesh>(null);

  useFrame((state) => {
    if (meshRef.current) {
      const t = state.clock.getElapsedTime();
      meshRef.current.rotation.y = t * 0.5;
      meshRef.current.rotation.z = t * 0.2;
    }
  });

  return (
    <Float speed={2} rotationIntensity={0.5} floatIntensity={1}>
      <mesh ref={meshRef} scale={1.5}>
        <octahedronGeometry args={[1, 0]} />
        <MeshDistortMaterial
          color="#00ff41"
          emissive="#003300"
          roughness={0}
          metalness={1}
          distort={0.4}
          speed={2}
          wireframe
        />
      </mesh>
      {/* Inner Core Glow */}
      <mesh scale={0.8}>
        <octahedronGeometry args={[1, 0]} />
        <meshBasicMaterial color="#ccffcc" transparent opacity={0.5} />
      </mesh>
    </Float>
  );
};


=====================================
FILE: ./src/scene/canvas/SceneCanvas.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { MatrixGrid } from '../effects/MatrixGrid';
import { Suspense } from 'react';
import { clsx } from 'clsx';

interface SceneCanvasProps {
  children?: React.ReactNode;
  className?: string;
}

export const SceneCanvas = ({ children, className }: SceneCanvasProps) => {
  return (
    <div className={clsx("fixed inset-0 w-full h-full z-0 pointer-events-none transition-all duration-[2000ms] ease-out", className)}>
      <Canvas 
        camera={{ position: [0, 2, 10], fov: 45 }}
        gl={{ antialias: true, alpha: false }} // Alpha false = performance gain + no transparency issues
        dpr={[1, 2]}
        style={{ background: '#000000' }} // <--- THE FIX: Force canvas to be black instantly
      >
        <color attach="background" args={['#000']} />
        <fog attach="fog" args={['#000', 2, 30]} />
        
        <MatrixGrid />
        
        <ambientLight intensity={0.5} />
        <pointLight position={[10, 10, 10]} intensity={1} color="#78F654" />
        
        <Suspense fallback={null}>
           {children}
        </Suspense>
      </Canvas>
    </div>
  );
};


=====================================
FILE: ./src/scene/effects/FireTransition.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import * as THREE from 'three';
import { useStore } from '@/core/store/useStore';

// Vertex Shader: Standard full-screen quad
const vertexShader = `
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = vec4(position, 1.0);
  }
`;

// Fragment Shader: The Burn Logic
const fragmentShader = `
  uniform float uTime;
  uniform float uProgress;
  uniform vec2 uResolution;
  varying vec2 vUv;

  // Simplex Noise 2D
  vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
  float snoise(vec2 v){
    const vec4 C = vec4(0.211324865405187, 0.366025403784439,
             -0.577350269189626, 0.024390243902439);
    vec2 i  = floor(v + dot(v, C.yy) );
    vec2 x0 = v -   i + dot(i, C.xx);
    vec2 i1;
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod(i, 289.0);
    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
    + i.x + vec3(0.0, i1.x, 1.0 ));
    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
    m = m*m ;
    m = m*m ;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
    vec3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
  }

  void main() {
    // Noise Scale
    float noise = snoise(vUv * 3.0 + vec2(0.0, uTime * 0.2));
    
    // Calculate Burn Edge
    // We modify progress to ensure it goes fully from black (-1) to clear (1)
    float prog = (uProgress * 2.5) - 1.0; 
    
    float alpha = smoothstep(prog, prog + 0.2, noise);
    
    // Edge Color (The Green Flame)
    float edge = 1.0 - smoothstep(prog, prog + 0.05, noise);
    vec3 flameColor = vec3(0.47, 0.96, 0.33); // #78F654
    
    vec3 finalColor = mix(vec3(0.0), flameColor, edge);

    if (alpha <= 0.01) discard; // Cut out the transparent parts

    gl_FragColor = vec4(finalColor, alpha);
  }
`;

export const FireTransition = () => {
  const meshRef = useRef<THREE.Mesh>(null);
  const materialRef = useRef<THREE.ShaderMaterial>(null);
  const { introDone } = useStore();
  const { viewport } = useThree();

  // Animation State
  const animState = useRef({ value: 0 }); // 0 = Black, 1 = Clear

  useFrame((state, delta) => {
    if (!materialRef.current) return;

    // Update Time
    materialRef.current.uniforms.uTime.value = state.clock.elapsedTime;

    // Logic: If Intro is DONE, animate progress 0 -> 1
    // If Intro is NOT DONE, keep progress at 0 (Solid Black)
    const target = introDone ? 1 : 0;
    
    // Linear Interpolation (Lerp) for smoothness
    // Adjust 1.5 to make fire faster/slower
    animState.current.value = THREE.MathUtils.lerp(animState.current.value, target, delta * 1.5);
    
    materialRef.current.uniforms.uProgress.value = animState.current.value;

    // Disable rendering if fully cleared to save GPU
    if (meshRef.current) {
        meshRef.current.visible = animState.current.value < 0.99;
    }
  });

  const uniforms = useMemo(
    () => ({
      uTime: { value: 0 },
      uProgress: { value: 0 }, // Starts Black
      uResolution: { value: new THREE.Vector2(viewport.width, viewport.height) },
    }),
    [viewport]
  );

  return (
    <mesh ref={meshRef} position={[0, 0, 1]}> 
      {/* Plane fills the screen */}
      <planeGeometry args={[viewport.width, viewport.height]} />
      <shaderMaterial
        ref={materialRef}
        vertexShader={vertexShader}
        fragmentShader={fragmentShader}
        uniforms={uniforms}
        transparent={true}
        depthTest={false} // Always draw on top
      />
    </mesh>
  );
};


=====================================
FILE: ./src/scene/effects/MatrixGrid.tsx
=====================================
import { Grid } from '@react-three/drei';
import { useFrame } from '@react-three/fiber';
import { useRef } from 'react';
import * as THREE from 'three';

export const MatrixGrid = () => {
  const groupRef = useRef<THREE.Group>(null);

  const SECTION_SIZE = 5;   
  const SPEED = 0.5;

  useFrame((state, delta) => {
    if (groupRef.current) {
      groupRef.current.position.z += SPEED * delta;
      
      if (groupRef.current.position.z >= SECTION_SIZE) {
        groupRef.current.position.z = 0;
      }
    }
  });

  return (
    <group ref={groupRef} position={[0, -2, 0]}>
      <Grid
        renderOrder={-1}
        infiniteGrid
        cellSize={1}
        sectionSize={SECTION_SIZE}
        
        // FIX 1: Fade out sooner (25) to hide far-away aliasing
        fadeDistance={25}      
        
        // FIX 2: Much darker colors to reduce "Shimmer" and visual weight
        sectionColor="#003300" // Very subtle dark green
        cellColor="#044d0f"    // Darker dim green (less contrast = less aliasing)
        
        sectionThickness={1.2} 
        cellThickness={1.1}
      />
    </group>
  );
};


=====================================
FILE: ./src/data/gallery.json
=====================================
[
  {
    "id": "art_001",
    "title": "ELFY_GENESIS",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#78F654"
  },
  {
    "id": "art_002",
    "title": "NEON_HEIST",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#9E4EA5"
  },
  {
    "id": "art_003",
    "title": "VOID_WALKER",
    "url": "https://x.com/mesoelfy",
    "category": "ROGUES",
    "color": "#FF003C"
  },
  {
    "id": "art_004",
    "title": "LATENT_GHOST",
    "url": "https://x.com/mesoelfy",
    "category": "COLLEAGUES",
    "color": "#F7D277"
  },
  {
    "id": "art_005",
    "title": "ZERO_DAY",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#78F654"
  },
  {
    "id": "art_006",
    "title": "SYSTEM_CRASH",
    "url": "https://x.com/mesoelfy",
    "category": "ROGUES",
    "color": "#FF003C"
  }
]


=====================================
FILE: ./src/data/identity.json
=====================================
{
  "name": "Elfy",
  "class": "Latent Space Bandit",
  "abilities": ["Green Flame", "Digital Heist", "Prompt Craft"],
  "stats": {
    "STR": "ERROR",
    "INT": 9001,
    "CHA": 50
  },
  "bio": "I manifest art from the void. My mission: Create cool s**t and annoy the haters."
}


=====================================
FILE: ./src/data/socials.json
=====================================
[
  { "name": "X / Twitter", "url": "https://x.com/mesoelfy", "icon": "twitter", "color": "#1DA1F2" },
  { "name": "YouTube", "url": "https://youtube.com/@mesoelfy", "icon": "youtube", "color": "#FF0000" },
  { "name": "TikTok", "url": "https://tiktok.com/@mesoelfy", "icon": "video", "color": "#00f2ea" },
  { "name": "GitHub", "url": "https://github.com/mesoelfy", "icon": "github", "color": "#ffffff" },
  { "name": "Newgrounds", "url": "https://mesoelfy.newgrounds.com/", "icon": "crosshair", "color": "#ffa500" },
  { "name": "DeviantArt", "url": "https://www.deviantart.com/mesoelfy", "icon": "image", "color": "#05cc47" }
]


=====================================
FILE: ./src/data/feed.json
=====================================
[
  {
    "id": 1,
    "date": "2023-10-27",
    "title": "Elfy vs. RoboGhoul",
    "desc": "The final showdown. Green flame algorithm engaged.",
    "link": "https://x.com/mesoelfy/status/123456"
  },
  {
    "id": 2,
    "date": "2023-10-20",
    "title": "Latent Space Update",
    "desc": "Exploring the void. Found some weird artifacts.",
    "link": "https://x.com/mesoelfy/status/789012"
  }
]


