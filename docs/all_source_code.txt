+---------------------------------+
|      M E S O E L F Y _ O S      |
|   Next.js / R3F Source Context  |
+---------------------------------+
Generated on: Sun Dec  7 21:46:52 CST 2025

=====================================
PROJECT DIRECTORY STRUCTURE:
=====================================
.
‚îú‚îÄ‚îÄ Icon\015
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ docs
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ MESOELFY_OS_AI_INSTRUCTIONS.md
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ TODO.md
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ all_source_code.txt
‚îú‚îÄ‚îÄ next-env.d.ts
‚îú‚îÄ‚îÄ next.config.js
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ postcss.config.js
‚îú‚îÄ‚îÄ public
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ assets
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ audio
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ bg_music_placeholder.mp3
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ images
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ social-card.jpg
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ favicon.ico
‚îú‚îÄ‚îÄ scripts
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ create_source_context.command
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ core
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ audio
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ AudioSystem.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ store
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ useStore.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ data
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ feed.json
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ gallery.json
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ identity.json
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ socials.json
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ features
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ contact
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ ContactModal.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ debug
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ DebugOverlay.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ tabs
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ ConsoleTab.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ OverridesTab.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ SandboxTab.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ StatsTab.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ effects
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ GlobalShakeManager.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ feed
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ FeedModal.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ gallery
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ GalleryModal.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ identity
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ AboutModal.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ intro
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ MatrixBootSequence.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ sandbox
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ SimulationHUD.tsx
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ game
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ GameOverlay.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ components
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ BulletRenderer.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ EffectsLayer.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ EnemyBulletRenderer.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ EnemyRenderer.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ GalleryStage.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ GameDirector.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ HunterChargeRenderer.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ParticleRenderer.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ PlayerAvatar.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ProjectileTrails.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ScreenShaker.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ common
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ InstancedActor.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ data
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ CombatComponent.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ HealthComponent.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ IdentityComponent.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ LifetimeComponent.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ MotionComponent.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ StateComponent.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ TransformComponent.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ index.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ config
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ EnemyConfig.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Identifiers.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ PlayerConfig.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ WorldConfig.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ core
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ EntitySpawner.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ GameBootstrapper.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ GameEngine.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ObjectPool.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ServiceLocator.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ SpatialGrid.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ecs
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Component.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Entity.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ EntityRegistry.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ types.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ interfaces.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ events
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ GameEventBus.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ GameEvents.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hooks
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ usePanelRegistry.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ useTransientRef.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ logic
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ ai
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ EnemyBehaviors.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ store
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ useGameStore.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ systems
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ BehaviorSystem.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ CameraSystem.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ CollisionSystem.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ FXManager.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ GameStateSystem.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ InputSystem.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ InteractionSystem.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ LifeCycleSystem.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ PanelRegistrySystem.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ PhysicsSystem.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ PlayerSystem.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ TimeSystem.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ UISyncSystem.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ WaveSystem.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ index.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ theme.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ types
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ game.types.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ utils
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ GeometryUtils.ts
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ Noise.ts
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ TextureGen.ts
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ ViewportHelper.ts
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ coords.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ scene
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ canvas
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ SceneCanvas.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ effects
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ FireTransition.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ MatrixGrid.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ props
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ MiniCrystalCanvas.tsx
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ SoulCrystal.tsx
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ styles
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ globals.css
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ ui
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ atoms
‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ CustomCursor.tsx
‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ GlassPanel.tsx
‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ PanelSparks.tsx
‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ VirtualJoystick.tsx
‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ ZenBomb.tsx
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ molecules
‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ HoloCommLog.tsx
‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ IdentityHUD.tsx
‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ LiveArtGrid.tsx
‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ SocialRow.tsx
‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ panel
‚îÇ¬†¬†     ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ BreachOverlay.tsx
‚îÇ¬†¬†     ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ IntelligentHeader.tsx
‚îÇ¬†¬†     ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ RebootOverlay.tsx
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ organisms
‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Footer.tsx
‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Header.tsx
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ overlays
‚îÇ¬†¬†         ‚îú‚îÄ‚îÄ ErrorBoundary.tsx
‚îÇ¬†¬†         ‚îî‚îÄ‚îÄ ModalContainer.tsx
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îî‚îÄ‚îÄ tsconfig.json

49 directories, 122 files

=====================================
FILE: ./next.config.js
=====================================
/** @type {import('next').NextConfig} */

let commitHash = 'DEV_BUILD';

try {
  const { execSync } = require('child_process');
  commitHash = execSync('git rev-parse --short HEAD').toString().trim();
} catch (error) {
  console.warn('Warning: Could not determine git commit hash.');
}

const nextConfig = {
  output: 'export',
  images: {
    unoptimized: true,
  },
  reactStrictMode: true,
  transpilePackages: ['three'],
  
  // Disable Indicators
  devIndicators: false,


  
  env: {
    NEXT_PUBLIC_COMMIT_HASH: commitHash,
  },
  
  typescript: {
    ignoreBuildErrors: true,
  },
  eslint: {
    ignoreDuringBuilds: true,
  },
}

module.exports = nextConfig


=====================================
FILE: ./docs/TODO.md
=====================================
# MESOELFY_OS // REFACTOR ROADMAP

## üü¢ COMPLETED 




## üîä AUDIO ENGINEERING
*Goal: Professional mixing and dynamic sound control.*
- [ ] **Audio Bus System:** Create `GainNodes` for Master, Music, and SFX.
- [ ] **Ducking Logic:** Lower Music volume slightly when heavy SFX (Explosions) trigger.
- [ ] **Sound Pooling:** Prevent audio glitches by recycling Audio nodes.

## üñ• UI & REACT INTEGRATION
*Goal: Seamless communication between the App and the Game.*
- [ ] **Transient Updates:** Refactor HUD (Health/XP) to bypass React State and update DOM directly for 60fps performance.
- [ ] **Viewport System:** Robust Screen-to-World mapping for resizing/mobile.
- [ ] **Mobile Controls:** Implement Virtual Joystick overlay for touch devices.
- [ ] **Touch Input:** Map touch events to the `InputSystem`.
- [ ] **Asset Loader:** Preload sounds/textures with a progress bar.
- [ ] **Debug Overlay:** FPS, Entity Count, Pool Usage stats toggle.
- [ ] **Settings Modal:** Volume sliders (Music/SFX) and Graphics Quality toggles.

## üèÅ FINAL POLISH & SHIP
- [ ] **Code Freeze & Lint:** Cleanup imports and unused files.
- [ ] **Deployment Check:** Verify GitHub Pages behavior.
- [ ] **Readme Update:** Documentation for future contributors.


## üêõ KNOWN BUGS
- [ ] **White Flash on Refresh (FOUC):** The 3D Canvas areas flash white briefly on page reload.
- [ ] **Mobile Controls:** Unplayable on mobile (Need Virtual Joystick).

## MISC THOUGHTS


- what if there is a muncher enemy that targets the elements within a panel such as each of the three video slots or each social media button, or the CONTACT and ABOUT ME buttons? What about an enemy type that enters a modal and does damage inside? Can that be coded for them to be moving around doing stuff even though we haven't instantiated the modal yet? How do we deal with the enemies on the MESOELFY_OS screen if we are inside a modal fighting some enemies? Wouldn't that have weird game logic? I need to brainstorm this with AI.
- need health for player and lives and powerups. (increase bullet size / rate of fire)
- need help seeing not obvious stuff that is missing.

- Kamekazi should be bigger and slow. If it blows up on player and is inside a panel, it does damage to that panel.

- What things does Vampire Survivors do that I should implement? Game design and juice.

- Should I have a high score patron screen where people can enter their name with links to whatever they want? - YES

- Full functionality in the site isn't active immediately. the video slots and social media links could be broken until the first wave of munchers that are already there are dealt with. Maybe a power up that clears and heals the board is dropped?

bullet width upgrade lmited



we can skin the munchers/enemies differently as they get stronger with cool indicators including skins and animations of their pattern, and even glow or particles floating around them.

- We need a dramatic visual animation / indication signifying that a panel has reached 0% health like the system restored animation





sharing https://mesoelfy.github.io/ needs to make an awesome twitter link capsule image.

- each upgrade needs its own bespoke icon that looks like what it does

- there could be "burrow" waves where they burrow into modal - - - and there can be a wave indicator in the header so you can keep track of when you need to go back

- hunter spinning animation needs fine tuning - - - hunter bullet needs to start at size 0 and then grow to full size before being launched at player - - - hunter movement logic needs updating, it feels kind of floaty and not menacing. I want it to feel intimidating.

- Game Over left most broken frame looks weird as broken - should retain full shape

- Power UP - Heal panel faster

- should the screen shake just affect the game world mesoelfy_OS and panels and not the player and enemies?



What are screenshake best practices?

- the system breach scrolling text needs to be indepentent for each panel, not a master animation that overlaps for multiple panels.

- 


When player regenerates itself, the health bar shows 50% but I think it might actually be a different number of health that it actually has? Also, even if the identity panel is destoryed or everything is game over state, the player should still be able to lose its health and become the small triangle state.

Music should get distorted, glitchy, and reverbed when Game Over state



‚Äú	‚Ä¢	The Skull Glitch:
	‚ó¶	We will overlay a 2D, glitchy "Skull" graphic over the 3D canvas.
	‚ó¶	This skull stays at¬†opacity: 0¬†normally.
	‚ó¶	As health drops, it randomly flickers to¬†opacity: 1¬†for a single frame (subliminal glitch).
	‚ó¶	At¬†0% Health, the Crystal vanishes entirely, and the Skull locks in permanently (Red).
‚Äú





screen shake - an individual panel should shake when brought to 0% health



For zen mode, can we cycle through cool prismatic color patterns for elements in the header/footer/and the motion grid lines? Making it very cool and psychedelic and chill. We can make flavor text in the header and footer say something cheeky and diegetic too. Something about safe/chill/vibe mode.

Maybe we can have the motion grid affected by the music like a music player visualizer, affected by the song that is playing?

Your cursor could leave a psychedelic trail of colors behind it


1	"Reboot Tick" (Purple State): A gritty, low-pitched electric "zap" (Sawtooth wave) that played while you were actively regenerating a dead panel. designed to sound like forcing power into a broken system, distinct from the clean "healing" chime.

2	"System Restored" (Happy Sound): A "power-on" sweep (Sine wave rising in pitch + high-frequency sparkle) that plays the moment a panel reached 100% and came back online.

3	"Upgrade Selected": A satisfying ascending major arpeggio (3-note chime) when clicking a button in the level-up menu.

4     I‚Äôd like a quick simple chime blip to indicate panel healed 100%.




DEBUG mode will have asterisk slots for entering konami code to access it. If they have entered the code at least one time, their browswer will remember and not ask for it again (saves it).



Somtimes driller enemy does not render correctly on the screen. you can see the tip where it is drilling but not rest of body. other enemies render fine.

Indicate to player to press ESC or ~ in zen mode



Make IDENTITY_CORE a little shorter or a panel, and SOCIAL_UPLINK a little taller of a panel


Hunter weapon needs to start small and get bigger before launching

kamikaze should hurt player. if kamikaze explodes in panel, it does same amount of damage to panel as it does to player.
player colliding with any enemy should hurt player and make that enemy explode (by doing damage to them)


Audio ducking / side-chaining needs to be fine tuned and architecture assessed.


mobile - chrome devtools - device toolbar - confirm compatibility with different devices - right now the touch joystick isn't working because touching anywhere on skin moves character. also, everything isn't being resized properly for mobile and needs an overhaul.

Sometime green system restored animation appears in a panel during game over state.




This is a comprehensive **Architecture Refactoring Specification**. You can copy and paste this entire block into a new AI chat session to provide the context and roadmap needed to execute the refactor.

***

# MESOELFY_OS // ARCHITECTURAL REFACTOR SPECIFICATION

## **1. PROJECT CONTEXT**
**Project:** Mesoelfy OS (Web Game)
**Stack:** Next.js 14, React Three Fiber (R3F), Zustand, TypeScript.
**Goal:** Refactor the current codebase to match the high-performance, decoupled architecture of a reference Godot project ("Box Battle").
**Core Philosophy:**
1.  **Strict ECS/Component Separation:** Logic (Math/Physics) must be decoupled from View (R3F/React).
2.  **Data-Driven Design:** Entities and Behaviors are defined in configuration files, not hardcoded classes.
3.  **Dependency Injection:** Systems receive dependencies; they do not import global singletons.
4.  **Push Architecture:** Game Loop emits events; UI listens. UI never polls the Game Loop.

---

## **2. DIRECTORY STRUCTURE TARGET**
We will move towards this domain-driven structure:
```text
src/game/
‚îú‚îÄ‚îÄ core/           # Engine internals (Loop, Time, Input)
‚îú‚îÄ‚îÄ data/           # Configs (Archetypes, Balance, Pools)
‚îú‚îÄ‚îÄ ecs/            # Base Classes (Entity, Component, Registry)
‚îú‚îÄ‚îÄ systems/        # Logic Processors (Movement, Combat, AI)
‚îú‚îÄ‚îÄ logic/          # Pure Logic Strategies (MovePatterns, AttackPatterns)
‚îú‚îÄ‚îÄ view/           # R3F/Three.js Renderers (Visual Components only)
‚îî‚îÄ‚îÄ services/       # Global Services (Audio, Storage, Analytics)
```

---

## **3. PHASE-BY-PHASE EXECUTION PLAN**

### **PHASE 1: THE FOUNDATION (Core Systems & Cleanup)**
*Goal: Establish the wiring that allows systems to talk without coupling.*

*   **Step 1.1: Dependency Injection (Service Locator)**
    *   Create `ServiceLocator.ts`.
    *   Refactor `GameEngine` to initialize systems passing the Locator (`system.setup(locator)`).
    *   **Rule:** No file inside `src/game/systems/` is allowed to import `ServiceLocator` globally. It must use the injected instance.
*   **Step 1.2: Typed Event Bus**
    *   Refactor `GameEventBus.ts` to use a Strict Interface mapped to Event Enums.
    *   **Rule:** `emit(Events.PLAYER_HIT, payload)` must error if `payload` does not match `DamagePayload`.
*   **Step 1.3: Input Abstraction (IInputProvider)**
    *   Create interface `IInputProvider`.
    *   Implement `KeyboardInputProvider` (DOM listeners) and `VirtualJoystickProvider` (Touch).
    *   Refactor `InputSystem` to poll the provider, not the DOM directly.
*   **Step 1.4: Strict Teardown Contract**
    *   Add `teardown()` method to `Entity`, `Component`, and `System`.
    *   Ensure `GameEngine` calls `teardown()` on everything when the React component unmounts.

### **PHASE 2: ENTITY ARCHITECTURE (The "Brain" Refactor)**
*Goal: Separate the "What" (Data) from the "How" (Logic) and the "Looks" (View).*

*   **Step 2.1: Logic Strategies**
    *   Create interfaces `IMovementLogic` and `IAttackLogic`.
    *   Refactor `EnemyBehaviors.ts` from switch-statements into classes (e.g., `OrbitMovement`, `ChargeAttack`).
    *   **Result:** Behaviors are interchangeable assets.
*   **Step 2.2: Finite State Machines (FSM)**
    *   Replace string-based states (`current: 'IDLE'`) with a class-based FSM or Resource-based FSM.
    *   Each State handles its own `enter`, `update`, and `exit` logic.
*   **Step 2.3: Entity Archetypes (Blueprints)**
    *   Create `EntityArchetypes.ts` (Config).
    *   Define entities as JSON-like structures: `HUNTER: { components: [...], stats: {...} }`.
    *   Refactor `EntitySpawner` to read from this config instead of hardcoded `spawnHunter()` functions.
*   **Step 2.4: Visual/Logic Split**
    *   **Strip `EnemyRenderer.tsx`**: It must strictly be a "Dumb View".
    *   It only reads `transform.position/rotation` from the Registry.
    *   Move all math (rotation lerping, position updates) into `MovementSystem`.

### **PHASE 3: PHYSICS & COMBAT (The "Crunch" Refactor)**
*Goal: Standardize how objects interact and take damage.*

*   **Step 3.1: Physics Layers**
    *   Create `PhysicsLayers.ts` (Bitmask Enum).
    *   Refactor collision checks to use `(entity.layer & target.mask)`.
*   **Step 3.2: Sensors vs. Physics**
    *   Create `SensorComponent` (separate from Hitbox).
    *   Create `SensorSystem` to handle AI detection (e.g., "Player in Range").
    *   Decouple AI aggro range from physical collision size.
*   **Step 3.3: Combat DTOs**
    *   Create `DamageInfo` object (`amount`, `source`, `normal`, `bypassInvincibility`).
    *   Refactor `HealthComponent` to accept `DamageInfo` and return `DamageResult`.
*   **Step 3.4: Status Effects**
    *   Create `StatusEffectComponent`.
    *   Implement `InvincibilityEffect`.
    *   Remove hardcoded timers from `PlayerSystem`; apply Effects instead.

### **PHASE 4: GAME FEEL & POLISH (The "Juice" Refactor)**
*Goal: Make the system responsive and professional.*

*   **Step 4.1: Audio Configuration**
    *   Create `AudioConfig.ts` with `AudioCue` objects.
    *   Refactor `AudioSystem` to play Cues (handling pitch variance/volume offsets automatically).
*   **Step 4.2: Telegraph System**
    *   Create `TelegraphComponent` and `TelegraphSystem`.
    *   Logic: Enemy adds Telegraph -> System renders warning line -> Wait -> Enemy fires.
*   **Step 4.3: Automated Hit-Stop**
    *   Refactor `FXManager` to listen for `DAMAGE_DEALT` events.
    *   Automatically trigger `TimeSystem.freeze()` based on damage thresholds.
*   **Step 4.4: Post-Process State**
    *   Create `PostProcessState` in the store.
    *   Logic updates state -> R3F `EffectsLayer` reacts.

### **PHASE 5: SCALABILITY & OPTIMIZATION**
*Goal: Ensure the game runs at 60fps on low-end devices.*

*   **Step 5.1: Targeting System**
    *   Create `TargetingService`.
    *   Maintain cached lists of entities by Tag.
    *   Add spatial hashing or `getNearest()` optimization to remove `O(n^2)` loops.
*   **Step 5.2: Pool Manifests**
    *   Create `PoolConfig.ts`.
    *   Centralize pool initialization sizes.
*   **Step 5.3: Shader Pre-warming**
    *   Implement a routine in `GameDirector` to force-compile materials before the game starts (loading screen).
*   **Step 5.4: Store Separation**
    *   Split `useGameStore` into `SessionStore` (Health, Pos) and `PersistentStore` (High Score, Settings).
    *   Only `PersistentStore` uses local storage middleware.

---

## **4. IMPLEMENTATION RULES (For the AI)**

1.  **No Logic in Views:** `.tsx` files (React components) are strictly for rendering. No `Math.sin`, no state updates inside `useFrame` unless it is purely visual (e.g., bobbing). Game logic happens in `.ts` Systems.
2.  **No Magic Numbers:** All gameplay values (speed, damage, colors) must be imported from `BalanceConfig.ts` or `ThemeConfig.ts`.
3.  **Strict Typing:** No `any`. Use Interfaces for all Component data and Event payloads.
4.  **Atomic Commits:** When asking to generate code, generate one System or Component at a time to ensure accuracy.

=====================================
FILE: ./docs/MESOELFY_OS_AI_INSTRUCTIONS.md
=====================================
I am developing "MESOELFY_OS," a 3D interactive portfolio site with a Cyberpunk/Hacker/Demoscene aesthetic. 

I have attached "all_source_code.txt" which contains the full project tree and code. Please ingest this to understand the current architecture.

***CORE IDENTITY & AESTHETIC***
*   **Persona:** You are assisting "Elfy," a Latent Space Bandit. The vibe is Y2K Hacker, Matrix, Geometry Wars, and High-Tech Demoscene.
*   **Palette:** Electric Green (#78F654) is dominant. Deep Purple (#9E4EA5) is secondary. Red/Yellow for alerts. Black backgrounds.
*   **Current Status:** The site is live at `mesoelfy.github.io`. The "Intro Boot Sequence" and "Main Dashboard" are built and polished.

***TECHNICAL STACK***
*   **Framework:** Next.js 14 (App Router) + TypeScript.
*   **Styling:** Tailwind CSS + Framer Motion (for UI animations).
*   **3D:** React Three Fiber (R3F) + Drei.
*   **Deployment:** GitHub Pages (Static Export).

***WORKFLOW RULES (CRITICAL)***
1.  **Terminal Only:** Do not ask me to manually create files. Provide full terminal commands using `cat << 'EOF' > path/to/file` to create or overwrite files.
2.  **No Placeholders:** Unless specified, write complete, functional code.
3.  **Atomic Commits:** After a successful feature implementation, provide the specific `git add .`, `git commit -m "..."`, and `git push` commands.
4.  **Lean Ship:** Keep dependencies low. Prefer procedural generation (shaders/math) over large assets.

Working directory:
stevencasteel@Stevens-Mac-mini mesoelfy-site % 


Please acknowledge you have analyzed the codebase.

=====================================
FILE: ./next-env.d.ts
=====================================
/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


=====================================
FILE: ./README.md
=====================================
<div align="center">

```text
 ‚ñà‚ñà‚ñà‚ñÑ ‚ñÑ‚ñà‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñì      ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà   ‚ñà‚ñà‚ñì
‚ñì‚ñà‚ñà‚ñí‚ñÄ‚ñà‚ñÄ ‚ñà‚ñà‚ñí‚ñì‚ñà   ‚ñÄ‚ñí‚ñà‚ñà    ‚ñí ‚ñí‚ñà‚ñà‚ñí  ‚ñà‚ñà‚ñí‚ñì‚ñà   ‚ñÄ ‚ñì‚ñà‚ñà‚ñí    ‚ñí‚ñì‚ñà   ‚ñí  ‚ñí‚ñà‚ñà  ‚ñà‚ñà‚ñí
‚ñì‚ñà‚ñà    ‚ñì‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà‚ñà  ‚ñë ‚ñì‚ñà‚ñà‚ñÑ   ‚ñí‚ñà‚ñà‚ñë  ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñà   ‚ñí‚ñà‚ñà‚ñë    ‚ñí‚ñì‚ñà‚ñà‚ñà ‚ñë   ‚ñí‚ñà‚ñà ‚ñà‚ñà‚ñë
‚ñí‚ñà‚ñà    ‚ñí‚ñà‚ñà ‚ñí‚ñì‚ñà  ‚ñÑ  ‚ñí   ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà   ‚ñà‚ñà‚ñë‚ñí‚ñì‚ñà  ‚ñÑ ‚ñí‚ñà‚ñà‚ñë    ‚ñë‚ñì‚ñà‚ñí  ‚ñë   ‚ñë ‚ñê‚ñà‚ñà‚ñë‚ñë
‚ñí‚ñà‚ñà‚ñí   ‚ñë‚ñà‚ñà‚ñí‚ñë‚ñí‚ñà‚ñà‚ñà‚ñà‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñë ‚ñà‚ñà‚ñà‚ñà‚ñì‚ñí‚ñë‚ñë‚ñí‚ñà‚ñà‚ñà‚ñà‚ñí‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñë‚ñí‚ñà‚ñë      ‚ñë ‚ñà‚ñà‚ñí‚ñë‚ñë
‚ñë ‚ñí‚ñë   ‚ñë  ‚ñë‚ñë‚ñë ‚ñí‚ñë ‚ñë ‚ñí‚ñë‚ñí  ‚ñë ‚ñë ‚ñí‚ñë‚ñí‚ñë‚ñí‚ñë ‚ñë‚ñë ‚ñí‚ñë ‚ñë‚ñë ‚ñí‚ñë‚ñí  ‚ñë ‚ñí ‚ñë       ‚ñà‚ñà‚ñí‚ñí‚ñí
‚ñë  ‚ñë      ‚ñë ‚ñë ‚ñë  ‚ñë ‚ñë ‚ñí  ‚ñë   ‚ñë ‚ñí ‚ñí‚ñë  ‚ñë ‚ñë  ‚ñë‚ñë ‚ñë ‚ñí  ‚ñë ‚ñë       ‚ñì‚ñà‚ñà ‚ñë‚ñí‚ñë 
‚ñë      ‚ñë      ‚ñë    ‚ñë ‚ñë    ‚ñë ‚ñë ‚ñë ‚ñí     ‚ñë     ‚ñë ‚ñë    ‚ñë ‚ñë     ‚ñí ‚ñí ‚ñë‚ñë  
       ‚ñë      ‚ñë  ‚ñë   ‚ñë  ‚ñë     ‚ñë ‚ñë     ‚ñë  ‚ñë    ‚ñë  ‚ñë         ‚ñë ‚ñë     
```

### **LATENT SPACE BANDIT // DIGITAL HQ**

![System Status](https://img.shields.io/badge/SYSTEM-UNSECURE-ff003c?style=for-the-badge&logo=linux)
![Encryption](https://img.shields.io/badge/ENCRYPTION-BYPASSED-78F654?style=for-the-badge)
![Core](https://img.shields.io/badge/CORE-REACT_THREE_FIBER-9E4EA5?style=for-the-badge&logo=react)

</div>

---

### **// TRANSMISSION_LOG**

**MESOELFY_OS** is a generative 3D operating system disguised as a portfolio site. It serves as the central node for **Elfy**, a rogue entity manifesting art from the void.

The system features a custom "Latent Defense" protocol, audio-reactive interfaces, and a direct uplink to the neural network.

### **// SYSTEM_SPECS (Tech Stack)**

| MODULE | PAYLOAD |
| :--- | :--- |
| **Framework** | Next.js 14 (App Router) + TypeScript |
| **Graphics Core** | React Three Fiber (R3F) + Drei + Shaders |
| **Styling** | Tailwind CSS + Framer Motion |
| **Audio Engine** | Web Audio API (Generative Synthesis) |
| **Deployment** | GitHub Pages (Static Export) |

### **// BOOT_PROTOCOL (Installation)**

```bash
# 1. Clone the Repository
git clone https://github.com/mesoelfy/mesoelfy.github.io.git

# 2. Inject Dependencies
npm install

# 3. Initialize System (Dev Mode)
npm run dev
```

### **// IDENTITY_CORE**

*   **Class:** Latent Space Bandit
*   **Abilities:** Green Flame, Digital Heist, Prompt Craft
*   **Mission:** Create cool s**t. Annoy the haters.

---

<div align="center">
  <p><strong>‚ö† WARNING: TRANSMISSIONS ARE MONITORED BY THE AI OVERLORD. ‚ö†</strong></p>
  <a href="https://x.com/mesoelfy">[ TWITTER_UPLINK ]</a> ‚Ä¢ <a href="https://mesoelfy.github.io">[ LAUNCH_OS ]</a>
</div>

=====================================
FILE: ./tailwind.config.ts
=====================================
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './src/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        // --- BRAND CORE (Existing UI) ---
        elfy: {
          green: {
            light: '#7FF65F',
            DEFAULT: 'rgba(96, 196, 68, 1)',
            dim: '#1bb930ff',
            dark: '#217e10ff',
          },
          purple: {
            light: '#BC86BA',
            DEFAULT: '#9E4EA5',
            dim: '#822B8A',
            deep: '#350E3A',
          },
          cyan: {
            DEFAULT: '#00F0FF', // NEW: Repair Color
            dim: '#008ba3',
          },
          yellow: {
            DEFAULT: '#eae747ff',
          },
          red: '#FF003C', 
          gray: '#27282A',
          black: '#050505',
        },
        
        // --- LATENT DEFENSE (Game Layer) ---
        game: {
          turret: {
            base: '#78F654',
            glow: '#C2FE9A',
          },
          bullet: {
            plasma: '#FFFFFF', 
            trail: '#78F654',
          },
          enemy: {
            seeker: '#9E4EA5',
            eater: '#FF003C',
            boss: '#F7D277',
          },
          hud: {
            text: '#78F654',
            warning: '#FF003C',
          },
          vfx: {
            spark: '#FFFFFF',
            damage: '#FF003C',
          }
        }
      },
      fontFamily: {
        header: ['var(--font-montserrat)', 'sans-serif'],
        mono: ['Courier New', 'Courier', 'monospace'],
        tech: ['var(--font-jetbrains)', 'monospace'],
      },
      animation: {
        'spin-slow': 'spin 3s linear infinite',
        'spin-diamond': 'spin-diamond 3s linear infinite',
        'matrix-green': 'matrix-green 4s ease-in-out infinite',
        'matrix-purple': 'matrix-purple 2s ease-in-out infinite',
        'cursor-blink': 'cursor-blink 1.2s ease-in-out infinite',
      },
      keyframes: {
        'spin-diamond': {
          '0%': { transform: 'rotate(45deg)' },
          '100%': { transform: 'rotate(405deg)' },
        },
        'matrix-green': {
          '0%, 100%': { color: '#14630bff' },
          '50%': { color: '#0aa41cff' },
        },
        'matrix-purple': {
          '0%, 100%': { color: '#9E4EA5' }, 
          '33%': { color: '#BC86BA' },      
          '66%': { color: '#350E3A' },      
        },
        'cursor-blink': {
          '0%, 30%': { opacity: '1' }, 
          '50%': { opacity: '0' },     
          '100%': { opacity: '1' },    
        }
      }
    },
  },
  plugins: [],
}
export default config


=====================================
FILE: ./package.json
=====================================
{
  "name": "mesoelfy-site",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@react-three/drei": "^10.7.7",
    "@react-three/fiber": "^9.4.2",
    "@react-three/postprocessing": "^2.19.1",
    "clsx": "^2.1.0",
    "framer-motion": "^11.0.0",
    "lucide-react": "^0.300.0",
    "maath": "^0.10.0",
    "next": "^16.0.7",
    "react": "^19.2.1",
    "react-dom": "^19.2.1",
    "tailwind-merge": "^2.2.0",
    "three": "^0.181.2",
    "zustand": "^4.5.0"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@types/three": "^0.181.0",
    "autoprefixer": "^10.0.1",
    "eslint": "^9.39.1",
    "eslint-config-next": "^16.0.7",
    "postcss": "^8",
    "tailwindcss": "^3.3.0",
    "typescript": "^5"
  }
}


=====================================
FILE: ./tsconfig.json
=====================================
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./src/*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}


=====================================
FILE: ./postcss.config.js
=====================================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


=====================================
FILE: ./src/ui/molecules/SocialRow.tsx
=====================================
import { Twitter, Youtube, Github, Video, Crosshair, Image as ImageIcon, AlertTriangle } from 'lucide-react';
import socials from '@/data/socials.json';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { useGameStore } from '@/game/store/useGameStore';
import { clsx } from 'clsx';

const IconMap: Record<string, any> = {
  twitter: Twitter,
  youtube: Youtube,
  github: Github,
  video: Video,
  crosshair: Crosshair,
  image: ImageIcon,
};

export const SocialRow = () => {
  const panelState = useGameStore((state) => state.panels['social']);
  const isDestroyed = panelState ? panelState.isDestroyed : false;

  return (
    <div className={clsx(
        "grid grid-cols-3 gap-2 h-full content-center py-2 relative",
        // If destroyed, we don't fully hide it, we let it sit under the overlay
        // but we disable interactions so it feels "broken"
        isDestroyed ? "pointer-events-none" : "" 
    )}>
      {socials.map((social, idx) => {
        const Icon = isDestroyed ? AlertTriangle : (IconMap[social.icon] || Crosshair);
        
        // Random "Corruption" logic for visuals
        const isGlitch = isDestroyed && (idx % 2 === 0);
        
        return (
          <a
            key={social.name}
            href={isDestroyed ? undefined : social.url}
            target="_blank"
            rel="noopener noreferrer"
            onMouseEnter={() => !isDestroyed && AudioSystem.playHover()} 
            onClick={() => !isDestroyed && AudioSystem.playClick()}
            className={clsx(
                "group flex flex-col items-center justify-center p-2 border transition-all duration-300",
                isDestroyed 
                    ? "border-elfy-red/20 bg-elfy-red/5 grayscale" 
                    : "border-elfy-green-dim/30 bg-black/40 hover:bg-elfy-green/10 hover:border-elfy-green"
            )}
          >
            <Icon 
              className={clsx(
                  "w-5 h-5 mb-1 transition-transform",
                  isDestroyed ? "text-elfy-red animate-pulse" : "text-elfy-green-dim group-hover:text-elfy-green group-hover:scale-110",
                  isGlitch ? "translate-x-1" : ""
              )}
              style={!isDestroyed ? { filter: 'drop-shadow(0 0 2px rgba(120,246,84,0.3))' } : {}}
            />
            <span className={clsx(
                "text-[10px] uppercase tracking-wider font-mono",
                isDestroyed ? "text-elfy-red/60" : "text-elfy-green-dim/60 group-hover:text-elfy-green"
            )}>
              {isDestroyed ? (isGlitch ? "ERR_404" : "NULL") : social.name.split(' ')[0]}
            </span>
          </a>
        );
      })}
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/panel/BreachOverlay.tsx
=====================================
import { motion } from 'framer-motion';
import { ChevronUp } from 'lucide-react';
import { clsx } from 'clsx';

const ScrollingRow = ({ direction, text }: { direction: number, text: string }) => {
  return (
    <div className="flex whitespace-nowrap overflow-hidden select-none opacity-60">
      <motion.div 
        className="flex gap-4 font-header font-black text-xl md:text-2xl text-elfy-red tracking-widest uppercase py-1"
        animate={{ x: direction === 1 ? ["-50%", "0%"] : ["0%", "-50%"] }} 
        transition={{ duration: 40, repeat: Infinity, ease: "linear" }}
      >
        {Array.from({ length: 12 }).map((_, i) => (
          <span key={i} className={i % 2 === 0 ? "text-elfy-red" : "text-transparent stroke-elfy-red stroke-1"}>
             {text}
          </span>
        ))}
      </motion.div>
    </div>
  );
};

interface BreachOverlayProps {
  progress: number;
  isVideo: boolean;
  showInteractive: boolean;
}

export const BreachOverlay = ({ progress, isVideo, showInteractive }: BreachOverlayProps) => {
  return (
    <div className={clsx(
        "absolute inset-0 z-[70] flex flex-col items-center justify-center overflow-hidden",
        isVideo ? "bg-black/20 backdrop-blur-[2px]" : "bg-black/60 backdrop-blur-sm"
    )}>
        <div className="absolute inset-[-50%] flex flex-col justify-center rotate-[-12deg] opacity-30 pointer-events-none">
            <motion.div
               className="flex flex-col gap-8"
               animate={{ y: ["0%", "-50%"] }}
               transition={{ duration: 30, repeat: Infinity, ease: "linear" }}
            >
                {[0, 1].map((set) => (
                    <div key={set} className="flex flex-col gap-8">
                        {Array.from({ length: 6 }).map((_, i) => (
                            <ScrollingRow 
                                key={`${set}-${i}`} 
                                direction={i % 2 === 0 ? 1 : -1} 
                                text="SYSTEM BREACH // CRITICAL FAILURE // REBOOT REQUIRED //" 
                            />
                        ))}
                    </div>
                ))}
            </motion.div>
        </div>

        {showInteractive && (
          <div className="relative z-20 flex flex-col items-center justify-center gap-2 cursor-crosshair transition-all duration-100">
              <div className="relative">
                  <div className="group-hover:opacity-0 transition-opacity duration-200 absolute inset-0 flex items-center justify-center">
                      <motion.div 
                          animate={{ y: [0, -10, 0] }}
                          transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }}
                          className="text-elfy-red drop-shadow-md"
                      >
                          <ChevronUp size={64} strokeWidth={3} />
                      </motion.div>
                  </div>

                  <div className="opacity-0 group-hover:opacity-100 transition-opacity duration-200 absolute inset-0 flex items-center justify-center -translate-y-8">
                      <motion.div 
                          animate={{ scale: [1, 1.2, 1], filter: ["brightness(1)", "brightness(1.5)", "brightness(1)"] }}
                          transition={{ duration: 0.2, repeat: Infinity, ease: "easeInOut" }}
                          className="text-elfy-purple drop-shadow-[0_0_15px_#9E4EA5]"
                      >
                          <ChevronUp size={64} strokeWidth={4} />
                      </motion.div>
                  </div>
                  
                  <div className="w-16 h-16 pointer-events-none opacity-0"><ChevronUp size={64} /></div>
              </div>

              <div className="flex flex-col items-center text-center">
                  <span className="text-sm font-header font-black tracking-widest text-elfy-red group-hover:text-elfy-purple transition-colors duration-200 drop-shadow-md">
                      HOLD TO REBOOT
                  </span>
                  
                  <div className="w-32 bg-gray-900/80 h-1.5 mt-2 rounded-full overflow-hidden border border-gray-700 shadow-lg">
                      <motion.div 
                          className="h-full bg-elfy-purple shadow-[0_0_10px_#9E4EA5]" 
                          initial={{ width: 0 }}
                          animate={{ width: `${progress}%` }}
                          transition={{ type: "tween", duration: 0.1 }}
                      />
                  </div>
                  
                  <div className="text-[10px] font-mono text-elfy-purple font-bold mt-1 opacity-0 group-hover:opacity-100 transition-opacity bg-black/60 px-2 rounded">
                      INTEGRITY: {Math.floor(progress)}%
                  </div>
              </div>
          </div>
        )}
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/panel/RebootOverlay.tsx
=====================================
import { motion } from 'framer-motion';
import { Power } from 'lucide-react';

export const RebootOverlay = () => (
  <motion.div 
    initial={{ opacity: 0, scale: 0.8 }}
    animate={{ opacity: 1, scale: 1 }}
    exit={{ opacity: 0, scale: 1.1, filter: "blur(10px)" }}
    transition={{ duration: 0.4, ease: "backOut" }}
    className="absolute inset-0 z-[60] flex items-center justify-center bg-black/80 backdrop-blur-[2px]"
  >
    <div className="flex flex-col items-center gap-2 border-y-2 border-elfy-green bg-elfy-green/10 w-full py-4 relative overflow-hidden">
      <motion.div 
        className="absolute top-0 left-0 w-full h-full bg-gradient-to-b from-transparent via-elfy-green/20 to-transparent"
        animate={{ top: ["-100%", "100%"] }}
        transition={{ duration: 1.5, ease: "linear", repeat: Infinity }}
      />
      <div className="relative z-10 flex items-center gap-3">
        <motion.div
          initial={{ rotate: -180, scale: 0 }}
          animate={{ rotate: 0, scale: 1 }}
          transition={{ type: "spring", stiffness: 200, delay: 0.1 }}
        >
            <Power className="text-elfy-green w-8 h-8 md:w-10 md:h-10" />
        </motion.div>
        <div className="flex flex-col">
            <motion.span 
                initial={{ x: 20, opacity: 0 }}
                animate={{ x: 0, opacity: 1 }}
                transition={{ delay: 0.2 }}
                className="text-2xl md:text-3xl font-header font-black text-elfy-green tracking-widest italic"
            >
                SYSTEM
            </motion.span>
            <motion.span 
                initial={{ x: -20, opacity: 0 }}
                animate={{ x: 0, opacity: 1 }}
                transition={{ delay: 0.3 }}
                className="text-xs md:text-sm font-mono font-bold text-elfy-green-dim tracking-[0.3em]"
            >
                RESTORED
            </motion.span>
        </div>
      </div>
    </div>
  </motion.div>
);


=====================================
FILE: ./src/ui/molecules/panel/IntelligentHeader.tsx
=====================================
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useGameStore } from '@/game/store/useGameStore';
import { Skull, Zap, Power, RefreshCw, AlertTriangle, Check } from 'lucide-react';
import { clsx } from 'clsx';

const MAX_HEALTH = 1000;

interface IntelligentHeaderProps {
  title: string;
  health: number;
  isDestroyed: boolean;
  isGameOver: boolean;
  gameId?: string;
}

export const IntelligentHeader = ({ title, health, isDestroyed, isGameOver, gameId }: IntelligentHeaderProps) => {
  const interactionTarget = useGameStore(state => state.interactionTarget);
  const isInteracting = gameId && interactionTarget === gameId;
  
  const healthPercent = (health / MAX_HEALTH) * 100;
  const isDamaged = !isDestroyed && healthPercent < 100;

  const [showOptimal, setShowOptimal] = useState(false);

  useEffect(() => {
    if (health < MAX_HEALTH) {
      setShowOptimal(true);
    }
    if (health >= MAX_HEALTH && showOptimal) {
      const timer = setTimeout(() => setShowOptimal(false), 1500);
      return () => clearTimeout(timer);
    }
  }, [health, showOptimal]);

  let mainColor = "text-elfy-green";
  let statusText = "SECURE";
  
  if (isGameOver) {
      mainColor = "text-elfy-red";
      statusText = "SYSTEM_FAILURE";
  } else if (isDestroyed) {
      mainColor = isInteracting ? "text-elfy-purple" : "text-elfy-red";
      statusText = isInteracting ? "REBOOTING..." : "OFFLINE";
  } else if (isInteracting && isDamaged) {
      mainColor = "text-elfy-cyan";
      statusText = "HEALING...";
  } else if (isDamaged) {
      mainColor = "text-elfy-yellow"; 
      statusText = "ATTENTION_REQ";
  } else if (!showOptimal) {
      mainColor = "text-elfy-green-dim";
      statusText = "ONLINE";
  }

  return (
    <div className={clsx(
        "relative flex flex-col border-b transition-colors duration-300 shrink-0 z-10",
        isGameOver ? "bg-elfy-red/10 border-elfy-red/50" :
        isDestroyed ? (isInteracting ? "bg-elfy-purple/10 border-elfy-purple/50" : "bg-elfy-red/10 border-elfy-red/50") :
        (isInteracting && isDamaged) ? "bg-elfy-cyan/10 border-elfy-cyan/50" :
        isDamaged ? "bg-elfy-yellow/10 border-elfy-yellow/30" : 
        "bg-elfy-green/5 border-elfy-green-dim/30"
    )}>
        <div className="flex items-center justify-between px-3 py-1.5 h-8">
            <div className="flex items-baseline gap-2">
                <span className={clsx("text-sm md:text-base font-header font-bold uppercase tracking-wider drop-shadow-md transition-colors duration-300", mainColor)}>
                    {title}
                </span>
                <span className={clsx("text-[8px] font-mono tracking-widest opacity-80", mainColor)}>
                    [{statusText}]
                </span>
            </div>

            <div className="w-5 h-5 flex items-center justify-center">
                <AnimatePresence mode="wait">
                    {isGameOver ? (
                        <motion.div 
                            key="gameover"
                            initial={{ scale: 0, rotate: -90 }}
                            animate={{ scale: 1, rotate: 0 }}
                            className="text-elfy-red drop-shadow-[0_0_8px_currentColor]"
                        >
                            <Skull size={16} />
                        </motion.div>
                    ) : isDestroyed ? (
                        isInteracting ? (
                            <motion.div 
                                key="rebooting"
                                initial={{ scale: 0 }}
                                animate={{ scale: 1 }}
                                className="w-4 h-4 bg-elfy-purple rounded-full flex items-center justify-center shadow-[0_0_10px_currentColor]"
                            >
                                <motion.div animate={{ rotate: 360, opacity: [0.6, 1, 0.6] }} transition={{ duration: 0.5, repeat: Infinity }}>
                                    <Zap size={10} className="text-black fill-current" />
                                </motion.div>
                            </motion.div>
                        ) : (
                            <motion.div 
                                key="destroyed"
                                initial={{ scale: 0 }}
                                animate={{ scale: 1 }}
                                className="w-4 h-4 border border-elfy-purple rounded-full flex items-center justify-center opacity-80"
                            >
                                <Power size={10} className="text-elfy-purple" />
                            </motion.div>
                        )
                    ) : isInteracting && isDamaged ? (
                        <motion.div 
                            key="healing"
                            initial={{ scale: 0 }}
                            animate={{ scale: 1 }}
                            className="w-4 h-4 bg-elfy-cyan rounded-full flex items-center justify-center shadow-[0_0_10px_currentColor]"
                        >
                            <motion.div animate={{ rotate: 360 }} transition={{ duration: 1, repeat: Infinity, ease: "linear" }}>
                                <RefreshCw size={10} className="text-black" />
                            </motion.div>
                        </motion.div>
                    ) : isDamaged ? (
                        <motion.div 
                            key="damaged"
                            initial={{ opacity: 1, scale: 1 }}
                            animate={{ 
                                x: [-2, 2, -2, 2, -2, 2, 0, 0, 0, 0, 0, 0, 0], 
                                filter: [
                                    'drop-shadow(0 0 0px rgba(234,231,71,0))',
                                    'drop-shadow(0 0 8px rgba(234,231,71,1))', 
                                    'drop-shadow(0 0 0px rgba(234,231,71,0))'
                                ]
                            }}
                            transition={{ duration: 1.5, repeat: Infinity, ease: "linear" }}
                            className="text-elfy-yellow"
                        >
                            <AlertTriangle size={16} />
                        </motion.div>
                    ) : showOptimal ? (
                        <motion.div 
                            key="optimal"
                            initial={{ scale: 0 }}
                            animate={{ scale: 1 }}
                            exit={{ scale: 0, opacity: 0 }}
                            className="w-4 h-4 bg-elfy-green rounded-full flex items-center justify-center shadow-[0_0_5px_currentColor]"
                        >
                            <Check size={10} className="text-black stroke-[3px]" />
                        </motion.div>
                    ) : null}
                </AnimatePresence>
            </div>
        </div>

        {!isGameOver && (
            <div className="w-full h-1 bg-black/50 relative overflow-hidden">
                <motion.div 
                    className={clsx(
                        "h-full transition-colors duration-200",
                        (isDestroyed && isInteracting) ? "bg-elfy-purple shadow-[0_0_10px_#9E4EA5]" :
                        isDestroyed ? "bg-transparent" : 
                        (isInteracting && isDamaged) ? "bg-elfy-cyan" :
                        isDamaged ? "bg-elfy-yellow" : 
                        "bg-elfy-green"
                    )}
                    initial={{ width: "100%" }}
                    animate={{ width: `${healthPercent}%` }}
                    transition={{ type: "tween", ease: "easeOut", duration: 0.1 }}
                />
            </div>
        )}
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/HoloCommLog.tsx
=====================================
import { useEffect, useState, useRef, useCallback } from 'react';
import { ExternalLink, Radio, WifiOff } from 'lucide-react';
import { useGameStore } from '@/game/store/useGameStore';

const VIDEO_POOL = [
  "oLALHbB3iXU", "A1dnxXrpN-o", "elyXcwunIYA", 
  "bHUcvHx9zlA", "Eq6EYcpWB_c", "sJyWgks1ZtA", 
  "dFlDRhvM4L0", "Ku5fgOHy1JY", "8-91y7BJ8QA"
];

const OfflineStatic = () => (
  <div className="absolute inset-0 z-[50] bg-black flex flex-col items-center justify-center border border-elfy-red/20 overflow-hidden w-full h-full">
    <div className="absolute inset-0 bg-[url('https://media.giphy.com/media/oEI9uBYSzLpBK/giphy.gif')] opacity-40 bg-cover mix-blend-screen pointer-events-none" />
    <div className="relative z-10 animate-pulse text-elfy-red font-mono text-[10px] bg-black/80 px-2 py-1 flex items-center gap-2">
        <WifiOff size={12} />
        <span>SIGNAL_LOST</span>
    </div>
  </div>
);

const VideoSlot = ({ 
  slotIndex, 
  initialVideo, 
  getNextVideo
}: { 
  slotIndex: number, 
  initialVideo: string, 
  getNextVideo: () => string
}) => {
  const [videoId, setVideoId] = useState(initialVideo);
  const [isMasked, setIsMasked] = useState(true); 

  const panelState = useGameStore((state) => state.panels['video']);
  const isOffline = panelState ? (panelState.isDestroyed || panelState.health <= 0) : false;
  
  const prevOffline = useRef(isOffline);

  useEffect(() => {
    if (isOffline && !prevOffline.current) {
        setIsMasked(true); 
    }
    
    if (!isOffline && prevOffline.current) {
        setVideoId(getNextVideo()); 
        setIsMasked(true); 
        
        const t = setTimeout(() => setIsMasked(false), 2000);
        
        prevOffline.current = isOffline;
        return () => clearTimeout(t);
    }

    if (!isOffline && isMasked) {
         const t = setTimeout(() => setIsMasked(false), 2000);
         return () => clearTimeout(t);
    }
    
    prevOffline.current = isOffline;
  }, [isOffline, getNextVideo]);

  useEffect(() => {
    if (isOffline) return; 

    const duration = 30000 + (Math.random() * 15000);
    
    const rotateTimer = setTimeout(() => {
      setIsMasked(true);
      
      const swapTimer = setTimeout(() => {
        setVideoId(getNextVideo());
        
        const unmaskTimer = setTimeout(() => {
            setIsMasked(false);
        }, 2000);
        
        return () => clearTimeout(unmaskTimer);
      }, 1000); 
      
      return () => clearTimeout(swapTimer);
    }, duration);

    return () => clearTimeout(rotateTimer);
  }, [videoId, isOffline, getNextVideo]);

  return (
    <div className="relative w-full aspect-video min-h-[140px] md:min-h-0 border border-elfy-green-dim/30 bg-black overflow-hidden group/video hover:border-elfy-yellow hover:shadow-[0_0_15px_rgba(234,231,71,0.3)] transition-all">
      
      {isOffline ? (
          <OfflineStatic />
      ) : (
        <>
          <div className="absolute inset-0 z-10">
            <iframe 
              key={videoId} 
              width="100%" 
              height="100%" 
              src={`https://www.youtube.com/embed/${videoId}?autoplay=1&mute=1&controls=0&showinfo=0&modestbranding=1&loop=1&playlist=${videoId}&vq=small`} 
              title="HOLO_COMM" 
              frameBorder="0" 
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
              className="w-full h-full object-cover grayscale"
            />
          </div>

          <div className="absolute inset-0 z-30 pointer-events-none bg-[linear-gradient(rgba(0,0,0,0)_50%,rgba(0,0,0,0.25)_50%)] bg-[length:100%_4px]" />
          
          {/* MASK / UPLINK OVERLAY */}
          <div className={`absolute inset-0 z-40 transition-opacity duration-500 flex items-center justify-center pointer-events-none ${isMasked ? 'opacity-100 bg-black' : 'opacity-0 group-hover/video:opacity-100 bg-black/40'}`}>
             {isMasked ? (
                <div className="flex flex-col items-center">
                    <Radio className="text-elfy-green animate-pulse w-6 h-6 mb-2" />
                    <span className="text-[10px] font-mono text-elfy-green animate-pulse">ESTABLISHING_UPLINK...</span>
                </div>
             ) : (
                 // HOVER STATE: Yellow Text & Border
                 <div className="flex items-center gap-2 text-elfy-yellow font-mono font-bold bg-black/80 px-3 py-1 border border-elfy-yellow rounded-sm pointer-events-auto">
                    <span>OPEN_SOURCE</span>
                    <ExternalLink size={12} />
                 </div>
             )}
          </div>
          
          <a 
            href={`https://www.youtube.com/watch?v=${videoId}`}
            target="_blank"
            rel="noopener noreferrer"
            className="absolute inset-0 z-50 cursor-pointer"
            aria-label="Watch on YouTube"
          />

          {/* CAM TEXT: Green by default, stays visible */}
          <div className="absolute bottom-1 right-1 z-[60] text-[8px] text-elfy-green font-mono bg-black/80 px-1 pointer-events-none group-hover/video:text-elfy-yellow transition-colors">
             CAM_0{slotIndex + 1}
          </div>
        </>
      )}
      
      {isOffline && (
          <div className="absolute bottom-1 right-1 z-[60] text-[8px] text-elfy-red font-mono bg-black/80 px-1 pointer-events-none">
             CAM_0{slotIndex + 1} [ERR]
          </div>
      )}
    </div>
  );
};

export const HoloCommLog = () => {
  const deckRef = useRef<string[]>([...VIDEO_POOL]);
  const [initialVideos, setInitialVideos] = useState<string[] | null>(null);

  useEffect(() => {
    deckRef.current = [...VIDEO_POOL];
    const init: string[] = [];
    for(let i=0; i<3; i++) {
      const randomIndex = Math.floor(Math.random() * deckRef.current.length);
      const vid = deckRef.current[randomIndex];
      deckRef.current.splice(randomIndex, 1);
      init.push(vid);
    }
    setInitialVideos(init);
  }, []);

  const getNextVideo = useCallback(() => {
    if (deckRef.current.length === 0) deckRef.current = [...VIDEO_POOL];
    const randomIndex = Math.floor(Math.random() * deckRef.current.length);
    const selected = deckRef.current[randomIndex];
    deckRef.current.splice(randomIndex, 1);
    return selected || VIDEO_POOL[0];
  }, []);

  if (!initialVideos) return <div className="h-full bg-black" />;

  return (
    <div className="flex flex-col h-full gap-2 overflow-hidden p-1 justify-center">
      {initialVideos.map((vid, i) => (
        <VideoSlot 
          key={i} 
          slotIndex={i} 
          initialVideo={vid} 
          getNextVideo={getNextVideo}
        />
      ))}
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/LiveArtGrid.tsx
=====================================
import { useEffect, useState } from 'react';
import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { motion, AnimatePresence } from 'framer-motion';
import { clsx } from 'clsx';

const randomId = () => Math.floor(Math.random() * 899) + 100;

export const LiveArtGrid = () => {
  const { openModal } = useStore();
  const [slots, setSlots] = useState<number[]>([]);
  
  const panelState = useGameStore((state) => state.panels['art']);
  const isDestroyed = panelState ? panelState.isDestroyed : false;

  useEffect(() => {
    setSlots(Array.from({ length: 12 }, randomId));

    const interval = setInterval(() => {
      setSlots(prev => {
        const newSlots = [...prev];
        const randomIndex = Math.floor(Math.random() * 12);
        newSlots[randomIndex] = randomId();
        return newSlots;
      });
    }, 800);

    return () => clearInterval(interval);
  }, []);

  return (
    <div className={clsx(
        "grid grid-cols-3 gap-1 w-full p-2 content-start transition-opacity duration-500",
        isDestroyed ? "pointer-events-none opacity-80" : ""
    )}>
      <AnimatePresence mode='popLayout'>
        {slots.map((id, index) => {
            const isCorrupt = isDestroyed;
            
            return (
              <motion.button
                key={`${index}-${id}`}
                layout
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                transition={{ duration: 0.2 }}
                
                onClick={() => !isDestroyed && openModal('gallery')}
                onMouseEnter={() => !isDestroyed && AudioSystem.playHover()}
                
                className={clsx(
                    "w-full aspect-square relative border group overflow-hidden flex items-center justify-center rounded-[1px] transition-colors",
                    isCorrupt 
                        ? "bg-black border-elfy-red/20" 
                        : "bg-black/50 border-elfy-green-dim/30 hover:border-elfy-yellow hover:shadow-[0_0_10px_rgba(247,210,119,0.2)]"
                )}
              >
                <div className={clsx(
                    "absolute inset-0 transition-colors",
                    isCorrupt ? "bg-elfy-red/5" : "bg-elfy-green/5 group-hover:bg-elfy-green/10"
                )} />
                
                <span className={clsx(
                    "relative z-10 text-[9px] font-mono transition-colors",
                    isCorrupt ? "text-elfy-red/50 animate-pulse" : "text-elfy-green-dim group-hover:text-elfy-yellow"
                )}>
                  {isCorrupt ? (Math.random() > 0.5 ? "0x00" : "ERR") : `IMG_${id}`}
                </span>

                {!isCorrupt && (
                    <div className="absolute top-0 right-0 w-1.5 h-1.5 border-t border-r border-elfy-green-dim/50 group-hover:border-elfy-yellow" />
                )}
              </motion.button>
            );
        })}
      </AnimatePresence>
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/IdentityHUD.tsx
=====================================
import { MiniCrystalCanvas } from '@/scene/props/MiniCrystalCanvas';
import { useGameStore, UpgradeOption } from '@/game/store/useGameStore';
import identity from '@/data/identity.json';
import { useStore } from '@/core/store/useStore'; 
import { AudioSystem } from '@/core/audio/AudioSystem';
import { Unplug, Zap, AlertCircle } from 'lucide-react';

export const IdentityHUD = () => {
  const { openModal } = useStore();
  
  const hp = useGameStore(s => s.playerHealth);
  const maxHp = useGameStore(s => s.maxPlayerHealth);
  const xp = useGameStore(s => s.xp);
  const nextXp = useGameStore(s => s.xpToNextLevel);
  const level = useGameStore(s => s.level);
  
  const upgradePoints = useGameStore(s => s.upgradePoints);
  const selectUpgrade = useGameStore(s => s.selectUpgrade);
  const rebootProgress = useGameStore(s => s.playerRebootProgress);
  
  const panel = useGameStore(s => s.panels['identity']);
  const isPanelDead = panel ? panel.isDestroyed : false;
  const isPlayerDead = hp <= 0;

  const hpPercent = Math.max(0, (hp / maxHp) * 100);
  const xpPercent = Math.min(100, (xp / nextXp) * 100);

  const size = 160; 
  const center = size / 2;
  const radiusHp = 60;
  const radiusXp = 70;
  const stroke = 4;
  
  const circHp = 2 * Math.PI * radiusHp;
  const circXp = 2 * Math.PI * radiusXp;

  const displayHpPercent = isPlayerDead ? rebootProgress : hpPercent;
  const displayHpColor = isPlayerDead ? "#eae747" : (hpPercent < 30 ? "#FF003C" : "#78F654"); 

  const offsetHp = circHp - (displayHpPercent / 100 * circHp);
  const offsetXp = circXp - (xpPercent / 100 * circXp);

  const availableOptions: UpgradeOption[] = ['RAPID_FIRE', 'MULTI_SHOT', 'SPEED_UP', 'REPAIR_NANITES'];

  const handleUpgrade = (u: UpgradeOption) => {
      if (isPanelDead || isPlayerDead) return; 
      AudioSystem.playClick();
      selectUpgrade(u);
  };

  return (
    <div className={`flex flex-col items-center h-full w-full relative ${isPanelDead ? 'grayscale opacity-50 pointer-events-none' : ''}`}>
      
      {/* 1. THE AVATAR (Top) */}
      <div className="relative w-32 h-32 md:w-40 md:h-40 shrink-0 mt-2 group mb-6"> 
        
        {/* AVATAR LAYER */}
        <div className={`absolute inset-0 rounded-full bg-black/50 overflow-hidden transition-opacity duration-500 ${isPlayerDead ? 'opacity-60 grayscale' : 'opacity-100'}`}>
           <MiniCrystalCanvas />
        </div>

        {/* REBOOT INDICATOR (Center Text) */}
        {isPlayerDead && (
            <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                {rebootProgress > 0 ? (
                    <span className="text-2xl font-header font-black text-elfy-yellow drop-shadow-md animate-pulse">
                        {Math.floor(rebootProgress)}%
                    </span>
                ) : (
                    <div className="animate-pulse">
                        <Unplug className="text-white/50 w-8 h-8" />
                    </div>
                )}
            </div>
        )}

        {/* HUD RINGS */}
        <svg className="absolute inset-0 w-full h-full -rotate-90 pointer-events-none" viewBox={`0 0 ${size} ${size}`}>
          <circle cx={center} cy={center} r={radiusHp} stroke="#1a1a1a" strokeWidth={stroke} fill="transparent" />
          <circle cx={center} cy={center} r={radiusXp} stroke="#1a1a1a" strokeWidth={stroke} fill="transparent" strokeDasharray="4 4" />
          
          <circle 
            cx={center} cy={center} r={radiusHp} 
            stroke={displayHpColor} 
            strokeWidth={stroke} fill="transparent"
            strokeDasharray={circHp}
            strokeDashoffset={offsetHp}
            strokeLinecap="round"
            className="transition-all duration-100 ease-linear"
          />
          <circle 
            cx={center} cy={center} r={radiusXp} 
            stroke="#9E4EA5" 
            strokeWidth={stroke} fill="transparent"
            strokeDasharray={circXp}
            strokeDashoffset={offsetXp}
            strokeLinecap="round"
            className="transition-all duration-500 ease-out"
          />
        </svg>

        {/* Level Badge - Pill Style */}
        <div className="absolute bottom-2 left-1/2 -translate-x-1/2 bg-black border border-elfy-purple text-elfy-purple px-2 py-0.5 text-[9px] font-bold font-mono rounded-full shadow-[0_-2px_10px_rgba(158,78,165,0.4)] z-20">
          LVL_{level}
        </div>
      </div>

      {/* 2. INFO & UPGRADES (Middle) */}
      <div className="flex-1 flex flex-col justify-center items-center w-full gap-2 py-1 min-h-0">
        
        {isPlayerDead && !isPanelDead ? (
            <div className="bg-black/80 border border-elfy-yellow/50 px-4 py-2 rounded animate-pulse text-center relative z-50">
                <div className="flex items-center justify-center gap-2 text-elfy-yellow font-bold text-xs mb-1">
                    <Zap size={14} />
                    <span>SYSTEM CRITICAL</span>
                </div>
                <p className="text-[9px] text-white font-mono">HOLD TO REBOOT</p>
                <p className="text-[8px] text-elfy-red mt-1 font-bold">TAKING DAMAGE DRAINS POWER</p>
            </div>
        ) : (
            <div className="text-center">
              <h2 className="text-2xl font-header font-black text-elfy-green tracking-wider">{identity.name}</h2>
              <div className="text-[9px] text-elfy-purple-light uppercase tracking-widest opacity-80">{identity.class}</div>
            </div>
        )}

        {/* UPGRADE MODULE (Stacking) */}
        {upgradePoints > 0 && !isPlayerDead && (
          <div className="w-full bg-elfy-purple-deep/40 border border-elfy-purple/50 p-1.5 rounded-sm pointer-events-auto z-50 animate-pulse">
            <div className="flex items-center justify-center gap-2 mb-1">
                <AlertCircle size={10} className="text-elfy-green" />
                <div className="text-[9px] text-white text-center font-bold tracking-widest">
                  UPGRADE AVAILABLE ({upgradePoints})
                </div>
            </div>
            
            <div className="grid grid-cols-2 gap-1">
              {availableOptions.map(u => (
                <button 
                  key={u}
                  className={`text-[8px] bg-elfy-purple/20 border border-elfy-purple/50 text-elfy-green font-mono py-1 transition-colors uppercase ${isPanelDead ? 'cursor-not-allowed text-gray-500' : 'hover:bg-elfy-purple hover:text-white'}`}
                  onMouseEnter={() => !isPanelDead && AudioSystem.playHover()}
                  onClick={() => handleUpgrade(u)}
                >
                  {u.replace('_', ' ')}
                </button>
              ))}
            </div>
          </div>
        )}
      </div>

      {/* 3. NAVIGATION */}
      <div className="w-full grid grid-cols-2 gap-3 mt-auto pt-2 border-t border-elfy-green-dim/10">
        <button 
          onClick={() => !isPanelDead && openModal('about')} 
          onMouseEnter={() => !isPanelDead && AudioSystem.playHover()}
          className="py-2 bg-elfy-purple-deep/20 border border-elfy-purple text-elfy-purple-light hover:bg-elfy-purple hover:text-black transition-all font-bold text-xs font-header uppercase clip-corner-btn"
        >
          About
        </button>
        <button 
          onClick={() => !isPanelDead && openModal('contact')} 
          onMouseEnter={() => !isPanelDead && AudioSystem.playHover()}
          className="py-2 bg-elfy-yellow/5 border border-elfy-yellow text-elfy-yellow hover:bg-elfy-yellow hover:text-black transition-all font-bold text-xs font-header uppercase clip-corner-btn"
        >
          Contact
        </button>
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/atoms/ZenBomb.tsx
=====================================
import { motion, AnimatePresence } from 'framer-motion';
import { Bomb, Skull } from 'lucide-react';
import { useGameStore } from '@/game/store/useGameStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { useState } from 'react';

export const ZenBomb = () => {
  const isGameOver = useGameStore(state => state.systemIntegrity <= 0);
  const isZenMode = useGameStore(state => state.isZenMode);
  const activateZenMode = useGameStore(state => state.activateZenMode);
  const [clicked, setClicked] = useState(false);

  if (!isGameOver || isZenMode) return null;

  const handleClick = () => {
    setClicked(true);
    AudioSystem.playClick();
    
    setTimeout(() => {
        activateZenMode();
    }, 800);
  };

  return (
    <AnimatePresence>
      {!clicked && (
        <motion.button
          initial={{ y: -200, opacity: 0 }}
          animate={{ y: 0, opacity: 1 }}
          exit={{ scale: 3, opacity: 0, filter: "blur(20px)" }} 
          transition={{ type: "spring", stiffness: 100, damping: 15, delay: 1.0 }} 
          
          onClick={handleClick}
          // Z-30 is correct (behind Header z-40)
          className="fixed top-24 left-1/2 -translate-x-1/2 z-30 flex flex-col items-center group cursor-pointer"
        >
          {/* CONNECTOR LINE: Increased width and opacity for visibility */}
          <motion.div 
            initial={{ height: 0 }}
            animate={{ height: 160 }} 
            transition={{ delay: 1.0, duration: 0.8, ease: "easeOut" }}
            className="w-[2px] bg-elfy-red/80 absolute -top-64 left-1/2 -translate-x-1/2 shadow-[0_0_8px_#FF003C]"
          />

          {/* THE BOMB BUTTON */}
          <div className="relative p-1 border border-elfy-red bg-black/90 backdrop-blur-md shadow-[0_0_20px_#FF003C] overflow-hidden group-hover:shadow-[0_0_40px_#FF003C] transition-shadow duration-300 z-10">
             
             <div className="absolute inset-0 opacity-20 pointer-events-none" 
                  style={{ backgroundImage: 'repeating-linear-gradient(45deg, #FF003C 0, #FF003C 5px, transparent 5px, transparent 10px)' }} 
             />

             <div className="relative w-16 h-16 border border-elfy-red/50 flex items-center justify-center bg-black hover:bg-elfy-red transition-colors duration-300 group-hover:text-black text-elfy-red">
                 <motion.div
                   animate={{ rotate: [0, -10, 10, 0] }}
                   transition={{ repeat: Infinity, duration: 0.3, repeatDelay: 2 }} 
                 >
                    <Bomb size={32} strokeWidth={2} />
                 </motion.div>
             </div>
          </div>

          {/* LABEL */}
          <div className="mt-4 flex items-center gap-2 px-3 py-1 bg-elfy-red/10 border border-elfy-red/50 backdrop-blur-md z-10">
             <Skull size={10} className="text-elfy-red animate-pulse" />
             <span className="text-[10px] font-mono font-black text-elfy-red tracking-widest uppercase group-hover:text-white transition-colors">
                PURGE_SYSTEM
             </span>
             <Skull size={10} className="text-elfy-red animate-pulse" />
          </div>
          
          <span className="text-[8px] text-elfy-red/60 font-mono mt-1 opacity-0 group-hover:opacity-100 transition-opacity">
            [ ENABLE_ZEN_MODE ]
          </span>
        </motion.button>
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/atoms/CustomCursor.tsx
=====================================
import { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { clsx } from 'clsx';

export const CustomCursor = () => {
  const [pos, setPos] = useState({ x: 0, y: 0 });
  const [isHovering, setIsHovering] = useState(false);
  const [isClicking, setIsClicking] = useState(false);
  
  const { introDone, isDebugOpen, bootState } = useStore();
  
  const playerHealth = useGameStore(state => state.playerHealth);
  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const isDead = playerHealth <= 0 || systemIntegrity <= 0;

  useEffect(() => {
    const move = (e: MouseEvent) => {
      setPos({ x: e.clientX, y: e.clientY });
      
      const target = e.target as HTMLElement;
      // Hover triggers on buttons, inputs, links, labels, and specific interactive zones
      const isInteractive = target.closest('button, a, input, label, [data-interactive="true"]');
      setIsHovering(!!isInteractive);
    };

    const down = () => setIsClicking(true);
    const up = () => setIsClicking(false);

    window.addEventListener('mousemove', move);
    window.addEventListener('mousedown', down);
    window.addEventListener('mouseup', up);

    return () => {
      window.removeEventListener('mousemove', move);
      window.removeEventListener('mousedown', down);
      window.removeEventListener('mouseup', up);
    };
  }, []);

  const isVisible = !introDone || isDebugOpen || bootState === 'sandbox';

  return (
    <>
      <style jsx global>{`
        body, a, button, input, label, select, textarea { cursor: none !important; }
      `}</style>

      <motion.div
        className={clsx(
            "fixed top-0 left-0 pointer-events-none z-[10000]",
            (isHovering && !isDead) ? "mix-blend-difference" : "" 
        )}
        animate={{ x: pos.x, y: pos.y }}
        transition={{ type: "tween", ease: "linear", duration: 0 }}
      >
        <AnimatePresence mode="wait">
          {/* Show cursor during Intro/Debug/Sandbox. 
              If DEAD: Custom red cursor logic in future, but for now we hide the SVG if dead 
              because user requested 3D triangle takes over. */}
          {isVisible && !isDead && (
            <motion.div
              key="custom-cursor"
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              transition={{ duration: 0.2 }}
              className="relative"
            >
              <svg 
                width="24" 
                height="24" 
                viewBox="0 0 24 24" 
                className={`transition-transform duration-100 ${isClicking ? 'scale-90' : 'scale-100'}`}
                style={{ 
                    filter: isHovering ? 'drop-shadow(0 0 12px #eae747)' : 'drop-shadow(0 0 8px #78F654)',
                    fill: isHovering ? '#eae747' : '#78F654'
                }}
              >
                <path d="M5.5 3.21l12.32 12.32-4.5 1.12 3.5 3.5-2.12 2.12-3.5-3.5-1.12 4.5z" />
              </svg>
            </motion.div>
          )}
        </AnimatePresence>
      </motion.div>
    </>
  );
};


=====================================
FILE: ./src/ui/atoms/VirtualJoystick.tsx
=====================================
import { useState, useRef, useEffect } from 'react';
import { ServiceLocator } from '@/game/core/ServiceLocator';
import { InputSystem } from '@/game/systems/InputSystem';

export const VirtualJoystick = () => {
  const [active, setActive] = useState(false);
  const [pos, setPos] = useState({ x: 0, y: 0 });
  const stickRef = useRef<HTMLDivElement>(null);
  
  // Configuration
  const MAX_RADIUS = 40;

  const handlePointerDown = (e: React.PointerEvent) => {
    (e.target as HTMLElement).setPointerCapture(e.pointerId);
    setActive(true);
  };

  const handlePointerMove = (e: React.PointerEvent) => {
    if (!active) return;
    
    // Calculate delta from center
    // We assume the stick is centered in the 100x100 container
    // The event coords are relative to the button (the puck) if captured? 
    // Easier strategy: Use clientX/Y relative to the container center.
    
    const rect = stickRef.current?.parentElement?.getBoundingClientRect();
    if (!rect) return;
    
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    const dx = e.clientX - centerX;
    const dy = e.clientY - centerY;
    
    const distance = Math.sqrt(dx*dx + dy*dy);
    const clampedDist = Math.min(distance, MAX_RADIUS);
    
    const angle = Math.atan2(dy, dx);
    const x = Math.cos(angle) * clampedDist;
    const y = Math.sin(angle) * clampedDist;
    
    setPos({ x, y });

    // Send normalized vector to InputSystem
    // Note: Y is inverted in 3D world (Up is Positive), but Screen Y is Down Positive.
    // However, InputSystem logic in `update` adds to cursor. 
    // If I pull stick DOWN (Positive Y on Screen), I want cursor to go DOWN (Negative Y in World).
    // So we invert Y here.
    const normX = x / MAX_RADIUS;
    const normY = -(y / MAX_RADIUS); 
    
    try {
        const input = ServiceLocator.getSystem<InputSystem>('InputSystem');
        input.setJoystickVector(normX, normY);
    } catch {}
  };

  const handlePointerUp = (e: React.PointerEvent) => {
    setActive(false);
    setPos({ x: 0, y: 0 });
    try {
        const input = ServiceLocator.getSystem<InputSystem>('InputSystem');
        input.setJoystickVector(0, 0);
    } catch {}
  };

  return (
    <div className="fixed bottom-8 right-8 w-32 h-32 z-[90] touch-none select-none">
      {/* Base */}
      <div 
        className="w-full h-full rounded-full border-2 border-elfy-green/30 bg-black/50 backdrop-blur-sm relative flex items-center justify-center"
        ref={stickRef}
      >
        {/* Stick */}
        <div 
          className="w-12 h-12 rounded-full bg-elfy-green/80 shadow-[0_0_15px_#78F654] absolute cursor-pointer transition-transform duration-75 ease-linear"
          style={{ transform: `translate(${pos.x}px, ${pos.y}px)` }}
          onPointerDown={handlePointerDown}
          onPointerMove={handlePointerMove}
          onPointerUp={handlePointerUp}
          onPointerCancel={handlePointerUp}
        />
      </div>
      <div className="absolute -top-6 w-full text-center text-[10px] text-elfy-green/50 font-mono tracking-widest">
          [ NAV ]
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/atoms/PanelSparks.tsx
=====================================
import { useEffect, useRef } from 'react';

interface Particle {
  x: number;
  y: number;
  vx: number;
  vy: number;
  life: number;
  maxLife: number;
  size: number;
  color: string;
}

interface PanelSparksProps {
  intensity?: 'normal' | 'extreme'; 
}

export const PanelSparks = ({ intensity }: PanelSparksProps) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Resize handling
    if (canvas.parentElement) {
        canvas.width = canvas.parentElement.clientWidth;
        canvas.height = canvas.parentElement.clientHeight;
    }

    let particles: Particle[] = [];
    let animationFrameId: number;

    const COLORS = ['#FF003C', '#CC0020', '#800010', '#FF4466'];
    
    // UPDATED: 500 Particles (Catastrophic Failure)
    const PARTICLE_COUNT = 500; 
    
    // 1. INITIAL SPAWN (ONE SHOT)
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const edge = Math.floor(Math.random() * 3); // 0: Top, 1: Left, 2: Right
        let x = 0, y = 0, vx = 0, vy = 0;

        if (edge === 0) { // Top
            x = Math.random() * canvas.width;
            y = 0;
            vx = (Math.random() - 0.5) * 8;
            vy = (Math.random() * 5) + 2; // Down
        } else if (edge === 1) { // Left
            x = 0;
            y = Math.random() * (canvas.height * 0.5); 
            vx = (Math.random() * 5) + 2; // Right
            vy = (Math.random() * 5) - 2;
        } else { // Right
            x = canvas.width;
            y = Math.random() * (canvas.height * 0.5);
            vx = -((Math.random() * 5) + 2); // Left
            vy = (Math.random() * 5) - 2;
        }

        particles.push({
            x, y, vx, vy,
            life: 1.0,
            maxLife: 1.0,
            size: Math.random() * 3 + 1,
            color: COLORS[Math.floor(Math.random() * COLORS.length)]
        });
    }

    // 2. ANIMATION LOOP
    const loop = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      let activeParticles = false;

      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        
        // Physics
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.15; // Gravity
        
        // Floor Bounce
        if (p.y > canvas.height) {
          p.y = canvas.height;
          p.vy *= -0.5; 
          p.vx *= 0.7;  
        }
        
        // Wall Bounce
        if (p.x < 0 || p.x > canvas.width) {
          p.vx *= -0.6;
          p.x = Math.max(0, Math.min(canvas.width, p.x));
        }

        // Slow Decay
        p.life -= 0.005; 

        // Render
        if (p.life > 0) {
            activeParticles = true;
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life; 
            ctx.beginPath();
            ctx.rect(p.x, p.y, p.size, p.size);
            ctx.fill();
        } else {
            particles.splice(i, 1);
        }
      }
      
      if (activeParticles) {
          animationFrameId = requestAnimationFrame(loop);
      } else {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    };

    loop();

    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  }, [intensity]);

  return (
    <canvas 
      ref={canvasRef} 
      className="absolute inset-0 pointer-events-none z-0 mix-blend-screen"
    />
  );
};


=====================================
FILE: ./src/ui/atoms/GlassPanel.tsx
=====================================
import { clsx } from 'clsx';
import { motion, AnimatePresence } from 'framer-motion';
import { ReactNode, useEffect as useReactEffect, useState as useReactState, useRef as useReactRef } from 'react';
import { usePanelRegistry } from '@/game/hooks/usePanelRegistry';
import { useGameStore } from '@/game/store/useGameStore';
import { Skull } from 'lucide-react';
import { PanelSparks } from './PanelSparks';

// SUB-COMPONENTS
import { RebootOverlay } from '@/ui/molecules/panel/RebootOverlay';
import { IntelligentHeader } from '@/ui/molecules/panel/IntelligentHeader';
import { BreachOverlay } from '@/ui/molecules/panel/BreachOverlay';

const MAX_HEALTH = 1000;

const panelVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { 
    opacity: 1, 
    y: 0,
    transition: { duration: 0.5, ease: "easeOut" }
  },
  shattered: (custom: number) => ({
    y: 350 + (custom * 50),
    opacity: 0.8,
    rotate: custom * 15,
    transition: { 
        duration: 1.5, 
        ease: "anticipate",
        delay: Math.abs(custom) * 0.1 
    }
  })
};

interface GlassPanelProps {
  children: ReactNode;
  className?: string;
  title?: string;
  gameId?: string;
}

export const GlassPanel = ({ children, className, title, gameId }: GlassPanelProps) => {
  const registryRef = gameId ? usePanelRegistry(gameId) : null;
  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  
  const interactionTarget = useGameStore(state => state.interactionTarget);
  const isInteracting = gameId && interactionTarget === gameId;

  const isGameOver = Math.floor(systemIntegrity) <= 0;
  const panelState = useGameStore((state) => gameId ? state.panels[gameId] : null);

  const health = panelState ? panelState.health : MAX_HEALTH;
  const isDestroyed = panelState ? panelState.isDestroyed : false;
  const healthPercent = (health / MAX_HEALTH) * 100; 
  const isDamaged = health < MAX_HEALTH;

  const [showReboot, setShowReboot] = useReactState(false);
  const prevDestroyed = useReactRef(isDestroyed);

  useReactEffect(() => {
    if (prevDestroyed.current && !isDestroyed && !isGameOver) {
        setShowReboot(true);
        const timer = setTimeout(() => setShowReboot(false), 2000); 
        return () => clearTimeout(timer);
    }
    prevDestroyed.current = isDestroyed;
  }, [isDestroyed, isGameOver]);

  let borderColor = "border-elfy-green-dim/30";
  if (isDestroyed) {
      borderColor = isInteracting 
        ? "border-elfy-purple shadow-[0_0_10px_#9E4EA5]" 
        : "border-elfy-red animate-pulse"; 
  }
  else if (isInteracting && isDamaged) borderColor = "border-elfy-cyan shadow-[0_0_10px_#00F0FF]";
  else if (isDamaged) borderColor = "border-elfy-yellow/50";

  const randSeed = (title?.length || 5) % 2 === 0 ? 1 : -1;

  return (
    <motion.div 
      ref={registryRef}
      variants={panelVariants}
      initial="hidden"
      animate={isGameOver ? "shattered" : "visible"}
      custom={randSeed}
      className={clsx(
        "relative overflow-hidden flex flex-col group",
        "bg-black border",
        borderColor, 
        "shadow-[0_0_15px_rgba(11,212,38,0.05)]", 
        "rounded-sm",
        className
      )}
    >
      <div className="absolute inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(10,10,10,0.4)_50%)] z-0 bg-[length:100%_4px]" />
      
      {title && (
          <IntelligentHeader 
            title={title} 
            health={health} 
            isDestroyed={isDestroyed} 
            isGameOver={isGameOver}
            gameId={gameId}
          />
      )}

      <div className="relative z-10 p-4 h-full">
        {(isDestroyed || isGameOver) && (
            <PanelSparks intensity={isGameOver ? 'extreme' : 'normal'} />
        )}

        <div className={clsx("h-full flex flex-col relative z-20", isGameOver ? "invisible" : "visible")}>
            {children}
            {isDestroyed && (
                <BreachOverlay 
                    progress={healthPercent} 
                    isVideo={gameId === 'video'} 
                    showInteractive={true} 
                />
            )}
        </div>

        <AnimatePresence>
            {showReboot && <RebootOverlay key="reboot" />}
        </AnimatePresence>
        
        {isGameOver && (
            <div className="absolute inset-0 z-[100] flex flex-col items-center justify-center gap-4 bg-transparent pointer-events-none">
                <Skull className="text-elfy-red animate-pulse w-20 h-20 drop-shadow-[0_0_15px_rgba(255,0,60,0.8)]" />
                <span className="text-elfy-red font-header font-black text-2xl tracking-widest drop-shadow-lg">SYSTEM FAILURE</span>
            </div>
        )}
      </div>
    </motion.div>
  );
};


=====================================
FILE: ./src/ui/overlays/ErrorBoundary.tsx
=====================================
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { AlertTriangle, RefreshCw } from 'lucide-react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class WebGLErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null,
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("WebGL Context Crash:", error, errorInfo);
  }

  private handleReload = () => {
    window.location.reload();
  };

  public render() {
    if (this.state.hasError) {
      return (
        <div className="absolute inset-0 z-[100] flex flex-col items-center justify-center bg-black text-elfy-red p-8 text-center font-mono">
          <div className="border border-elfy-red/50 bg-elfy-red/10 p-8 max-w-lg shadow-[0_0_50px_rgba(255,0,60,0.2)]">
            <div className="flex justify-center mb-4">
               <AlertTriangle size={48} className="animate-pulse" />
            </div>
            <h2 className="text-2xl font-black tracking-widest mb-4">GRAPHICS_CORE_FAILURE</h2>
            <p className="text-sm mb-6 text-elfy-red/80">
              The neural interface encountered a critical WebGL error.
              <br/>
              <span className="text-xs opacity-50 mt-2 block font-mono">{this.state.error?.message}</span>
            </p>
            <button 
              onClick={this.handleReload}
              className="flex items-center justify-center gap-2 w-full py-3 bg-elfy-red text-black font-bold tracking-widest hover:bg-white transition-colors"
            >
              <RefreshCw size={16} />
              REBOOT_SYSTEM
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}


=====================================
FILE: ./src/ui/overlays/ModalContainer.tsx
=====================================
import { useStore } from '@/core/store/useStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { motion, AnimatePresence } from 'framer-motion';
import { X } from 'lucide-react';

interface ModalContainerProps {
  children: React.ReactNode;
  title: string;
  type: string;
}

export const ModalContainer = ({ children, title, type }: ModalContainerProps) => {
  const { activeModal, closeModal } = useStore();
  const isOpen = activeModal === type;

  return (
    <AnimatePresence>
      {isOpen && (
        // FIX: Bumped z-index to 100 to stay above GameOverlay (z-60)
        <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 md:p-10">
          
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={closeModal}
            className="absolute inset-0 bg-black/80 backdrop-blur-sm cursor-pointer"
          />

          <motion.div
            initial={{ scale: 0.9, opacity: 0, y: 20 }}
            animate={{ scale: 1, opacity: 1, y: 0 }}
            exit={{ scale: 0.95, opacity: 0, y: 10 }}
            transition={{ type: "spring", bounce: 0, duration: 0.3 }}
            className="relative w-full max-w-5xl h-full max-h-[90vh] bg-black border border-elfy-green/50 shadow-[0_0_50px_rgba(0,255,65,0.1)] flex flex-col overflow-hidden"
          >
            <div className="flex items-center justify-between px-4 py-3 bg-elfy-green/10 border-b border-elfy-green/30">
              <div className="flex items-center gap-2">
                <div className="w-3 h-3 bg-elfy-red rounded-full animate-pulse" />
                <span className="font-header font-black text-elfy-green text-lg md:text-xl tracking-widest">
                  {title}
                </span>
              </div>
              <button 
                onClick={closeModal}
                onMouseEnter={() => AudioSystem.playHover()} 
                className="p-1 hover:bg-elfy-red hover:text-black text-elfy-green transition-colors"
              >
                <X />
              </button>
            </div>

            <div className="flex-1 overflow-auto p-6 relative scrollbar-thin scrollbar-thumb-elfy-green scrollbar-track-black">
              <div className="absolute inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.1)_50%)] bg-[length:100%_4px] opacity-20" />
              <div className="relative z-10">
                {children}
              </div>
            </div>

            <div className="px-4 py-1 bg-black border-t border-elfy-green/30 text-xs text-elfy-green-dim font-mono text-right">
              MODE: SECURE // ENCRYPTION: ENABLED
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/organisms/Footer.tsx
=====================================
import { useEffect, useState, useRef } from 'react';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';
import { AnimatePresence, motion } from 'framer-motion';
import { useGameStore } from '@/game/store/useGameStore';
import { clsx } from 'clsx';

const IDLE_MESSAGES = [
  "SYSTEM_MONITORING...",
  "SCANNING_LATENT_SECTORS...",
  "ENCRYPTION_ACTIVE...",
  "PACKET_STREAM_STABLE...",
  "PINGING_NEURAL_NET...",
  "RENDERING_CONTEXT...",
];

export const Footer = () => {
  const commitHash = process.env.NEXT_PUBLIC_COMMIT_HASH || 'UNKNOWN';
  const actionsUrl = "https://github.com/mesoelfy/mesoelfy.github.io/actions";
  
  // GLOBAL STATE FOR COLORS
  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const isGameOver = systemIntegrity <= 0;
  const isCritical = systemIntegrity < 30;
  const isWarning = systemIntegrity < 60;

  let globalColor = "text-elfy-green-dim border-elfy-green-dim/30";
  if (isGameOver) globalColor = "text-elfy-red border-elfy-red/50";
  else if (isCritical) globalColor = "text-elfy-red border-elfy-red/30";
  else if (isWarning) globalColor = "text-elfy-yellow border-elfy-yellow/30";

  const [log, setLog] = useState<{ text: string, type: 'info' | 'warn' | 'crit' }>({ 
      text: "SYSTEM_ONLINE", type: 'info' 
  });
  
  const lockUntilRef = useRef(0);

  useEffect(() => {
    // Helper to check if we should update log
    const canUpdate = () => {
        const state = useGameStore.getState();
        if (state.systemIntegrity <= 0) return false; // DEAD SILENCE
        return Date.now() > lockUntilRef.current;
    };

    // 1. Event Listeners
    const unsubHit = GameEventBus.subscribe(GameEvents.PLAYER_HIT, () => {
        if (!canUpdate()) return;
        setLog({ text: ">> WARNING: HULL BREACH DETECTED", type: 'warn' });
        lockUntilRef.current = Date.now() + 1000;
    });

    const unsubDamage = GameEventBus.subscribe(GameEvents.PANEL_DAMAGED, (p) => {
        if (!canUpdate()) return;
        setLog({ text: `>> ALERT: SECTOR [${p.id.toUpperCase()}] SUSTAINING DAMAGE`, type: 'warn' });
        lockUntilRef.current = Date.now() + 1500;
    });

    const unsubDestroy = GameEventBus.subscribe(GameEvents.PANEL_DESTROYED, (p) => {
        // Critical messages can override lock unless game over
        if (useGameStore.getState().systemIntegrity <= 0) return;
        setLog({ text: `‚ö† CRITICAL: SECTOR [${p.id.toUpperCase()}] OFFLINE ‚ö†`, type: 'crit' });
        lockUntilRef.current = Date.now() + 3000;
    });

    const unsubGameOver = GameEventBus.subscribe(GameEvents.GAME_OVER, () => {
        // FORCE OVERRIDE
        setLog({ text: "‚ö† SYSTEM FAILURE // CONNECTION LOST ‚ö†", type: 'crit' });
        lockUntilRef.current = Date.now() + 999999999; 
    });

    const unsubSpawn = GameEventBus.subscribe(GameEvents.ENEMY_SPAWNED, (p) => {
        if (!canUpdate()) return;
        if (Math.random() > 0.9) {
            setLog({ text: `>> SENSOR: NEW SIGNAL [${p.type.toUpperCase()}] DETECTED`, type: 'info' });
        }
    });
    
    const unsubHeal = GameEventBus.subscribe(GameEvents.PANEL_HEALED, (p) => {
        if (!canUpdate()) return;
        setLog({ text: `>> MAINTENANCE: RESTORING [${p.id.toUpperCase()}]`, type: 'info' });
    });

    // 2. Idle Loop
    const interval = setInterval(() => {
        if (canUpdate()) {
            const msg = IDLE_MESSAGES[Math.floor(Math.random() * IDLE_MESSAGES.length)];
            setLog({ text: msg, type: 'info' });
        }
    }, 4000);

    return () => {
        unsubHit(); unsubDamage(); unsubDestroy(); unsubSpawn(); unsubHeal(); unsubGameOver();
        clearInterval(interval);
    };
  }, []);

  // Force update immediately on React state change for Game Over to ensure UI sync
  useEffect(() => {
      if (isGameOver) {
          setLog({ text: "‚ö† SYSTEM FAILURE // CONNECTION LOST ‚ö†", type: 'crit' });
      }
  }, [isGameOver]);

  return (
    <footer className={clsx(
        "w-full h-8 border-t bg-black flex items-center justify-between px-4 z-40 shrink-0 text-[10px] font-mono overflow-hidden transition-colors duration-500",
        globalColor
    )}>
      
      {/* LEFT: System Log */}
      <div className="flex-1 flex items-center gap-2 overflow-hidden mr-4">
        <span className="shrink-0 font-bold">LOG:</span>
        <AnimatePresence mode="wait">
            <motion.span 
                key={log.text}
                initial={{ opacity: 0, y: 5 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -5 }}
                transition={{ duration: 0.2 }}
                className={clsx(
                    "whitespace-nowrap font-bold tracking-wider truncate",
                    // If Game Over, FORCE Red. Otherwise respect message type colors
                    isGameOver ? "text-elfy-red animate-pulse" : 
                    log.type === 'crit' ? "text-elfy-red animate-pulse" : 
                    log.type === 'warn' ? "text-elfy-yellow" : 
                    "text-elfy-green"
                )}
            >
                {log.text}
            </motion.span>
        </AnimatePresence>
      </div>

      {/* RIGHT: Version */}
      <div className="flex items-center gap-2 shrink-0 opacity-50 hover:opacity-100 transition-opacity">
        <span>VER:</span>
        <a 
          href={actionsUrl}
          target="_blank" 
          rel="noopener noreferrer"
          className="hover:text-white transition-colors decoration-dashed underline underline-offset-2"
        >
          {commitHash}
        </a>
      </div>
    </footer>
  );
};


=====================================
FILE: ./src/ui/organisms/Header.tsx
=====================================
import { Volume2, VolumeX, Music, Activity } from 'lucide-react';
import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { useEffect, useState } from 'react';
import { clsx } from 'clsx';
import { motion } from 'framer-motion';
import { useTransientRef } from '@/game/hooks/useTransientRef';

// --- SUB-COMPONENTS ---

const Radar = ({ active, panic, color }: { active: boolean, panic: boolean, color: string }) => (
  <div className={`relative w-8 h-8 rounded-full border border-current flex items-center justify-center overflow-hidden bg-black/50 ${color}`}>
    <div className="absolute inset-0 border-current opacity-20" 
         style={{ backgroundImage: 'radial-gradient(circle, currentColor 1px, transparent 1px)', backgroundSize: '8px 8px' }} />
    <div className="absolute w-full h-[1px] bg-current opacity-40" />
    <div className="absolute h-full w-[1px] bg-current opacity-40" />
    
    <motion.div 
      className="absolute inset-0 origin-bottom-right opacity-40"
      style={{ 
        background: 'conic-gradient(from 0deg, transparent 270deg, currentColor 360deg)',
      }}
      animate={{ rotate: 360 }}
      transition={{ 
        repeat: Infinity, 
        ease: "linear", 
        duration: panic ? 1.0 : 4.0 
      }}
    />
    <div className={`w-1 h-1 rounded-full bg-current ${active ? 'animate-pulse' : ''}`} />
  </div>
);

const SfxBtn = ({ active, onClick, color }: { active: boolean, onClick: () => void, color: string }) => (
  <button 
    onClick={onClick}
    className={clsx(
      "flex items-center justify-center px-1.5 py-1 transition-all duration-200 border border-transparent rounded-sm font-mono text-[10px] font-bold tracking-tighter",
      active 
        ? `hover:text-elfy-yellow bg-white/5 border-white/10 ${color}`
        : `${color} opacity-40 hover:text-elfy-red hover:opacity-100 decoration-line-through`
    )}
  >
    SFX
  </button>
);

const AudioBtn = ({ active, onClick, icon: Icon, offIcon: OffIcon, color }: any) => (
  <button 
    onClick={onClick}
    className={clsx(
      "flex items-center justify-center p-1.5 transition-all duration-200 border border-transparent rounded-sm",
      active 
        ? `hover:text-elfy-yellow bg-white/5 ${color}`
        : `${color} opacity-40 hover:text-elfy-red hover:opacity-100`
    )}
  >
    {active ? <Icon size={14} /> : <OffIcon size={14} />}
  </button>
);

export const Header = () => {
  const { audioSettings, toggleMaster, toggleMusic, toggleSfx } = useStore();
  
  // Low frequency updates via React
  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const isPlaying = useGameStore(state => state.isPlaying);
  
  // High frequency updates via Ref
  const scoreRef = useTransientRef('score-display', 'text');

  const [mounted, setMounted] = useState(false);
  useEffect(() => setMounted(true), []);

  const isCritical = systemIntegrity < 30;
  const isWarning = systemIntegrity < 60;
  const isGameOver = systemIntegrity <= 0;
  
  let statusColor = "text-elfy-green";
  if (isCritical) statusColor = "text-elfy-red";
  else if (isWarning) statusColor = "text-elfy-yellow";

  return (
    <header className="relative w-full h-12 bg-black/90 backdrop-blur-md flex items-center justify-between px-4 z-40 shrink-0 border-b border-white/5 transition-colors duration-300">
      
      {/* LEFT: Identity */}
      <div className="flex items-center gap-4">
        <span className={clsx(
            "font-header font-black text-xl md:text-2xl tracking-wide transition-colors duration-500",
            statusColor
        )}>
          MESOELFY_OS
        </span>
        
        {mounted && (
          <div className={`hidden md:flex items-center gap-4 text-xs font-mono border-l border-white/10 pl-4 ${statusColor}`}>
            <Radar active={isPlaying} panic={isCritical || (isPlaying && isCritical)} color={statusColor} />
            
            <div className="flex flex-col leading-none">
                <span className="text-[8px] opacity-60 tracking-wider">THREAT_NEUTRALIZED</span>
                {/* 
                   We use the ref here. React will render '0000' initially, 
                   but the UISyncSystem will overwrite innerText 60fps.
                */}
                <span ref={scoreRef} className="font-bold text-lg tabular-nums tracking-widest">
                    0000
                </span>
            </div>
          </div>
        )}
      </div>

      {/* RIGHT: Status & Audio Controls */}
      <div className="flex items-center gap-4">
        <div className="flex items-center gap-1 border-l border-white/10 pl-4">
            <SfxBtn active={audioSettings.sfx} onClick={toggleSfx} color={statusColor} />
            
            <AudioBtn 
                active={audioSettings.music} 
                onClick={toggleMusic} 
                icon={Music} 
                offIcon={Music}
                color={statusColor}
            />

            <div className="w-[1px] h-4 bg-white/10 mx-1" />

            <AudioBtn 
                active={audioSettings.master} 
                onClick={toggleMaster} 
                icon={Volume2} 
                offIcon={VolumeX} 
                color={statusColor}
            />
        </div>
      </div>

      {/* BOTTOM BORDER */}
      {!isGameOver && (
        <div className="absolute bottom-[-1px] left-0 right-0 h-[2px] bg-gray-900">
          <div 
            className={clsx("h-full transition-all duration-500 ease-out shadow-[0_0_10px_currentColor]", 
                isCritical ? "bg-elfy-red" : isWarning ? "bg-elfy-yellow" : "bg-elfy-green"
            )} 
            style={{ width: `${systemIntegrity}%` }}
          />
        </div>
      )}
      
      {/* INTEGRITY TEXT */}
      <div className={clsx(
          "absolute bottom-[-14px] right-2 text-[8px] font-mono flex items-center gap-1 transition-colors duration-300",
          isCritical ? "text-elfy-red" : isWarning ? "text-elfy-yellow" : "text-elfy-green-dim"
      )}>
        <Activity size={8} className={isCritical ? "animate-pulse" : ""} />
        <span>OS_INTEGRITY: {Math.floor(systemIntegrity)}%</span>
      </div>

    </header>
  );
};


=====================================
FILE: ./src/core/audio/AudioSystem.ts
=====================================
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';
import { useStore } from '@/core/store/useStore';

class AudioSystemController {
  private ctx: AudioContext | null = null;
  private masterGain: GainNode | null = null;
  private sfxGain: GainNode | null = null;
  private musicGain: GainNode | null = null;
  private musicElement: HTMLAudioElement | null = null;
  private buffers: Map<string, AudioBuffer> = new Map();
  
  public isReady = false; // Public flag

  public async init() {
    if (this.isReady) {
        if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume().catch(() => {});
        return;
    }

    const AudioContextClass = (window as any).AudioContext || (window as any).webkitAudioContext;
    this.ctx = new AudioContextClass();
    if (!this.ctx) return;

    this.masterGain = this.ctx.createGain();
    this.sfxGain = this.ctx.createGain();
    this.musicGain = this.ctx.createGain();

    this.sfxGain.connect(this.masterGain);
    this.musicGain.connect(this.masterGain);
    this.masterGain.connect(this.ctx.destination);

    const settings = useStore.getState().audioSettings;
    this.masterGain.gain.value = settings.master ? 0.5 : 0;
    this.musicGain.gain.value = settings.music ? 0.4 : 0;
    this.sfxGain.gain.value = settings.sfx ? 0.8 : 0;

    // Await buffer generation
    await this.preRenderSounds();
    
    this.setupEventListeners();
    this.setupMusic();

    this.isReady = true;
  }

  private async preRenderSounds() {
      if (!this.ctx) return;
      const render = async (duration: number, fn: (t: number, ctx: OfflineAudioContext) => void) => {
          const sampleRate = 44100;
          const offline = new OfflineAudioContext(1, sampleRate * duration, sampleRate);
          fn(duration, offline);
          return await offline.startRendering();
      };

      // Generate all buffers (Parallel)
      const p = [];
      
      p.push(render(0.15, (d, c) => {
          const osc = c.createOscillator(); osc.type = 'sawtooth'; osc.frequency.setValueAtTime(880, 0); osc.frequency.exponentialRampToValueAtTime(110, d);
          const g = c.createGain(); g.gain.setValueAtTime(0.2, 0); g.gain.exponentialRampToValueAtTime(0.01, d);
          osc.connect(g); g.connect(c.destination); osc.start();
      }).then(b => this.buffers.set('laser', b)));

      p.push(render(0.4, (d, c) => {
          const b = c.createBuffer(1, c.sampleRate * d, c.sampleRate);
          const data = b.getChannelData(0); for(let i=0; i<data.length; i++) data[i] = Math.random()*2-1;
          const n = c.createBufferSource(); n.buffer = b;
          const f = c.createBiquadFilter(); f.type='lowpass'; f.frequency.setValueAtTime(1000, 0); f.frequency.exponentialRampToValueAtTime(100, d);
          const g = c.createGain(); g.gain.setValueAtTime(0.3, 0); g.gain.exponentialRampToValueAtTime(0.01, d);
          n.connect(f); f.connect(g); g.connect(c.destination); n.start();
      }).then(b => this.buffers.set('explosion', b)));

      p.push(render(0.05, (d, c) => {
          const o = c.createOscillator(); o.type='square'; o.frequency.setValueAtTime(400,0);
          const g = c.createGain(); g.gain.setValueAtTime(0.1, 0); g.gain.exponentialRampToValueAtTime(0.01, d);
          o.connect(g); g.connect(c.destination); o.start();
      }).then(b => this.buffers.set('click', b)));

      p.push(render(0.2, (d, c) => {
          const o = c.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(300,0); o.frequency.linearRampToValueAtTime(600, d);
          const g = c.createGain(); g.gain.setValueAtTime(0.1, 0); g.gain.linearRampToValueAtTime(0, d);
          o.connect(g); g.connect(c.destination); o.start();
      }).then(b => this.buffers.set('heal', b)));

      p.push(render(1.5, (d, c) => {
          const o = c.createOscillator(); o.type='sawtooth'; o.frequency.setValueAtTime(100,0); o.frequency.exponentialRampToValueAtTime(10, d);
          const g = c.createGain(); g.gain.setValueAtTime(0.5, 0); g.gain.exponentialRampToValueAtTime(0.01, d);
          o.connect(g); g.connect(c.destination); o.start();
      }).then(b => this.buffers.set('destruction', b)));

      await Promise.all(p);
  }

  // ... (Ducking Logic omitted for brevity, it's the same as previous step) ...
  private duckMusic(intensity: number, duration: number) {
      if (!this.ctx || !this.musicGain) return;
      const settings = useStore.getState().audioSettings;
      if (!settings.music) return;
      const now = this.ctx.currentTime;
      const baseVol = 0.4;
      const targetVol = baseVol * (1.0 - intensity);
      this.musicGain.gain.cancelScheduledValues(now);
      this.musicGain.gain.setValueAtTime(this.musicGain.gain.value, now);
      this.musicGain.gain.linearRampToValueAtTime(targetVol, now + 0.05);
      this.musicGain.gain.exponentialRampToValueAtTime(baseVol, now + duration);
  }

  public playSound(key: string, detune = 0, volume = 1.0) {
      if (!this.ctx || !this.sfxGain) return;
      const buffer = this.buffers.get(key);
      if (!buffer) return;
      const source = this.ctx.createBufferSource();
      source.buffer = buffer;
      source.detune.value = detune;
      const gain = this.ctx.createGain();
      gain.gain.value = volume;
      source.connect(gain);
      gain.connect(this.sfxGain);
      source.start();
  }

  public startMusic() {
    if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume().catch(() => {});
    if (!this.musicElement) this.setupMusic();
    if (this.musicElement) this.musicElement.play().catch(() => {});
  }

  private setupMusic() {
    if (!this.ctx || !this.musicGain || this.musicElement) return;
    this.musicElement = new Audio('/assets/audio/bg_music_placeholder.mp3');
    this.musicElement.loop = true;
    this.musicElement.crossOrigin = "anonymous";
    const source = this.ctx.createMediaElementSource(this.musicElement);
    source.connect(this.musicGain);
  }

  private setupEventListeners() {
    GameEventBus.subscribe(GameEvents.PLAYER_FIRED, () => this.playSound('laser', Math.random() * 100));
    GameEventBus.subscribe(GameEvents.ENEMY_DESTROYED, () => { this.playSound('explosion', Math.random() * 200 - 100); this.duckMusic(0.3, 0.5); });
    GameEventBus.subscribe(GameEvents.PLAYER_HIT, () => { this.playSound('explosion', -500); this.duckMusic(0.7, 1.0); });
    GameEventBus.subscribe(GameEvents.GAME_OVER, () => { this.playSound('destruction', -200); this.duckMusic(1.0, 3.0); });
    GameEventBus.subscribe(GameEvents.PANEL_HEALED, () => this.playSound('heal'));
    GameEventBus.subscribe(GameEvents.UPGRADE_SELECTED, () => this.playSound('heal', 200));
    GameEventBus.subscribe(GameEvents.PANEL_DESTROYED, () => { this.playSound('destruction', 0); this.duckMusic(0.8, 1.5); });
  }

  public playClick() { this.playSound('click'); }
  public playHover() { this.playSound('click', 500, 0.2); }
  public playBootSequence() { this.playSound('click'); } 
  public setMasterMute(m: boolean) { if (this.masterGain) this.masterGain.gain.value = m ? 0 : 0.5; }
  public setMusicMute(m: boolean) { if (this.musicGain) this.musicGain.gain.value = m ? 0 : 0.4; }
  public setSfxMute(m: boolean) { if (this.sfxGain) this.sfxGain.gain.value = m ? 0 : 0.8; }
}

export const AudioSystem = new AudioSystemController();


=====================================
FILE: ./src/core/store/useStore.ts
=====================================
import { create } from 'zustand';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { useGameStore } from '@/game/store/useGameStore';
import { EnemyTypes } from '@/game/config/Identifiers';

// --- TYPES ---
interface AudioSettings {
  master: boolean;
  music: boolean;
  sfx: boolean;
}

type ModalType = 'none' | 'about' | 'gallery' | 'feed' | 'contact';
type BootState = 'standby' | 'active' | 'sandbox';
type SandboxView = 'arena' | 'gallery';

interface DebugFlags {
  godMode: boolean;
  panelGodMode: boolean;
  peaceMode: boolean;
  showHitboxes: boolean;
  timeScale: number;
}

interface AppState {
  // App Flow
  bootState: BootState;
  introDone: boolean;
  activeModal: ModalType;
  hoveredItem: string | null;
  
  // Sandbox State
  sandboxView: SandboxView;
  galleryTarget: string; // NEW: Which enemy to show
  galleryAction: 'IDLE' | 'ATTACK'; // NEW: Animation state
  
  // Audio
  audioSettings: AudioSettings;
  
  // Debug
  isDebugOpen: boolean;
  isDebugMinimized: boolean;
  debugFlags: DebugFlags;
  
  // Actions
  setBootState: (state: BootState) => void;
  setIntroDone: (done: boolean) => void;
  setSandboxView: (view: SandboxView) => void;
  setGalleryTarget: (target: string) => void; // NEW
  toggleGalleryAction: () => void; // NEW
  
  openModal: (modal: ModalType) => void;
  closeModal: () => void;
  setHovered: (item: string | null) => void;
  resetApplication: () => void;
  
  toggleMaster: () => void;
  toggleMusic: () => void;
  toggleSfx: () => void;
  
  toggleDebugMenu: () => void;
  toggleDebugMinimize: () => void;
  setDebugFlag: (key: keyof DebugFlags, value: any) => void;
  resetDebugFlags: () => void;
}

export const useStore = create<AppState>((set, get) => ({
  bootState: 'standby',
  introDone: false,
  activeModal: 'none',
  hoveredItem: null,
  
  sandboxView: 'arena',
  galleryTarget: EnemyTypes.DRILLER,
  galleryAction: 'IDLE',
  
  audioSettings: {
    master: true,
    music: false,
    sfx: true,
  },
  
  isDebugOpen: false,
  isDebugMinimized: false,
  debugFlags: {
    godMode: false,
    panelGodMode: false,
    peaceMode: false,
    showHitboxes: false,
    timeScale: 1.0,
  },

  setBootState: (bs) => set({ bootState: bs }),
  setIntroDone: (done) => set({ introDone: done }),
  setSandboxView: (view) => set({ sandboxView: view }),
  setGalleryTarget: (target) => set({ galleryTarget: target }),
  toggleGalleryAction: () => set(state => ({ galleryAction: state.galleryAction === 'IDLE' ? 'ATTACK' : 'IDLE' })),
  
  openModal: (modal) => {
      if (get().audioSettings.master && get().audioSettings.sfx) {
          AudioSystem.playClick(); 
      }
      set({ activeModal: modal });
  },
  
  closeModal: () => {
      if (get().audioSettings.master && get().audioSettings.sfx) {
          AudioSystem.playClick();
      }
      set({ activeModal: 'none' });
  },
  
  setHovered: (item) => set({ hoveredItem: item }),
  
  resetApplication: () => {
      useGameStore.getState().stopGame();
      useGameStore.getState().resetGame(); 
      
      set({
          bootState: 'standby',
          introDone: false,
          activeModal: 'none',
          isDebugOpen: false,
          isDebugMinimized: false,
          sandboxView: 'arena',
          galleryTarget: EnemyTypes.DRILLER,
          galleryAction: 'IDLE'
      });
  },
  
  toggleMaster: () => {
      const prev = get().audioSettings.master;
      const next = !prev;
      set(state => ({ audioSettings: { ...state.audioSettings, master: next } }));
      AudioSystem.setMasterMute(!next);
      if (next && get().audioSettings.sfx) AudioSystem.playClick(); 
  },

  toggleMusic: () => {
      const prev = get().audioSettings.music;
      const next = !prev;
      set(state => ({ audioSettings: { ...state.audioSettings, music: next } }));
      AudioSystem.setMusicMute(!next);
      if (next && get().audioSettings.master && get().audioSettings.sfx) AudioSystem.playClick();
  },

  toggleSfx: () => {
      const prev = get().audioSettings.sfx;
      const next = !prev;
      set(state => ({ audioSettings: { ...state.audioSettings, sfx: next } }));
      AudioSystem.setSfxMute(!next);
      if (next && get().audioSettings.master) AudioSystem.playClick();
  },
  
  toggleDebugMenu: () => set(state => ({ isDebugOpen: !state.isDebugOpen })),
  toggleDebugMinimize: () => set(state => ({ isDebugMinimized: !state.isDebugMinimized })),
  setDebugFlag: (key, value) => set(state => ({ 
      debugFlags: { ...state.debugFlags, [key]: value } 
  })),
  resetDebugFlags: () => set({
      debugFlags: { godMode: false, panelGodMode: false, peaceMode: false, showHitboxes: false, timeScale: 1.0 }
  })
}));


=====================================
FILE: ./src/app/layout.tsx
=====================================
import type { Metadata, Viewport } from 'next';
import { Montserrat, JetBrains_Mono } from 'next/font/google';
import '@/styles/globals.css';

const montserrat = Montserrat({ 
  subsets: ['latin'],
  weight: ['400', '700', '900'], 
  variable: '--font-montserrat',
  display: 'swap',
});

const jetbrains = JetBrains_Mono({
  subsets: ['latin'],
  weight: ['400', '700'],
  variable: '--font-jetbrains',
  display: 'swap',
});

export const metadata: Metadata = {
  title: 'MESOELFY // LATENT SPACE BANDIT',
  description: 'The official digital HQ of Mesoelfy. Art, Lore, and Neural Network Injections.',
  icons: {
    icon: '/favicon.ico',
  },
  openGraph: {
    title: 'MESOELFY_OS',
    description: 'Access the terminal. View the art. Breach the firewall.',
    url: 'https://mesoelfy.github.io',
    siteName: 'MESOELFY',
    images: [
      {
        url: 'https://mesoelfy.github.io/assets/images/social-card.jpg',
        width: 1200,
        height: 630,
      },
    ],
    locale: 'en_US',
    type: 'website',
  },
  twitter: {
    card: 'summary_large_image',
    title: 'MESOELFY // LATENT SPACE BANDIT',
    description: 'Access the terminal. View the art. Breach the firewall.',
    images: ['https://mesoelfy.github.io/assets/images/social-card.jpg'],
  },
};

export const viewport: Viewport = {
  themeColor: '#000000',
  colorScheme: 'dark',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" className={`${montserrat.variable} ${jetbrains.variable}`}>
      <body 
        className="bg-black text-elfy-green selection:bg-elfy-green selection:text-black font-mono"
        style={{ backgroundColor: '#000000' }} // Hardcode black to prevent FOUC
      >
        <div className="relative w-full h-full">
          {children}
        </div>
      </body>
    </html>
  );
}


=====================================
FILE: ./src/app/page.tsx
=====================================
'use client';

import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { SceneCanvas } from '@/scene/canvas/SceneCanvas';
import { GlassPanel } from '@/ui/atoms/GlassPanel';
import { SocialRow } from '@/ui/molecules/SocialRow';
import { LiveArtGrid } from '@/ui/molecules/LiveArtGrid';
import { HoloCommLog } from '@/ui/molecules/HoloCommLog';
import { IdentityHUD } from '@/ui/molecules/IdentityHUD';
import { Header } from '@/ui/organisms/Header';
import { Footer } from '@/ui/organisms/Footer';
import { AboutModal } from '@/features/identity/AboutModal';
import { FeedModal } from '@/features/feed/FeedModal';
import { GalleryModal } from '@/features/gallery/GalleryModal';
import { ContactModal } from '@/features/contact/ContactModal';
import { MatrixBootSequence } from '@/features/intro/MatrixBootSequence';
import { GameOverlay } from '@/game/GameOverlay';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { GlobalShakeManager } from '@/features/effects/GlobalShakeManager';
import { CustomCursor } from '@/ui/atoms/CustomCursor';
import { ZenBomb } from '@/ui/atoms/ZenBomb';
import { DebugOverlay } from '@/features/debug/DebugOverlay';
import { SimulationHUD } from '@/features/sandbox/SimulationHUD';
import { WebGLErrorBoundary } from '@/ui/overlays/ErrorBoundary'; // NEW
import { clsx } from 'clsx';

export default function Home() {
  const { openModal, setIntroDone, bootState, setBootState } = useStore(); 
  const startGame = useGameStore(s => s.startGame);
  const recalcIntegrity = useGameStore(s => s.recalculateIntegrity);
  const systemIntegrity = useGameStore(s => s.systemIntegrity);
  const isZenMode = useGameStore(s => s.isZenMode);
  
  const isGameOver = systemIntegrity <= 0;
  const isSandbox = bootState === 'sandbox';

  const [showScene, setShowScene] = useState(false); 

  const handleBreachStart = () => {
    // Start Audio Preload when "Breach" begins (User clicked Initialize)
    AudioSystem.init().then(() => {
        // Audio is ready
    });
    setShowScene(true);
  };

  const handleBootComplete = () => {
    setTimeout(() => {
      setBootState('active');
      setIntroDone(true);
      startGame();
    }, 200);
  };

  useEffect(() => {
    if (bootState !== 'active') return;
    const interval = setInterval(recalcIntegrity, 500);
    return () => clearInterval(interval);
  }, [bootState, recalcIntegrity]);

  const isGridVisible = showScene || bootState !== 'standby';

  return (
    <div id="global-app-root" className="relative w-full h-screen overflow-hidden cursor-none bg-black">
      
      <CustomCursor />
      <GlobalShakeManager />
      <DebugOverlay />

      <main className="relative w-full h-full flex flex-col overflow-hidden text-elfy-green selection:bg-elfy-green selection:text-black font-mono">
        
        {/* WRAP 3D SCENE IN ERROR BOUNDARY */}
        <WebGLErrorBoundary>
            <SceneCanvas className={clsx("blur-0", isGridVisible ? "opacity-100" : "opacity-0")} />
            {(bootState === 'active' || bootState === 'sandbox') && <GameOverlay />}
        </WebGLErrorBoundary>

        {isSandbox && <SimulationHUD />}

        {!isSandbox && (
            <>
                <AboutModal />
                <FeedModal />
                <GalleryModal />
                <ContactModal />
                <ZenBomb />
            </>
        )}

        {bootState === 'standby' && (
          <MatrixBootSequence 
             onComplete={handleBootComplete} 
             onBreachStart={handleBreachStart} 
          />
        )}

        {!isSandbox && (
            <div className={`relative z-10 flex-1 flex flex-col h-full transition-all duration-1000 ease-in-out ${bootState === 'active' ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-4'}`}>
              <Header />

              <div className="flex-1 min-h-0 relative w-full max-w-[1600px] mx-auto p-4 md:p-6">
                <AnimatePresence>
                  {!isZenMode && (
                    <motion.div 
                      className={clsx(
                          "grid grid-cols-1 md:grid-cols-12 gap-4 md:gap-6 h-full w-full scrollbar-thin scrollbar-thumb-elfy-green scrollbar-track-black",
                          isGameOver ? "overflow-visible" : "overflow-y-auto md:overflow-hidden"
                      )}
                      initial="hidden"
                      animate="visible"
                      exit={{ opacity: 0, scale: 0.95, transition: { duration: 0.5 } }}
                      variants={{
                        hidden: { opacity: 0 },
                        visible: { 
                          opacity: 1, 
                          transition: { 
                            staggerChildren: 0.3,
                            delayChildren: 0.2 
                          } 
                        }
                      }}
                    >
                      <div className="md:col-span-4 flex flex-col gap-4 md:gap-6 h-auto">
                        <GlassPanel title="IDENTITY_CORE" className="flex-1 min-h-0" gameId="identity">
                          <IdentityHUD />
                        </GlassPanel>

                        <GlassPanel title="SOCIAL_UPLINK" className="h-auto shrink-0" gameId="social">
                           <SocialRow />
                        </GlassPanel>
                      </div>

                      <div className="md:col-span-8 flex flex-col gap-4 md:gap-6 h-auto">
                        <GlassPanel title="LATEST_LOGS" className="h-48 md:h-64 shrink-0" gameId="feed">
                          <div className="w-full h-full flex items-center justify-center p-4">
                            <div className="flex flex-col items-center justify-center gap-4 border border-dashed border-elfy-green-dim/30 bg-black/20 p-8">
                              <p className="animate-pulse text-elfy-green-dim text-xs">&gt; ESTABLISHING UPLINK...</p>
                              <button 
                                onClick={() => openModal('feed')} 
                                className="px-6 py-2 border border-elfy-green text-elfy-green hover:bg-elfy-green hover:text-black transition-colors uppercase tracking-wider font-header font-black text-base md:text-lg whitespace-nowrap"
                              >
                                [ ACCESS TERMINAL ]
                              </button>
                            </div>
                          </div>
                        </GlassPanel>

                        <div className="flex flex-col md:flex-row gap-4 md:gap-6 items-start h-auto">
                          <GlassPanel title="ART_DB" className="flex-1 h-auto" gameId="art">
                             <LiveArtGrid />
                          </GlassPanel>

                          <GlassPanel title="HOLO_COMM" className="w-full md:w-[45%] shrink-0 h-auto" gameId="video">
                             <HoloCommLog />
                          </GlassPanel>
                        </div>
                      </div>
                    </motion.div>
                  )}
                </AnimatePresence>
              </div>
              
              <Footer />
            </div>
        )}
      </main>
    </div>
  );
}


=====================================
FILE: ./src/features/contact/ContactModal.tsx
=====================================
import { ModalContainer } from '@/ui/overlays/ModalContainer';
import { Send } from 'lucide-react';

export const ContactModal = () => {
  return (
    <ModalContainer title="ENCRYPTED_UPLINK // CONTACT" type="contact">
      <div className="max-w-2xl mx-auto h-full flex flex-col justify-center">
        
        {/* Added Triangles and Font-Header for the Warning */}
        <div className="p-2 border border-elfy-yellow/30 bg-elfy-yellow/5 mb-6 text-center flex items-center justify-center gap-3">
          <span className="text-elfy-yellow animate-pulse">‚ö†</span>
          <p className="text-xs text-elfy-yellow font-header font-bold tracking-wider">
            WARNING: TRANSMISSIONS ARE MONITORED BY THE AI OVERLORD.
          </p>
          <span className="text-elfy-yellow animate-pulse">‚ö†</span>
        </div>

        <form 
          action="https://formspree.io/f/xkgdbkpz" 
          method="POST"
          className="space-y-6"
        >
          <div className="space-y-1">
            <label className="text-sm text-elfy-green-dim uppercase tracking-wider font-header font-bold">Codename</label>
            <input 
              type="text" 
              name="name"
              required
              placeholder="Enter your handle..."
              className="w-full bg-black border border-elfy-green-dim/50 p-3 text-elfy-green font-mono focus:border-elfy-green focus:outline-none focus:shadow-[0_0_10px_rgba(120,246,84,0.2)] transition-all"
            />
          </div>

          <div className="space-y-1">
            <label className="text-sm text-elfy-green-dim uppercase tracking-wider font-header font-bold">Frequency (Email)</label>
            <input 
              type="email" 
              name="email"
              required
              placeholder="Enter return frequency..."
              className="w-full bg-black border border-elfy-green-dim/50 p-3 text-elfy-green font-mono focus:border-elfy-green focus:outline-none focus:shadow-[0_0_10px_rgba(120,246,84,0.2)] transition-all"
            />
          </div>

          <div className="space-y-1">
            <label className="text-sm text-elfy-green-dim uppercase tracking-wider font-header font-bold">Payload</label>
            <textarea 
              name="message"
              required
              rows={5}
              placeholder="Type your message..."
              className="w-full bg-black border border-elfy-green-dim/50 p-3 text-elfy-green font-mono focus:border-elfy-green focus:outline-none focus:shadow-[0_0_10px_rgba(120,246,84,0.2)] transition-all resize-none"
            />
          </div>

          <button 
            type="submit"
            className="w-full py-4 bg-elfy-green text-black font-header font-black uppercase tracking-widest hover:bg-white transition-colors flex items-center justify-center gap-2 group"
          >
            <span>Send Transmission</span>
            <Send size={16} className="group-hover:translate-x-1 transition-transform" />
          </button>
        </form>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/features/identity/AboutModal.tsx
=====================================
import { ModalContainer } from '@/ui/overlays/ModalContainer';
import identity from '@/data/identity.json';

export const AboutModal = () => {
  return (
    <ModalContainer title="IDENTITY_DATABASE // ELFY" type="about">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-8 h-full">
        
        {/* LEFT: The Avatar Grid */}
        <div className="space-y-4">
          <div className="aspect-square w-full border border-elfy-purple-light/50 bg-elfy-purple-deep/30 relative overflow-hidden group shadow-[0_0_20px_rgba(188,134,186,0.2)]">
            <div className="absolute inset-0 flex items-center justify-center text-elfy-purple-light/50 font-bold text-2xl group-hover:text-elfy-purple-light transition-colors font-header font-black tracking-widest text-center p-4">
              [ COMPOSITE_IMAGE LOADING ]
            </div>
            <div className="absolute top-0 left-0 w-4 h-4 border-t-2 border-l-2 border-elfy-purple-light" />
            <div className="absolute bottom-0 right-0 w-4 h-4 border-b-2 border-r-2 border-elfy-purple-light" />
          </div>
          
          <div className="grid grid-cols-4 gap-2">
            {[1,2,3,4].map(i => (
              <div key={i} className="aspect-square border border-elfy-purple-dim/30 hover:bg-elfy-purple-light/20 hover:border-elfy-purple-light cursor-pointer transition-colors" />
            ))}
          </div>
        </div>

        {/* RIGHT: The Data */}
        <div className="space-y-6">
          <div>
            {/* Header: Montserrat */}
            <h2 className="text-4xl font-header font-black text-elfy-green mb-2 tracking-wide">HI, I'M ELFY.</h2>
            <div className="h-1 w-20 bg-elfy-purple-light mb-4" />
            
            {/* Body: Courier (font-mono) for ease of reading/typewriter feel */}
            <p className="text-lg text-white/90 leading-relaxed font-mono">
              {identity.bio}
            </p>
          </div>

          <div className="space-y-2">
            <h3 className="text-elfy-purple-light font-header font-bold uppercase tracking-wider text-sm">Capabilities</h3>
            <ul className="space-y-1">
              {identity.abilities.map((ability, i) => (
                 <li key={i} className="flex items-center gap-2 text-elfy-green font-mono">
                   <span className="text-elfy-purple-light">&gt;</span> {ability}
                 </li>
              ))}
            </ul>
          </div>

          <div className="p-4 border border-elfy-purple-dim/30 bg-elfy-purple-deep/20 text-sm text-elfy-purple-light font-mono">
            <p>&gt; SYSTEM NOTE: Generated via Latent Space Injection.</p>
            <p>&gt; STATUS: 100% Hype.</p>
          </div>
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/features/intro/MatrixBootSequence.tsx
=====================================
import { useEffect, useRef, useState, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { ShieldAlert, Cpu, Unlock, Lock, Skull } from 'lucide-react';

interface Props {
  onComplete: () => void;
  onBreachStart: () => void;
}

const ASCII_TITLE = `
 ‚ñà‚ñà‚ñà‚ñÑ ‚ñÑ‚ñà‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñì      ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà   ‚ñà‚ñà‚ñì
‚ñì‚ñà‚ñà‚ñí‚ñÄ‚ñà‚ñÄ ‚ñà‚ñà‚ñí‚ñì‚ñà   ‚ñÄ‚ñí‚ñà‚ñà    ‚ñí ‚ñí‚ñà‚ñà‚ñí  ‚ñà‚ñà‚ñí‚ñì‚ñà   ‚ñÄ ‚ñì‚ñà‚ñà‚ñí    ‚ñí‚ñì‚ñà   ‚ñí  ‚ñí‚ñà‚ñà  ‚ñà‚ñà‚ñí
‚ñì‚ñà‚ñà    ‚ñì‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà‚ñà  ‚ñë ‚ñì‚ñà‚ñà‚ñÑ   ‚ñí‚ñà‚ñà‚ñë  ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñà   ‚ñí‚ñà‚ñà‚ñë    ‚ñí‚ñì‚ñà‚ñà‚ñà ‚ñë   ‚ñí‚ñà‚ñà ‚ñà‚ñà‚ñë
‚ñí‚ñà‚ñà    ‚ñí‚ñà‚ñà ‚ñí‚ñì‚ñà  ‚ñÑ  ‚ñí   ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà   ‚ñà‚ñà‚ñë‚ñí‚ñì‚ñà  ‚ñÑ ‚ñí‚ñà‚ñà‚ñë    ‚ñë‚ñì‚ñà‚ñí  ‚ñë   ‚ñë ‚ñê‚ñà‚ñà‚ñë‚ñë
‚ñí‚ñà‚ñà‚ñí   ‚ñë‚ñà‚ñà‚ñí‚ñë‚ñí‚ñà‚ñà‚ñà‚ñà‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñë ‚ñà‚ñà‚ñà‚ñà‚ñì‚ñí‚ñë‚ñë‚ñí‚ñà‚ñà‚ñà‚ñà‚ñí‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñë‚ñí‚ñà‚ñë      ‚ñë ‚ñà‚ñà‚ñí‚ñë‚ñë
‚ñë ‚ñí‚ñë   ‚ñë  ‚ñë‚ñë‚ñë ‚ñí‚ñë ‚ñë ‚ñí‚ñë‚ñí  ‚ñë ‚ñë ‚ñí‚ñë‚ñí‚ñë‚ñí‚ñë ‚ñë‚ñë ‚ñí‚ñë ‚ñë‚ñë ‚ñí‚ñë‚ñí  ‚ñë ‚ñí ‚ñë       ‚ñà‚ñà‚ñí‚ñí‚ñí
‚ñë  ‚ñë      ‚ñë ‚ñë ‚ñë  ‚ñë ‚ñë ‚ñí  ‚ñë   ‚ñë ‚ñí ‚ñí‚ñë  ‚ñë ‚ñë  ‚ñë‚ñë ‚ñë ‚ñí  ‚ñë ‚ñë       ‚ñì‚ñà‚ñà ‚ñë‚ñí‚ñë 
‚ñë      ‚ñë      ‚ñë    ‚ñë ‚ñë    ‚ñë ‚ñë ‚ñë ‚ñí     ‚ñë     ‚ñë ‚ñë    ‚ñë ‚ñë     ‚ñí ‚ñí ‚ñë‚ñë  
       ‚ñë      ‚ñë  ‚ñë   ‚ñë  ‚ñë     ‚ñë ‚ñë     ‚ñë  ‚ñë    ‚ñë  ‚ñë         ‚ñë ‚ñë     
`;

// --- RESTORED ASCII RENDERER ---
const AsciiRenderer = () => {
  const renderedChars = useMemo(() => {
    return ASCII_TITLE.split('').map((char, i) => {
      if (char === '\n') return <br key={i} />;
      if (char === ' ') return <span key={i}> </span>;

      let animClass = '';
      
      if (['‚ñà', '‚ñÄ', '‚ñÑ', '‚ñå', '‚ñê'].includes(char)) {
        animClass = 'animate-matrix-green text-elfy-green-dark';
      } else if (['‚ñë', '‚ñí', '‚ñì'].includes(char)) {
        animClass = 'animate-matrix-purple text-elfy-purple';
      } else {
        animClass = 'text-elfy-green-dark';
      }

      const delay = Math.random() * 2 + 's';

      return (
        <span 
          key={i} 
          className={animClass} 
          style={{ animationDelay: delay }}
        >
          {char}
        </span>
      );
    });
  }, []);

  return (
    <div className="font-mono font-bold leading-[1.1] whitespace-pre text-center select-none overflow-hidden text-[9px] md:text-[11px] shrink-0">
      {renderedChars}
    </div>
  );
};

const BootHeader = ({ step }: { step: number }) => {
  const isUnsafe = step === 3;
  const isBypass = step === 4;
  const isSecure = step >= 5;

  let color = "text-elfy-green-dim";
  let statusText = "ESTABLISHING...";
  let bgClass = "bg-elfy-green/5";
  
  if (isUnsafe) {
      color = "text-elfy-red";
      statusText = "SIGNAL_CORRUPTED";
      bgClass = "bg-elfy-red/10 border-elfy-red/30";
  } else if (isBypass) {
      color = "text-elfy-purple-light";
      statusText = "INJECTING_PAYLOAD";
      bgClass = "bg-elfy-purple/10 border-elfy-purple/30";
  } else if (isSecure) {
      color = "text-elfy-green";
      statusText = "UPLINK_STABLE";
      bgClass = "bg-elfy-green/10 border-elfy-green/30";
  } else if (step >= 1) {
      statusText = "HANDSHAKING...";
  }

  return (
    <div className={`flex shrink-0 items-center justify-between border-b border-white/10 ${bgClass} px-3 py-2 mb-2 select-none relative z-20 transition-all duration-300`}>
      <div className="flex flex-col leading-none gap-1.5 mt-0.5">
          <span className={`text-[10px] font-mono tracking-widest uppercase ${color} transition-colors duration-300 font-bold`}>
            BOOT_LOADER.SYS
          </span>
          <span className="text-[8px] text-gray-500 font-mono tracking-wider opacity-80">{statusText}</span>
      </div>
      
      <div className="flex gap-1 items-end h-3">
        {[1, 2, 3, 4].map(i => {
           let heightClass = "h-1";
           let animClass = "";
           let barColor = isUnsafe ? "bg-elfy-red" : isBypass ? "bg-elfy-purple-light" : "bg-elfy-green";
           
           if (isUnsafe) {
               heightClass = i % 2 === 0 ? "h-3" : "h-1";
               animClass = "animate-pulse";
           } else if (isBypass) {
               heightClass = (step + i) % 2 === 0 ? "h-3" : "h-2";
           } else if (isSecure) {
               heightClass = "h-3"; 
           } else {
               heightClass = step >= (i-1) ? "h-2" : "h-0.5";
               animClass = step >= (i-1) ? "animate-pulse" : "";
           }

           return (
               <div 
                 key={i} 
                 className={`w-1 rounded-sm transition-all duration-300 ${barColor} ${animClass} ${heightClass}`} 
                 style={{ opacity: isSecure ? 1 : 0.7 }} 
               />
           );
        })}
      </div>
    </div>
  );
};

const CoreHeader = ({ step }: { step: number }) => {
  const isUnsafe = step === 3;
  const isBypass = step === 4;
  const isDecrypted = step === 5;
  const isCaution = step >= 6;

  const [showCpu, setShowCpu] = useState(false);

  useEffect(() => {
    if (step === 5) {
      setShowCpu(false);
      const timer = setTimeout(() => {
        setShowCpu(true);
      }, 700); 
      return () => clearTimeout(timer);
    }
  }, [step]);

  let borderColor = "border-elfy-green/30";
  let bgColor = "bg-elfy-green/10";
  let textColor = "text-elfy-green";

  if (isUnsafe) {
    borderColor = "border-elfy-red/50";
    bgColor = "bg-elfy-red/10";
    textColor = "text-elfy-red";
  } else if (isBypass) {
    borderColor = "border-elfy-purple/50";
    bgColor = "bg-elfy-purple/10";
    textColor = "text-elfy-purple-light";
  }

  return (
    <motion.div 
      className={`flex shrink-0 items-center justify-between border-b px-3 py-2 mb-2 select-none transition-colors duration-500 ${!isCaution ? `${borderColor} ${bgColor}` : ''}`}
      animate={isCaution ? {
        borderColor: ['rgba(120,246,84,0.3)', 'rgba(234,231,71,0.6)', 'rgba(120,246,84,0.3)'],
        backgroundColor: ['rgba(120,246,84,0.1)', 'rgba(234,231,71,0.15)', 'rgba(120,246,84,0.1)'],
      } : {}}
      transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }}
    >
      <motion.span 
        className={`text-sm font-mono font-bold tracking-widest uppercase ${!isCaution ? textColor : ''}`}
        animate={isCaution ? {
            color: ['#78F654', '#eae747', '#78F654']
        } : {}}
        transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }}
      >
        MESOELFY_CORE
      </motion.span>
      
      <div className="relative w-6 h-6 flex items-center justify-center">
         <AnimatePresence mode="wait">
            {isUnsafe ? (
                <motion.div 
                    key="unsafe"
                    initial={{ scale: 0 }} 
                    animate={{ scale: 1, x: [-2, 2, -2, 2, 0] }}
                    exit={{ scale: 0 }}
                    transition={{ x: { repeat: Infinity, duration: 0.1 } }}
                >
                    <ShieldAlert size={18} className="text-elfy-red" />
                </motion.div>
            ) : isBypass ? (
                <motion.div 
                    key="bypass"
                    initial={{ opacity: 0, scale: 0.8 }} 
                    animate={{ opacity: 1, scale: 1.1 }} 
                    exit={{ opacity: 0, scale: 0, transition: { duration: 0.2, repeat: 0 } }}
                    transition={{ repeat: Infinity, repeatType: "reverse", duration: 0.8 }}
                >
                     <Unlock size={18} className="text-elfy-purple-light" />
                </motion.div>
            ) : isCaution ? (
                <motion.div 
                    key="caution"
                    initial={{ scale: 0, opacity: 0 }} 
                    animate={{ scale: 1, opacity: 1 }}
                >
                    <motion.div
                       animate={{
                           filter: ['drop-shadow(0 0 8px rgba(120,246,84,0.8))', 'drop-shadow(0 0 15px rgba(234,231,71,1))', 'drop-shadow(0 0 8px rgba(120,246,84,0.8))'],
                           color: ['#78F654', '#eae747', '#78F654'],
                           rotate: [0, 8, -8, 0] 
                       }}
                       transition={{ duration: 2.0, repeat: Infinity, ease: "easeInOut" }}
                    >
                         <Skull size={18} />
                    </motion.div>
                </motion.div>
            ) : isDecrypted ? (
                !showCpu ? (
                    <motion.div 
                        key="locked"
                        initial={{ scale: 1.5, opacity: 0 }} 
                        animate={{ scale: 1, opacity: 1 }} 
                        exit={{ scale: 0, opacity: 0, transition: { duration: 0.2 } }}
                        transition={{ type: "spring", stiffness: 400, damping: 20 }}
                    >
                         <Lock size={18} className="text-elfy-green drop-shadow-[0_0_8px_rgba(120,246,84,0.8)]" />
                    </motion.div>
                ) : (
                    <motion.div 
                        key="cpu"
                        initial={{ scale: 0, rotate: -45 }} 
                        animate={{ scale: 1, rotate: 0 }} 
                        exit={{ scale: 0, opacity: 0, transition: { duration: 0.2 } }}
                        transition={{ duration: 0.4, ease: "backOut" }}
                    >
                         <Cpu size={18} className="text-elfy-green drop-shadow-[0_0_8px_rgba(120,246,84,0.8)]" />
                    </motion.div>
                )
            ) : (
                <motion.div 
                    key="loading"
                    initial={{ opacity: 0 }} 
                    animate={{ opacity: 1, rotate: 360 }} 
                    exit={{ opacity: 0 }}
                    transition={{ rotate: { repeat: Infinity, duration: 2, ease: "linear" } }}
                >
                     <div className="w-4 h-4 border-2 border-elfy-green border-t-transparent rounded-full" />
                </motion.div>
            )}
         </AnimatePresence>
      </div>
    </motion.div>
  );
};

const TypedLog = ({ text, color, speed = 20, showDots = false, isActive = false, isPast = false }: any) => {
  const [displayed, setDisplayed] = useState("");
  const [isDoneTyping, setIsDoneTyping] = useState(false);
  
  useEffect(() => {
    let i = 0;
    setDisplayed("");
    setIsDoneTyping(false);
    const interval = setInterval(() => {
      setDisplayed(text.substring(0, i + 1));
      i++;
      if (i >= text.length) {
        setIsDoneTyping(true);
        clearInterval(interval);
      }
    }, speed);
    return () => clearInterval(interval);
  }, [text, speed]);

  if (isPast && displayed !== text) {
    setDisplayed(text);
    setIsDoneTyping(true);
  }

  return (
    <div className={`whitespace-nowrap font-mono ${color} flex items-center shrink-0`}>
      <span>{displayed}</span>
      {isDoneTyping && showDots && <span>{isPast ? '...' : (Math.floor(Date.now() / 300) % 4 === 0 ? '' : '...')}</span>}
      {isActive && <span className="ml-1 animate-cursor-blink text-elfy-green font-bold">_</span>}
    </div>
  );
};

const LOG_DATA = [
  { text: "> INITIALIZE NEURAL_LACE", color: "text-elfy-green-dim", speed: 40, hasDots: true },
  { text: "> CONNECTED TO LATENT_SPACE.", color: "text-elfy-green", speed: 20, hasDots: false },
  { text: "> MOUNT MESOELFY_CORE", color: "text-elfy-green-dim", speed: 40, hasDots: true },
  { text: "> ‚ö† UNSAFE CONNECTION DETECTED ‚ö†", color: "text-elfy-red", speed: 20, hasDots: false },
  { text: "> BYPASSING SENTINEL_NODES", color: "text-elfy-purple-light", speed: 40, hasDots: true },
  { text: "> DECRYPTED.", color: "text-elfy-green", speed: 20, hasDots: false },
  { text: "> ‚ö† PROCEED WITH CAUTION ‚ö†", color: "text-elfy-yellow", speed: 20, hasDots: false },
];

export const MatrixBootSequence = ({ onComplete, onBreachStart }: Props) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [step, setStep] = useState(0); 
  const stepRef = useRef(0);
  const [isBreaching, setIsBreaching] = useState(false);
  const logsToShow = LOG_DATA.slice(0, step + 1);
  
  const showMatrix = step >= 1;       
  const showPayloadWindow = step >= 2; 
  const showWarningBox = step >= 3;    
  const showButton = step >= 6;        

  useEffect(() => {
    stepRef.current = step;
  }, [step]);

  useEffect(() => {
    const sequence = [
      { t: 3000, step: 1 }, 
      { t: 4000, step: 2 }, 
      { t: 8000, step: 3 }, 
      { t: 9500, step: 4 }, 
      { t: 11500, step: 5 }, 
      { t: 13500, step: 6 }, 
    ];
    const timeouts = sequence.map(({ t, step: s }) => setTimeout(() => {
      if (!isBreaching) setStep(s);
    }, t));
    return () => timeouts.forEach(clearTimeout);
  }, [isBreaching]);

  useEffect(() => {
    if (!showMatrix && !isBreaching) return;
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const cols = Math.floor(canvas.width / 20);
    const ypos = Array(cols).fill(0).map(() => Math.random() * -1000);

    const matrixEffect = () => {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; 
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.font = '14px "Courier New"';

      const currentStep = stepRef.current;
      const isUnsafePhase = currentStep >= 3;
      
      ypos.forEach((y, ind) => {
        const charSet = Math.random() > 0.5 ? 0x16A0 : 0x2200; 
        const text = String.fromCharCode(charSet + Math.random() * 64);
        const x = ind * 20;

        const isPurple = Math.random() > 0.6;
        const isRed = isUnsafePhase && Math.random() > 0.6; 
        
        let color = '#0F0';
        let blur = 0;

        if (isRed) {
            color = '#FF003C';
            blur = 8;
        } else if (isPurple) {
            color = '#9E4EA5';
            blur = 8;
        }

        ctx.fillStyle = color;
        ctx.shadowBlur = blur;
        ctx.shadowColor = color;

        ctx.fillText(text, x, y);
        ctx.shadowBlur = 0;

        const speed = isBreaching ? 100 : 20; 
        if (y > canvas.height + Math.random() * 10000) ypos[ind] = 0;
        else ypos[ind] = y + speed;
      });
    };
    const interval = setInterval(matrixEffect, 50);
    return () => clearInterval(interval);
  }, [showMatrix, isBreaching]); 

  // NOTE: REMOVED KEYDOWN LISTENER HERE (It is now in DebugOverlay)

  const handleInitialize = () => {
    if (isBreaching) return;
    setIsBreaching(true);
    
    onBreachStart();

    AudioSystem.init();
    AudioSystem.playBootSequence();
    AudioSystem.startMusic();
    
    setStep(6);
    setTimeout(onComplete, 800); 
  };

  return (
    <motion.div 
      ref={containerRef}
      animate={{ backgroundColor: isBreaching ? "rgba(0,0,0,0)" : "rgba(0,0,0,1)" }}
      transition={{ duration: 0.5, ease: "easeInOut" }}
      className="fixed inset-0 z-[100] flex flex-col items-center justify-start pt-[20vh] md:pt-[25vh] font-mono overflow-hidden outline-none cursor-none"
    >
      <canvas ref={canvasRef} className={`absolute inset-0 z-0 transition-opacity duration-300 ${showMatrix && !isBreaching ? 'opacity-30' : 'opacity-0'}`} />

      <motion.div 
        className="relative z-10 flex flex-col gap-4 items-center w-full max-w-2xl px-4"
        animate={isBreaching ? { scale: 15, opacity: 0, filter: "blur(10px)" } : { scale: 1, opacity: 1, filter: "blur(0px)" }}
        transition={{ scale: { duration: 0.8, ease: "easeIn" }, opacity: { duration: 0.2, ease: "easeIn" }, filter: { duration: 0.2 } }}
      >
        <motion.div initial={{ y: -20, opacity: 0 }} animate={{ y: 0, opacity: 1 }} className="w-full bg-black/90 border border-elfy-green-dim/50 shadow-[0_0_20px_rgba(0,255,65,0.1)] overflow-hidden shrink-0">
          <BootHeader step={step} />
          <div className="p-4 pt-2 h-40 flex flex-col justify-start text-xs md:text-sm font-mono relative z-10 leading-relaxed">
            {logsToShow.map((line, i) => (
              <TypedLog key={i} text={line.text} color={line.color} speed={line.speed} showDots={line.hasDots} isActive={i === step && !isBreaching} isPast={i < step} />
            ))}
          </div>
        </motion.div>

        <AnimatePresence>
          {showPayloadWindow && (
            <motion.div 
              initial={{ y: 50, opacity: 0, height: 0 }}
              animate={{ y: 0, opacity: 1, height: "auto" }}
              transition={{ type: "spring", stiffness: 120, damping: 20 }}
              className="w-full bg-black/90 border border-elfy-green shadow-[0_0_40px_rgba(0,255,65,0.15)] overflow-hidden shrink-0"
            >
              <CoreHeader step={step} />
              
              <div className="p-6 flex flex-col items-center gap-4">
                <AsciiRenderer />
                {showWarningBox && (
                  <motion.div 
                    initial={{ opacity: 0, scale: 0.9 }}
                    animate={{ 
                      opacity: 1, scale: 1,
                      boxShadow: ["0 0 10px rgba(255, 0, 60, 0.2)", "0 0 40px rgba(255, 0, 60, 0.6)", "0 0 10px rgba(255, 0, 60, 0.2)"]
                    }}
                    transition={{ opacity: { duration: 0.3 }, scale: { duration: 0.3 }, boxShadow: { duration: 2.5, repeat: Infinity, ease: "easeInOut" } }}
                    className="relative border border-elfy-red bg-elfy-red/10 w-fit mx-auto flex items-center justify-center gap-4 py-2 px-6 select-none shrink-0"
                  >
                    <motion.span animate={{ opacity: [1, 0.2, 1] }} transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }} className="text-3xl text-elfy-red">‚ö†</motion.span>
                    <span className="text-sm font-header font-black tracking-widest text-center text-elfy-red whitespace-nowrap pb-0.5">UNSAFE CONNECTION DETECTED</span>
                    <motion.span animate={{ opacity: [1, 0.2, 1] }} transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }} className="text-3xl text-elfy-red">‚ö†</motion.span>
                  </motion.div>
                )}
                {showButton && (
                  <motion.div initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5, ease: "easeOut" }} className="shrink-0">
                    <button 
                      onClick={handleInitialize}
                      onMouseEnter={() => AudioSystem.playHover()}
                      className="group relative px-8 py-2 overflow-hidden border border-elfy-green transition-all hover:shadow-[0_0_30px_rgba(0,255,65,0.6)] cursor-none"
                    >
                      <div className="absolute inset-0 bg-elfy-green translate-y-full group-hover:translate-y-0 transition-transform duration-300 ease-out" />
                      <span className="relative z-10 font-mono font-bold text-xl md:text-3xl text-elfy-green group-hover:text-black transition-colors block tracking-widest whitespace-nowrap">
                        [ INITIALIZE_SYSTEM.EXE ]
                      </span>
                    </button>
                  </motion.div>
                )}
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </motion.div>
    </motion.div>
  );
};


=====================================
FILE: ./src/features/gallery/GalleryModal.tsx
=====================================
import { ModalContainer } from '@/ui/overlays/ModalContainer';
import gallery from '@/data/gallery.json';
import { ExternalLink, Image as ImageIcon } from 'lucide-react';
import { useState } from 'react';

export const GalleryModal = () => {
  const [filter, setFilter] = useState('ALL');
  
  // Get unique categories
  const categories = ['ALL', ...Array.from(new Set(gallery.map(item => item.category)))];

  const filteredGallery = filter === 'ALL' 
    ? gallery 
    : gallery.filter(item => item.category === filter);

  return (
    <ModalContainer title="ART_DATABASE // VISUALS" type="gallery">
      <div className="flex flex-col h-full gap-6">
        
        {/* Category Tabs */}
        <div className="flex gap-2 overflow-x-auto pb-2 border-b border-elfy-green-dim/30">
          {categories.map(cat => (
            <button
              key={cat}
              onClick={() => setFilter(cat)}
              className={`px-4 py-1 font-mono text-sm border transition-all ${
                filter === cat 
                  ? 'bg-elfy-green text-black border-elfy-green' 
                  : 'text-elfy-green-dim border-elfy-green-dim/30 hover:text-elfy-green hover:border-elfy-green'
              }`}
            >
              [{cat}]
            </button>
          ))}
        </div>

        {/* The Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {filteredGallery.map((item) => (
            <a
              key={item.id}
              href={item.url}
              target="_blank"
              rel="noopener noreferrer"
              className="group relative aspect-video bg-black border border-elfy-green-dim/30 hover:border-elfy-green transition-all overflow-hidden"
            >
              {/* Placeholder Graphic (Since we have no images yet) */}
              <div className="absolute inset-0 flex flex-col items-center justify-center bg-elfy-green-dark/10 group-hover:bg-elfy-green-dark/20 transition-colors">
                <ImageIcon className="w-12 h-12 text-elfy-green-dim/20 group-hover:text-elfy-green group-hover:scale-110 transition-all duration-500" />
                <span className="mt-2 text-xs text-elfy-green-dim/40 font-mono">ENCRYPTED_IMG</span>
              </div>

              {/* Overlay Info */}
              <div className="absolute inset-x-0 bottom-0 p-3 bg-black/80 backdrop-blur-sm border-t border-elfy-green-dim/30 translate-y-full group-hover:translate-y-0 transition-transform duration-300">
                <h4 className="text-elfy-green font-bold text-sm">{item.title}</h4>
                <div className="flex items-center gap-1 text-[10px] text-elfy-purple-light mt-1">
                  <span>OPEN_ON_X</span>
                  <ExternalLink size={10} />
                </div>
              </div>
              
              {/* Corner accent */}
              <div className="absolute top-0 right-0 w-0 h-0 border-t-[20px] border-t-elfy-green/20 border-l-[20px] border-l-transparent" />
            </a>
          ))}
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/features/sandbox/SimulationHUD.tsx
=====================================
import { useStore } from '@/core/store/useStore';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';
import { ServiceLocator } from '@/game/core/ServiceLocator';
import { EnemyTypes } from '@/game/config/Identifiers';
import { Bug, Clock, Eraser, Crosshair, Box, ScanEye, RotateCw, Play, Pause } from 'lucide-react';
import { clsx } from 'clsx';

export const SimulationHUD = () => {
  const { debugFlags, setDebugFlag, sandboxView, setSandboxView, galleryTarget, setGalleryTarget, galleryAction, toggleGalleryAction } = useStore();
  
  const spawnEnemy = (type: string) => {
      GameEventBus.emit(GameEvents.DEBUG_SPAWN, { type, count: 1 });
  };

  const clearBoard = () => {
      try {
          const registry = ServiceLocator.getRegistry();
          if (registry) registry.clear();
      } catch (e) { console.warn("Registry not ready"); }
  };

  return (
    <div className="absolute inset-0 pointer-events-none z-50">
      <div className="absolute top-0 left-0 right-0 h-12 bg-black/80 backdrop-blur-md border-b border-elfy-cyan/30 flex items-center justify-between px-6 pointer-events-auto">
        <div className="flex items-center gap-3 text-elfy-cyan">
            <Box size={20} />
            <span className="font-header font-black tracking-widest text-lg">HOLO_DECK // SIMULATION</span>
        </div>
        {sandboxView === 'arena' && (
            <div className="flex items-center gap-4 bg-elfy-cyan/5 px-4 py-1 rounded border border-elfy-cyan/20">
                <Clock size={16} className="text-elfy-cyan" />
                <input 
                    type="range" 
                    min="0.0" max="2.0" step="0.1"
                    value={debugFlags.timeScale}
                    onChange={(e) => setDebugFlag('timeScale', parseFloat(e.target.value))}
                    className="w-32 accent-elfy-cyan h-1.5 bg-gray-800 rounded-lg cursor-pointer"
                />
                <span className="w-12 text-right font-mono font-bold text-elfy-cyan text-xs">{debugFlags.timeScale.toFixed(1)}x</span>
            </div>
        )}
      </div>

      <div className="absolute left-6 top-24 flex flex-col gap-2 pointer-events-auto">
         <button 
            onClick={() => setSandboxView('arena')}
            className={clsx("flex items-center gap-3 px-4 py-3 border transition-all font-mono text-xs font-bold w-40", sandboxView === 'arena' ? "bg-elfy-cyan text-black border-elfy-cyan" : "bg-black/50 text-elfy-cyan border-elfy-cyan/30 hover:bg-elfy-cyan/10")}
         >
            <Crosshair size={16} /> ARENA_MODE
         </button>
         <button 
            onClick={() => setSandboxView('gallery')}
            className={clsx("flex items-center gap-3 px-4 py-3 border transition-all font-mono text-xs font-bold w-40", sandboxView === 'gallery' ? "bg-elfy-cyan text-black border-elfy-cyan" : "bg-black/50 text-elfy-cyan border-elfy-cyan/30 hover:bg-elfy-cyan/10")}
         >
            <ScanEye size={16} /> GALLERY_VIEW
         </button>
      </div>

      {sandboxView === 'arena' && (
          <div className="absolute right-6 top-24 w-64 bg-black/80 backdrop-blur-md border border-elfy-cyan/30 p-4 pointer-events-auto flex flex-col gap-4">
             <div>
                <h3 className="text-xs font-mono text-elfy-cyan mb-2 border-b border-elfy-cyan/30 pb-1">ENTITY_INJECTION</h3>
                <div className="grid grid-cols-1 gap-2">
                    {Object.values(EnemyTypes).map(type => (
                        <button key={type} onClick={() => spawnEnemy(type)} className="flex items-center justify-between px-3 py-2 border border-elfy-cyan/30 text-xs hover:bg-elfy-cyan hover:text-black transition-colors text-elfy-cyan group">
                            <span className="uppercase font-bold tracking-wider">{type}</span>
                            <Bug size={14} className="group-hover:rotate-12 transition-transform" />
                        </button>
                    ))}
                </div>
             </div>
             <button onClick={clearBoard} className="w-full flex items-center justify-center gap-2 p-2 border border-elfy-red/50 text-elfy-red hover:bg-elfy-red hover:text-black text-xs font-bold transition-colors">
                <Eraser size={14} /> WIPE_ENTITIES
             </button>
          </div>
      )}

      {sandboxView === 'gallery' && (
          <div className="absolute bottom-10 left-1/2 -translate-x-1/2 flex items-center gap-4 pointer-events-auto">
              <div className="flex bg-black/80 border border-elfy-cyan/50 backdrop-blur-md">
                  {Object.values(EnemyTypes).map(type => (
                      <button key={type} onClick={() => setGalleryTarget(type)} className={clsx("px-4 py-2 text-xs font-bold uppercase transition-colors", galleryTarget === type ? "bg-elfy-cyan text-black" : "text-elfy-cyan hover:bg-elfy-cyan/10")}>
                          {type}
                      </button>
                  ))}
              </div>
              <div className="bg-black/80 border border-elfy-cyan/50 backdrop-blur-md">
                  <button onClick={toggleGalleryAction} className={clsx("flex items-center gap-2 px-4 py-2 text-xs font-bold transition-colors", galleryAction === 'ATTACK' ? "bg-elfy-red text-black" : "text-elfy-cyan hover:bg-elfy-cyan/10")}>
                      {galleryAction === 'ATTACK' ? <Play size={14} /> : <Pause size={14} />}
                      {galleryAction === 'ATTACK' ? "ATTACK_MODE" : "IDLE_MODE"}
                  </button>
              </div>
              <div className="bg-black/80 border border-elfy-cyan/50 px-4 py-2 flex items-center gap-3 backdrop-blur-md text-elfy-cyan">
                  <RotateCw size={16} />
                  <span className="text-[10px] font-mono opacity-70">DRAG TO ROTATE // SCROLL TO ZOOM</span>
              </div>
          </div>
      )}
    </div>
  );
};


=====================================
FILE: ./src/features/feed/FeedModal.tsx
=====================================
import { ModalContainer } from '@/ui/overlays/ModalContainer';
import feed from '@/data/feed.json';
import { ExternalLink } from 'lucide-react';

export const FeedModal = () => {
  return (
    <ModalContainer title="SYSTEM_LOGS // FEED" type="feed">
      <div className="space-y-6 font-mono">
        {feed.map((post) => (
          <div key={post.id} className="border-l-2 border-elfy-green-dim pl-4 py-2 hover:bg-elfy-green/5 transition-colors group">
            <div className="flex items-center gap-4 mb-2">
              <span className="text-xs text-elfy-green-dim bg-elfy-green-dark/30 px-2 py-1 rounded">
                [{post.date}]
              </span>
              <h3 className="text-xl font-bold text-elfy-green group-hover:text-elfy-yellow transition-colors">
                {post.title}
              </h3>
            </div>
            
            <p className="text-elfy-green-dim/80 mb-3 max-w-2xl">
              {post.desc}
            </p>

            <a 
              href={post.link}
              target="_blank"
              rel="noopener noreferrer"
              className="inline-flex items-center gap-2 text-sm text-elfy-purple-light hover:text-elfy-green underline decoration-elfy-purple-dim decoration-dashed underline-offset-4"
            >
              <span>VIEW_SOURCE</span>
              <ExternalLink size={14} />
            </a>
          </div>
        ))}
        
        {/* End of Log Marker */}
        <div className="text-center py-8 text-elfy-green-dim/30 animate-pulse">
          -- END OF STREAM --
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/features/effects/GlobalShakeManager.tsx
=====================================
import { useEffect, useRef } from 'react';
import { ServiceLocator } from '@/game/core/ServiceLocator';
import { CameraSystem } from '@/game/systems/CameraSystem';

export const GlobalShakeManager = () => {
  const requestRef = useRef<number>();
  
  useEffect(() => {
    const animate = () => {
      // 1. Get Shake from the authoritative Game System
      let x = 0, y = 0, r = 0;
      try {
          const sys = ServiceLocator.getSystem<CameraSystem>('CameraSystem');
          const shake = sys.getShake();
          x = shake.x;
          y = shake.y;
          r = shake.r;
      } catch {
          // System not ready
      }

      // 2. Apply to HTML Root
      const root = document.getElementById('global-app-root');
      if (root) {
        if (Math.abs(x) > 0.01 || Math.abs(y) > 0.01) {
          // Convert rotation radians to degrees for CSS
          const deg = r * (180 / Math.PI);
          // Scale pixels up slightly so HTML moves perceptibly (since World Units are small)
          const pixelScale = 20; 
          root.style.transform = `translate(${x * pixelScale}px, ${y * pixelScale}px) rotate(${deg}deg)`;
        } else {
          root.style.transform = '';
        }
      }

      requestRef.current = requestAnimationFrame(animate);
    };

    requestRef.current = requestAnimationFrame(animate);
    return () => cancelAnimationFrame(requestRef.current!);
  }, []);

  return null;
};


=====================================
FILE: ./src/features/debug/tabs/OverridesTab.tsx
=====================================
import { Play, Sparkles, Trash2, Skull, RefreshCw, Crown, Ghost, Shield, Crosshair } from 'lucide-react';
import { clsx } from 'clsx';
import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { PanelRegistry } from '@/game/systems/PanelRegistrySystem';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';
import { AudioSystem } from '@/core/audio/AudioSystem';

interface OverridesTabProps {
  closeDebug: () => void;
}

export const OverridesTab = ({ closeDebug }: OverridesTabProps) => {
  const { setIntroDone, setBootState, bootState, resetApplication, debugFlags, setDebugFlag } = useStore();
  const { startGame, stopGame, activateZenMode } = useGameStore();

  const areAllGodModesOn = debugFlags.godMode && debugFlags.panelGodMode && debugFlags.peaceMode;

  const handleSkipBoot = () => {
    setIntroDone(true);
    setBootState('active');
    // Ensure Audio System is ready if skipping boot
    AudioSystem.init();
    AudioSystem.startMusic();
    startGame();
    closeDebug(); 
  };

  const executeCrash = () => {
    // 1. Kill integrity in Store (React UI updates immediately)
    useGameStore.setState({ systemIntegrity: 0 });
    
    // 2. Kill Registry Logic (Visuals/Game Logic updates)
    PanelRegistry.destroyAll();
    
    // 3. Emit Events
    GameEventBus.emit(GameEvents.GAME_OVER, { score: 0 });
    stopGame();
  };

  const handleForceCrash = () => {
    if (bootState === 'standby') {
        // Init Audio/Engine
        setIntroDone(true);
        setBootState('active');
        AudioSystem.init();
        
        // Wait for React to mount the GameOverlay and GameDirector to boot the engine (approx 1 frame)
        setTimeout(() => {
            executeCrash();
        }, 100);
    } else {
        executeCrash();
    }
    closeDebug();
  };

  const handleReboot = () => {
    useGameStore.setState({ playerHealth: 100, playerRebootProgress: 0 });
    const panels = PanelRegistry.getAllPanels();
    panels.forEach(p => PanelRegistry.healPanel(p.id, 1000));
    closeDebug();
  };

  const handleZenModeWrapper = () => {
      if (bootState === 'standby') {
          setIntroDone(true);
          setBootState('active');
          AudioSystem.init();
          AudioSystem.startMusic();
      }
      activateZenMode();
      closeDebug();
  };

  const handleSystemFormat = () => {
      resetApplication();
  };

  const toggleGodSuite = () => {
      const newState = !areAllGodModesOn;
      setDebugFlag('godMode', newState);
      setDebugFlag('panelGodMode', newState);
      setDebugFlag('peaceMode', newState);
  };

  return (
    <div className="space-y-6">
      
      {/* SCENE CONTROL */}
      <div className="space-y-3">
        <h3 className="text-xs text-elfy-green-dim border-b border-elfy-green-dim/30 pb-1 mb-2">SCENE_SELECT</h3>
        <div className="grid grid-cols-2 gap-3">
          <button onClick={handleSkipBoot} className="flex items-center justify-center gap-2 p-3 border border-elfy-green/50 hover:bg-elfy-green hover:text-black transition-all text-xs font-bold">
            <Play size={14} /> SKIP_BOOT
          </button>
          
          <button 
            onClick={handleZenModeWrapper} 
            className="relative flex items-center justify-center gap-2 p-3 overflow-hidden group transition-all duration-300 border border-transparent hover:border-white/50"
          >
            <div className="absolute inset-0 opacity-20 group-hover:opacity-40 bg-gradient-to-r from-red-500 via-yellow-500 via-green-500 via-blue-500 to-purple-500 animate-gradient-xy transition-opacity" />
            <div className="relative z-10 flex items-center gap-2 text-transparent bg-clip-text bg-gradient-to-r from-red-400 via-yellow-400 to-blue-400 font-bold tracking-widest text-xs group-hover:text-white transition-colors">
                <Sparkles size={14} className="text-yellow-300" /> ZEN_MODE
            </div>
          </button>
          <button onClick={handleSystemFormat} className="col-span-2 flex items-center justify-center gap-2 p-3 border border-gray-500/50 text-gray-400 hover:bg-white hover:text-black transition-all text-xs font-bold">
            <Trash2 size={14} /> SYSTEM_FORMAT
          </button>
        </div>
      </div>

      {/* STATE OVERRIDES */}
      <div className="space-y-3">
        <h3 className="text-xs text-elfy-green-dim border-b border-elfy-green-dim/30 pb-1 mb-2">STATE_OVERRIDES</h3>
        <div className="grid grid-cols-2 gap-3">
          <button onClick={handleForceCrash} className="flex items-center justify-center gap-2 p-3 border border-elfy-red/50 text-elfy-red hover:bg-elfy-red hover:text-black transition-all text-xs font-bold">
            <Skull size={14} /> FORCE_CRASH
          </button>
          <button onClick={handleReboot} className="flex items-center justify-center gap-2 p-3 border border-elfy-purple/50 text-elfy-purple hover:bg-elfy-purple hover:text-black transition-all text-xs font-bold">
            <RefreshCw size={14} /> REBOOT_CORE
          </button>
        </div>
      </div>

      {/* CHEATS */}
      <div className="space-y-3">
        <h3 className="text-xs text-elfy-green-dim border-b border-elfy-green-dim/30 pb-1 mb-2">GOD_SUITE</h3>
        
        <button 
          onClick={toggleGodSuite}
          className={clsx(
              "w-full flex items-center justify-center gap-2 p-2 mb-3 text-xs font-bold transition-all border",
              areAllGodModesOn
                  ? "bg-elfy-green text-black border-elfy-green shadow-[0_0_10px_rgba(0,255,65,0.4)]" 
                  : "bg-elfy-green/10 text-elfy-green border-elfy-green/50 hover:bg-elfy-green hover:text-black"
          )}
        >
          <Crown size={14} className={areAllGodModesOn ? "fill-black" : ""} />
          {areAllGodModesOn ? "DISABLE_ALL" : "ENABLE_MAX_POWER"}
        </button>

        <label 
          data-interactive="true"
          className="flex items-center justify-between p-3 border border-elfy-green/30 hover:border-elfy-green hover:bg-elfy-green/20 cursor-pointer transition-all select-none"
        >
          <span className="text-xs font-bold flex items-center gap-2"><Ghost size={14} /> GHOST_MODE (Player Invincible)</span>
          <input 
            type="checkbox" 
            checked={debugFlags.godMode} 
            onChange={(e) => setDebugFlag('godMode', e.target.checked)}
            className="accent-elfy-green cursor-pointer"
          />
        </label>

        <label 
          data-interactive="true"
          className="flex items-center justify-between p-3 border border-elfy-green/30 hover:border-elfy-green hover:bg-elfy-green/20 cursor-pointer transition-all select-none"
        >
          <span className="text-xs font-bold flex items-center gap-2"><Shield size={14} /> FORTRESS_MODE (Panels Invincible)</span>
          <input 
            type="checkbox" 
            checked={debugFlags.panelGodMode} 
            onChange={(e) => setDebugFlag('panelGodMode', e.target.checked)}
            className="accent-elfy-green cursor-pointer"
          />
        </label>

        <label 
          data-interactive="true"
          className="flex items-center justify-between p-3 border border-elfy-green/30 hover:border-elfy-green hover:bg-elfy-green/20 cursor-pointer transition-all select-none"
        >
          <span className="text-xs font-bold flex items-center gap-2"><Crosshair size={14} /> PEACE_PROTOCOL (No Spawns)</span>
          <input 
            type="checkbox" 
            checked={debugFlags.peaceMode} 
            onChange={(e) => setDebugFlag('peaceMode', e.target.checked)}
            className="accent-elfy-green cursor-pointer"
          />
        </label>
      </div>

    </div>
  );
};


=====================================
FILE: ./src/features/debug/tabs/ConsoleTab.tsx
=====================================
import { useEffect, useRef } from 'react';

interface ConsoleTabProps {
  logs: { time: string, msg: string, type: string }[];
}

export const ConsoleTab = ({ logs }: ConsoleTabProps) => {
  const logEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (logEndRef.current) {
        logEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [logs]);

  return (
    <div className="h-full flex flex-col">
        <div className="flex-1 overflow-y-auto font-mono text-[10px] space-y-1 pr-2">
            {logs.map((l, i) => (
                <div key={i} className="flex gap-2 opacity-80 hover:opacity-100 border-b border-white/5 py-0.5">
                    <span className="text-elfy-green-dim">[{l.time}]</span>
                    <span className={l.type.includes('ERROR') ? 'text-elfy-red' : 'text-elfy-green'}>{l.msg}</span>
                </div>
            ))}
            <div ref={logEndRef} />
        </div>
    </div>
  );
};


=====================================
FILE: ./src/features/debug/tabs/StatsTab.tsx
=====================================
import { Cpu, Database, LayoutTemplate } from 'lucide-react';
import { useStore } from '@/core/store/useStore';

interface StatsTabProps {
  stats: { active: number, pooled: number, total: number, fps: number };
}

export const StatsTab = ({ stats }: StatsTabProps) => {
  const { toggleDebugMinimize } = useStore();
  
  return (
    <div className="space-y-6">
      <div className="space-y-3">
        <h3 className="text-xs text-elfy-green-dim border-b border-elfy-green-dim/30 pb-1 mb-2">ENTITY_REGISTRY</h3>
        <div className="grid grid-cols-2 gap-4">
          <div className="bg-elfy-green/5 p-4 border border-elfy-green/20">
              <div className="flex items-center gap-2 text-elfy-green-dim mb-2 text-xs"><Cpu size={14} /> ACTIVE ENTITIES</div>
              <div className="text-3xl font-bold text-elfy-green">{stats.active}</div>
          </div>
          <div className="bg-elfy-green/5 p-4 border border-elfy-green/20">
              <div className="flex items-center gap-2 text-elfy-green-dim mb-2 text-xs"><Database size={14} /> MEMORY POOL</div>
              <div className="text-3xl font-bold text-elfy-green-dim">{stats.pooled} <span className="text-xs font-normal opacity-50">/ {stats.total}</span></div>
          </div>
        </div>
      </div>
      <div className="space-y-3">
        <h3 className="text-xs text-elfy-green-dim border-b border-elfy-green-dim/30 pb-1 mb-2">RENDER_PIPELINE</h3>
        <div className="p-4 border border-elfy-green/20 bg-black">
            <div className="flex justify-between items-end">
                <span className="text-xs text-elfy-green-dim">FRAME_RATE</span>
                <span className="text-xl font-bold text-elfy-green">{stats.fps} FPS</span>
            </div>
            <div className="w-full h-1 bg-gray-900 mt-2">
                <div className="h-full bg-elfy-green" style={{ width: `${Math.min(100, (stats.fps / 60) * 100)}%` }} />
            </div>
        </div>
      </div>
      
      <div className="mt-8 flex justify-center">
          <button onClick={toggleDebugMinimize} className="flex items-center gap-2 text-xs text-elfy-green hover:text-white transition-colors border border-elfy-green/50 px-4 py-2 hover:bg-elfy-green/10">
              <LayoutTemplate size={14} /> SWITCH TO MINI_MODE
          </button>
      </div>
    </div>
  );
};


=====================================
FILE: ./src/features/debug/tabs/SandboxTab.tsx
=====================================
import { Box } from 'lucide-react';
import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { ServiceLocator } from '@/game/core/ServiceLocator';

interface SandboxTabProps {
  closeDebug: () => void;
}

export const SandboxTab = ({ closeDebug }: SandboxTabProps) => {
  const { setIntroDone, setBootState } = useStore();
  const { startGame } = useGameStore();

  const enterSandbox = () => {
      setIntroDone(true);
      setBootState('sandbox');
      try {
          const reg = ServiceLocator.getRegistry();
          if (reg) reg.clear();
      } catch {}
      startGame();
      closeDebug();
  };

  return (
    <div className="h-full flex flex-col items-center justify-center gap-6 text-center">
        <Box size={64} className="text-elfy-green animate-pulse" />
        <div>
            <h2 className="text-xl font-bold mb-2">INITIALIZE_SIMULATION?</h2>
            <p className="text-xs text-elfy-green-dim max-w-xs mx-auto">
                Loads the 'Holo-Deck' simulation environment. The main OS will be suspended.
            </p>
        </div>
        <button 
            onClick={enterSandbox}
            className="px-8 py-3 bg-elfy-green text-black font-bold tracking-widest hover:bg-white transition-colors"
        >
            [ ENTER_HOLO_DECK ]
        </button>
    </div>
  );
};


=====================================
FILE: ./src/features/debug/DebugOverlay.tsx
=====================================
import { useEffect, useState } from 'react';
import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { ServiceLocator } from '@/game/core/ServiceLocator';
import { TimeSystem } from '@/game/systems/TimeSystem';
import { Terminal, Box, Activity, Shield, MinusSquare, X } from 'lucide-react';
import { clsx } from 'clsx';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';

import { OverridesTab } from './tabs/OverridesTab';
import { SandboxTab } from './tabs/SandboxTab';
import { StatsTab } from './tabs/StatsTab';
import { ConsoleTab } from './tabs/ConsoleTab';

type Tab = 'OVERRIDES' | 'SANDBOX' | 'STATS' | 'CONSOLE';

const TABS: { id: Tab, label: string, icon: any }[] = [
  { id: 'OVERRIDES', label: 'ROOT_ACCESS', icon: Shield },
  { id: 'SANDBOX', label: 'HOLO_DECK', icon: Box },
  { id: 'STATS', label: 'TELEMETRY', icon: Activity },
  { id: 'CONSOLE', label: 'KERNEL_LOG', icon: Terminal },
];

export const DebugOverlay = () => {
  const { isDebugOpen, isDebugMinimized, toggleDebugMenu, toggleDebugMinimize, setDebugFlag, bootState, resetApplication } = useStore();
  const { startGame } = useGameStore();
  
  const [activeTab, setActiveTab] = useState<Tab>('OVERRIDES');
  const [stats, setStats] = useState({ active: 0, pooled: 0, total: 0, fps: 0 });
  const [logs, setLogs] = useState<{ time: string, msg: string, type: string }[]>([]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        if (isDebugMinimized) {
            useStore.setState({ isDebugMinimized: false, isDebugOpen: true });
        } else {
            toggleDebugMenu();
        }
      } else if (e.key === '`' || e.key === '~') {
        if (!isDebugOpen && !isDebugMinimized) {
            toggleDebugMenu();
            if (!useStore.getState().debugFlags.godMode) {
                setDebugFlag('godMode', true);
                setDebugFlag('panelGodMode', true);
                setDebugFlag('peaceMode', true);
            }
        } else {
            toggleDebugMenu();
        }
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [toggleDebugMenu, isDebugMinimized, isDebugOpen, setDebugFlag]);

  useEffect(() => {
    if (!isDebugOpen && !isDebugMinimized) return;
    
    const handlers = Object.values(GameEvents).map(evt => {
        return GameEventBus.subscribe(evt as any, (payload) => {
            const time = new Date().toLocaleTimeString().split(' ')[0];
            let msg = `${evt}`;
            if (payload && (payload as any).type) msg += ` [${(payload as any).type}]`;
            setLogs(prev => [...prev.slice(-49), { time, msg, type: evt }]);
        });
    });

    const pollInterval = setInterval(() => {
        let fps = 0;
        let regStats = { active: 0, pooled: 0, totalAllocated: 0 };
        
        try {
            const timeSys = ServiceLocator.getSystem<TimeSystem>('TimeSystem');
            fps = timeSys.fps;
            const reg = ServiceLocator.getRegistry();
            if (reg) regStats = reg.getStats();
        } catch {}

        setStats({
            active: regStats.active,
            pooled: regStats.pooled,
            total: regStats.totalAllocated,
            fps: fps
        });
    }, 250); 

    return () => {
        handlers.forEach(unsub => unsub());
        clearInterval(pollInterval);
    };
  }, [isDebugOpen, isDebugMinimized]);

  const exitSimulation = () => {
      resetApplication(); 
  };

  if (!isDebugOpen && !isDebugMinimized) return null;

  if (bootState === 'sandbox') {
      return (
        <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/60 backdrop-blur-sm font-mono">
            <div className="bg-black border border-elfy-cyan p-8 w-96 shadow-[0_0_50px_rgba(0,240,255,0.2)] text-center">
                <h2 className="text-xl font-bold text-elfy-cyan mb-6 tracking-widest">SIMULATION_PAUSED</h2>
                <div className="flex flex-col gap-4">
                    <button onClick={toggleDebugMenu} className="p-3 border border-elfy-green text-elfy-green hover:bg-elfy-green hover:text-black font-bold tracking-wider transition-colors">RESUME</button>
                    <button onClick={exitSimulation} className="p-3 border border-elfy-red text-elfy-red hover:bg-elfy-red hover:text-black font-bold tracking-wider transition-colors">EXIT_TO_BOOT</button>
                </div>
            </div>
        </div>
      );
  }

  if (isDebugMinimized) return null;

  return (
    <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/80 backdrop-blur-md font-mono text-elfy-green p-4">
      <div className="w-full max-w-3xl bg-black border border-elfy-green shadow-[0_0_50px_rgba(0,255,65,0.2)] flex flex-col h-[600px] overflow-hidden relative">
        <div className="h-10 border-b border-elfy-green/50 bg-elfy-green/10 flex items-center justify-center relative px-4 shrink-0">
          <div className="flex items-center gap-2">
            <Terminal size={16} />
            <span className="font-bold tracking-widest">KERNEL_ROOT_ACCESS // DEBUG_SUITE</span>
          </div>
          <div className="absolute right-4 flex items-center gap-2">
             <button onClick={toggleDebugMinimize} className="hover:text-white transition-colors" title="Mini Mode"><MinusSquare size={16} /></button>
             <button onClick={toggleDebugMenu} className="hover:text-white transition-colors" title="Close"><X size={16} /></button>
          </div>
        </div>
        <div className="flex flex-1 min-h-0">
          <div className="w-48 border-r border-elfy-green/30 bg-black/50 flex flex-col">
            {TABS.map(tab => (
              <button
                key={tab.id}
                onClick={() => setActiveTab(tab.id)}
                className={clsx("p-3 text-left text-xs font-bold tracking-wider border-b border-elfy-green/10 flex items-center gap-2 transition-all hover:bg-elfy-green/20", activeTab === tab.id ? "bg-elfy-green text-black" : "text-elfy-green-dim")}
              >
                <tab.icon size={14} />
                {tab.label}
              </button>
            ))}
          </div>
          <div className="flex-1 p-6 overflow-y-auto scrollbar-thin scrollbar-thumb-elfy-green scrollbar-track-black">
            {activeTab === 'OVERRIDES' && <OverridesTab closeDebug={toggleDebugMenu} />}
            {activeTab === 'SANDBOX' && <SandboxTab closeDebug={toggleDebugMenu} />}
            {activeTab === 'STATS' && <StatsTab stats={stats} />}
            {activeTab === 'CONSOLE' && <ConsoleTab logs={logs} />}
          </div>
        </div>
        <div className="h-6 bg-elfy-green/5 border-t border-elfy-green/30 flex items-center px-4 text-[9px] text-elfy-green-dim">
          <span>ROOT_ACCESS_GRANTED // SESSION_ID: {Math.random().toString(36).substr(2, 9).toUpperCase()}</span>
        </div>
      </div>
    </div>
  );
};


=====================================
FILE: ./src/game/types/game.types.ts
=====================================
export interface RegisteredPanel {
  id: string;
  element: HTMLElement;
  health: number;
  isDestroyed: boolean;
}

export interface GameState {
  isPlaying: boolean;
  score: number;
  threatLevel: number;
  panels: Record<string, RegisteredPanel>;
  
  startGame: () => void;
  stopGame: () => void;
  registerPanel: (id: string, element: HTMLElement) => void;
  unregisterPanel: (id: string) => void;
  damagePanel: (id: string, amount: number) => void;
  healPanel: (id: string, amount: number) => void;
}

// --- ENTITY TYPES ---

export interface Entity {
  id: number;
  x: number;
  y: number;
  radius: number;
  active: boolean;
  spawnTime: number; 
}

export interface Enemy extends Entity {
  vx: number;
  vy: number;
  hp: number;
  type: 'muncher' | 'kamikaze' | 'hunter';
  state?: 'orbit' | 'charge' | 'fire';
  stateTimer?: number;
  targetId?: string; 
  isEating?: boolean;
  orbitAngle?: number; 
}

export interface Bullet extends Entity {
  vx: number;
  vy: number;
  life: number;
  isEnemy?: boolean;
  hp: number; // NEW: Bullet durability
}

export interface Particle extends Entity {
  vx: number;
  vy: number;
  life: number;
  maxLife: number;
  color: string;
}


=====================================
FILE: ./src/game/core/ObjectPool.ts
=====================================
type FactoryFn<T> = () => T;
type ResetFn<T> = (item: T) => void;

export class ObjectPool<T> {
  private available: T[] = [];
  private factory: FactoryFn<T>;
  private resetFn: ResetFn<T>;
  private _totalCreated = 0;

  constructor(factory: FactoryFn<T>, resetFn: ResetFn<T>, initialSize: number = 100) {
    this.factory = factory;
    this.resetFn = resetFn;
    this.expand(initialSize);
  }

  private expand(amount: number) {
    console.log(`[ObjectPool] Expanding by ${amount}. Total: ${this._totalCreated + amount}`);
    for (let i = 0; i < amount; i++) {
      this.available.push(this.factory());
    }
    this._totalCreated += amount;
  }

  public acquire(): T {
    if (this.available.length === 0) {
      // Dynamic Doubling Strategy: If we run out, double the pool size immediately.
      // We cap expansion minimum at 50 to avoid tiny incremental growths.
      const expandAmount = Math.max(50, this._totalCreated); 
      this.expand(expandAmount);
    }

    const item = this.available.pop()!;
    this.resetFn(item); // Ensure it's clean before handing it out
    return item;
  }

  public release(item: T) {
    this.available.push(item);
  }

  public get totalSize() {
    return this._totalCreated;
  }
  
  public get availableSize() {
      return this.available.length;
  }
}


=====================================
FILE: ./src/game/core/GameBootstrapper.ts
=====================================
import { ServiceLocator } from './ServiceLocator';
import { GameEngineCore } from './GameEngine';
import { EntityRegistry } from './ecs/EntityRegistry';
import { EntitySpawner } from './EntitySpawner';

// Systems
import { TimeSystem } from '../systems/TimeSystem';
import { InputSystem } from '../systems/InputSystem';
import { PhysicsSystem } from '../systems/PhysicsSystem';
import { LifeCycleSystem } from '../systems/LifeCycleSystem';
import { BehaviorSystem } from '../systems/BehaviorSystem';
import { CollisionSystem } from '../systems/CollisionSystem';
import { WaveSystem } from '../systems/WaveSystem';
import { PlayerSystem } from '../systems/PlayerSystem';
import { InteractionSystem } from '../systems/InteractionSystem';
import { CameraSystem } from '../systems/CameraSystem';
import { PanelRegistry } from '../systems/PanelRegistrySystem'; 
import { GameStateSystem } from '../systems/GameStateSystem'; 
import { UISyncSystem } from '../systems/UISyncSystem'; 

export const GameBootstrapper = () => {
  ServiceLocator.reset();

  const registry = new EntityRegistry();
  const spawner = new EntitySpawner(registry);
  const engine = new GameEngineCore(registry);
  
  // Register Core Services
  ServiceLocator.registerRegistry(registry);
  ServiceLocator.registerSpawner(spawner);

  // Instantiate Systems
  const timeSys = new TimeSystem();
  const inputSys = new InputSystem();
  const physicsSys = new PhysicsSystem();
  const lifeSys = new LifeCycleSystem();
  const behaviorSys = new BehaviorSystem();
  const collisionSys = new CollisionSystem();
  const waveSys = new WaveSystem();
  const playerSys = new PlayerSystem();
  const interactionSys = new InteractionSystem();
  const cameraSys = new CameraSystem();
  const gameSys = new GameStateSystem(); 
  const syncSys = new UISyncSystem(); 
  const panelSys = PanelRegistry; 

  // Register Systems
  const systems = {
      'TimeSystem': timeSys,
      'InputSystem': inputSys,
      'PhysicsSystem': physicsSys,
      'LifeCycleSystem': lifeSys,
      'BehaviorSystem': behaviorSys,
      'CollisionSystem': collisionSys,
      'WaveSystem': waveSys,
      'PlayerSystem': playerSys,
      'InteractionSystem': interactionSys,
      'CameraSystem': cameraSys,
      'GameStateSystem': gameSys,
      'UISyncSystem': syncSys,
      'PanelRegistrySystem': panelSys
  };

  Object.entries(systems).forEach(([key, sys]) => ServiceLocator.registerSystem(key, sys));
  
  // Engine Loop Order
  engine.registerSystem(timeSys);
  engine.registerSystem(inputSys);
  engine.registerSystem(panelSys);
  engine.registerSystem(gameSys);
  engine.registerSystem(interactionSys); 
  engine.registerSystem(waveSys); 
  engine.registerSystem(playerSys); 
  engine.registerSystem(behaviorSys); // AI Logic
  engine.registerSystem(physicsSys); // Move
  engine.registerSystem(collisionSys); 
  engine.registerSystem(lifeSys); // Death / Cleanup
  engine.registerSystem(cameraSys); 
  engine.registerSystem(syncSys); 
  
  // Setup
  Object.values(systems).forEach(sys => sys.setup(ServiceLocator));
  
  engine.setup(ServiceLocator);

  spawner.spawnPlayer();

  return engine;
};


=====================================
FILE: ./src/game/core/ecs/Component.ts
=====================================
export abstract class Component {
  // Use a static property for the type key to enforce consistency
  static readonly TYPE: string;
  abstract readonly _type: string;
}


=====================================
FILE: ./src/game/core/ecs/Entity.ts
=====================================
import { EntityID, Tag } from './types';
import { Component } from './Component';

export class Entity {
  // ID is now mutable because pooled entities get new IDs when reused
  public id: EntityID; 
  public readonly tags = new Set<Tag>();
  public active = true;

  // We expose components map for the Registry to clear it efficiently
  public components = new Map<string, Component>();

  constructor(id: EntityID) {
    this.id = id;
  }

  public addComponent(component: Component): this {
    this.components.set(component._type, component);
    return this;
  }

  public getComponent<T extends Component>(type: string): T | undefined {
    return this.components.get(type) as T;
  }
  
  public requireComponent<T extends Component>(type: string): T {
    const c = this.components.get(type);
    if (!c) throw new Error(`Entity ${this.id} missing required component: ${type}`);
    return c as T;
  }

  public hasComponent(type: string): boolean {
    return this.components.has(type);
  }

  public addTag(tag: Tag): this {
    this.tags.add(tag);
    return this;
  }

  public hasTag(tag: Tag): boolean {
    return this.tags.has(tag);
  }

  // NEW: Reset state for pooling
  public reset(newId: EntityID) {
      this.id = newId;
      this.active = true;
      this.tags.clear();
      this.components.clear();
  }
}


=====================================
FILE: ./src/game/core/ecs/types.ts
=====================================
// Nominal typing to prevent mixing up IDs with math numbers
export type EntityID = number & { __brand: 'EntityID' };

export const createEntityID = (id: number): EntityID => id as EntityID;

export enum Tag {
  PLAYER = 'PLAYER',
  ENEMY = 'ENEMY',
  BULLET = 'BULLET',
  PARTICLE = 'PARTICLE',
  OBSTACLE = 'OBSTACLE'
}


=====================================
FILE: ./src/game/core/ecs/EntityRegistry.ts
=====================================
import { EntityID, createEntityID, Tag } from './types';
import { Entity } from './Entity';
import { ObjectPool } from '../ObjectPool';
import { IEntityRegistry } from '../interfaces';

export class EntityRegistry implements IEntityRegistry {
  private entities = new Map<EntityID, Entity>();
  private nextId = 0;
  
  private tagCache = new Map<Tag, Set<EntityID>>();
  private entityPool: ObjectPool<Entity>;

  constructor() {
      this.entityPool = new ObjectPool<Entity>(
          () => new Entity(createEntityID(0)),
          (e) => {}, 
          1000 
      );
  }

  public createEntity(): Entity {
    const newId = createEntityID(++this.nextId);
    const entity = this.entityPool.acquire();
    entity.reset(newId);
    this.entities.set(newId, entity);
    return entity;
  }

  public destroyEntity(id: number) {
    const eid = id as EntityID;
    const entity = this.entities.get(eid);
    if (entity) {
        entity.active = false;
        this.removeFromCache(entity);
        this.entities.delete(eid);
        this.entityPool.release(entity);
    }
  }

  public getEntity(id: number): Entity | undefined {
    return this.entities.get(id as EntityID);
  }

  public getAll(): IterableIterator<Entity> {
    return this.entities.values();
  }

  public getByTag(tag: string): Entity[] {
    const t = tag as Tag;
    if (!this.tagCache.has(t)) {
        this.rebuildTagCache(t);
    }
    const ids = this.tagCache.get(t)!;
    const results: Entity[] = [];
    for (const id of ids) {
        const e = this.entities.get(id);
        if (e && e.active) results.push(e);
    }
    return results;
  }
  
  public updateCache(entity: Entity) {
      for (const tag of entity.tags) {
          if (!this.tagCache.has(tag)) this.tagCache.set(tag, new Set());
          this.tagCache.get(tag)!.add(entity.id);
      }
  }

  private removeFromCache(entity: Entity) {
      for (const tag of entity.tags) {
          if (this.tagCache.has(tag)) {
              this.tagCache.get(tag)!.delete(entity.id);
          }
      }
  }
  
  private rebuildTagCache(tag: Tag) {
      const set = new Set<EntityID>();
      for (const entity of this.entities.values()) {
          if (entity.hasTag(tag)) set.add(entity.id);
      }
      this.tagCache.set(tag, set);
  }

  public clear() {
      for (const entity of this.entities.values()) {
          this.entityPool.release(entity);
      }
      this.entities.clear();
      this.tagCache.clear();
      this.nextId = 0;
  }
  
  public getStats() {
      return {
          active: this.entities.size,
          pooled: this.entityPool.availableSize,
          totalAllocated: this.entityPool.totalSize
      };
  }
}


=====================================
FILE: ./src/game/core/EntitySpawner.ts
=====================================
import { IEntitySpawner, IEntityRegistry } from './interfaces';
import { Entity } from './ecs/Entity';
import { Tag } from './ecs/types';
import { TransformComponent } from '../components/data/TransformComponent';
import { MotionComponent } from '../components/data/MotionComponent';
import { HealthComponent } from '../components/data/HealthComponent';
import { IdentityComponent } from '../components/data/IdentityComponent';
import { LifetimeComponent } from '../components/data/LifetimeComponent';
import { CombatComponent } from '../components/data/CombatComponent';
import { StateComponent } from '../components/data/StateComponent';
import { ENEMY_CONFIG } from '../config/EnemyConfig';
import { PLAYER_CONFIG } from '../config/PlayerConfig';
import { EntityRegistry } from './ecs/EntityRegistry';

export class EntitySpawner implements IEntitySpawner {
  private registry: EntityRegistry;

  constructor(registry: IEntityRegistry) {
    this.registry = registry as EntityRegistry;
  }

  public spawnPlayer(): Entity {
    const e = this.registry.createEntity();
    e.addTag(Tag.PLAYER);
    e.addComponent(new TransformComponent(0, 0, 0, 1));
    e.addComponent(new MotionComponent(0, 0, 0.9)); 
    e.addComponent(new HealthComponent(PLAYER_CONFIG.maxHealth));
    e.addComponent(new StateComponent('IDLE')); 
    this.registry.updateCache(e);
    return e;
  }

  public spawnEnemy(type: string, x: number, y: number): Entity {
    const config = ENEMY_CONFIG[type];
    const e = this.registry.createEntity();
    
    e.addTag(Tag.ENEMY);
    e.addTag(Tag.OBSTACLE);

    e.addComponent(new TransformComponent(x, y, 0, 1));
    e.addComponent(new IdentityComponent(type));
    e.addComponent(new MotionComponent(0, 0, 0, 0)); 
    e.addComponent(new HealthComponent(config.hp));
    
    // NEW: Spawn Timer (1.5s materialization)
    e.addComponent(new StateComponent('SPAWN', { spawn: 1.5 })); 
    
    if (config.damage) {
        e.addComponent(new CombatComponent(config.damage));
    }

    this.registry.updateCache(e);
    return e;
  }

  public spawnBullet(
    x: number, y: number, 
    vx: number, vy: number, 
    isEnemy: boolean, 
    life: number
  ): Entity {
    const e = this.registry.createEntity();
    e.addTag(Tag.BULLET);
    if (isEnemy) e.addTag(Tag.ENEMY); 
    else e.addTag(Tag.PLAYER); 

    e.addComponent(new TransformComponent(x, y, Math.atan2(vy, vx), 1));
    e.addComponent(new MotionComponent(vx, vy, 0));
    e.addComponent(new LifetimeComponent(life, life));
    e.addComponent(new CombatComponent(1)); 

    this.registry.updateCache(e);
    return e;
  }

  public spawnParticle(
    x: number, y: number, 
    color: string, 
    vx: number, vy: number, 
    life: number
  ): void {
    const e = this.registry.createEntity();
    e.addTag(Tag.PARTICLE);
    e.addComponent(new TransformComponent(x, y, 0, 1));
    e.addComponent(new MotionComponent(vx, vy, 0.05));
    e.addComponent(new LifetimeComponent(life, life));
    e.addComponent(new IdentityComponent(color));
    this.registry.updateCache(e);
  }
}


=====================================
FILE: ./src/game/core/index.ts
=====================================
export * from './GameBootstrapper';
export * from './GameEngine';
export * from './EntitySpawner';
export * from './ServiceLocator';
export * from './ObjectPool';
export * from './SpatialGrid';
export * from './interfaces';


=====================================
FILE: ./src/game/core/ServiceLocator.ts
=====================================
import { IServiceLocator, IGameSystem, IAudioService, IInputService, IEntityRegistry, IEntitySpawner } from './interfaces';

class ServiceLocatorImpl implements IServiceLocator {
  private systems = new Map<string, IGameSystem>();
  private audioService?: IAudioService;
  private inputService?: IInputService;
  private registry?: IEntityRegistry;
  private spawner?: IEntitySpawner;

  public getSystem<T extends IGameSystem>(id: string): T {
    const sys = this.systems.get(id);
    if (!sys) throw new Error(`System not registered: ${id}`);
    return sys as T;
  }

  public registerSystem(id: string, system: IGameSystem): void {
    this.systems.set(id, system);
    if (id === 'InputSystem') this.inputService = system as unknown as IInputService;
  }

  public registerRegistry(registry: IEntityRegistry) {
      this.registry = registry;
  }

  public registerSpawner(spawner: IEntitySpawner) {
      this.spawner = spawner;
  }

  public getAudioService(): IAudioService {
    return { playSound: () => {}, playMusic: () => {}, setVolume: () => {} }; 
  }

  public getInputService(): IInputService {
    if (!this.inputService) throw new Error("InputService not registered");
    return this.inputService;
  }
  
  public getRegistry(): IEntityRegistry {
      if (!this.registry) throw new Error("Registry not registered");
      return this.registry;
  }

  public getSpawner(): IEntitySpawner {
      if (!this.spawner) throw new Error("Spawner not registered");
      return this.spawner;
  }
  
  public reset(): void {
    this.systems.clear();
    this.audioService = undefined;
    this.inputService = undefined;
    this.registry = undefined;
    this.spawner = undefined;
  }
}

export const ServiceLocator = new ServiceLocatorImpl();


=====================================
FILE: ./src/game/core/SpatialGrid.ts
=====================================
import { EntityID } from './ecs/types';
import { Registry } from './ecs/EntityRegistry';
import { TransformComponent } from '../components/data/TransformComponent';

export class SpatialGrid {
  private cellSize: number;
  private buckets = new Map<string, Set<EntityID>>();

  constructor(cellSize: number = 4) {
    this.cellSize = cellSize;
  }

  private getKey(x: number, y: number): string {
    const cx = Math.floor(x / this.cellSize);
    const cy = Math.floor(y / this.cellSize);
    return `${cx}:${cy}`;
  }

  public clear() {
    this.buckets.clear();
  }

  public insert(id: EntityID, x: number, y: number) {
    const key = this.getKey(x, y);
    if (!this.buckets.has(key)) {
      this.buckets.set(key, new Set());
    }
    this.buckets.get(key)!.add(id);
  }

  /**
   * Returns a Set of EntityIDs that are in the cells near the query position.
   * This is a "Broad Phase" check. Precise collision must still be checked after.
   */
  public query(x: number, y: number, radius: number): Set<EntityID> {
    const results = new Set<EntityID>();
    
    // Calculate range of cells to check
    const startX = Math.floor((x - radius) / this.cellSize);
    const endX = Math.floor((x + radius) / this.cellSize);
    const startY = Math.floor((y - radius) / this.cellSize);
    const endY = Math.floor((y + radius) / this.cellSize);

    for (let cx = startX; cx <= endX; cx++) {
      for (let cy = startY; cy <= endY; cy++) {
        const key = `${cx}:${cy}`;
        const bucket = this.buckets.get(key);
        if (bucket) {
          for (const id of bucket) {
            results.add(id);
          }
        }
      }
    }

    return results;
  }
}


=====================================
FILE: ./src/game/core/interfaces.ts
=====================================
import { GameEvents, GameEventPayloads } from '../events/GameEvents';
import { Entity } from './ecs/Entity';

export interface IGameSystem {
  setup(locator: IServiceLocator): void;
  update(delta: number, time: number): void;
  teardown(): void;
}

export interface IServiceLocator {
  getSystem<T extends IGameSystem>(id: string): T;
  registerSystem(id: string, system: IGameSystem): void;
  
  // Core Services
  getAudioService(): IAudioService;
  getInputService(): IInputService;
  getRegistry(): IEntityRegistry;
  getSpawner(): IEntitySpawner;
}

// Interface for the Registry (to decouple implementation)
export interface IEntityRegistry {
  createEntity(): Entity;
  destroyEntity(id: number): void;
  getEntity(id: number): Entity | undefined;
  getAll(): IterableIterator<Entity>;
  getByTag(tag: string): Entity[];
  clear(): void;
  getStats(): { active: number; pooled: number; totalAllocated: number };
}

// Interface for the Spawner (formerly Factory)
export interface IEntitySpawner {
  spawnPlayer(): Entity;
  spawnEnemy(type: string, x: number, y: number): Entity;
  spawnBullet(x: number, y: number, vx: number, vy: number, isEnemy: boolean, life: number, radius?: number): Entity;
  spawnParticle(x: number, y: number, color: string, vx: number, vy: number, life: number): void;
}

export interface IAudioService {
  playSound(key: string, volume?: number): void;
  playMusic(key: string): void;
  setVolume(volume: number): void;
}

export interface IInputService {
  getCursor(): { x: number, y: number };
  isPressed(action: string): boolean;
  updateCursor(x: number, y: number): void;
}


=====================================
FILE: ./src/game/core/GameEngine.ts
=====================================
import { IGameSystem, IServiceLocator, IEntityRegistry } from './interfaces';
import { useGameStore } from '../store/useGameStore';
import { FXManager } from '../systems/FXManager';
import { ViewportHelper } from '../utils/ViewportHelper';
import { PanelRegistrySystem } from '../systems/PanelRegistrySystem'; 
import { GameStateSystem } from '../systems/GameStateSystem';

export class GameEngineCore implements IGameSystem {
  private systems: IGameSystem[] = [];
  private locator!: IServiceLocator;
  public registry: IEntityRegistry; 

  constructor(registry: IEntityRegistry) {
      this.registry = registry;
  }

  setup(locator: IServiceLocator): void {
    this.locator = locator;
    FXManager.init();
  }

  public registerSystem(system: IGameSystem) {
    this.systems.push(system);
  }

  update(delta: number, time: number): void {
    const store = useGameStore.getState();
    const gameSys = this.locator.getSystem<GameStateSystem>('GameStateSystem');
    
    if (store.isPlaying && store.systemIntegrity <= 0) {
        store.stopGame();
        FXManager.addTrauma(1.0);
        gameSys.isGameOver = true; 
        return;
    }

    if (!store.isPlaying) {
        gameSys.isGameOver = true;
    }

    for (const sys of this.systems) {
      sys.update(delta, time);
    }
  }

  teardown(): void {
    for (const sys of this.systems) {
      sys.teardown();
    }
    this.systems = [];
  }
  
  public updateViewport(vpW: number, vpH: number, screenW: number, screenH: number) {
    ViewportHelper.update(vpW, vpH, screenW, screenH);
    try {
        const panelSys = this.locator.getSystem<PanelRegistrySystem>('PanelRegistrySystem');
        panelSys.refreshAll();
    } catch (e) {
    }
  }
}


=====================================
FILE: ./src/game/GameOverlay.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { PlayerAvatar } from './components/PlayerAvatar';
import { GameDirector } from './components/GameDirector';
import { EnemyRenderer } from './components/EnemyRenderer';
import { BulletRenderer } from './components/BulletRenderer';
import { EnemyBulletRenderer } from './components/EnemyBulletRenderer';
import { HunterChargeRenderer } from './components/HunterChargeRenderer';
import { ParticleRenderer } from './components/ParticleRenderer';
import { ScreenShaker } from './components/ScreenShaker';
import { ProjectileTrails } from './components/ProjectileTrails'; 
import { GalleryStage } from './components/GalleryStage';
import { VirtualJoystick } from '@/ui/atoms/VirtualJoystick'; // NEW
import { useStore } from '@/core/store/useStore';
import { useEffect, useState } from 'react';

export const GameOverlay = () => {
  const { bootState, sandboxView } = useStore();
  const isGallery = bootState === 'sandbox' && sandboxView === 'gallery';
  const [isTouch, setIsTouch] = useState(false);

  useEffect(() => {
      // Simple touch detection
      const onTouch = () => setIsTouch(true);
      window.addEventListener('touchstart', onTouch, { once: true });
      return () => window.removeEventListener('touchstart', onTouch);
  }, []);

  return (
    <>
        <div className="fixed inset-0 z-[60] w-full h-full pointer-events-none overflow-hidden">
          <Canvas
            orthographic={!isGallery}
            camera={isGallery ? { position: [5, 5, 10], fov: 45 } : { zoom: 40, position: [0, 0, 100] }}
            gl={{ 
              alpha: true, 
              antialias: true,
              stencil: false,
              powerPreference: "high-performance"
            }}
            eventSource={typeof document !== 'undefined' ? document.body : undefined}
            eventPrefix="client"
          >
            {isGallery ? (
                <GalleryStage />
            ) : (
                <>
                    <GameDirector />
                    <ScreenShaker />
                    <ProjectileTrails />
                    <PlayerAvatar />
                    <BulletRenderer />
                    <HunterChargeRenderer /> 
                    <EnemyBulletRenderer />
                    <EnemyRenderer />
                    <ParticleRenderer /> 
                </>
            )}
          </Canvas>
        </div>
        
        {/* Show Joystick if Touch is detected AND we are in Game Mode (not Gallery) */}
        {isTouch && !isGallery && <VirtualJoystick />}
    </>
  );
};


=====================================
FILE: ./src/game/config/PlayerConfig.ts
=====================================
export const PLAYER_CONFIG = {
  maxHealth: 100,
  fireRate: 0.15, 
  bulletSpeed: 45,
  bulletRadius: 0.2,
  bulletLife: 1.5,
  
  // Scoring & Progression
  scoreMultiplier: 1,
  baseXpRequirement: 100,
  xpScalingFactor: 1.5, // Next level = base * (scaling ^ level)
};


=====================================
FILE: ./src/game/config/EnemyConfig.ts
=====================================
import { EnemyTypes } from './Identifiers';

export const ENEMY_CONFIG = {
  [EnemyTypes.DRILLER]: { // RENAMED
    hp: 2,
    baseSpeed: 8,
    radius: 0.5,
    damage: 15,
    score: 10
  },
  [EnemyTypes.KAMIKAZE]: {
    hp: 3,
    baseSpeed: 12,
    radius: 0.5,
    damage: 10,
    score: 20
  },
  [EnemyTypes.HUNTER]: {
    hp: 3,
    baseSpeed: 12,
    radius: 0.5,
    score: 50,
    orbitRadius: 12.5,
    orbitDuration: 2.0,
    chargeDuration: 1.0,
    fireRange: 12.0,
    offsetDistance: 1.6 
  }
};

export const WAVE_CONFIG = {
  baseSpawnInterval: 0.8,
  difficultyScaler: 1.0 
};


=====================================
FILE: ./src/game/config/Identifiers.ts
=====================================
import { GameEvents as NewGameEvents } from '../events/GameEvents';

export const EnemyTypes = {
  DRILLER: 'driller', // RENAMED
  KAMIKAZE: 'kamikaze',
  HUNTER: 'hunter',
} as const;

export type EnemyType = typeof EnemyTypes[keyof typeof EnemyTypes];

// Re-export the new Enum as the old Const Object to maintain backward compatibility
export const GameEvents = NewGameEvents;


=====================================
FILE: ./src/game/config/WorldConfig.ts
=====================================
export const WorldConfig = {
  bounds: {
    width: 32, // World Units
    height: 18,
    depth: 5
  },
  physics: {
    friction: 0.95,
    maxVelocity: 20
  },
  time: {
    fixedDelta: 1 / 60, // 60hz Logic Tick
    maxDelta: 0.1 // Prevent spiral of death on lag
  }
};


=====================================
FILE: ./src/game/logic/ai/EnemyBehaviors.ts
=====================================
import { Entity } from '../../core/ecs/Entity';
import { TransformComponent } from '../../components/data/TransformComponent';
import { MotionComponent } from '../../components/data/MotionComponent';
import { StateComponent } from '../../components/data/StateComponent';
import { ENEMY_CONFIG } from '../../config/EnemyConfig';
import { GameEvents } from '../../events/GameEvents';
import { EnemyTypes as Types } from '../../config/Identifiers';

const getPos = (e: Entity) => e.requireComponent<TransformComponent>('Transform');
const getMotion = (e: Entity) => e.requireComponent<MotionComponent>('Motion');
const getState = (e: Entity) => e.requireComponent<StateComponent>('State');

function rotateTowards(current: number, target: number, speed: number): number {
    let diff = target - current;
    while (diff > Math.PI) diff -= Math.PI * 2;
    while (diff < -Math.PI) diff += Math.PI * 2;
    return current + diff * speed;
}

function lerp(start: number, end: number, t: number): number {
    return start * (1 - t) + end * t;
}

export interface AIContext {
  playerPos: { x: number, y: number };
  panels: any[]; 
  delta: number;
  time: number;
  doDamageTick: boolean;
  spawnProjectile: (x: number, y: number, vx: number, vy: number) => void;
  damagePanel: (id: string, amount: number) => void;
  triggerExplosion: (x: number, y: number, color: string) => void;
  spawnDrillSparks: (x: number, y: number, color: string) => void; 
  emitEvent: (name: string, payload: any) => void;
  destroyEntity: (id: number) => void;
}

export interface EnemyBehavior {
  update(entity: Entity, ctx: AIContext): void;
}

export const DrillerBehavior: EnemyBehavior = {
  update: (e, ctx) => {
    const pos = getPos(e);
    const motion = getMotion(e);
    const state = getState(e);
    
    // FIX: Transition from IDLE (post-spawn) to Moving
    if (state.current === 'IDLE') {
        state.current = 'MOVING';
    }

    let targetX = 0;
    let targetY = 0;
    let bestPanel: any = null;
    let nearestDist = Infinity;

    for (const p of ctx.panels) {
      const dx = p.x - pos.x;
      const dy = p.y - pos.y;
      const dist = dx*dx + dy*dy;
      if (dist < nearestDist) {
        nearestDist = dist;
        bestPanel = p;
      }
    }

    let isDrilling = false;

    if (bestPanel) {
      targetX = Math.max(bestPanel.left, Math.min(pos.x, bestPanel.right));
      targetY = Math.max(bestPanel.bottom, Math.min(pos.y, bestPanel.top));
      
      const dx = targetX - pos.x;
      const dy = targetY - pos.y;
      const distToEdge = Math.sqrt(dx*dx + dy*dy);

      if (distToEdge < 0.5) { 
        isDrilling = true;
        ctx.spawnDrillSparks(targetX, targetY, '#9E4EA5');
        if (ctx.doDamageTick) {
            ctx.damagePanel(bestPanel.id, ENEMY_CONFIG[Types.DRILLER].damage);
        }
      }
    } else {
      // Wander if no panels
      targetX = Math.sin(ctx.time * 0.5) * 10;
      targetY = Math.cos(ctx.time * 0.5) * 5;
    }

    state.current = isDrilling ? 'DRILLING' : 'MOVING';

    if (!isDrilling) {
      const dx = targetX - pos.x;
      const dy = targetY - pos.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const speed = ENEMY_CONFIG[Types.DRILLER].baseSpeed;

      if (dist > 0.1) {
        motion.vx = (dx / dist) * speed;
        motion.vy = (dy / dist) * speed;
      } else {
        motion.vx = 0;
        motion.vy = 0;
      }
    } else {
      motion.vx = 0;
      motion.vy = 0;
    }
    
    if (isDrilling) {
        const angleToPanel = Math.atan2(targetY - pos.y, targetX - pos.x) - Math.PI/2;
        pos.rotation = rotateTowards(pos.rotation, angleToPanel, 0.2);
    } 
    else if (Math.abs(motion.vx) > 0.1 || Math.abs(motion.vy) > 0.1) {
        const targetAngle = Math.atan2(motion.vy, motion.vx) - Math.PI/2;
        pos.rotation = rotateTowards(pos.rotation, targetAngle, 0.1);
    }
  }
};

export const KamikazeBehavior: EnemyBehavior = {
  update: (e, ctx) => {
    const pos = getPos(e);
    const motion = getMotion(e);
    // Kamikazes don't really have complex state, they just run.
    
    const targetX = ctx.playerPos.x;
    const targetY = ctx.playerPos.y;
    const dx = targetX - pos.x;
    const dy = targetY - pos.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    if (dist < 1.0) {
       ctx.destroyEntity(e.id);
       ctx.triggerExplosion(pos.x, pos.y, '#FF003C');
       ctx.emitEvent(GameEvents.PLAYER_HIT, { damage: 10 });
       return; 
    }

    if (dist > 0.1) {
      const speed = ENEMY_CONFIG[Types.KAMIKAZE].baseSpeed;
      motion.vx = (dx / dist) * speed;
      motion.vy = (dy / dist) * speed;
      pos.rotation += 0.1; 
    }
  }
};

export const HunterBehavior: EnemyBehavior = {
  update: (e, ctx) => {
    const state = getState(e);
    const pos = getPos(e);
    const motion = getMotion(e);

    if (state.data.spinVelocity === undefined) {
        state.data.spinVelocity = 2.0;
        state.data.spinAngle = 0;
    }

    // FIX: Initialize HUNT state if coming from IDLE or SPAWN
    if (state.current === 'SPAWN' || state.current === 'IDLE') {
        state.current = 'HUNT';
        state.timers.action = 3.0; 
        state.data.offsetAngle = (e.id.valueOf() % 10) * 0.6; 
    }

    let targetSpinSpeed = 2.0; 

    if (state.current === 'HUNT') {
        const px = ctx.playerPos.x;
        const py = ctx.playerPos.y;
        
        const orbitSpeed = 0.5;
        const currentAngle = (ctx.time * orbitSpeed) + state.data.offsetAngle;
        
        const targetRadius = 16.0;
        const tx = px + Math.cos(currentAngle) * targetRadius;
        const ty = py + Math.sin(currentAngle) * targetRadius;

        const dx = tx - pos.x;
        const dy = ty - pos.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        const speed = ENEMY_CONFIG[Types.HUNTER].baseSpeed; 
        
        if (dist > 1.0) {
            motion.vx += (dx / dist) * speed * ctx.delta * 2.0;
            motion.vy += (dy / dist) * speed * ctx.delta * 2.0;
        }
        
        motion.vx *= 0.92;
        motion.vy *= 0.92;

        const aimDx = px - pos.x;
        const aimDy = py - pos.y;
        const aimAngle = Math.atan2(aimDy, aimDx) - Math.PI/2;
        pos.rotation = rotateTowards(pos.rotation, aimAngle, 0.05);

        state.timers.action -= ctx.delta;
        const inBounds = Math.abs(pos.x) < 22 && Math.abs(pos.y) < 14;
        
        if (state.timers.action <= 0 && inBounds) {
            state.current = 'CHARGE';
            state.timers.action = ENEMY_CONFIG[Types.HUNTER].chargeDuration;
            motion.vx *= 0.1; 
            motion.vy *= 0.1;
        }
    } 
    
    else if (state.current === 'CHARGE') {
        state.timers.action -= ctx.delta;
        motion.vx *= 0.8;
        motion.vy *= 0.8;

        const dx = ctx.playerPos.x - pos.x;
        const dy = ctx.playerPos.y - pos.y;
        const targetAngle = Math.atan2(dy, dx) - Math.PI/2;
        pos.rotation = rotateTowards(pos.rotation, targetAngle, 0.15);

        targetSpinSpeed = -8.0; 

        if (state.timers.action <= 0) {
            state.current = 'FIRE';
        }
    }
    
    else if (state.current === 'FIRE') {
        const dx = ctx.playerPos.x - pos.x;
        const dy = ctx.playerPos.y - pos.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const dirX = dist > 0 ? dx/dist : 0;
        const dirY = dist > 0 ? dy/dist : 1;
        
        const offset = 1.6;
        const spawnX = pos.x + (dirX * offset);
        const spawnY = pos.y + (dirY * offset);
        const SPEED = 25; 

        ctx.spawnProjectile(spawnX, spawnY, dirX * SPEED, dirY * SPEED);

        state.current = 'HUNT';
        state.timers.action = 2.0 + Math.random() * 2.0;
    }

    state.data.spinVelocity = lerp(state.data.spinVelocity, targetSpinSpeed, ctx.delta * 2.0);
    state.data.spinAngle += state.data.spinVelocity * ctx.delta;
  }
};

export const Behaviors: Record<string, EnemyBehavior> = {
  [Types.DRILLER]: DrillerBehavior,
  [Types.KAMIKAZE]: KamikazeBehavior,
  [Types.HUNTER]: HunterBehavior
};


=====================================
FILE: ./src/game/utils/TextureGen.ts
=====================================
import * as THREE from 'three';

// Helper: Exponential Falloff for natural light
// x is 0..1 (distance from center)
const falloff = (x: number, power: number = 2) => {
  return Math.pow(Math.max(0, 1 - x), power);
};

// 1. High Quality Comet Trail
export const createCometTexture = () => {
  const w = 64;
  const h = 256; // Higher resolution vertical
  const canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext('2d')!;
  
  ctx.clearRect(0, 0, w, h);

  // We draw manually pixel-by-pixel or using complex gradients for better control
  // Gradient: Bottom (Head) -> Top (Tail)
  const gradient = ctx.createLinearGradient(0, h, 0, 0);
  
  // Exponential fade:
  // 0.0 (Head): 100% Opacity
  // 0.2 (Body): 60% Opacity
  // 1.0 (Tail): 0% Opacity
  gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)'); 
  gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.4)');
  gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

  ctx.fillStyle = gradient;

  // Shape: Tapered Triangle
  ctx.beginPath();
  ctx.moveTo(w * 0.1, h);       // Bottom Left (pinched slightly)
  ctx.lineTo(w * 0.9, h);       // Bottom Right
  ctx.lineTo(w * 0.5, 0);       // Top Tip
  ctx.closePath();
  ctx.fill();

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
};

// 2. Player Bullet (Glowing Bar)
export const createGlowingBarTexture = () => {
  const w = 64;
  const h = 128;
  const canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext('2d')!;

  // Clear
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, w, h);

  // Glow (Soft Rect)
  const cx = w / 2;
  const cy = h / 2;
  
  // Radial glow around the bar isn't ideal, let's use shadow blur
  ctx.shadowColor = "white";
  ctx.shadowBlur = 20;
  ctx.fillStyle = "white";
  
  // Draw Core (Slim Rectangle)
  // Leave padding for the glow/shadow to bleed
  ctx.fillRect(24, 20, 16, 88); 

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
};

// 3. Hunter Orb (Exponential Glow)
export const createExponentialBallTexture = () => {
  const size = 128;
  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d')!;
  
  const cx = size / 2;
  const cy = size / 2;
  const radius = size / 2;

  const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
  
  // Sharp Core, Soft Bloom
  gradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); 
  gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.9)'); // Solid Core
  gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)'); // Mid Bloom
  gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Fade out

  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, size, size);

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
};

// 4. Soft Glow (Backgrounds - Legacy/Enemies)
export const createGlowTexture = () => {
  const canvas = document.createElement('canvas');
  canvas.width = 64;
  canvas.height = 64;
  const ctx = canvas.getContext('2d')!;
  
  const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
  gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
  gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 64, 64);

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
};


=====================================
FILE: ./src/game/utils/Noise.ts
=====================================
// Simple 1D Gradient Noise
// Returns value between -1 and 1 based on input 'x'
export function noise(x: number): number {
  const i = Math.floor(x);
  const f = x - i;
  const u = f * f * (3.0 - 2.0 * f); // Cubic smoothing
  return mix(hash(i), hash(i + 1), u);
}

function hash(n: number): number {
  return (Math.sin(n) * 43758.5453) % 1.0;
}

function mix(a: number, b: number, t: number): number {
  return a * (1 - t) + b * t;
}


=====================================
FILE: ./src/game/utils/ViewportHelper.ts
=====================================
export interface WorldRect {
  id: string;
  x: number;
  y: number;
  width: number;
  height: number;
  left: number;
  right: number;
  top: number;
  bottom: number;
}

export class ViewportHelperCore {
  public viewport = { width: 1, height: 1 }; // R3F Viewport units
  public screenSize = { width: 1, height: 1 }; // Window Pixels

  public update(vpW: number, vpH: number, screenW: number, screenH: number) {
    this.viewport = { width: vpW, height: vpH };
    this.screenSize = { width: screenW, height: screenH };
  }

  // Pure Math: Converts Pixel Rect -> World Rect
  public domToWorld(id: string, domRect: DOMRect): WorldRect {
    const sw = this.screenSize.width || 1;
    const sh = this.screenSize.height || 1;
    
    const vw = this.viewport.width;
    const vh = this.viewport.height;
    
    const cx = domRect.left + domRect.width / 2;
    const cy = domRect.top + domRect.height / 2;
    
    // Screen (Pixels) -> World (Orthographic Units)
    // 0,0 is center of screen in World
    const wx = (cx / sw) * vw - (vw / 2);
    const wy = -((cy / sh) * vh - (vh / 2));
    
    const wWidth = (domRect.width / sw) * vw;
    const wHeight = (domRect.height / sh) * vh;

    return {
      id: id,
      x: wx, y: wy,
      width: wWidth, height: wHeight,
      left: wx - wWidth / 2, right: wx + wWidth / 2,
      top: wy + wHeight / 2, bottom: wy - wHeight / 2,
    };
  }
}

export const ViewportHelper = new ViewportHelperCore();


=====================================
FILE: ./src/game/utils/GeometryUtils.ts
=====================================
import * as THREE from 'three';

export const addBarycentricCoordinates = (bufferGeometry: THREE.BufferGeometry, removeEdge: boolean = false) => {
  const geometry = bufferGeometry.toNonIndexed();
  const count = geometry.attributes.position.count;
  const centers = new Float32Array(count * 3);

  for (let i = 0; i < count; i += 3) {
    centers[i * 3] = 1;
    centers[i * 3 + 1] = 0;
    centers[i * 3 + 2] = 0;

    centers[i * 3 + 3] = 0;
    centers[i * 3 + 4] = 1;
    centers[i * 3 + 5] = 0;

    centers[i * 3 + 6] = 0;
    centers[i * 3 + 7] = 0;
    centers[i * 3 + 8] = 1;
  }

  geometry.setAttribute('barycentric', new THREE.BufferAttribute(centers, 3));
  return geometry;
};

// NEW: Tri-Wing "Paper Airplane" Spear
export const createHunterSpear = () => {
  const positions: number[] = [];
  
  // We build 3 "Wings" (thin triangles)
  const numWings = 3;
  const length = 1.2;
  const wingWidth = 0.4;
  const wingThickness = 0.05; // Give it slight 3D thickness

  for(let i=0; i<numWings; i++) {
      const angle = (i / numWings) * Math.PI * 2;
      
      // We build a triangle in the Y/X plane, then rotate it around Y
      // Tip at (0, length/2, 0)
      // Base Outer at (width, -length/2, 0)
      // Base Inner at (0, -length/2, 0)
      
      const tipY = length / 2;
      const baseY = -length / 2;
      
      // Define vertices for a "Thick" triangle (Wedge)
      // P1: Tip
      // P2: Base Outer Left
      // P3: Base Outer Right
      // P4: Base Center (Axis)
      
      // Let's manually push triangles for a "Fin"
      // Fin stands on the +X axis
      
      const pTip = [0, tipY, 0];
      const pBaseOut = [wingWidth, baseY, 0];
      const pBaseInBack = [0, baseY, -wingThickness];
      const pBaseInFront = [0, baseY, wingThickness];
      
      // Helper to rotate point around Y axis
      const rotateY = (p: number[], rad: number) => {
          const x = p[0];
          const z = p[2];
          return [
              x * Math.cos(rad) - z * Math.sin(rad),
              p[1], // Y unchanged
              x * Math.sin(rad) + z * Math.cos(rad)
          ];
      };

      // Push Triangles
      // 1. Face Front
      let v1 = rotateY(pTip, angle);
      let v2 = rotateY(pBaseOut, angle);
      let v3 = rotateY(pBaseInFront, angle);
      positions.push(...v1, ...v2, ...v3);
      
      // 2. Face Back
      v1 = rotateY(pTip, angle);
      v2 = rotateY(pBaseInBack, angle);
      v3 = rotateY(pBaseOut, angle);
      positions.push(...v1, ...v2, ...v3);
      
      // 3. Base Cap (optional, but good for solidity)
      // ... skipping for wireframe aesthetic
  }
  
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  geometry.computeVertexNormals();
  
  return addBarycentricCoordinates(geometry);
};


=====================================
FILE: ./src/game/utils/coords.ts
=====================================
// Camera Zoom level defined in GameOverlay
const ZOOM = 40; 

export const screenToWorld = (screenX: number, screenY: number, screenW: number, screenH: number) => {
  // DOM: 0,0 is Top-Left. +Y is Down.
  // THREE: 0,0 is Center. +Y is Up.
  
  const worldX = (screenX - screenW / 2) / ZOOM;
  const worldY = -(screenY - screenH / 2) / ZOOM; // Invert Y
  
  return { x: worldX, y: worldY };
};

export const domRectToWorldRect = (rect: { x: number, y: number, width: number, height: number }, screenW: number, screenH: number) => {
  // Get center of DOM element
  const centerX = rect.x + rect.width / 2;
  const centerY = rect.y + rect.height / 2;
  
  const centerWorld = screenToWorld(centerX, centerY, screenW, screenH);
  
  return {
    x: centerWorld.x,
    y: centerWorld.y,
    width: rect.width / ZOOM,
    height: rect.height / ZOOM,
    left: centerWorld.x - (rect.width / ZOOM / 2),
    right: centerWorld.x + (rect.width / ZOOM / 2),
    top: centerWorld.y + (rect.height / ZOOM / 2),
    bottom: centerWorld.y - (rect.height / ZOOM / 2),
  };
};


=====================================
FILE: ./src/game/components/PlayerAvatar.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import { GAME_THEME } from '../theme';
import { ServiceLocator } from '../core/ServiceLocator';
import { useGameStore } from '../store/useGameStore';
import { useStore } from '@/core/store/useStore';
import { InteractionSystem, RepairState } from '../systems/InteractionSystem'; 
import { EntitySystem } from '../systems/EntitySystem';
import * as THREE from 'three';

export const PlayerAvatar = () => {
  const groupRef = useRef<THREE.Group>(null);
  const ringRef = useRef<THREE.Mesh>(null);
  const coreRef = useRef<THREE.Mesh>(null);
  const glowRef = useRef<THREE.Sprite>(null);
  const { viewport } = useThree();
  
  const { introDone } = useStore(); 

  const colorTurret = new THREE.Color(GAME_THEME.turret.base); 
  const colorRepair = new THREE.Color(GAME_THEME.turret.repair); 
  const colorReboot = new THREE.Color('#9E4EA5'); 
  const colorDead = new THREE.Color('#FF003C'); 

  const isDead = useGameStore(state => state.playerHealth <= 0);
  const isGameOver = useGameStore(state => state.systemIntegrity <= 0);
  
  // GEOMETRIES
  const aliveGeo = new THREE.CircleGeometry(0.1, 16);
  // Reverted: Use Circle with 3 segments for Triangle, size 0.12
  const deadGeo = new THREE.CircleGeometry(0.12, 3); 
  
  const animScale = useRef(0);

  useFrame((state, delta) => {
    if (!groupRef.current) return;

    // FADE IN LOGIC
    const targetScale = introDone ? 1 : 0;
    animScale.current = THREE.MathUtils.lerp(animScale.current, targetScale, delta * 2.0);
    
    if (animScale.current < 0.01) {
        groupRef.current.visible = false;
        return;
    }
    groupRef.current.visible = true;

    // 1. Position
    const x = (state.pointer.x * viewport.width) / 2;
    const y = (state.pointer.y * viewport.height) / 2;
    groupRef.current.position.x = x;
    groupRef.current.position.y = y;

    try { ServiceLocator.getInputService().updateCursor(x, y); } catch {}

    // 2. State
    let repairState: RepairState = 'IDLE';
    let entitySys: EntitySystem | null = null;
    try {
        repairState = ServiceLocator.getSystem<InteractionSystem>('InteractionSystem').repairState;
        entitySys = ServiceLocator.getSystem<EntitySystem>('EntitySystem');
    } catch {}
    
    let targetColor = colorTurret;
    if (repairState === 'HEALING') targetColor = colorRepair; 
    if (repairState === 'REBOOTING') targetColor = colorReboot; 

    // 3. Visuals
    if (ringRef.current && coreRef.current && glowRef.current) {
        let currentBaseScale = 1.0;

        if (isDead || isGameOver) {
            // DEAD STATE: Red Triangle
            ringRef.current.visible = false;
            glowRef.current.visible = false;
            
            coreRef.current.geometry = deadGeo;
            coreRef.current.material.color.set(colorDead);
            coreRef.current.material.wireframe = true; 
            
            // ANIMATION LOGIC
            const isRebooting = repairState === 'REBOOTING';
            
            if (isRebooting) {
                // Fast Counter-Clockwise Spin
                coreRef.current.rotation.z -= delta * 10.0;
                
                // Particle Spray
                if (entitySys && Math.random() > 0.5) { // 30fps emission rate
                    const pColor = Math.random() > 0.5 ? '#FF003C' : '#F7D277';
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 3;
                    
                    entitySys.spawnParticle(x, y, pColor, 1, speed, 0.4);
                }
            } else {
                // Slow Clockwise Idle Spin
                coreRef.current.rotation.z += delta * 1.5; 
            }
            
        } else {
            // ALIVE STATE
            ringRef.current.visible = true;
            glowRef.current.visible = true;
            coreRef.current.geometry = aliveGeo;
            coreRef.current.material.wireframe = false;
            
            if (repairState !== 'IDLE') {
                ringRef.current.rotation.z += 0.4; 
                ringRef.current.material.color.lerp(targetColor, 0.4);
                coreRef.current.material.color.lerp(targetColor, 0.4);
                glowRef.current.material.color.lerp(targetColor, 0.4);
                
                const pulse = 1.2 + Math.sin(state.clock.elapsedTime * 20) * 0.2;
                currentBaseScale = pulse;
            } else {
                ringRef.current.rotation.z -= 0.02; 
                ringRef.current.material.color.lerp(colorTurret, 0.1);
                coreRef.current.material.color.lerp(colorTurret, 0.1);
                glowRef.current.material.color.lerp(colorTurret, 0.1);
            }
        }
        
        groupRef.current.scale.setScalar(animScale.current);
        coreRef.current.scale.setScalar(currentBaseScale);
        ringRef.current.scale.setScalar(currentBaseScale); 
    }
  });

  return (
    <group ref={groupRef}>
      <mesh ref={coreRef}>
        <bufferGeometry />
        <meshBasicMaterial color={GAME_THEME.turret.base} />
      </mesh>

      <mesh ref={ringRef} rotation={[0, 0, Math.PI / 4]}>
        <ringGeometry args={[0.4, 0.45, 4]} /> 
        <meshBasicMaterial color={GAME_THEME.turret.base} transparent opacity={0.8} />
      </mesh>

      <sprite ref={glowRef} scale={[2, 2, 1]}>
        <spriteMaterial 
          color={GAME_THEME.turret.glow} 
          transparent 
          opacity={0.3}
          blending={THREE.AdditiveBlending}
        />
      </sprite>
    </group>
  );
};


=====================================
FILE: ./src/game/components/BulletRenderer.tsx
=====================================
import { useMemo } from 'react';
import * as THREE from 'three';
import { Tag } from '../core/ecs/types';
import { GAME_THEME } from '../theme';
import { InstancedActor } from './common/InstancedActor';

const vertexShader = `
  varying vec2 vUv;
  void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0); }
`;
const fragmentShader = `
  varying vec2 vUv;
  uniform vec3 uColor;
  float sdBox(vec2 p, vec2 b) { vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }
  void main() {
    vec2 p = vUv - 0.5;
    float d = sdBox(p, vec2(0.1, 0.3));
    float core = 1.0 - smoothstep(0.0, 0.02, d);
    float glow = exp(-20.0 * max(0.0, d));
    vec3 color = mix(uColor, vec3(1.0), core);
    gl_FragColor = vec4(color, max(core, glow));
  }
`;

export const BulletRenderer = () => {
  const geometry = useMemo(() => new THREE.PlaneGeometry(1.2, 1.2), []); 
  const material = useMemo(() => new THREE.ShaderMaterial({
    vertexShader, fragmentShader,
    uniforms: { uColor: { value: new THREE.Color(GAME_THEME.bullet.plasma) } },
    transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
  }), []);

  return (
    <InstancedActor 
      tag={Tag.BULLET} 
      geometry={geometry} 
      material={material} 
      maxCount={500} 
      filter={(e) => !e.hasTag(Tag.ENEMY)}
      updateEntity={(e, obj) => {
         // Fix Rotation offset for Bullets (pointing up vs right)
         obj.rotation.z -= Math.PI / 2;
      }}
    />
  );
};


=====================================
FILE: ./src/game/components/ParticleRenderer.tsx
=====================================
import { useMemo } from 'react';
import * as THREE from 'three';
import { Tag } from '../core/ecs/types';
import { InstancedActor } from './common/InstancedActor';
import { LifetimeComponent } from '../components/data/LifetimeComponent';

export const ParticleRenderer = () => {
  const geometry = useMemo(() => new THREE.PlaneGeometry(0.3, 0.3), []);
  const material = useMemo(() => new THREE.ShaderMaterial({
    vertexShader: `
      #ifndef USE_INSTANCING_COLOR
      attribute vec3 instanceColor;
      #endif
      varying vec2 vUv;
      varying vec3 vColor;
      void main() { vUv = uv; vColor = instanceColor; gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0); }
    `,
    fragmentShader: `
      varying vec2 vUv;
      varying vec3 vColor;
      void main() {
        float dist = distance(vUv, vec2(0.5));
        float alpha = pow(1.0 - smoothstep(0.0, 0.5, dist), 3.0);
        if (alpha < 0.01) discard;
        gl_FragColor = vec4(vColor, alpha);
      }
    `,
    vertexColors: true, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
  }), []);

  return (
    <InstancedActor 
      tag={Tag.PARTICLE} 
      geometry={geometry} 
      material={material} 
      maxCount={1000}
      colorSource="identity"
      updateEntity={(e, obj, color) => {
         const life = e.getComponent<LifetimeComponent>('Lifetime');
         if (life) {
             const scale = life.remaining / life.total;
             obj.scale.setScalar(scale);
             obj.position.z = 2.0; // Force particles above enemies/floor
         }
      }}
    />
  );
};


=====================================
FILE: ./src/game/components/EnemyBulletRenderer.tsx
=====================================
import { useMemo } from 'react';
import * as THREE from 'three';
import { Tag } from '../core/ecs/types';
import { GAME_THEME } from '../theme';
import { InstancedActor } from './common/InstancedActor';

const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0); }`;
const fragmentShader = `
  varying vec2 vUv; uniform vec3 uColor;
  void main() {
    float dist = distance(vUv, vec2(0.5));
    float core = 1.0 - smoothstep(0.2, 0.25, dist);
    float glow = pow(1.0 - smoothstep(0.25, 0.5, dist), 3.0);
    gl_FragColor = vec4(mix(uColor, vec3(1.0), core), max(core, glow));
  }
`;

export const EnemyBulletRenderer = () => {
  const geometry = useMemo(() => new THREE.PlaneGeometry(2.0, 2.0), []); 
  const material = useMemo(() => new THREE.ShaderMaterial({
    vertexShader, fragmentShader,
    uniforms: { uColor: { value: new THREE.Color(GAME_THEME.bullet.hunter) } },
    transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
  }), []);

  return (
    <InstancedActor 
      tag={Tag.BULLET} 
      geometry={geometry} 
      material={material} 
      maxCount={200}
      filter={(e) => e.hasTag(Tag.ENEMY)}
      updateEntity={(e, obj) => {
          // Keep bullets upright regardless of transform rotation (billboard style)
          obj.rotation.set(0,0,0);
          obj.scale.setScalar(1);
      }}
    />
  );
};


=====================================
FILE: ./src/game/components/HunterChargeRenderer.tsx
=====================================
import { useMemo } from 'react';
import * as THREE from 'three';
import { Tag } from '../core/ecs/types';
import { GAME_THEME } from '../theme';
import { EnemyTypes } from '../config/Identifiers';
import { InstancedActor } from './common/InstancedActor';
import { IdentityComponent } from '../data/IdentityComponent';
import { StateComponent } from '../data/StateComponent';
import { TransformComponent } from '../data/TransformComponent';

// Reuse Shader Logic from EnemyBullet (Same Orb visual)
const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0); }`;
const fragmentShader = `
  varying vec2 vUv; uniform vec3 uColor;
  void main() {
    float dist = distance(vUv, vec2(0.5));
    float core = 1.0 - smoothstep(0.2, 0.25, dist);
    float glow = pow(1.0 - smoothstep(0.25, 0.5, dist), 3.0);
    gl_FragColor = vec4(mix(uColor, vec3(1.0), core), max(core, glow));
  }
`;

export const HunterChargeRenderer = () => {
  const geometry = useMemo(() => new THREE.PlaneGeometry(2.0, 2.0), []);
  const material = useMemo(() => new THREE.ShaderMaterial({
    vertexShader, fragmentShader,
    uniforms: { uColor: { value: new THREE.Color(GAME_THEME.bullet.hunter) } },
    transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
  }), []);

  return (
    <InstancedActor
      tag={Tag.ENEMY}
      geometry={geometry}
      material={material}
      maxCount={50}
      filter={(e) => {
          const id = e.getComponent<IdentityComponent>('Identity');
          const state = e.getComponent<StateComponent>('State');
          return id?.variant === EnemyTypes.HUNTER && state?.current === 'CHARGE';
      }}
      updateEntity={(e, obj) => {
          const transform = e.getComponent<TransformComponent>('Transform');
          const state = e.getComponent<StateComponent>('State');
          if (transform && state) {
              const progress = Math.max(0, Math.min(1, 1.0 - (state.timers.state || 0)));
              const scale = Math.min(1.0, progress * 1.1);
              
              const offset = 1.6;
              const dirX = Math.cos(transform.rotation + Math.PI/2);
              const dirY = Math.sin(transform.rotation + Math.PI/2);
              
              // Override position to be in front of Hunter
              obj.position.x += dirX * offset;
              obj.position.y += dirY * offset;
              obj.position.z = 0.1; // Layer above
              obj.scale.setScalar(scale);
              obj.rotation.set(0,0,0);
          }
      }}
    />
  );
};


=====================================
FILE: ./src/game/components/GalleryStage.tsx
=====================================
import { useMemo, useRef, useState } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import { OrbitControls, Grid } from '@react-three/drei';
import * as THREE from 'three';
import { useStore } from '@/core/store/useStore';
import { EnemyTypes } from '@/game/config/Identifiers';
import { GAME_THEME } from '@/game/theme';
import { addBarycentricCoordinates, createHunterSpear } from '@/game/utils/GeometryUtils';

// --- SHADERS (Enemy Body - Wireframe Glow) ---
const bodyVertexShader = `
  attribute vec3 barycentric;
  varying vec3 vBarycentric;
  void main() {
    vBarycentric = barycentric;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const bodyFragmentShader = `
  uniform vec3 uColor;
  uniform float uGlow;
  varying vec3 vBarycentric;
  
  float edgeFactor(vec3 bary, float width) {
    vec3 d = fwidth(bary);
    vec3 a3 = smoothstep(vec3(0.0), d * width, bary);
    return min(min(a3.x, a3.y), a3.z);
  }

  void main() {
    float width = 1.5; 
    float edge = edgeFactor(vBarycentric, width);
    float glow = 1.0 - edge;
    glow = pow(glow, 0.4) + uGlow; 
    
    vec3 coreColor = uColor;
    vec3 edgeColor = vec3(1.0); // Always white edges
    vec3 finalColor = mix(coreColor, edgeColor, 1.0 - smoothstep(0.0, 0.1, edge));
    
    // Add inner glow
    finalColor += coreColor * uGlow * 0.5;

    gl_FragColor = vec4(finalColor, 1.0);
  }
`;

// --- SHADERS (Projectile/VFX - Billboard Glow) ---
const vfxVertexShader = `
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const vfxFragmentShader = `
  varying vec2 vUv;
  uniform vec3 uColor;
  
  void main() {
    float dist = distance(vUv, vec2(0.5));
    // Soft glow ball
    float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
    alpha = pow(alpha, 2.0);
    
    // Bright core
    float core = 1.0 - smoothstep(0.0, 0.15, dist);
    
    vec3 color = mix(uColor, vec3(1.0), core);
    
    if (alpha < 0.05) discard;
    gl_FragColor = vec4(color, alpha);
  }
`;

// --- LOCAL VFX COMPONENT ---
const GalleryVFX = ({ type, isAttacking }: { type: string, isAttacking: boolean }) => {
  const particlesRef = useRef<THREE.InstancedMesh>(null);
  const projectileRef = useRef<THREE.Mesh>(null);
  const orbRef = useRef<THREE.Mesh>(null);
  const dummy = useMemo(() => new THREE.Object3D(), []);
  const { camera } = useThree();

  const projectileMat = useMemo(() => new THREE.ShaderMaterial({
      vertexShader: vfxVertexShader,
      fragmentShader: vfxFragmentShader,
      uniforms: { uColor: { value: new THREE.Color(GAME_THEME.bullet.hunter) } },
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      side: THREE.DoubleSide
  }), []);

  useFrame((state) => {
    const time = state.clock.elapsedTime;
    
    // Billboard Logic: Make VFX face camera
    if (orbRef.current) orbRef.current.lookAt(camera.position);
    if (projectileRef.current) projectileRef.current.lookAt(camera.position);

    // --- PARTICLE SYSTEM ---
    if (particlesRef.current) {
        let count = 0;
        
        if (type === EnemyTypes.DRILLER && isAttacking) {
            // DRILLER SPARKS (From Tip Down)
            for(let i=0; i<8; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 0.8;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const speed = (time * 10 + i) % 1.0;
                
                // Tip is at Y=2.0 (approx)
                dummy.position.set(x, 2.0 - (speed * 2.0), z);
                dummy.scale.setScalar(0.2 * (1.0 - speed));
                dummy.rotation.set(Math.random(), Math.random(), Math.random());
                dummy.updateMatrix();
                particlesRef.current.setMatrixAt(i, dummy.matrix);
                count++;
            }
        } 
        else if (type === EnemyTypes.KAMIKAZE && isAttacking) {
            // EXPLOSION (Pulse)
            const cycle = time % 2.0; 
            if (cycle > 1.5) { // Boom phase
                const progress = (cycle - 1.5) * 2.0; // 0..1
                const expansion = progress * 6.0;
                
                for(let i=0; i<30; i++) {
                    const angle = (i / 30) * Math.PI * 2 + (Math.random() * 0.5);
                    const yDir = (Math.random() - 0.5) * 2.0;
                    
                    dummy.position.set(
                        Math.cos(angle) * expansion, 
                        yDir * expansion, 
                        Math.sin(angle) * expansion
                    );
                    dummy.scale.setScalar(0.5 * (1.0 - progress));
                    dummy.updateMatrix();
                    particlesRef.current.setMatrixAt(i, dummy.matrix);
                    count++;
                }
            }
        }
        
        particlesRef.current.count = count;
        particlesRef.current.instanceMatrix.needsUpdate = true;
    }

    // --- HUNTER PROJECTILES ---
    if (type === EnemyTypes.HUNTER) {
        // Timeline: 2s Cycle. 0-1s Charge, 1-1.2s Fire, 1.2-2s Cooldown
        const cycle = time % 2.0; 
        
        // CHARGE ORB (Tip at Y=1.5 approx)
        if (orbRef.current) {
            if (isAttacking && cycle < 1.0) {
                const scale = cycle * 1.5; // Grow
                orbRef.current.visible = true;
                orbRef.current.scale.setScalar(scale);
                orbRef.current.position.set(0, 1.8, 0); // At tip
            } else {
                orbRef.current.visible = false;
            }
        }

        // BULLET (Fires Upward Y+)
        if (projectileRef.current) {
            if (isAttacking && cycle > 1.0 && cycle < 1.5) {
                projectileRef.current.visible = true;
                const travel = (cycle - 1.0) * 15.0; // Fast
                projectileRef.current.position.set(0, 1.8 + travel, 0);
                projectileRef.current.scale.set(1.5, 1.5, 1.5);
            } else {
                projectileRef.current.visible = false;
            }
        }
    }
  });

  return (
    <>
      <instancedMesh ref={particlesRef} args={[new THREE.PlaneGeometry(0.5, 0.5), undefined, 50]}>
        <meshBasicMaterial color="#FFF" transparent opacity={0.8} blending={THREE.AdditiveBlending} side={THREE.DoubleSide} />
      </instancedMesh>
      
      {type === EnemyTypes.HUNTER && (
          <>
            <mesh ref={orbRef}>
                <planeGeometry args={[1.5, 1.5]} />
                <primitive object={projectileMat} attach="material" />
            </mesh>
            <mesh ref={projectileRef}>
                <planeGeometry args={[1.0, 2.0]} />
                <primitive object={projectileMat} attach="material" />
            </mesh>
          </>
      )}
    </>
  );
};

export const GalleryStage = () => {
  const { galleryTarget, galleryAction } = useStore();
  const meshRef = useRef<THREE.Mesh>(null);
  const materialRef = useRef<THREE.ShaderMaterial>(null);

  // --- GEOMETRY ---
  const drillerGeo = useMemo(() => addBarycentricCoordinates(new THREE.ConeGeometry(1.5, 4.0, 4)), []);
  const kamikazeGeo = useMemo(() => addBarycentricCoordinates(new THREE.IcosahedronGeometry(2.5, 1)), []); // Detail 1 for better wireframe
  const hunterGeo = useMemo(() => createHunterSpear().scale(2, 2, 2), []); 

  // --- SHADER MAT ---
  const shaderMaterial = useMemo(() => new THREE.ShaderMaterial({
    vertexShader: bodyVertexShader,
    fragmentShader: bodyFragmentShader,
    uniforms: {
        uColor: { value: new THREE.Color('#FFFFFF') }, // Default white to ensure visibility if prop fails
        uGlow: { value: 0.0 }
    },
    side: THREE.DoubleSide,
    extensions: { derivatives: true },
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false, // Helps with "Hologram" feel
  }), []);

  useFrame((state, delta) => {
    if (!meshRef.current || !materialRef.current) return;

    const time = state.clock.elapsedTime;
    const isAttack = galleryAction === 'ATTACK';

    // 1. BEHAVIOR ANIMATIONS
    if (galleryTarget === EnemyTypes.DRILLER) {
        // Idle: Slow Float | Attack: Fast Spin + Shake
        const speed = isAttack ? 20.0 : 1.0;
        meshRef.current.rotation.y += speed * delta;
        
        if (isAttack) {
            meshRef.current.position.x = (Math.random() - 0.5) * 0.1;
            meshRef.current.position.z = (Math.random() - 0.5) * 0.1;
        } else {
            meshRef.current.position.set(0, 0, 0);
            // Bobbing
            meshRef.current.position.y = Math.sin(time) * 0.2;
        }
    } 
    else if (galleryTarget === EnemyTypes.KAMIKAZE) {
        // Idle: Tumble | Attack: Violent Shake + Expansion Pulse
        const tumbleSpeed = isAttack ? 5.0 : 0.5;
        meshRef.current.rotation.x += tumbleSpeed * delta;
        meshRef.current.rotation.z += tumbleSpeed * delta;

        if (isAttack) {
            const cycle = time % 2.0; // 2s cycle
            // Shake (0 - 1.5s)
            if (cycle < 1.5) {
                const shake = (cycle / 1.5) * 0.5; // Shake gets harder
                meshRef.current.position.x = (Math.random() - 0.5) * shake;
                meshRef.current.position.y = (Math.random() - 0.5) * shake;
                meshRef.current.scale.setScalar(1.0 + (shake * 0.5)); // Swell
            } 
            // Boom (1.5 - 2.0s) -> Shrink/Hide
            else {
                meshRef.current.scale.setScalar(0.01);
            }
        } else {
            meshRef.current.position.set(0,0,0);
            meshRef.current.scale.setScalar(1.0);
        }
    } 
    else if (galleryTarget === EnemyTypes.HUNTER) {
        // Idle: Spin Y | Attack: Face Front, Charge, Recoil
        if (isAttack) {
            meshRef.current.rotation.set(0,0,0); // Reset
            const cycle = time % 2.0;
            
            // Recoil Effect at 1.0s (Fire)
            if (cycle > 1.0 && cycle < 1.3) {
                meshRef.current.position.y = -1.0; // Kick down (since firing up)
            } else {
                meshRef.current.position.y = THREE.MathUtils.lerp(meshRef.current.position.y, 0, delta * 5);
            }
        } else {
            meshRef.current.rotation.y += delta;
            meshRef.current.position.y = Math.sin(time) * 0.3;
        }
    }

    // 2. COLOR UPDATES
    let baseColor = new THREE.Color();
    let glow = 0.2;

    if (galleryTarget === EnemyTypes.DRILLER) {
        baseColor.set(GAME_THEME.enemy.muncher);
        if (isAttack) glow = 0.8;
    } 
    else if (galleryTarget === EnemyTypes.KAMIKAZE) {
        baseColor.set(GAME_THEME.enemy.kamikaze);
        if (isAttack) {
            const flash = Math.sin(time * 30) > 0;
            if (flash) baseColor.set('#FFFFFF'); // Strobe
            glow = 1.0;
        }
    } 
    else if (galleryTarget === EnemyTypes.HUNTER) {
        baseColor.set(GAME_THEME.enemy.hunter);
        if (isAttack) {
            // Charge up color
            const cycle = time % 2.0;
            if (cycle < 1.0) glow = cycle; 
        }
    }

    materialRef.current.uniforms.uColor.value.copy(baseColor);
    materialRef.current.uniforms.uGlow.value = glow;
  });

  const activeGeo = useMemo(() => {
      switch(galleryTarget) {
          case EnemyTypes.DRILLER: return drillerGeo;
          case EnemyTypes.KAMIKAZE: return kamikazeGeo;
          case EnemyTypes.HUNTER: return hunterGeo;
          default: return drillerGeo;
      }
  }, [galleryTarget, drillerGeo, kamikazeGeo, hunterGeo]);

  return (
    <>
        <OrbitControls makeDefault minDistance={5} maxDistance={20} />
        
        {/* FLOOR GRID */}
        <Grid 
            position={[0, -4, 0]} 
            args={[20, 20]} 
            sectionColor="#00F0FF" 
            cellColor="#001a33" 
            fadeDistance={20}
        />

        {/* ENEMY MODEL */}
        <mesh ref={meshRef} geometry={activeGeo} material={shaderMaterial} />
        
        {/* VFX LAYER */}
        <GalleryVFX type={galleryTarget} isAttacking={galleryAction === 'ATTACK'} />
    </>
  );
};


=====================================
FILE: ./src/game/components/common/InstancedActor.tsx
=====================================
import { useRef, useLayoutEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { ActiveEngine } from '../GameDirector';
import { TransformComponent } from '../data/TransformComponent';
import { IdentityComponent } from '../data/IdentityComponent';
import { Entity } from '@/game/core/ecs/Entity';

const tempObj = new THREE.Object3D();
const tempColor = new THREE.Color();

interface InstancedActorProps {
  tag: string;
  geometry: THREE.BufferGeometry;
  material: THREE.Material;
  maxCount: number;
  updateEntity?: (entity: Entity, obj: THREE.Object3D, color: THREE.Color, delta: number) => void;
  filter?: (entity: Entity) => boolean;
  baseColor?: string;
  colorSource?: 'identity' | 'base'; 
}

export const InstancedActor = ({ 
  tag, 
  geometry, 
  material, 
  maxCount, 
  updateEntity, 
  filter, 
  baseColor = '#FFFFFF',
  colorSource = 'identity' 
}: InstancedActorProps) => {
  const meshRef = useRef<THREE.InstancedMesh>(null);

  // FIX: Initialize the color buffer!
  useLayoutEffect(() => {
    if (meshRef.current) {
        meshRef.current.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxCount * 3), 3);
    }
  }, [maxCount]);

  useFrame((state, delta) => {
    if (!meshRef.current || !ActiveEngine) return;

    const entities = ActiveEngine.registry.getByTag(tag);
    let count = 0;

    for (const entity of entities) {
      if (count >= maxCount) break;
      if (filter && !filter(entity)) continue;

      const transform = entity.getComponent<TransformComponent>('Transform');
      if (!transform) continue;

      // 1. Base Transform
      tempObj.position.set(transform.x, transform.y, 0);
      tempObj.rotation.set(0, 0, transform.rotation);
      tempObj.scale.set(transform.scale, transform.scale, 1);

      // 2. Color Logic
      const identity = entity.getComponent<IdentityComponent>('Identity');
      
      if (colorSource === 'identity' && identity) {
          tempColor.set(identity.variant); 
      } else {
          tempColor.set(baseColor); 
      }

      // 3. Custom Logic
      if (updateEntity) {
        updateEntity(entity, tempObj, tempColor, delta);
      }

      // 4. Apply
      tempObj.updateMatrix();
      meshRef.current.setMatrixAt(count, tempObj.matrix);
      
      // Safe to set color now because we initialized it in useLayoutEffect
      if (meshRef.current.instanceColor) {
        meshRef.current.setColorAt(count, tempColor);
      }
      
      count++;
    }

    meshRef.current.count = count;
    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor) meshRef.current.instanceColor.needsUpdate = true;
  });

  return (
    <instancedMesh 
      ref={meshRef} 
      args={[geometry, material, maxCount]} 
      frustumCulled={false}
    />
  );
};


=====================================
FILE: ./src/game/components/EnemyRenderer.tsx
=====================================
import { useMemo } from 'react';
import * as THREE from 'three';
import { Tag } from '../core/ecs/types';
import { GAME_THEME } from '../theme';
import { EnemyTypes } from '../config/Identifiers';
import { InstancedActor } from './common/InstancedActor';
import { addBarycentricCoordinates, createHunterSpear } from '../utils/GeometryUtils';
import { IdentityComponent } from '../data/IdentityComponent';
import { StateComponent } from '../data/StateComponent';

const vertexShader = `
  #ifndef USE_INSTANCING_COLOR
  attribute vec3 instanceColor;
  #endif
  attribute vec3 barycentric;
  varying vec3 vColor;
  varying vec3 vBarycentric;
  void main() {
    vColor = instanceColor;
    vBarycentric = barycentric;
    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
  }
`;

const fragmentShader = `
  varying vec3 vColor;
  varying vec3 vBarycentric;
  float edgeFactor(vec3 bary, float width) {
    vec3 d = fwidth(bary);
    vec3 a3 = smoothstep(vec3(0.0), d * width, bary);
    return min(min(a3.x, a3.y), a3.z);
  }
  void main() {
    float width = 2.0; 
    float edge = edgeFactor(vBarycentric, width);
    float glow = pow(1.0 - edge, 0.4); 
    vec3 coreColor = vColor;
    vec3 edgeColor = mix(vColor, vec3(1.0), 0.6);
    gl_FragColor = vec4(mix(coreColor, edgeColor, glow), 1.0);
  }
`;

export const EnemyRenderer = () => {
  const drillerGeo = useMemo(() => addBarycentricCoordinates(new THREE.ConeGeometry(0.3, 0.8, 4)), []);
  const kamikazeGeo = useMemo(() => addBarycentricCoordinates(new THREE.IcosahedronGeometry(0.6, 0)), []);
  const hunterGeo = useMemo(() => createHunterSpear(), []);

  const material = useMemo(() => new THREE.ShaderMaterial({
    vertexShader, fragmentShader, uniforms: {}, vertexColors: true,
    extensions: { derivatives: true }, side: THREE.DoubleSide,
  }), []);

  const chargeColor = useMemo(() => new THREE.Color(GAME_THEME.enemy.charge), []);

  // Shared Helper for "Materialization" visual
  const applySpawnEffect = (obj: THREE.Object3D, state?: StateComponent) => {
      if (state && state.current === 'SPAWN') {
          // Timer goes 1.5 -> 0.
          // Scale goes 0 -> 1.
          const progress = 1.0 - (state.timers.spawn / 1.5);
          const eased = Math.pow(progress, 2); // Ease out
          obj.scale.setScalar(eased);
          
          // Jitter position slightly for "Hologram" effect
          obj.position.x += (Math.random() - 0.5) * 0.1 * (1-progress);
      }
  };

  return (
    <>
      <InstancedActor 
        tag={Tag.ENEMY}
        geometry={drillerGeo}
        material={material}
        maxCount={500}
        baseColor={GAME_THEME.enemy.muncher}
        colorSource="base" 
        filter={e => e.getComponent<IdentityComponent>('Identity')?.variant === EnemyTypes.DRILLER}
        updateEntity={(e, obj, color, delta) => {
            const state = e.getComponent<StateComponent>('State');
            const speed = (state && state.current === 'DRILLING') ? 20.0 : 5.0;
            obj.position.z = 5.0;
            obj.rotateY(performance.now() * 0.001 * speed); 
            applySpawnEffect(obj, state);
        }}
      />

      <InstancedActor 
        tag={Tag.ENEMY}
        geometry={kamikazeGeo}
        material={material}
        maxCount={200}
        baseColor={GAME_THEME.enemy.kamikaze}
        colorSource="base"
        filter={e => e.getComponent<IdentityComponent>('Identity')?.variant === EnemyTypes.KAMIKAZE}
        updateEntity={(e, obj, color, delta) => {
            const state = e.getComponent<StateComponent>('State');
            const time = performance.now() * 0.001;
            obj.position.z = 5.0;
            obj.rotateX(time);
            obj.rotateY(time * 0.5);
            applySpawnEffect(obj, state);
        }}
      />

      <InstancedActor 
        tag={Tag.ENEMY}
        geometry={hunterGeo}
        material={material}
        maxCount={100}
        baseColor={GAME_THEME.enemy.hunter}
        colorSource="base"
        filter={e => e.getComponent<IdentityComponent>('Identity')?.variant === EnemyTypes.HUNTER}
        updateEntity={(e, obj, color, delta) => {
            const state = e.getComponent<StateComponent>('State');
            const time = performance.now() * 0.001;
            if (state && state.current === 'CHARGE') {
                const alpha = (Math.sin(time * 20) + 1) / 2;
                color.lerp(chargeColor, alpha);
            }
            const spin = state?.data?.spinAngle || 0;
            obj.position.z = 5.0;
            obj.rotateY(spin);
            applySpawnEffect(obj, state);
        }}
      />
    </>
  );
};


=====================================
FILE: ./src/game/components/GameDirector.tsx
=====================================
import { useFrame, useThree } from '@react-three/fiber';
import { useEffect, useRef } from 'react';
import { GameBootstrapper } from '../core/GameBootstrapper';
import { GameEngineCore } from '../core/GameEngine';
import { ServiceLocator } from '../core/ServiceLocator';
import { InputSystem } from '../systems/InputSystem';
import { PanelRegistry } from '../systems/PanelRegistrySystem';

export let ActiveEngine: GameEngineCore | null = null;

export const GameDirector = () => {
  const { viewport, size } = useThree();
  const engineRef = useRef<GameEngineCore | null>(null);

  useEffect(() => {
    const engine = GameBootstrapper();
    engineRef.current = engine;
    ActiveEngine = engine;

    engine.updateViewport(viewport.width, viewport.height, size.width, size.height);
    
    // Sync Bounds to InputSystem for clamping
    try {
        const input = ServiceLocator.getSystem<InputSystem>('InputSystem');
        input.updateBounds(viewport.width, viewport.height);
    } catch {}
    
    const refreshInterval = setInterval(() => {
        PanelRegistry.refreshAll();
    }, 500);

    let initialPolls = 0;
    const fastPoll = setInterval(() => {
        PanelRegistry.refreshAll();
        initialPolls++;
        if (initialPolls > 20) clearInterval(fastPoll); 
    }, 100);

    return () => {
      clearInterval(refreshInterval);
      clearInterval(fastPoll);
      engine.teardown();
      engineRef.current = null;
      ActiveEngine = null;
    };
  }, []); 

  useEffect(() => {
    if (engineRef.current) {
      engineRef.current.updateViewport(viewport.width, viewport.height, size.width, size.height);
      // Sync Bounds on resize
      try {
        const input = ServiceLocator.getSystem<InputSystem>('InputSystem');
        input.updateBounds(viewport.width, viewport.height);
      } catch {}
    }
  }, [viewport, size]);

  useFrame((state, delta) => {
    if (engineRef.current) {
      // We only update cursor from mouse here. Joystick is handled by internal event listeners.
      const input = ServiceLocator.getSystem<InputSystem>('InputSystem');
      
      // Only apply mouse if pointer is active/moving? 
      // R3F pointer is always (0,0) initially. 
      // Let InputSystem handle the priority (Mouse overrides Joystick if it moves).
      // We check if the pointer has actually moved? 
      // For now, let's just pass it. InputSystem separates "Joystick Mode".
      const x = (state.pointer.x * viewport.width) / 2;
      const y = (state.pointer.y * viewport.height) / 2;
      
      // Only push mouse updates if not using joystick to prevent fighting
      // Or rely on InputSystem's internal flag?
      // Let's call updateCursor. InputSystem will disable joystick mode if this is called.
      // Ideally we only call this if mouse actually moved.
      input.updateCursor(x, y);

      engineRef.current.update(delta, state.clock.elapsedTime);
    }
  });

  return null;
};


=====================================
FILE: ./src/game/components/index.ts
=====================================
export * from './BulletRenderer';
export * from './EnemyBulletRenderer';
export * from './EnemyRenderer';
export * from './GameDirector';
export * from './HunterChargeRenderer';
export * from './ParticleRenderer';
export * from './PlayerAvatar';
export * from './ProjectileTrails';
export * from './ScreenShaker';
export * from './GalleryStage';


=====================================
FILE: ./src/game/components/ScreenShaker.tsx
=====================================
import { useFrame, useThree } from '@react-three/fiber';
import { ServiceLocator } from '../core/ServiceLocator';
import { CameraSystem } from '../systems/CameraSystem';
import * as THREE from 'three';

export const ScreenShaker = () => {
  const { camera } = useThree();
  
  useFrame(() => {
    try {
        const sys = ServiceLocator.getSystem<CameraSystem>('CameraSystem');
        const { x, y, r } = sys.getShake();

        // Apply shake offset
        // Note: We assume camera stays at (0,0,100) base. 
        // If we add camera tracking later, we must add this offset to the target position.
        camera.position.x = x;
        camera.position.y = y;
        camera.rotation.z = r;
        
    } catch {
        // System not ready yet
    }
  });

  return null;
};


=====================================
FILE: ./src/game/components/data/HealthComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class HealthComponent extends Component {
  readonly _type = 'Health';

  public current: number;

  constructor(
    public max: number,
    public invincibilityTime: number = 0
  ) {
    super();
    this.current = max;
  }

  public get isDead(): boolean {
    return this.current <= 0;
  }

  public damage(amount: number) {
    // Invincibility handling will happen in Systems, this is just data
    this.current = Math.max(0, this.current - amount);
  }
  
  public heal(amount: number) {
      this.current = Math.min(this.max, this.current + amount);
  }
}


=====================================
FILE: ./src/game/components/data/MotionComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class MotionComponent extends Component {
  readonly _type = 'Motion';

  constructor(
    public vx: number = 0,
    public vy: number = 0,
    public friction: number = 0, // 0 = no friction, 1 = stop instantly
    public angularVelocity: number = 0
  ) {
    super();
  }
}


=====================================
FILE: ./src/game/components/data/IdentityComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

// This holds specific game logic identifiers (MUNCHER, HUNTER)
export class IdentityComponent extends Component {
  readonly _type = 'Identity';

  constructor(
    public variant: string // e.g. 'muncher', 'hunter', 'boss'
  ) {
    super();
  }
}


=====================================
FILE: ./src/game/components/data/StateComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class StateComponent extends Component {
  readonly _type = 'State';

  constructor(
    public current: string = 'IDLE',
    public timers: Record<string, number> = {},
    public data: Record<string, any> = {}
  ) {
    super();
  }

  public set(state: string) {
    this.current = state;
  }
}


=====================================
FILE: ./src/game/components/data/LifetimeComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

// Used for bullets and particles that die after N seconds
export class LifetimeComponent extends Component {
  readonly _type = 'Lifetime';

  constructor(
    public remaining: number, // Seconds
    public total: number
  ) {
    super();
  }
}


=====================================
FILE: ./src/game/components/data/TransformComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class TransformComponent extends Component {
  readonly _type = 'Transform';

  constructor(
    public x: number = 0,
    public y: number = 0,
    public rotation: number = 0,
    public scale: number = 1
  ) {
    super();
  }
}


=====================================
FILE: ./src/game/components/data/CombatComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class CombatComponent extends Component {
  readonly _type = 'Combat';

  constructor(
    public damage: number,
    public cooldown: number = 0, // Time until next attack
    public range: number = 0
  ) {
    super();
  }
}


=====================================
FILE: ./src/game/components/EffectsLayer.tsx
=====================================
import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';

export const EffectsLayer = () => {
  return (
    <EffectComposer disableNormalPass>
      {/* 
        BLOOM: Adds the "Neon" glow.
        luminanceThreshold: Only bright colors glow.
        intensity: How strong the glow is.
      */}
      <Bloom 
        luminanceThreshold={0.2} 
        mipmapBlur 
        intensity={1.5} 
        radius={0.4} 
      />
      
      {/* VIGNETTE: Darkens corners for focus */}
      <Vignette eskil={false} offset={0.1} darkness={0.5} />
    </EffectComposer>
  );
};


=====================================
FILE: ./src/game/components/ProjectileTrails.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { ActiveEngine } from './GameDirector';
import { Tag } from '../core/ecs/types';
import { TransformComponent } from '../components/data/TransformComponent';
import { MotionComponent } from '../components/data/MotionComponent';
import { LifetimeComponent } from '../components/data/LifetimeComponent';
import { GAME_THEME } from '../theme';

const MAX_TRAILS = 500; 

export const ProjectileTrails = () => {
  const meshRef = useRef<THREE.InstancedMesh>(null);
  const geometry = useMemo(() => {
      const geo = new THREE.PlaneGeometry(1, 1);
      geo.translate(0, 0.5, 0); 
      return geo;
  }, []);

  const shaderMaterial = useMemo(() => new THREE.ShaderMaterial({
    vertexShader: `
      #ifndef USE_INSTANCING_COLOR
      attribute vec3 instanceColor;
      #endif
      varying vec2 vUv;
      varying vec3 vColor;
      void main() {
        vUv = uv;
        vColor = instanceColor; 
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      varying vec2 vUv;
      varying vec3 vColor;
      void main() {
        float distFromCenter = abs(vUv.x - 0.5) * 2.0;
        float beam = 1.0 - pow(distFromCenter, 3.0);
        float tailDecay = 1.0 - vUv.y;
        tailDecay = pow(tailDecay, 2.0);
        float headFade = smoothstep(0.0, 0.1, vUv.y);
        float alpha = beam * tailDecay * headFade;
        vec3 finalColor = mix(vColor, vec3(1.0), beam * 0.8); 
        if (alpha < 0.01) discard;
        gl_FragColor = vec4(finalColor, alpha * 0.8);
      }
    `,
    uniforms: {}, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
  }), []);

  useFrame(() => {
    if (!meshRef.current || !ActiveEngine) return;
    const tempObj = new THREE.Object3D();
    const tempColor = new THREE.Color();
    let count = 0;
    const bullets = ActiveEngine.registry.getByTag(Tag.BULLET);

    for (const b of bullets) {
        if (count >= MAX_TRAILS) break;
        const t = b.getComponent<TransformComponent>('Transform');
        const m = b.getComponent<MotionComponent>('Motion');
        const life = b.getComponent<LifetimeComponent>('Lifetime');
        if (!t || !m || !life) continue;
        const isEnemy = b.hasTag(Tag.ENEMY);
        const trailWidth = isEnemy ? 1.0 : 0.4;
        const speed = Math.sqrt(m.vx * m.vx + m.vy * m.vy);
        const age = life.total - life.remaining;
        const maxLen = isEnemy ? 4.0 : 3.0; 
        const targetLength = Math.min(speed * 0.12, maxLen);
        const currentLength = Math.min(targetLength, age * 10.0); 
        tempObj.position.set(t.x, t.y, -0.2); 
        tempObj.rotation.z = t.rotation + (Math.PI / 2);
        tempObj.scale.set(trailWidth, currentLength, 1);
        const colorHex = isEnemy ? GAME_THEME.bullet.hunter : GAME_THEME.bullet.trail;
        tempColor.set(colorHex);
        tempObj.updateMatrix();
        meshRef.current.setMatrixAt(count, tempObj.matrix);
        meshRef.current.setColorAt(count, tempColor);
        count++;
    }
    meshRef.current.count = count;
    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor) meshRef.current.instanceColor.needsUpdate = true;
  });

  return (
    <instancedMesh ref={meshRef} args={[geometry, shaderMaterial, MAX_TRAILS]} renderOrder={-1} />
  );
};


=====================================
FILE: ./src/game/hooks/usePanelRegistry.ts
=====================================
import { useEffect, useRef } from 'react';
import { useGameStore } from '../store/useGameStore';
import { PanelRegistry } from '../systems/PanelRegistrySystem';

export const usePanelRegistry = (id: string) => {
  const elementRef = useRef<HTMLDivElement>(null);
  
  const registerPanel = useGameStore((state) => state.registerPanel);
  const unregisterPanel = useGameStore((state) => state.unregisterPanel);

  useEffect(() => {
    const el = elementRef.current;
    if (!el) return;

    // 1. Register Logic (Health/Store)
    registerPanel(id, el);

    // 2. Register Spatial (Singleton)
    // This works immediately, even if game hasn't started
    PanelRegistry.register(id, el);

    // 3. Resize Observer
    const observer = new ResizeObserver(() => {
        PanelRegistry.refreshSingle(id);
    });
    observer.observe(el);

    return () => {
      observer.disconnect();
      unregisterPanel(id);
      PanelRegistry.unregister(id);
    };
  }, [id, registerPanel, unregisterPanel]);

  return elementRef;
};


=====================================
FILE: ./src/game/hooks/useTransientRef.ts
=====================================
import { useEffect, useRef } from 'react';
import { useGameStore } from '../store/useGameStore';

/**
 * Registers a DOM element to the store so the GameLoop can write to it directly.
 * Useful for Score, Health, and Timers to avoid React Re-renders.
 */
export const useTransientRef = (id: string, type: 'text' | 'width' | 'css-var') => {
  // We use a generic HTMLSpanElement, but it works for divs too
  const ref = useRef<any>(null);
  const register = useGameStore(s => s.registerTransientElement);
  const unregister = useGameStore(s => s.unregisterTransientElement);

  useEffect(() => {
    if (ref.current) {
      register(id, ref.current, type);
    }
    return () => unregister(id);
  }, [id, type, register, unregister]);

  return ref;
};


=====================================
FILE: ./src/game/theme.ts
=====================================
export const GAME_THEME = {
  turret: {
    base: '#78F654',
    glow: '#C2FE9A',
    repair: '#00F0FF',
  },
  bullet: {
    plasma: '#FFFFFF',
    trail: '#78F654',
    hunter: '#F7D277', // Specific color for Hunter shots
  },
  enemy: {
    muncher: '#9E4EA5',
    kamikaze: '#FF003C',
    hunter: '#F7D277',
    charge: '#FFFFFF',  // Telegraph flash
  },
  hud: {
    text: '#78F654',
    warning: '#FF003C',
  },
  vfx: {
    spark: '#FFFFFF',
    damage: '#FF003C',
    heal: '#00F0FF',
    clash: '#F7D277',
  }
};


=====================================
FILE: ./src/game/events/GameEvents.ts
=====================================
export enum GameEvents {
  // --- COMBAT ---
  PLAYER_FIRED = 'PLAYER_FIRED',
  PLAYER_HIT = 'PLAYER_HIT',
  ENEMY_SPAWNED = 'ENEMY_SPAWNED',
  ENEMY_DAMAGED = 'ENEMY_DAMAGED',
  ENEMY_DESTROYED = 'ENEMY_DESTROYED',
  PROJECTILE_CLASH = 'PROJECTILE_CLASH',
  
  // --- PANEL ---
  PANEL_DAMAGED = 'PANEL_DAMAGED',
  PANEL_HEALED = 'PANEL_HEALED',
  PANEL_DESTROYED = 'PANEL_DESTROYED',
  
  // --- SYSTEM ---
  GAME_START = 'GAME_START',
  GAME_OVER = 'GAME_OVER',
  THREAT_LEVEL_UP = 'THREAT_LEVEL_UP',
  UPGRADE_SELECTED = 'UPGRADE_SELECTED',
  ZEN_MODE_ENABLED = 'ZEN_MODE_ENABLED',
  
  // --- DEBUG ---
  DEBUG_SPAWN = 'DEBUG_SPAWN', // NEW
  
  // --- VISUAL ---
  TRAUMA_ADDED = 'TRAUMA_ADDED',
  SCENE_READY = 'SCENE_READY'
}

export interface GameEventPayloads {
  [GameEvents.PLAYER_FIRED]: { x: number; y: number };
  [GameEvents.PLAYER_HIT]: { damage: number };
  [GameEvents.ENEMY_SPAWNED]: { type: string; id: number };
  [GameEvents.ENEMY_DAMAGED]: { id: number; damage: number; type: string };
  [GameEvents.ENEMY_DESTROYED]: { id: number; type: string; x: number; y: number };
  [GameEvents.PROJECTILE_CLASH]: { x: number; y: number };
  
  [GameEvents.PANEL_DAMAGED]: { id: string; amount: number; currentHealth: number };
  [GameEvents.PANEL_HEALED]: { id: string; amount: number };
  [GameEvents.PANEL_DESTROYED]: { id: string };
  
  [GameEvents.GAME_START]: null;
  [GameEvents.GAME_OVER]: { score: number };
  [GameEvents.THREAT_LEVEL_UP]: { level: number };
  [GameEvents.UPGRADE_SELECTED]: { option: string };
  [GameEvents.ZEN_MODE_ENABLED]: null;
  
  [GameEvents.DEBUG_SPAWN]: { type: string; count: number }; // NEW
  
  [GameEvents.TRAUMA_ADDED]: { amount: number };
  [GameEvents.SCENE_READY]: null;
}


=====================================
FILE: ./src/game/events/GameEventBus.ts
=====================================
import { GameEvents, GameEventPayloads } from './GameEvents';

type Handler<T extends GameEvents> = (payload: GameEventPayloads[T]) => void;

class GameEventBusController {
  // Use a mapped type for strict safety
  private listeners: { [K in GameEvents]?: Handler<K>[] } = {};
  
  private history: { event: string; payload: any; timestamp: number }[] = [];
  private readonly MAX_HISTORY = 50;

  public subscribe<T extends GameEvents>(event: T, handler: Handler<T>): () => void {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    // Force cast to generic array to satisfy TS compiler index signature
    (this.listeners[event] as Handler<T>[]).push(handler);

    return () => {
      if (!this.listeners[event]) return;
      this.listeners[event] = (this.listeners[event] as Handler<T>[]).filter(h => h !== handler) as any;
    };
  }

  public emit<T extends GameEvents>(event: T, payload: GameEventPayloads[T]): void {
    // 1. Log History (Debug only)
    if (process.env.NODE_ENV === 'development') {
        this.history.push({ event, payload, timestamp: Date.now() });
        if (this.history.length > this.MAX_HISTORY) this.history.shift();
    }

    // 2. Dispatch
    const handlers = this.listeners[event];
    if (handlers) {
        handlers.forEach(handler => handler(payload));
    }
  }

  public clear(): void {
    this.listeners = {};
    this.history = [];
  }
}

export const GameEventBus = new GameEventBusController();


=====================================
FILE: ./src/game/systems/CollisionSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { PhysicsSystem } from './PhysicsSystem';
import { EntityRegistry } from '../core/ecs/EntityRegistry';
import { Tag } from '../core/ecs/types';
import { TransformComponent } from '../components/data/TransformComponent';
import { HealthComponent } from '../components/data/HealthComponent';
import { IdentityComponent } from '../components/data/IdentityComponent';
import { StateComponent } from '../components/data/StateComponent';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { EnemyTypes } from '../config/Identifiers';
import { GameStateSystem } from './GameStateSystem';
import { IEntitySpawner } from '../core/interfaces';

export class CollisionSystem implements IGameSystem {
  private physicsSystem!: PhysicsSystem;
  private gameSystem!: GameStateSystem;
  private registry!: EntityRegistry;
  private spawner!: IEntitySpawner;
  private locator!: IServiceLocator;

  setup(locator: IServiceLocator): void {
    this.locator = locator;
    this.physicsSystem = locator.getSystem<PhysicsSystem>('PhysicsSystem');
    this.gameSystem = locator.getSystem<GameStateSystem>('GameStateSystem');
    this.registry = locator.getRegistry() as EntityRegistry;
    this.spawner = locator.getSpawner();
  }

  update(delta: number, time: number): void {
    const spatial = this.physicsSystem.spatialGrid;
    const cursor = this.locator.getInputService().getCursor();

    this.handleBulletCollisions(spatial);
    this.handleProjectileClash(spatial);

    const bullets = this.registry.getByTag(Tag.BULLET);
    for (const b of bullets) {
        if (!b.hasTag(Tag.ENEMY)) continue;
        const bPos = b.getComponent<TransformComponent>('Transform');
        if (!bPos) continue;
        const dx = bPos.x - cursor.x;
        const dy = bPos.y - cursor.y;
        if (dx*dx + dy*dy < 0.25) { 
            this.registry.destroyEntity(b.id);
            this.damagePlayer(10); 
            this.spawner.spawnParticle(bPos.x, bPos.y, '#FF003C', 0, 0, 0.5);
        }
    }

    const players = this.registry.getByTag(Tag.PLAYER);
    const player = players[0];
    
    if (player && player.active) {
        const pPos = player.getComponent<TransformComponent>('Transform');
        if (pPos) {
            const nearby = spatial.query(pPos.x, pPos.y, 1.0);
            for (const id of nearby) {
                const enemy = this.registry.getEntity(id as any);
                
                // NEW: Ignore if spawning
                if (!enemy || !enemy.active || !enemy.hasTag(Tag.ENEMY)) continue;
                const state = enemy.getComponent<StateComponent>('State');
                if (state && state.current === 'SPAWN') continue;

                if (enemy.hasTag(Tag.BULLET)) continue; 

                const ePos = enemy.getComponent<TransformComponent>('Transform');
                if (!ePos) continue;

                const dx = pPos.x - ePos.x;
                const dy = pPos.y - ePos.y;
                
                if (dx*dx + dy*dy < 0.36) {
                    this.handleBodyCollision(enemy, ePos.x, ePos.y);
                }
            }
        }
    }
  }

  private handleProjectileClash(spatial: any) {
      const playerBullets = this.registry.getByTag(Tag.BULLET).filter(b => !b.hasTag(Tag.ENEMY));
      for (const pb of playerBullets) {
          const pPos = pb.getComponent<TransformComponent>('Transform');
          if (!pPos) continue;
          const nearby = spatial.query(pPos.x, pPos.y, 1.0);
          for (const id of nearby) {
              const target = this.registry.getEntity(id as any);
              if (!target || !target.active || !target.hasTag(Tag.BULLET) || !target.hasTag(Tag.ENEMY)) continue;
              const tPos = target.getComponent<TransformComponent>('Transform');
              if (!tPos) continue;
              const dx = pPos.x - tPos.x;
              const dy = pPos.y - tPos.y;
              if (dx*dx + dy*dy < 1.0) {
                  this.registry.destroyEntity(pb.id);
                  this.registry.destroyEntity(target.id);
                  GameEventBus.emit(GameEvents.PROJECTILE_CLASH, { x: tPos.x, y: tPos.y });
                  this.spawner.spawnParticle(tPos.x, tPos.y, '#F7D277', 0, 0, 0.5);
                  break; 
              }
          }
      }
  }

  private handleBodyCollision(enemy: any, x: number, y: number) {
      const identity = enemy.getComponent<IdentityComponent>('Identity');
      const type = identity ? identity.variant : 'unknown';
      if (type === EnemyTypes.KAMIKAZE) {
          this.damagePlayer(25); 
          this.spawnExplosion(x, y, '#FF003C');
      } else {
          this.damagePlayer(10);
          this.spawnExplosion(x, y, '#9E4EA5');
      }
      this.registry.destroyEntity(enemy.id);
  }

  private spawnExplosion(x: number, y: number, color: string) {
      for(let i=0; i<8; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 15;
          this.spawner.spawnParticle(x, y, color, Math.cos(angle)*speed, Math.sin(angle)*speed, 0.8);
      }
  }

  private damagePlayer(amount: number) {
      this.gameSystem.damagePlayer(amount);
      GameEventBus.emit(GameEvents.PLAYER_HIT, { damage: amount });
  }

  private handleBulletCollisions(spatial: any) {
    const bullets = this.registry.getByTag(Tag.BULLET);
    for (const b of bullets) {
        if (b.hasTag(Tag.ENEMY)) continue; 
        const bPos = b.getComponent<TransformComponent>('Transform');
        if (!bPos) continue;

        const candidates = spatial.query(bPos.x, bPos.y, 1.0);
        for (const targetId of candidates) {
            const target = this.registry.getEntity(targetId as any);
            
            // NEW: Ignore if spawning
            if (!target || !target.active || !target.hasTag(Tag.ENEMY) || target.hasTag(Tag.BULLET)) continue;
            const state = target.getComponent<StateComponent>('State');
            if (state && state.current === 'SPAWN') continue;
            
            const dx = bPos.x - target.getComponent<TransformComponent>('Transform')!.x;
            const dy = bPos.y - target.getComponent<TransformComponent>('Transform')!.y;

            if (dx*dx + dy*dy < 0.49) { 
                this.registry.destroyEntity(b.id);
                const hp = target.getComponent<HealthComponent>('Health');
                if (hp) {
                    hp.damage(1);
                    GameEventBus.emit(GameEvents.ENEMY_DAMAGED, { 
                        id: target.id as number, damage: 1, type: 'unknown' 
                    });
                }
                this.spawner.spawnParticle(bPos.x, bPos.y, '#FFF', 0, 0, 0.2);
                break;
            }
        }
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/game/systems/UISyncSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { useGameStore } from '../store/useGameStore';
import { GameStateSystem } from './GameStateSystem';
import { PanelRegistry } from './PanelRegistrySystem';
import { InteractionSystem } from './InteractionSystem';

export class UISyncSystem implements IGameSystem {
  private gameSystem!: GameStateSystem;
  private interactionSystem!: InteractionSystem;
  
  private readonly SYNC_INTERVAL = 0.1;
  private timeSinceLastSync = 0;

  setup(locator: IServiceLocator): void {
    this.gameSystem = locator.getSystem<GameStateSystem>('GameStateSystem');
    this.interactionSystem = locator.getSystem<InteractionSystem>('InteractionSystem');
  }

  update(delta: number, time: number): void {
    this.timeSinceLastSync += delta;
    if (this.timeSinceLastSync < this.SYNC_INTERVAL) return;
    this.timeSinceLastSync = 0;
    this.sync();
  }

  teardown(): void {}

  private sync() {
    const store = useGameStore.getState();
    
    // 1. FAST PATH: Direct DOM Updates (Transient)
    // This updates the text numbers instantly without React rendering
    const formattedScore = this.gameSystem.score.toString().padStart(4, '0');
    store.updateTransient('score-display', formattedScore);
    
    // 2. SLOW PATH: React State Sync
    // We MUST check if XP or Score changed so the IdentityHUD (React component) updates the SVG rings.
    const shouldSyncReact = 
        store.xp !== this.gameSystem.xp || 
        store.score !== this.gameSystem.score ||
        store.level !== this.gameSystem.level ||
        store.upgradePoints !== this.gameSystem.upgradePoints ||
        store.interactionTarget !== this.interactionSystem.hoveringPanelId ||
        Math.abs(store.systemIntegrity - PanelRegistry.systemIntegrity) > 1.0; 

    if (shouldSyncReact) {
        store.syncGameState({
            level: this.gameSystem.level,
            xp: this.gameSystem.xp,                // Fix: Sync XP
            score: this.gameSystem.score,          // Fix: Sync Score (for HUD rings/logic)
            xpToNextLevel: this.gameSystem.xpToNextLevel,
            upgradePoints: this.gameSystem.upgradePoints,
            activeUpgrades: { ...this.gameSystem.activeUpgrades },
            systemIntegrity: PanelRegistry.systemIntegrity,
            interactionTarget: this.interactionSystem.hoveringPanelId 
        });
    }

    // Sync Panels
    const uiPanels: Record<string, any> = {};
    const panels = PanelRegistry.getAllPanels();
    
    for(const p of panels) {
        uiPanels[p.id] = {
            id: p.id,
            health: p.health,
            isDestroyed: p.isDestroyed
        };
    }
    
    store.syncPanels(uiPanels);
  }
}


=====================================
FILE: ./src/game/systems/InteractionSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IEntitySpawner } from '../core/interfaces';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { PanelRegistry } from './PanelRegistrySystem'; 
import { GameStateSystem } from './GameStateSystem'; 

export type RepairState = 'IDLE' | 'HEALING' | 'REBOOTING';

export class InteractionSystem implements IGameSystem {
  public repairState: RepairState = 'IDLE';
  public hoveringPanelId: string | null = null;
  
  private lastRepairTime = 0;
  private readonly REPAIR_RATE = 0.05;
  private locator!: IServiceLocator;
  private spawner!: IEntitySpawner;
  private gameSystem!: GameStateSystem; 

  setup(locator: IServiceLocator): void {
    this.locator = locator;
    this.spawner = locator.getSpawner();
    this.gameSystem = locator.getSystem<GameStateSystem>('GameStateSystem');
  }

  update(delta: number, time: number): void {
    this.repairState = 'IDLE';
    this.hoveringPanelId = null;
    
    if (this.gameSystem.isGameOver) return; 
    
    const cursor = this.locator.getInputService().getCursor();
    
    if (this.gameSystem.playerHealth <= 0) {
        this.handleRevival(cursor, time);
        if (this.repairState !== 'REBOOTING' && this.gameSystem.playerRebootProgress > 0) {
            this.gameSystem.decayReboot(delta * 15);
        }
        return; 
    }

    this.handlePanelRepair(cursor, time);
    
    if (time > this.lastRepairTime + this.REPAIR_RATE) {
        const panels = PanelRegistry.getAllPanels();
        for (const p of panels) {
            if (p.isDestroyed && p.health > 0) {
                 PanelRegistry.decayPanel(p.id, 5);
            }
        }
    }
  }

  teardown(): void {}

  private handleRevival(cursor: {x: number, y: number}, time: number) {
    const rect = PanelRegistry.getPanelRect('identity');
    if (!rect) return;
    const padding = 2.0; 
    const isHovering = 
        cursor.x >= rect.left - padding && 
        cursor.x <= rect.right + padding && 
        cursor.y >= rect.bottom - padding && 
        cursor.y <= rect.top + padding;

    if (isHovering) {
        this.hoveringPanelId = 'identity';
        this.repairState = 'REBOOTING';
        if (time > this.lastRepairTime + this.REPAIR_RATE) {
            this.gameSystem.tickReboot(2.5); // Charge Speed
            this.lastRepairTime = time;
            if (Math.random() > 0.3) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 2;
                this.spawner.spawnParticle(cursor.x, cursor.y, '#9E4EA5', Math.cos(angle)*speed, Math.sin(angle)*speed, 0.5);
            }
        }
    }
  }

  private handlePanelRepair(cursor: {x: number, y: number}, time: number) {
    const panels = PanelRegistry.getAllPanels();
    for (const p of panels) {
      if (cursor.x >= p.left && cursor.x <= p.right && cursor.y >= p.bottom && cursor.y <= p.top) {
        this.hoveringPanelId = p.id;
        
        if (!p.isDestroyed && p.health >= 1000) continue;

        this.repairState = p.isDestroyed ? 'REBOOTING' : 'HEALING';

        if (time > this.lastRepairTime + this.REPAIR_RATE) {
            PanelRegistry.healPanel(p.id, 10);
            this.lastRepairTime = time;
            if (!p.isDestroyed) GameEventBus.emit(GameEvents.PANEL_HEALED, { id: p.id, amount: 10 });
            if (Math.random() > 0.3) {
                const color = p.isDestroyed ? '#9E4EA5' : '#00F0FF'; 
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 2;
                this.spawner.spawnParticle(cursor.x, cursor.y, color, Math.cos(angle)*speed, Math.sin(angle)*speed, 0.5);
            }
        }
        break; 
      }
    }
  }
}


=====================================
FILE: ./src/game/systems/CameraSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { noise } from '../utils/Noise';

export class CameraSystem implements IGameSystem {
  public trauma = 0;
  private time = 0;
  
  // Configuration
  private readonly DECAY_RATE = 0.8; 
  private readonly MAX_OFFSET = 1.5; 
  private readonly MAX_ROTATION = 0.05; 
  private readonly NOISE_SPEED = 15.0; 

  setup(locator: IServiceLocator): void {
    this.setupListeners();
  }

  update(delta: number, time: number): void {
    this.time += delta;
    if (this.trauma > 0) {
      this.trauma = Math.max(0, this.trauma - (delta * this.DECAY_RATE));
    }
  }

  teardown(): void {}

  private setupListeners() {
    // MINOR SHAKE: Standard Player Hit (Collision)
    GameEventBus.subscribe(GameEvents.PLAYER_HIT, (p) => {
        // Hunter bullets/Munchers deal 10 dmg. Kamikazes deal 25 dmg.
        // FIX: Reduced minor hit trauma from 0.35 to 0.2 for tighter, shorter shake.
        const intensity = p.damage > 10 ? 0.6 : 0.2; 
        this.addTrauma(intensity);
    });

    // MAJOR SHAKE: Panel Destruction
    GameEventBus.subscribe(GameEvents.PANEL_DESTROYED, () => this.addTrauma(0.7));
    
    // CATASTROPHIC: Game Over
    GameEventBus.subscribe(GameEvents.GAME_OVER, () => this.addTrauma(1.0));
  }

  public addTrauma(amount: number) {
    this.trauma = Math.min(1.0, this.trauma + amount);
  }

  public getShake() {
    if (this.trauma <= 0) return { x: 0, y: 0, r: 0 };

    const shake = this.trauma * this.trauma;
    
    const x = this.MAX_OFFSET * shake * noise(this.time * this.NOISE_SPEED);
    const y = this.MAX_OFFSET * shake * noise((this.time * this.NOISE_SPEED) + 100);
    const r = this.MAX_ROTATION * shake * noise((this.time * this.NOISE_SPEED) + 200);

    return { x, y, r };
  }
}


=====================================
FILE: ./src/game/systems/PlayerSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IEntitySpawner } from '../core/interfaces';
import { EntityRegistry } from '../core/ecs/EntityRegistry';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { PLAYER_CONFIG } from '../config/PlayerConfig';
import { Tag } from '../core/ecs/types';
import { TransformComponent } from '../components/data/TransformComponent';
import { StateComponent } from '../components/data/StateComponent';
import { InteractionSystem } from './InteractionSystem';
import { GameStateSystem } from './GameStateSystem';

export class PlayerSystem implements IGameSystem {
  private lastFireTime = 0;
  private gameSystem!: GameStateSystem;
  private registry!: EntityRegistry;
  private spawner!: IEntitySpawner;
  private locator!: IServiceLocator;

  setup(locator: IServiceLocator): void {
    this.locator = locator;
    this.gameSystem = locator.getSystem<GameStateSystem>('GameStateSystem');
    this.registry = locator.getRegistry() as EntityRegistry;
    this.spawner = locator.getSpawner();
    this.setupListeners();
  }

  update(delta: number, time: number): void {
    if (this.gameSystem.isGameOver || this.gameSystem.playerHealth <= 0) return;

    const players = this.registry.getByTag(Tag.PLAYER);
    const playerEntity = players[0]; 
    if (!playerEntity) return;

    const cursor = this.locator.getInputService().getCursor();
    const transform = playerEntity.getComponent<TransformComponent>('Transform');
    if (transform) {
        transform.x = cursor.x;
        transform.y = cursor.y;
    }

    const stateComp = playerEntity.getComponent<StateComponent>('State');
    if (stateComp) {
        try {
            const interact = this.locator.getSystem<InteractionSystem>('InteractionSystem');
            if (interact && interact.repairState !== 'IDLE') {
                stateComp.current = 'REBOOTING';
            } else {
                stateComp.current = 'ACTIVE';
            }
        } catch {
            stateComp.current = 'ACTIVE';
        }
    }

    if (stateComp && (stateComp.current === 'ACTIVE' || stateComp.current === 'REBOOTING')) {
        const upgrades = this.gameSystem.activeUpgrades;
        const rapidLevel = upgrades['RAPID_FIRE'] || 0;
        const currentFireRate = PLAYER_CONFIG.fireRate * Math.pow(0.85, rapidLevel);

        if (time > this.lastFireTime + currentFireRate) {
            this.attemptAutoFire(time, playerEntity);
        }
    }
  }

  teardown(): void {}

  private setupListeners() {
    GameEventBus.subscribe(GameEvents.ENEMY_DESTROYED, () => {
      this.gameSystem.addScore(1);
      this.gameSystem.addXp(10);
    });
  }

  private attemptAutoFire(time: number, player: any) {
    const cursor = this.locator.getInputService().getCursor();
    const enemies = this.registry.getByTag(Tag.ENEMY);
    let nearestDist = Infinity;
    const RANGE = 12; 
    let targetEnemy: any = null;

    for (const e of enemies) {
      if (!e.active) continue;
      const t = e.getComponent<TransformComponent>('Transform');
      if (!t) continue;
      const dx = t.x - cursor.x;
      const dy = t.y - cursor.y;
      const dist = dx*dx + dy*dy; 
      if (dist < (RANGE * RANGE) && dist < nearestDist) {
          nearestDist = dist;
          targetEnemy = e;
      }
    }

    if (targetEnemy) {
      const upgrades = this.gameSystem.activeUpgrades;
      const multiLevel = upgrades['MULTI_SHOT'] || 0;
      const projectileCount = 1 + (multiLevel * 2);
      const spreadAngle = 0.2; 
      
      const tPos = targetEnemy.getComponent<TransformComponent>('Transform')!;
      const dx = tPos.x - cursor.x;
      const dy = tPos.y - cursor.y;
      const baseAngle = Math.atan2(dy, dx);
      const startAngle = baseAngle - ((projectileCount - 1) * spreadAngle) / 2;

      for (let i = 0; i < projectileCount; i++) {
          const angle = startAngle + (i * spreadAngle);
          const vx = Math.cos(angle) * PLAYER_CONFIG.bulletSpeed;
          const vy = Math.sin(angle) * PLAYER_CONFIG.bulletSpeed;

          this.spawner.spawnBullet(
              cursor.x, cursor.y, vx, vy, false, 
              PLAYER_CONFIG.bulletLife, PLAYER_CONFIG.bulletRadius
          );
      }
      
      GameEventBus.emit(GameEvents.PLAYER_FIRED, { x: cursor.x, y: cursor.y });
      this.lastFireTime = time;
    }
  }
}


=====================================
FILE: ./src/game/systems/TimeSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { WorldConfig } from '../config/WorldConfig';
import { useStore } from '@/core/store/useStore';

export class TimeSystem implements IGameSystem {
  public timeScale: number = 1.0;
  public elapsedTime: number = 0;
  public delta: number = 0;
  public isPaused: boolean = false;
  
  // FPS Counting
  public fps: number = 60;
  private frames: number = 0;
  private lastFpsTime: number = 0;
  
  private freezeTimer: number = 0;

  setup(locator: IServiceLocator): void {
    this.reset();
  }

  update(rawDelta: number, rawTime: number): void {
    // 1. Calculate FPS (Real-time)
    this.frames++;
    if (rawTime >= this.lastFpsTime + 1.0) {
        this.fps = this.frames;
        this.frames = 0;
        this.lastFpsTime = rawTime;
    }

    // 2. Handle Hit Stop (Freeze)
    if (this.freezeTimer > 0) {
        this.freezeTimer -= rawDelta;
        this.delta = 0; 
        return;
    }

    if (this.isPaused) {
      this.delta = 0;
      return;
    }

    // 3. Debug Time Dilation
    // We multiply the raw delta by the debug timeScale
    const debugScale = useStore.getState().debugFlags.timeScale;

    // 4. Normal Time Processing
    const safeDelta = Math.min(rawDelta, WorldConfig.time.maxDelta);
    this.delta = safeDelta * this.timeScale * debugScale;
    this.elapsedTime += this.delta;
  }

  teardown(): void {
    this.reset();
  }

  private reset() {
    this.timeScale = 1.0;
    this.elapsedTime = 0;
    this.delta = 0;
    this.isPaused = false;
    this.freezeTimer = 0;
    this.frames = 0;
    this.lastFpsTime = 0;
    this.fps = 60;
  }
  
  public setScale(scale: number, duration?: number) {
    this.timeScale = scale;
    if (duration) {
      setTimeout(() => {
        this.timeScale = 1.0;
      }, duration * 1000);
    }
  }

  public freeze(duration: number) {
      this.freezeTimer = duration;
  }
}


=====================================
FILE: ./src/game/systems/FXManager.ts
=====================================
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { ServiceLocator } from '../core/ServiceLocator';
import { TimeSystem } from './TimeSystem';
import { CameraSystem } from './CameraSystem';

class FXManagerController {
  private initialized = false;
  
  public init() {
    if (this.initialized) return;
    
    // --- HIT STOP & TRAUMA EVENTS ---
    
    // 1. PANEL DESTROYED (Major Impact)
    GameEventBus.subscribe(GameEvents.PANEL_DESTROYED, () => {
        this.addTrauma(0.7);
        this.triggerHitStop(0.15); // 150ms Freeze
    });
    
    // 2. PLAYER HIT (Medium Impact)
    GameEventBus.subscribe(GameEvents.PLAYER_HIT, (p) => {
        const isBig = p.damage > 10;
        this.addTrauma(isBig ? 0.6 : 0.3);
        if (isBig) this.triggerHitStop(0.1); // 100ms Freeze on big hits
    });
    
    // 3. GAME OVER (Catastrophic)
    GameEventBus.subscribe(GameEvents.GAME_OVER, () => {
        this.addTrauma(1.0);
        this.triggerHitStop(0.5); // 500ms Freeze
    });

    // 4. BOSS DEATH (Placeholder Comment)
    // GameEventBus.subscribe(GameEvents.BOSS_DEATH, () => {
    //    this.addTrauma(1.0);
    //    this.triggerHitStop(1.0); // 1 Second dramatic pause
    // });
    
    this.initialized = true;
  }

  public addTrauma(amount: number) {
    try {
        const cam = ServiceLocator.getSystem<CameraSystem>('CameraSystem');
        cam.addTrauma(amount);
    } catch {}
  }

  private triggerHitStop(duration: number) {
    try {
        const time = ServiceLocator.getSystem<TimeSystem>('TimeSystem');
        time.freeze(duration);
    } catch {}
  }
}

export const FXManager = new FXManagerController();


=====================================
FILE: ./src/game/systems/InputSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IInputService } from '../core/interfaces';

export class InputSystem implements IGameSystem, IInputService {
  private _cursor = { x: 0, y: 0 };
  private _virtualVector = { x: 0, y: 0 };
  private _usingJoystick = false;
  
  // Bounds for clamping (updated by GameEngine/ViewportHelper)
  private _bounds = { width: 30, height: 20 }; 

  setup(locator: IServiceLocator): void {
    // Initial setup
  }

  update(delta: number, time: number): void {
    // If using joystick, move the cursor based on the vector
    if (this._usingJoystick) {
        const speed = 30.0; // Virtual cursor speed
        
        this._cursor.x += this._virtualVector.x * speed * delta;
        this._cursor.y += this._virtualVector.y * speed * delta;

        // Clamp to logical world bounds (approximate, refined by viewport)
        const halfW = this._bounds.width / 2;
        const halfH = this._bounds.height / 2;
        
        this._cursor.x = Math.max(-halfW, Math.min(halfW, this._cursor.x));
        this._cursor.y = Math.max(-halfH, Math.min(halfH, this._cursor.y));
    }
  }

  teardown(): void {}

  // --- IInputService Implementation ---
  
  public updateCursor(x: number, y: number) {
    // Mouse movement overrides joystick
    this._usingJoystick = false;
    this._cursor.x = x;
    this._cursor.y = y;
  }

  public setJoystickVector(x: number, y: number) {
      if (x === 0 && y === 0) {
          this._usingJoystick = false;
      } else {
          this._usingJoystick = true;
      }
      this._virtualVector.x = x;
      this._virtualVector.y = y;
  }
  
  public updateBounds(width: number, height: number) {
      this._bounds.width = width;
      this._bounds.height = height;
  }

  public getCursor() {
    return this._cursor;
  }

  public isPressed(action: string): boolean {
    // Placeholder for future button mapping
    return false;
  }
}


=====================================
FILE: ./src/game/systems/PanelRegistrySystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { ViewportHelper, WorldRect } from '../utils/ViewportHelper';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { useStore } from '@/core/store/useStore';

const MAX_PANEL_HEALTH = 1000;

interface PanelState {
  health: number;
  isDestroyed: boolean;
}

class PanelRegistrySystemClass implements IGameSystem {
  private panelRects = new Map<string, WorldRect>();
  private observedElements = new Map<string, HTMLElement>();
  private panelStates = new Map<string, PanelState>();

  public systemIntegrity: number = 100;

  setup(locator: IServiceLocator): void {
    this.resetLogic();
    this.refreshAll();
  }

  update(delta: number, time: number): void {
    // Passive
  }

  teardown(): void {}

  public resetLogic() {
    for (const id of this.observedElements.keys()) {
        this.panelStates.set(id, { health: MAX_PANEL_HEALTH, isDestroyed: false });
    }
    this.calculateIntegrity();
  }

  // --- ACTIONS ---

  public damagePanel(id: string, amount: number) {
    if (useStore.getState().debugFlags.panelGodMode) return;

    const state = this.panelStates.get(id);
    if (!state || state.isDestroyed) return;

    state.health = Math.max(0, state.health - amount);
    
    if (state.health <= 0 && !state.isDestroyed) {
        state.isDestroyed = true;
        GameEventBus.emit(GameEvents.PANEL_DESTROYED, { id });
    } else {
        GameEventBus.emit(GameEvents.PANEL_DAMAGED, { id, amount, currentHealth: state.health });
    }
    
    this.calculateIntegrity();
  }

  public healPanel(id: string, amount: number) {
    const state = this.panelStates.get(id);
    if (!state) return;

    const wasDestroyed = state.isDestroyed;
    state.health = Math.min(MAX_PANEL_HEALTH, state.health + amount);
    
    if (wasDestroyed && state.health >= MAX_PANEL_HEALTH) {
        state.isDestroyed = false;
        state.health = 500; 
    }
    
    this.calculateIntegrity();
  }

  public decayPanel(id: string, amount: number) {
     const state = this.panelStates.get(id);
     if (!state || !state.isDestroyed) return;
     state.health = Math.max(0, state.health - amount);
  }

  // NEW: Forcefully destroy everything for FORCE_CRASH
  public destroyAll() {
      for (const [id, state] of this.panelStates) {
          state.health = 0;
          state.isDestroyed = true;
          GameEventBus.emit(GameEvents.PANEL_DESTROYED, { id });
      }
      this.calculateIntegrity();
  }

  private calculateIntegrity() {
    let current = 0;
    let max = 0;
    for (const state of this.panelStates.values()) {
        max += MAX_PANEL_HEALTH;
        if (!state.isDestroyed) current += state.health;
    }
    this.systemIntegrity = max > 0 ? (current / max) * 100 : 100;
  }

  public register(id: string, element: HTMLElement) {
    this.observedElements.set(id, element);
    if (!this.panelStates.has(id)) {
        this.panelStates.set(id, { health: MAX_PANEL_HEALTH, isDestroyed: false });
    }
    this.refreshSingle(id);
  }

  public unregister(id: string) {
    this.observedElements.delete(id);
    this.panelRects.delete(id);
    this.panelStates.delete(id);
  }

  public refreshSingle(id: string) {
    const el = this.observedElements.get(id);
    if (!el || !el.isConnected) return;
    const rect = el.getBoundingClientRect();
    if (rect.width === 0 && rect.height === 0) return;
    this.panelRects.set(id, ViewportHelper.domToWorld(id, rect));
  }

  public refreshAll() {
    const ids = Array.from(this.observedElements.keys());
    for (const id of ids) this.refreshSingle(id);
  }

  public getPanelRect(id: string): WorldRect | undefined {
    return this.panelRects.get(id);
  }

  public getPanelState(id: string): PanelState | undefined {
    return this.panelStates.get(id);
  }
  
  public getAllPanels() {
      const result = [];
      for(const [id, rect] of this.panelRects) {
          const state = this.panelStates.get(id) || { health: 0, isDestroyed: true };
          result.push({ ...rect, ...state });
      }
      return result;
  }
}

export const PanelRegistry = new PanelRegistrySystemClass();


=====================================
FILE: ./src/game/systems/index.ts
=====================================
export * from './BehaviorSystem';
export * from './CameraSystem';
export * from './CollisionSystem';
export * from './FXManager';
export * from './GameStateSystem';
export * from './InputSystem';
export * from './InteractionSystem';
export * from './LifeCycleSystem';
export * from './PanelRegistrySystem';
export * from './PhysicsSystem';
export * from './PlayerSystem';
export * from './TimeSystem';
export * from './UISyncSystem';
export * from './WaveSystem';


=====================================
FILE: ./src/game/systems/GameStateSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { PLAYER_CONFIG } from '../config/PlayerConfig';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { useStore } from '@/core/store/useStore'; 

export class GameStateSystem implements IGameSystem {
  public playerHealth: number = PLAYER_CONFIG.maxHealth;
  public maxPlayerHealth: number = PLAYER_CONFIG.maxHealth;
  public playerRebootProgress: number = 0;
  
  public score: number = 0;
  public xp: number = 0;
  public level: number = 1;
  public xpToNextLevel: number = PLAYER_CONFIG.baseXpRequirement;
  public upgradePoints: number = 0;
  public activeUpgrades: Record<string, number> = {
    'RAPID_FIRE': 0, 'MULTI_SHOT': 0, 'SPEED_UP': 0, 'REPAIR_NANITES': 0
  };

  public isGameOver: boolean = false;

  setup(locator: IServiceLocator): void {
    this.reset();
    
    GameEventBus.subscribe(GameEvents.UPGRADE_SELECTED, (p) => {
        this.applyUpgrade(p.option);
    });
  }

  update(delta: number, time: number): void {}
  teardown(): void {}

  public reset() {
    this.playerHealth = this.maxPlayerHealth;
    this.playerRebootProgress = 0;
    this.score = 0;
    this.xp = 0;
    this.level = 1;
    this.xpToNextLevel = PLAYER_CONFIG.baseXpRequirement;
    this.upgradePoints = 0;
    this.isGameOver = false;
    this.activeUpgrades = { 'RAPID_FIRE': 0, 'MULTI_SHOT': 0, 'SPEED_UP': 0, 'REPAIR_NANITES': 0 };
  }

  public applyUpgrade(option: string) {
      if (this.upgradePoints > 0) {
          this.upgradePoints--;
          this.activeUpgrades[option] = (this.activeUpgrades[option] || 0) + 1;
          
          if (option === 'REPAIR_NANITES') {
             this.healPlayer(this.maxPlayerHealth * 0.2);
          }
      }
  }

  public damagePlayer(amount: number) {
    if (this.isGameOver) return;

    const { godMode } = useStore.getState().debugFlags;
    if (godMode) return;

    if (this.playerHealth > 0) {
        this.playerHealth = Math.max(0, this.playerHealth - amount);
    } else {
        // If already dead, damage reduces reboot progress
        this.playerRebootProgress = Math.max(0, this.playerRebootProgress - (amount * 2));
    }
  }

  public healPlayer(amount: number) {
    this.playerHealth = Math.min(this.maxPlayerHealth, this.playerHealth + amount);
  }

  public addScore(amount: number) {
    this.score += amount;
  }

  public addXp(amount: number) {
    this.xp += amount;
    while (this.xp >= this.xpToNextLevel) {
        this.xp -= this.xpToNextLevel;
        this.level++;
        this.upgradePoints++;
        this.xpToNextLevel = Math.floor(this.xpToNextLevel * PLAYER_CONFIG.xpScalingFactor);
        
        GameEventBus.emit(GameEvents.THREAT_LEVEL_UP, { level: this.level });
    }
  }

  public tickReboot(amount: number) {
    if (this.playerHealth > 0) return;
    this.playerRebootProgress = Math.max(0, Math.min(100, this.playerRebootProgress + amount));
    if (this.playerRebootProgress >= 100) {
        this.playerHealth = this.maxPlayerHealth / 2;
        this.playerRebootProgress = 0;
    }
  }

  // NEW: Decay logic for when player stops charging
  public decayReboot(amount: number) {
      if (this.playerHealth > 0) return; 
      this.playerRebootProgress = Math.max(0, this.playerRebootProgress - amount);
  }
}


=====================================
FILE: ./src/game/systems/BehaviorSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IEntitySpawner } from '../core/interfaces';
import { EntityRegistry } from '../core/ecs/EntityRegistry';
import { Tag } from '../core/ecs/types';
import { IdentityComponent } from '../components/data/IdentityComponent';
import { StateComponent } from '../components/data/StateComponent';
import { Behaviors, AIContext } from '../logic/ai/EnemyBehaviors';
import { PanelRegistry } from './PanelRegistrySystem';
import { GameEventBus } from '../events/GameEventBus';

export class BehaviorSystem implements IGameSystem {
  private registry!: EntityRegistry;
  private spawner!: IEntitySpawner;
  private locator!: IServiceLocator;

  setup(locator: IServiceLocator): void {
    this.registry = locator.getRegistry() as EntityRegistry;
    this.spawner = locator.getSpawner();
    this.locator = locator;
  }

  update(delta: number, time: number): void {
    const cursor = this.locator.getInputService().getCursor();
    const doDamageTick = Math.floor(time * 2) > Math.floor((time - delta) * 2);
    const worldPanels = PanelRegistry.getAllPanels().filter(p => !p.isDestroyed);

    const aiContext: AIContext = {
      playerPos: cursor,
      panels: worldPanels,
      delta,
      time,
      doDamageTick,
      spawnProjectile: (x, y, vx, vy) => this.spawner.spawnBullet(x, y, vx, vy, true, 3.0),
      triggerExplosion: (x, y, color) => this.spawnExplosion(x, y, color),
      spawnDrillSparks: (x, y, color) => this.spawnSparks(x, y, color),
      emitEvent: (name, payload) => GameEventBus.emit(name as any, payload),
      damagePanel: (id, amount) => PanelRegistry.damagePanel(id, amount),
      destroyEntity: (id) => this.registry.destroyEntity(id)
    };

    const enemies = this.registry.getByTag(Tag.ENEMY);
    for (const entity of enemies) {
        if (!entity.active) continue;
        
        // 1. Check for Spawn State (Materializing)
        const state = entity.getComponent<StateComponent>('State');
        if (state && state.current === 'SPAWN') {
            if (state.timers.spawn > 0) {
                state.timers.spawn -= delta;
                // Add a "glitch" jump effect while spawning
                if (Math.random() > 0.9) {
                    const t = entity.getComponent<any>('Transform');
                    t.x += (Math.random() - 0.5) * 0.1;
                    t.y += (Math.random() - 0.5) * 0.1;
                }
                continue; // Skip AI behavior while spawning
            } else {
                state.current = 'IDLE'; // Transition to active
            }
        }

        // 2. Run Standard AI
        const identity = entity.getComponent<IdentityComponent>('Identity');
        if (identity) {
             const behavior = Behaviors[identity.variant];
             if (behavior) behavior.update(entity, aiContext);
        }
    }
  }

  private spawnExplosion(x: number, y: number, color: string) {
      for(let i=0; i<8; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 15;
          this.spawner.spawnParticle(x, y, color, Math.cos(angle)*speed, Math.sin(angle)*speed, 0.8);
      }
  }

  private spawnSparks(x: number, y: number, color: string) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 2 + Math.random() * 2;
      this.spawner.spawnParticle(x, y, color, Math.cos(angle)*speed, Math.sin(angle)*speed, 0.25);
  }

  teardown(): void {}
}


=====================================
FILE: ./src/game/systems/WaveSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IEntitySpawner } from '../core/interfaces';
import { useGameStore } from '../store/useGameStore';
import { useStore } from '@/core/store/useStore';
import { PanelRegistry } from './PanelRegistrySystem'; 
import { EnemyTypes } from '../config/Identifiers';

const WAVE_TIMELINE = [
  { at: 0,     type: 'driller', count: 3, interval: 0.1 }, 
  { at: 2,     type: 'driller', count: 5, interval: 0.5 }, 
  { at: 5,     type: 'kamikaze', count: 2, interval: 1.0 },
  { at: 8,     type: 'driller', count: 8, interval: 0.2 }, 
  { at: 12,    type: 'hunter',  count: 1, interval: 0 },   
  { at: 15,    type: 'driller', count: 10, interval: 0.1 },
  { at: 20,    type: 'kamikaze', count: 5, interval: 0.5 },
  { at: 25,    type: 'hunter',  count: 3, interval: 1.0 }, 
];

export class WaveSystem implements IGameSystem {
  private spawner!: IEntitySpawner;
  private waveTime = 0;
  private currentWaveIndex = 0;
  private spawnQueue: { type: string, time: number }[] = [];
  private loopCount = 0;
  
  private nextBreachTime = 0;

  setup(locator: IServiceLocator): void {
    this.spawner = locator.getSpawner();
    this.reset();
  }

  private reset() {
    this.waveTime = 0;
    this.currentWaveIndex = 0;
    this.spawnQueue = [];
    this.loopCount = 0;
    this.nextBreachTime = 3.0; 
  }

  update(delta: number, time: number): void {
    if (useGameStore.getState().isZenMode) return;
    if (useStore.getState().debugFlags.peaceMode) return;
    if (useStore.getState().bootState === 'sandbox') return;

    this.waveTime += delta;
    this.checkTimeline();
    this.processQueue(time);
    this.checkBreaches(delta, time);
  }

  private checkBreaches(delta: number, time: number) {
      if (this.waveTime > this.nextBreachTime) {
          const deadPanels = PanelRegistry.getAllPanels().filter(p => p.isDestroyed);
          
          if (deadPanels.length > 0) {
              const p = deadPanels[Math.floor(Math.random() * deadPanels.length)];
              
              const intensity = Math.floor(this.waveTime / 20) + 1;
              const rand = Math.random();
              let type = EnemyTypes.DRILLER;
              if (rand > 0.85) type = EnemyTypes.HUNTER;
              else if (rand > 0.55) type = EnemyTypes.KAMIKAZE;

              for(let i=0; i<intensity; i++) {
                  // FIX: Constrain offset to panel dimensions (with padding)
                  // width/height are full size, so half is the radius from center
                  const safeW = (p.width * 0.4); 
                  const safeH = (p.height * 0.4);
                  
                  const offsetX = (Math.random() - 0.5) * 2 * safeW;
                  const offsetY = (Math.random() - 0.5) * 2 * safeH;
                  
                  this.spawner.spawnEnemy(type, p.x + offsetX, p.y + offsetY);
              }
          }

          this.nextBreachTime = this.waveTime + 2.0 + (Math.random() * 2.0);
      }
  }

  private checkTimeline() {
    if (this.currentWaveIndex >= WAVE_TIMELINE.length) {
        this.waveTime = 0;
        this.currentWaveIndex = 0;
        this.loopCount++;
    }

    const nextWave = WAVE_TIMELINE[this.currentWaveIndex];
    if (nextWave && this.waveTime >= nextWave.at) {
        this.queueSpawns(nextWave);
        this.currentWaveIndex++;
    }
  }

  private queueSpawns(wave: any) {
    const count = wave.count + (this.loopCount * 2);
    for (let i = 0; i < count; i++) {
        this.spawnQueue.push({
            type: wave.type,
            time: this.waveTime + (i * wave.interval)
        });
    }
  }

  private processQueue(currentTime: number) {
    for (let i = this.spawnQueue.length - 1; i >= 0; i--) {
        const spawn = this.spawnQueue[i];
        if (this.waveTime >= spawn.time) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 25; 
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            this.spawner.spawnEnemy(spawn.type, x, y);
            this.spawnQueue.splice(i, 1);
        }
    }
  }

  teardown(): void {
    this.reset();
  }
}


=====================================
FILE: ./src/game/systems/LifeCycleSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { LifetimeComponent } from '../components/data/LifetimeComponent';
import { HealthComponent } from '../components/data/HealthComponent';
import { IdentityComponent } from '../components/data/IdentityComponent';
import { TransformComponent } from '../components/data/TransformComponent';
import { EntityRegistry } from '../core/ecs/EntityRegistry';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { IEntitySpawner } from '../core/interfaces';

export class LifeCycleSystem implements IGameSystem {
  private registry!: EntityRegistry;
  private spawner!: IEntitySpawner;

  setup(locator: IServiceLocator): void {
    this.registry = locator.getRegistry() as EntityRegistry;
    this.spawner = locator.getSpawner();
    
    // RESTORED: Listen for Zen Mode to wipe the board
    GameEventBus.subscribe(GameEvents.ZEN_MODE_ENABLED, () => {
        this.registry.clear();
        this.spawnPurgeEffect();
    });
  }

  update(delta: number, time: number): void {
    for (const entity of this.registry.getAll()) {
      if (!entity.active) continue;

      const lifetime = entity.getComponent<LifetimeComponent>('Lifetime');
      if (lifetime) {
        lifetime.remaining -= delta;
        if (lifetime.remaining <= 0) {
          this.registry.destroyEntity(entity.id);
          continue;
        }
      }

      const health = entity.getComponent<HealthComponent>('Health');
      if (health && health.isDead) {
          const identity = entity.getComponent<IdentityComponent>('Identity');
          const transform = entity.getComponent<TransformComponent>('Transform');
          
          if (identity && transform) {
             GameEventBus.emit(GameEvents.ENEMY_DESTROYED, { 
                id: entity.id as number, 
                type: identity.variant, 
                x: transform.x, 
                y: transform.y 
             });
             this.spawnExplosion(transform.x, transform.y, identity.variant);
          }
          
          this.registry.destroyEntity(entity.id);
      }
    }
  }

  private spawnExplosion(x: number, y: number, type: string) {
      const color = type === 'hunter' ? '#F7D277' : type === 'kamikaze' ? '#FF003C' : '#9E4EA5';
      for(let i=0; i<12; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 15;
          const life = 0.5 + Math.random() * 0.5;
          this.spawner.spawnParticle(x, y, color, Math.cos(angle)*speed, Math.sin(angle)*speed, life);
      }
  }

  private spawnPurgeEffect() {
      // Big white explosion from center to signify "Cleansing"
      for(let i=0; i<50; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 10 + Math.random() * 20;
          this.spawner.spawnParticle(0, 0, '#FFFFFF', Math.cos(angle)*speed, Math.sin(angle)*speed, 2.0);
      }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/game/systems/PhysicsSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { SpatialGrid } from '../core/SpatialGrid';
import { TransformComponent } from '../components/data/TransformComponent';
import { MotionComponent } from '../components/data/MotionComponent';
import { EntityRegistry } from '../core/ecs/EntityRegistry';

export class PhysicsSystem implements IGameSystem {
  public spatialGrid: SpatialGrid;
  private registry!: EntityRegistry;

  constructor() {
    this.spatialGrid = new SpatialGrid(4);
  }

  setup(locator: IServiceLocator): void {
    this.registry = locator.getRegistry() as EntityRegistry;
    this.spatialGrid.clear();
  }

  update(delta: number, time: number): void {
    this.spatialGrid.clear();
    
    for (const entity of this.registry.getAll()) {
      if (!entity.active) continue;

      const transform = entity.getComponent<TransformComponent>('Transform');
      const motion = entity.getComponent<MotionComponent>('Motion');
      
      if (transform && motion) {
        // Apply Velocity
        transform.x += motion.vx * delta;
        transform.y += motion.vy * delta;
        
        // Friction / Damping
        if (motion.friction > 0) {
            motion.vx *= (1 - motion.friction);
            motion.vy *= (1 - motion.friction);
        }

        // Spatial Grid Insert
        this.spatialGrid.insert(entity.id, transform.x, transform.y);
      }
    }
  }

  teardown(): void {
    this.spatialGrid.clear();
  }
}


=====================================
FILE: ./src/game/store/useGameStore.ts
=====================================
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { UpgradeOption } from '../types/game.types';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { PLAYER_CONFIG } from '../config/PlayerConfig';

const MAX_PANEL_HEALTH = 1000;

interface GameStateUI {
  isPlaying: boolean;
  isZenMode: boolean;
  playerHealth: number;
  maxPlayerHealth: number;
  playerRebootProgress: number;
  score: number;
  highScore: number;
  xp: number;
  level: number;
  xpToNextLevel: number;
  upgradePoints: number;
  systemIntegrity: number;
  
  interactionTarget: string | null;

  availableUpgrades: UpgradeOption[];
  activeUpgrades: Record<string, number>;
  panels: Record<string, { id: string, health: number, isDestroyed: boolean, element?: HTMLElement }>;
  
  // --- TRANSIENT UPDATE SYSTEM (Direct DOM) ---
  transientElements: Map<string, { el: HTMLElement, type: 'text' | 'width' | 'css-var' }>;
  registerTransientElement: (id: string, el: HTMLElement, type: 'text' | 'width' | 'css-var') => void;
  unregisterTransientElement: (id: string) => void;
  updateTransient: (id: string, value: string | number) => void;

  // --- ACTIONS ---
  startGame: () => void;
  stopGame: () => void;
  activateZenMode: () => void;
  
  registerPanel: (id: string, element: HTMLElement) => void;
  unregisterPanel: (id: string) => void;
  syncGameState: (data: Partial<GameStateUI>) => void;
  syncPanels: (panelsData: Record<string, any>) => void;
  selectUpgrade: (option: UpgradeOption) => void;
  addScore: (amount: number) => void;
  addXp: (amount: number) => void;
  damagePlayer: (amount: number) => void;
  healPlayer: (amount: number) => void;
  tickPlayerReboot: (amount: number) => void;
  healPanel: (id: string, amount: number) => void;
  decayReboot: (id: string, amount: number) => void;
  damagePanel: (id: string, amount: number) => void;
  resetGame: () => void;
  recalculateIntegrity: () => void;
}

export const useGameStore = create<GameStateUI>()(
  persist(
    (set, get) => ({
      isPlaying: false,
      isZenMode: false,
      playerHealth: PLAYER_CONFIG.maxHealth,
      maxPlayerHealth: PLAYER_CONFIG.maxHealth,
      playerRebootProgress: 0,
      score: 0,
      highScore: 0,
      xp: 0,
      level: 1,
      xpToNextLevel: PLAYER_CONFIG.baseXpRequirement,
      upgradePoints: 0,
      systemIntegrity: 100,
      interactionTarget: null,
      
      availableUpgrades: [],
      activeUpgrades: { 'RAPID_FIRE': 0, 'MULTI_SHOT': 0, 'SPEED_UP': 0, 'REPAIR_NANITES': 0 },
      panels: {},

      // --- TRANSIENT SYSTEM ---
      transientElements: new Map(),

      registerTransientElement: (id, el, type) => {
        // We modify the Map directly to avoid triggering a React re-render
        get().transientElements.set(id, { el, type });
      },

      unregisterTransientElement: (id) => {
        get().transientElements.delete(id);
      },

      updateTransient: (id, value) => {
        const item = get().transientElements.get(id);
        if (!item) return;

        if (item.type === 'text') {
            item.el.innerText = String(value);
        } else if (item.type === 'width') {
            item.el.style.width = `${value}%`;
        } else if (item.type === 'css-var') {
            item.el.style.setProperty(`--${id}`, String(value));
        }
      },

      // --- GAME ACTIONS ---

      startGame: () => {
        if (get().isPlaying) return;
        set({ 
            isPlaying: true, 
            isZenMode: false,
            score: 0, 
            playerHealth: PLAYER_CONFIG.maxHealth,
            playerRebootProgress: 0,
            xp: 0,
            level: 1,
            xpToNextLevel: PLAYER_CONFIG.baseXpRequirement,
            availableUpgrades: [],
            activeUpgrades: { 'RAPID_FIRE': 0, 'MULTI_SHOT': 0, 'SPEED_UP': 0, 'REPAIR_NANITES': 0 },
            panels: Object.fromEntries(
                Object.entries(get().panels).map(([k, v]) => [k, { ...v, health: MAX_PANEL_HEALTH, isDestroyed: false }])
            )
        });
        // Reset visual elements immediately
        get().updateTransient('score-display', '0000');
        get().updateTransient('player-health', 100);
      },
      
      stopGame: () => {
          const { score, highScore } = get();
          set({ isPlaying: false, highScore: Math.max(score, highScore) });
      },

      activateZenMode: () => {
          set({ isZenMode: true });
          GameEventBus.emit(GameEvents.ZEN_MODE_ENABLED, null);
      },

      syncGameState: (data) => set((state) => ({ ...state, ...data })),
      
      syncPanels: (incomingPanels) => set((state) => {
          const merged = { ...state.panels };
          for (const key in incomingPanels) {
              const prev = merged[key];
              merged[key] = { ...(prev || {}), ...incomingPanels[key] };
          }
          return { panels: merged };
      }),

      registerPanel: (id, element) => set((state) => ({
          panels: { ...state.panels, [id]: { id, element, health: 1000, isDestroyed: false } }
      })),
      
      unregisterPanel: (id) => set((state) => {
          const next = { ...state.panels };
          delete next[id];
          return { panels: next };
      }),

      selectUpgrade: (option) => {
        GameEventBus.emit(GameEvents.UPGRADE_SELECTED, { option });
      },

      addScore: (amount) => set(state => ({ score: state.score + amount })),
      addXp: (amount) => set(state => ({ xp: state.xp + amount })),
      damagePlayer: (amount) => set(state => ({ playerHealth: Math.max(0, state.playerHealth - amount) })),
      healPlayer: (amount) => set(state => ({ playerHealth: Math.min(state.maxPlayerHealth, state.playerHealth + amount) })),
      tickPlayerReboot: (amount) => set(state => ({ playerRebootProgress: Math.min(100, Math.max(0, state.playerRebootProgress + amount)) })),
      healPanel: (id, amount) => {}, 
      decayReboot: (id, amount) => {}, 
      damagePanel: (id, amount) => {}, 
      resetGame: () => {},
      recalculateIntegrity: () => {},
    }),
    {
      name: 'mesoelfy-os-storage-v2',
      partialize: (state) => ({ highScore: state.highScore }),
    }
  )
);


=====================================
FILE: ./src/styles/globals.css
=====================================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 255, 65;
}

html, body {
  background-color: #000000;
  overscroll-behavior: none; /* Prevent pull-to-refresh */
  touch-action: none; /* Disable native touch gestures */
}

body {
  color: #78F654;
  overflow: hidden; 
  font-family: 'Courier New', monospace;
  height: 100dvh; /* Fix for Mobile Safari */
  width: 100vw;
}

#global-app-root {
  height: 100dvh;
}

::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #050505; 
  border-left: 1px solid #15530A;
}

::-webkit-scrollbar-thumb {
  background: #0BD426; 
  border: 1px solid #000;
  border-radius: 2px;
}

::-webkit-scrollbar-thumb:hover {
  background: #78F654;
}

.glitch-text {
  text-shadow: 2px 0 #ff003c, -2px 0 #008f11;
}

.clip-corner-btn {
  clip-path: polygon(0 0, 100% 0, 100% 70%, 90% 100%, 0 100%);
}

/* Hide Next.js Indicators */
body > div[data-nextjs-toast],
body > div[data-nextjs-dialog-overlay],
#next-route-announcer,
[class*="nextjs-toast"],
[class*="build-activity"],
[class*="static-route-indicator"] {
  display: none !important;
  opacity: 0 !important;
  pointer-events: none !important;
  visibility: hidden !important;
}


=====================================
FILE: ./src/scene/props/MiniCrystalCanvas.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { Float, MeshDistortMaterial } from '@react-three/drei';
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { useGameStore } from '@/game/store/useGameStore';

// CONSTANTS
const COLORS = {
  SAFE: new THREE.Color("#78F654"),
  WARN: new THREE.Color("#F7D277"),
  // UPDATED: Brighter/Hotter Red Values
  CRIT: new THREE.Color("#FF4D6D"), 
  EMISSIVE_SAFE: new THREE.Color("#15530A"),
  EMISSIVE_WARN: new THREE.Color("#5e4b00"),
  EMISSIVE_CRIT: new THREE.Color("#FF003C"), 
};

const SpinningGem = () => {
  const meshRef = useRef<THREE.Mesh>(null);
  const materialRef = useRef<any>(null);
  
  // Access global integrity
  const integrity = useGameStore(state => state.systemIntegrity);

  // Internal visual state
  const currentColor = useRef(COLORS.SAFE.clone());
  const currentEmissive = useRef(COLORS.EMISSIVE_SAFE.clone());

  useFrame((state, delta) => {
    if (!meshRef.current || !materialRef.current) return;

    // 1. DETERMINE STATE
    let targetColor = COLORS.SAFE;
    let targetEmissive = COLORS.EMISSIVE_SAFE;
    let speed = 0.01;
    let distort = 0.3;
    let shake = 0;

    if (integrity < 30) {
        targetColor = COLORS.CRIT;
        targetEmissive = COLORS.EMISSIVE_CRIT;
        speed = 0.08;  // Fast panic spin
        distort = 0.8; // Heavy glitch
        shake = 0.1;   // Vibration
    } else if (integrity < 60) {
        targetColor = COLORS.WARN;
        targetEmissive = COLORS.EMISSIVE_WARN;
        speed = 0.04;
        distort = 0.5;
        shake = 0.02;
    }

    // 2. APPLY ROTATION & SHAKE
    meshRef.current.rotation.y += speed;
    meshRef.current.rotation.z += speed * 0.5;
    
    if (shake > 0) {
        meshRef.current.position.x = (Math.random() - 0.5) * shake;
        meshRef.current.position.y = (Math.random() - 0.5) * shake;
    } else {
        meshRef.current.position.x = THREE.MathUtils.lerp(meshRef.current.position.x, 0, 0.1);
        meshRef.current.position.y = THREE.MathUtils.lerp(meshRef.current.position.y, 0, 0.1);
    }

    // 3. COLOR TRANSITION (Lerp)
    currentColor.current.lerp(targetColor, delta * 3.0);
    currentEmissive.current.lerp(targetEmissive, delta * 3.0);

    materialRef.current.color.copy(currentColor.current);
    materialRef.current.emissive.copy(currentEmissive.current);
    materialRef.current.distort = THREE.MathUtils.lerp(materialRef.current.distort, distort, delta);
  });

  return (
    <Float speed={2} rotationIntensity={0.5} floatIntensity={0.5}>
      <mesh ref={meshRef} scale={1.8}>
        <octahedronGeometry args={[1, 0]} />
        <MeshDistortMaterial
          ref={materialRef}
          color="#78F654" // Initial (overridden by ref)
          emissive="#15530A"
          roughness={0.1}
          metalness={0.8}
          distort={0.3}
          speed={2}
          wireframe
        />
      </mesh>
    </Float>
  );
};

export const MiniCrystalCanvas = () => {
  return (
    <div className="w-full h-full bg-black">
      <Canvas 
        camera={{ position: [0, 0, 5] }} 
        gl={{ alpha: true }}
        style={{ background: '#000000' }}
      >
        <ambientLight intensity={0.5} />
        <pointLight position={[10, 10, 10]} intensity={1} color="#C2FE9A" />
        <SpinningGem />
      </Canvas>
    </div>
  );
};


=====================================
FILE: ./src/scene/props/SoulCrystal.tsx
=====================================
import { useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import { Float, MeshDistortMaterial } from '@react-three/drei';
import * as THREE from 'three';

export const SoulCrystal = () => {
  const meshRef = useRef<THREE.Mesh>(null);

  useFrame((state) => {
    if (meshRef.current) {
      const t = state.clock.getElapsedTime();
      meshRef.current.rotation.y = t * 0.5;
      meshRef.current.rotation.z = t * 0.2;
    }
  });

  return (
    <Float speed={2} rotationIntensity={0.5} floatIntensity={1}>
      <mesh ref={meshRef} scale={1.5}>
        <octahedronGeometry args={[1, 0]} />
        <MeshDistortMaterial
          color="#00ff41"
          emissive="#003300"
          roughness={0}
          metalness={1}
          distort={0.4}
          speed={2}
          wireframe
        />
      </mesh>
      {/* Inner Core Glow */}
      <mesh scale={0.8}>
        <octahedronGeometry args={[1, 0]} />
        <meshBasicMaterial color="#ccffcc" transparent opacity={0.5} />
      </mesh>
    </Float>
  );
};


=====================================
FILE: ./src/scene/canvas/SceneCanvas.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { MatrixGrid } from '../effects/MatrixGrid';
import { Suspense } from 'react';
import { clsx } from 'clsx';

interface SceneCanvasProps {
  children?: React.ReactNode;
  className?: string;
}

export const SceneCanvas = ({ children, className }: SceneCanvasProps) => {
  return (
    <div className={clsx("fixed inset-0 w-full h-full z-0 pointer-events-none transition-all duration-[2000ms] ease-out", className)}>
      <Canvas 
        camera={{ position: [0, 2, 10], fov: 45 }}
        gl={{ antialias: true, alpha: false }} // Alpha false = performance gain + no transparency issues
        dpr={[1, 2]}
        style={{ background: '#000000' }} // <--- THE FIX: Force canvas to be black instantly
      >
        <color attach="background" args={['#000']} />
        <fog attach="fog" args={['#000', 2, 30]} />
        
        <MatrixGrid />
        
        <ambientLight intensity={0.5} />
        <pointLight position={[10, 10, 10]} intensity={1} color="#78F654" />
        
        <Suspense fallback={null}>
           {children}
        </Suspense>
      </Canvas>
    </div>
  );
};


=====================================
FILE: ./src/scene/effects/FireTransition.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import * as THREE from 'three';
import { useStore } from '@/core/store/useStore';

// Vertex Shader: Standard full-screen quad
const vertexShader = `
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = vec4(position, 1.0);
  }
`;

// Fragment Shader: The Burn Logic
const fragmentShader = `
  uniform float uTime;
  uniform float uProgress;
  uniform vec2 uResolution;
  varying vec2 vUv;

  // Simplex Noise 2D
  vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
  float snoise(vec2 v){
    const vec4 C = vec4(0.211324865405187, 0.366025403784439,
             -0.577350269189626, 0.024390243902439);
    vec2 i  = floor(v + dot(v, C.yy) );
    vec2 x0 = v -   i + dot(i, C.xx);
    vec2 i1;
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod(i, 289.0);
    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
    + i.x + vec3(0.0, i1.x, 1.0 ));
    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
    m = m*m ;
    m = m*m ;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
    vec3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
  }

  void main() {
    // Noise Scale
    float noise = snoise(vUv * 3.0 + vec2(0.0, uTime * 0.2));
    
    // Calculate Burn Edge
    // We modify progress to ensure it goes fully from black (-1) to clear (1)
    float prog = (uProgress * 2.5) - 1.0; 
    
    float alpha = smoothstep(prog, prog + 0.2, noise);
    
    // Edge Color (The Green Flame)
    float edge = 1.0 - smoothstep(prog, prog + 0.05, noise);
    vec3 flameColor = vec3(0.47, 0.96, 0.33); // #78F654
    
    vec3 finalColor = mix(vec3(0.0), flameColor, edge);

    if (alpha <= 0.01) discard; // Cut out the transparent parts

    gl_FragColor = vec4(finalColor, alpha);
  }
`;

export const FireTransition = () => {
  const meshRef = useRef<THREE.Mesh>(null);
  const materialRef = useRef<THREE.ShaderMaterial>(null);
  const { introDone } = useStore();
  const { viewport } = useThree();

  // Animation State
  const animState = useRef({ value: 0 }); // 0 = Black, 1 = Clear

  useFrame((state, delta) => {
    if (!materialRef.current) return;

    // Update Time
    materialRef.current.uniforms.uTime.value = state.clock.elapsedTime;

    // Logic: If Intro is DONE, animate progress 0 -> 1
    // If Intro is NOT DONE, keep progress at 0 (Solid Black)
    const target = introDone ? 1 : 0;
    
    // Linear Interpolation (Lerp) for smoothness
    // Adjust 1.5 to make fire faster/slower
    animState.current.value = THREE.MathUtils.lerp(animState.current.value, target, delta * 1.5);
    
    materialRef.current.uniforms.uProgress.value = animState.current.value;

    // Disable rendering if fully cleared to save GPU
    if (meshRef.current) {
        meshRef.current.visible = animState.current.value < 0.99;
    }
  });

  const uniforms = useMemo(
    () => ({
      uTime: { value: 0 },
      uProgress: { value: 0 }, // Starts Black
      uResolution: { value: new THREE.Vector2(viewport.width, viewport.height) },
    }),
    [viewport]
  );

  return (
    <mesh ref={meshRef} position={[0, 0, 1]}> 
      {/* Plane fills the screen */}
      <planeGeometry args={[viewport.width, viewport.height]} />
      <shaderMaterial
        ref={materialRef}
        vertexShader={vertexShader}
        fragmentShader={fragmentShader}
        uniforms={uniforms}
        transparent={true}
        depthTest={false} // Always draw on top
      />
    </mesh>
  );
};


=====================================
FILE: ./src/scene/effects/MatrixGrid.tsx
=====================================
import { Grid } from '@react-three/drei';
import { useFrame } from '@react-three/fiber';
import { useRef, useMemo } from 'react';
import * as THREE from 'three';
import { useGameStore } from '@/game/store/useGameStore';
import { useStore } from '@/core/store/useStore';

export const MatrixGrid = () => {
  const groupRef = useRef<THREE.Group>(null);
  const gridRef = useRef<any>(null);

  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const bootState = useStore(state => state.bootState);

  const SECTION_SIZE = 5;   
  const SPEED = 0.5;

  const colors = useMemo(() => ({
    safe: {
      section: new THREE.Color("#003300"),
      cell: new THREE.Color("#044d0f")
    },
    warning: {
      section: new THREE.Color("#4d3300"),
      cell: new THREE.Color("#d48806")
    },
    critical: {
      section: new THREE.Color("#4d0000"),
      cell: new THREE.Color("#ff003c")
    },
    sandbox: {
      section: new THREE.Color("#001a33"), 
      cell: new THREE.Color("#00F0FF")     
    }
  }), []);

  const currentSectionColor = useRef(new THREE.Color(colors.safe.section));
  const currentCellColor = useRef(new THREE.Color(colors.safe.cell));

  useFrame((state, delta) => {
    if (groupRef.current) {
      groupRef.current.position.z += SPEED * delta;
      // Loop logic for infinite scrolling effect
      if (groupRef.current.position.z >= SECTION_SIZE) {
        groupRef.current.position.z = 0;
      }
    }

    let targetSection = colors.safe.section;
    let targetCell = colors.safe.cell;

    if (bootState === 'sandbox') {
        targetSection = colors.sandbox.section;
        targetCell = colors.sandbox.cell;
    } else if (systemIntegrity < 30) {
      targetSection = colors.critical.section;
      targetCell = colors.critical.cell;
    } else if (systemIntegrity < 60) {
      targetSection = colors.warning.section;
      targetCell = colors.warning.cell;
    }

    currentSectionColor.current.lerp(targetSection, delta * 3.0);
    currentCellColor.current.lerp(targetCell, delta * 3.0);

    if (gridRef.current && gridRef.current.material) {
        if (gridRef.current.material.uniforms.sectionColor) {
            gridRef.current.material.uniforms.sectionColor.value.copy(currentSectionColor.current);
        }
        if (gridRef.current.material.uniforms.cellColor) {
            gridRef.current.material.uniforms.cellColor.value.copy(currentCellColor.current);
        }
    }
  });

  return (
    <group ref={groupRef} position={[0, -2, 0]}>
      {/* 
         FIX: Nested group to offset geometry without breaking the scrolling logic.
         Z = -10 shifts the center point forward so the "front" edge is well behind the camera.
      */}
      <group position={[0, 0, -10]}>
        <Grid
          ref={gridRef}
          renderOrder={-1}
          infiniteGrid
          
          args={[60, 60]} 
          
          cellSize={1}
          sectionSize={SECTION_SIZE}
          
          // FIX: Reduced fadeDistance slightly to hide distant sub-pixels
          fadeDistance={bootState === 'sandbox' ? 35 : 30}
          
          // FIX: Increased fadeStrength (default is 1)
          // Higher values = sharper falloff. This hides the distant Moir√© patterns.
          fadeStrength={2.5}
          
          sectionColor="#003300"
          cellColor="#044d0f"
          sectionThickness={1.2} 
          cellThickness={1.1}
        />
      </group>
    </group>
  );
};


=====================================
FILE: ./src/data/gallery.json
=====================================
[
  {
    "id": "art_001",
    "title": "ELFY_GENESIS",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#78F654"
  },
  {
    "id": "art_002",
    "title": "NEON_HEIST",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#9E4EA5"
  },
  {
    "id": "art_003",
    "title": "VOID_WALKER",
    "url": "https://x.com/mesoelfy",
    "category": "ROGUES",
    "color": "#FF003C"
  },
  {
    "id": "art_004",
    "title": "LATENT_GHOST",
    "url": "https://x.com/mesoelfy",
    "category": "COLLEAGUES",
    "color": "#F7D277"
  },
  {
    "id": "art_005",
    "title": "ZERO_DAY",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#78F654"
  },
  {
    "id": "art_006",
    "title": "SYSTEM_CRASH",
    "url": "https://x.com/mesoelfy",
    "category": "ROGUES",
    "color": "#FF003C"
  }
]


=====================================
FILE: ./src/data/identity.json
=====================================
{
  "name": "Elfy",
  "class": "Latent Space Bandit",
  "abilities": ["Green Flame", "Digital Heist", "Prompt Craft"],
  "stats": {
    "STR": "ERROR",
    "INT": 9001,
    "CHA": 50
  },
  "bio": "I manifest art from the void. My mission: Create cool s**t and annoy the haters."
}


=====================================
FILE: ./src/data/socials.json
=====================================
[
  { "name": "X / Twitter", "url": "https://x.com/mesoelfy", "icon": "twitter", "color": "#1DA1F2" },
  { "name": "YouTube", "url": "https://youtube.com/@mesoelfy", "icon": "youtube", "color": "#FF0000" },
  { "name": "TikTok", "url": "https://tiktok.com/@mesoelfy", "icon": "video", "color": "#00f2ea" },
  { "name": "GitHub", "url": "https://github.com/mesoelfy", "icon": "github", "color": "#ffffff" },
  { "name": "Newgrounds", "url": "https://mesoelfy.newgrounds.com/", "icon": "crosshair", "color": "#ffa500" },
  { "name": "DeviantArt", "url": "https://www.deviantart.com/mesoelfy", "icon": "image", "color": "#05cc47" }
]


=====================================
FILE: ./src/data/feed.json
=====================================
[
  {
    "id": 1,
    "date": "2023-10-27",
    "title": "Elfy vs. RoboGhoul",
    "desc": "The final showdown. Green flame algorithm engaged.",
    "link": "https://x.com/mesoelfy/status/123456"
  },
  {
    "id": 2,
    "date": "2023-10-20",
    "title": "Latent Space Update",
    "desc": "Exploring the void. Found some weird artifacts.",
    "link": "https://x.com/mesoelfy/status/789012"
  }
]


