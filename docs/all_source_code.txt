+---------------------------------+
|      M E S O E L F Y _ O S      |
|   Next.js / R3F Source Context  |
+---------------------------------+
Generated on: Wed Dec 10 11:36:19 CST 2025

=====================================
PROJECT DIRECTORY STRUCTURE:
=====================================
.
├── Icon\015
├── README.md
├── docs
│   ├── MESOELFY_OS_AI_INSTRUCTIONS.md
│   └── all_source_code.txt
├── next-env.d.ts
├── next.config.js
├── package.json
├── postcss.config.js
├── public
│   ├── assets
│   │   ├── audio
│   │   │   └── bg_music_placeholder.mp3
│   │   └── images
│   │       └── social-card.jpg
│   └── favicon.ico
├── scripts
│   └── create_source_context.command
├── src
│   ├── app
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── core
│   │   ├── audio
│   │   │   └── AudioSystem.ts
│   │   └── store
│   │       └── useStore.ts
│   ├── data
│   │   ├── feed.json
│   │   ├── gallery.json
│   │   ├── identity.json
│   │   └── socials.json
│   ├── features
│   │   ├── contact
│   │   │   └── ContactModal.tsx
│   │   ├── debug
│   │   │   ├── DebugOverlay.tsx
│   │   │   └── tabs
│   │   │       ├── ConsoleTab.tsx
│   │   │       ├── OverridesTab.tsx
│   │   │       ├── SandboxTab.tsx
│   │   │       └── StatsTab.tsx
│   │   ├── feed
│   │   │   └── FeedModal.tsx
│   │   ├── gallery
│   │   │   └── GalleryModal.tsx
│   │   ├── identity
│   │   │   └── AboutModal.tsx
│   │   ├── intro
│   │   │   └── MatrixBootSequence.tsx
│   │   ├── sandbox
│   │   │   └── SimulationHUD.tsx
│   │   └── settings
│   │       ├── SettingsModal.tsx
│   │       ├── components
│   │       │   └── RangeSlider.tsx
│   │       └── tabs
│   │           └── SoundTab.tsx
│   ├── game
│   │   ├── GameOverlay.tsx
│   │   ├── components
│   │   │   ├── BulletRenderer.tsx
│   │   │   ├── DaemonBulletRenderer.tsx
│   │   │   ├── DaemonChargeRenderer.tsx
│   │   │   ├── DaemonRenderer.tsx
│   │   │   ├── EffectsLayer.tsx
│   │   │   ├── EnemyBulletRenderer.tsx
│   │   │   ├── EnemyRenderer.tsx
│   │   │   ├── GalleryStage.tsx
│   │   │   ├── GameDirector.tsx
│   │   │   ├── HunterChargeRenderer.tsx
│   │   │   ├── ParticleRenderer.tsx
│   │   │   ├── PlayerAvatar.tsx
│   │   │   ├── ProjectileTrails.tsx
│   │   │   ├── ScreenShaker.tsx
│   │   │   ├── common
│   │   │   │   └── InstancedActor.tsx
│   │   │   ├── data
│   │   │   │   ├── ColliderComponent.ts
│   │   │   │   ├── CombatComponent.ts
│   │   │   │   ├── HealthComponent.ts
│   │   │   │   ├── IdentityComponent.ts
│   │   │   │   ├── LifetimeComponent.ts
│   │   │   │   ├── MotionComponent.ts
│   │   │   │   ├── OrbitalComponent.ts
│   │   │   │   ├── StateComponent.ts
│   │   │   │   ├── TargetComponent.ts
│   │   │   │   └── TransformComponent.ts
│   │   │   └── index.ts
│   │   ├── config
│   │   │   ├── AIConfig.ts
│   │   │   ├── AudioConfig.ts
│   │   │   ├── EnemyConfig.ts
│   │   │   ├── Identifiers.ts
│   │   │   ├── ModelConfig.ts
│   │   │   ├── PhysicsConfig.ts
│   │   │   ├── PlayerConfig.ts
│   │   │   └── WorldConfig.ts
│   │   ├── core
│   │   │   ├── ComponentBuilder.ts
│   │   │   ├── EntitySpawner.ts
│   │   │   ├── GameBootstrapper.ts
│   │   │   ├── GameEngine.ts
│   │   │   ├── ObjectPool.ts
│   │   │   ├── ServiceLocator.ts
│   │   │   ├── SpatialGrid.ts
│   │   │   ├── ecs
│   │   │   │   ├── Component.ts
│   │   │   │   ├── Entity.ts
│   │   │   │   ├── EntityRegistry.ts
│   │   │   │   └── types.ts
│   │   │   ├── index.ts
│   │   │   └── interfaces.ts
│   │   ├── data
│   │   │   └── Archetypes.ts
│   │   ├── events
│   │   │   ├── GameEventBus.ts
│   │   │   └── GameEvents.ts
│   │   ├── hooks
│   │   │   ├── useHeartbeat.ts
│   │   │   ├── usePanelRegistry.ts
│   │   │   └── useTransientRef.ts
│   │   ├── logic
│   │   │   └── ai
│   │   │       ├── DaemonLogic.ts
│   │   │       ├── DrillerLogic.ts
│   │   │       ├── HunterLogic.ts
│   │   │       ├── KamikazeLogic.ts
│   │   │       └── types.ts
│   │   ├── store
│   │   │   └── useGameStore.ts
│   │   ├── systems
│   │   │   ├── BehaviorSystem.ts
│   │   │   ├── CollisionSystem.ts
│   │   │   ├── CombatSystem.ts
│   │   │   ├── FXManager.ts
│   │   │   ├── GameStateSystem.ts
│   │   │   ├── GuidanceSystem.ts
│   │   │   ├── InputSystem.ts
│   │   │   ├── InteractionSystem.ts
│   │   │   ├── LifeCycleSystem.ts
│   │   │   ├── OrbitalSystem.ts
│   │   │   ├── PanelRegistrySystem.ts
│   │   │   ├── PhysicsSystem.ts
│   │   │   ├── PlayerSystem.ts
│   │   │   ├── ShakeSystem.ts
│   │   │   ├── TargetingSystem.ts
│   │   │   ├── TimeSystem.ts
│   │   │   ├── UISyncSystem.ts
│   │   │   ├── WaveSystem.ts
│   │   │   └── index.ts
│   │   ├── theme.ts
│   │   ├── types
│   │   │   └── game.types.ts
│   │   └── utils
│   │       ├── GeometryUtils.ts
│   │       ├── Noise.ts
│   │       ├── TextureGen.ts
│   │       ├── ViewportHelper.ts
│   │       ├── ai
│   │       │   └── StateMachine.ts
│   │       └── coords.ts
│   ├── scene
│   │   ├── canvas
│   │   │   └── SceneCanvas.tsx
│   │   ├── effects
│   │   │   └── MatrixGrid.tsx
│   │   └── props
│   │       ├── MiniCrystalCanvas.tsx
│   │       └── SoulCrystal.tsx
│   ├── styles
│   │   └── globals.css
│   └── ui
│       ├── atoms
│       │   ├── CustomCursor.tsx
│       │   ├── GlassPanel.tsx
│       │   ├── PanelSparks.tsx
│       │   ├── SafePanelContent.tsx
│       │   ├── VirtualJoystick.tsx
│       │   ├── VitalsRing.tsx
│       │   └── ZenBomb.tsx
│       ├── molecules
│       │   ├── HoloCommLog.tsx
│       │   ├── IdentityFooter.tsx
│       │   ├── IdentityHUD.tsx
│       │   ├── LiveArtGrid.tsx
│       │   ├── SocialRow.tsx
│       │   ├── SystemOps.tsx
│       │   ├── UpgradeTerminal.tsx
│       │   └── panel
│       │       ├── BreachOverlay.tsx
│       │       ├── IntelligentHeader.tsx
│       │       └── RebootOverlay.tsx
│       ├── organisms
│       │   ├── Footer.tsx
│       │   └── Header.tsx
│       └── overlays
│           ├── ErrorBoundary.tsx
│           ├── GlobalBackdrop.tsx
│           └── ModalContainer.tsx
├── tailwind.config.ts
└── tsconfig.json

53 directories, 150 files

=====================================
FILE: ./next.config.js
=====================================
/** @type {import('next').NextConfig} */

let commitHash = 'DEV_BUILD';

try {
  const { execSync } = require('child_process');
  commitHash = execSync('git rev-parse --short HEAD').toString().trim();
} catch (error) {
  console.warn('Warning: Could not determine git commit hash.');
}

const nextConfig = {
  output: 'export',
  images: {
    unoptimized: true,
  },
  reactStrictMode: true,
  transpilePackages: ['three'],
  
  // Disable Indicators
  devIndicators: false,


  
  env: {
    NEXT_PUBLIC_COMMIT_HASH: commitHash,
  },
  
  typescript: {
    ignoreBuildErrors: true,
  },
  eslint: {
    ignoreDuringBuilds: true,
  },
}

module.exports = nextConfig


=====================================
FILE: ./docs/MESOELFY_OS_AI_INSTRUCTIONS.md
=====================================
I am developing "MESOELFY_OS," a 3D interactive portfolio site with a Cyberpunk/Hacker/Demoscene aesthetic. 

I have attached "all_source_code.txt" which contains the full project tree and code. Please ingest this to understand the current architecture.

***CORE IDENTITY & AESTHETIC***
*   **Persona:** You are assisting "Elfy," a Latent Space Bandit. The vibe is Y2K Hacker, Matrix, Geometry Wars, and High-Tech Demoscene.
*   **Palette:** Electric Green (#78F654) is dominant. Deep Purple (#9E4EA5) is secondary. Red/Yellow for alerts. Black backgrounds.
*   **Current Status:** The site is live at `mesoelfy.github.io`. The "Intro Boot Sequence" and "Main Dashboard" are built and polished.

***TECHNICAL STACK***
*   **Framework:** Next.js 14 (App Router) + TypeScript.
*   **Styling:** Tailwind CSS + Framer Motion (for UI animations).
*   **3D:** React Three Fiber (R3F) + Drei.
*   **Deployment:** GitHub Pages (Static Export).

***WORKFLOW RULES (CRITICAL)***
1.  **Terminal Only:** Do not ask me to manually create files. Provide full terminal commands using `cat << 'EOF' > path/to/file` to create or overwrite files.
2.  **No Placeholders:** Unless specified, write complete, functional code.
3.  **Atomic Commits:** After a successful feature implementation, provide the specific `git add .`, `git commit -m "..."`, and `git push` commands.
4.  **Lean Ship:** Keep dependencies low. Prefer procedural generation (shaders/math) over large assets.

Working directory:
stevencasteel@Stevens-Mac-mini mesoelfy-site % 


Please acknowledge you have analyzed the codebase.

=====================================
FILE: ./next-env.d.ts
=====================================
/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


=====================================
FILE: ./README.md
=====================================
<div align="center">

```text
 ███▄ ▄███▓▓█████  ██████  ▒█████  ▓█████  ██▓      █████▒▓██   ██▓
▓██▒▀█▀ ██▒▓█   ▀▒██    ▒ ▒██▒  ██▒▓█   ▀ ▓██▒    ▒▓█   ▒  ▒██  ██▒
▓██    ▓██░▒███  ░ ▓██▄   ▒██░  ██▒▒███   ▒██░    ▒▓███ ░   ▒██ ██░
▒██    ▒██ ▒▓█  ▄  ▒   ██▒▒██   ██░▒▓█  ▄ ▒██░    ░▓█▒  ░   ░ ▐██░░
▒██▒   ░██▒░▒████▒██████▒▒░ ████▓▒░░▒████▒░██████▒░▒█░      ░ ██▒░░
░ ▒░   ░  ░░░ ▒░ ░ ▒░▒  ░ ░ ▒░▒░▒░ ░░ ▒░ ░░ ▒░▒  ░ ▒ ░       ██▒▒▒
░  ░      ░ ░ ░  ░ ░ ▒  ░   ░ ▒ ▒░  ░ ░  ░░ ░ ▒  ░ ░       ▓██ ░▒░ 
░      ░      ░    ░ ░    ░ ░ ░ ▒     ░     ░ ░    ░ ░     ▒ ▒ ░░  
       ░      ░  ░   ░  ░     ░ ░     ░  ░    ░  ░         ░ ░     
```

### **LATENT SPACE BANDIT // DIGITAL HQ**

![System Status](https://img.shields.io/badge/SYSTEM-UNSECURE-ff003c?style=for-the-badge&logo=linux)
![Encryption](https://img.shields.io/badge/ENCRYPTION-BYPASSED-78F654?style=for-the-badge)
![Core](https://img.shields.io/badge/CORE-REACT_THREE_FIBER-9E4EA5?style=for-the-badge&logo=react)

</div>

---

### **// TRANSMISSION_LOG**

**MESOELFY_OS** is a generative 3D operating system disguised as a portfolio site. It serves as the central node for **Elfy**, a rogue entity manifesting art from the void.

The system features a custom "Latent Defense" protocol, audio-reactive interfaces, and a direct uplink to the neural network.

### **// SYSTEM_SPECS (Tech Stack)**

| MODULE | PAYLOAD |
| :--- | :--- |
| **Framework** | Next.js 14 (App Router) + TypeScript |
| **Graphics Core** | React Three Fiber (R3F) + Drei + Shaders |
| **Styling** | Tailwind CSS + Framer Motion |
| **Audio Engine** | Web Audio API (Generative Synthesis) |
| **Deployment** | GitHub Pages (Static Export) |

### **// BOOT_PROTOCOL (Installation)**

```bash
# 1. Clone the Repository
git clone https://github.com/mesoelfy/mesoelfy.github.io.git

# 2. Inject Dependencies
npm install

# 3. Initialize System (Dev Mode)
npm run dev
```

### **// IDENTITY_CORE**

*   **Class:** Latent Space Bandit
*   **Abilities:** Green Flame, Digital Heist, Prompt Craft
*   **Mission:** Create cool s**t. Annoy the haters.

---

<div align="center">
  <p><strong>⚠ WARNING: TRANSMISSIONS ARE MONITORED BY THE AI OVERLORD. ⚠</strong></p>
  <a href="https://x.com/mesoelfy">[ TWITTER_UPLINK ]</a> • <a href="https://mesoelfy.github.io">[ LAUNCH_OS ]</a>
</div>

=====================================
FILE: ./tailwind.config.ts
=====================================
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './src/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        // --- SEMANTIC PALETTE ---
        
        // The core system color (Safe, Online, Active)
        'primary-green': {
          light: '#7FF65F',
          DEFAULT: 'rgba(96, 196, 68, 1)',
          dim: '#1bb930ff',
          dark: '#217e10ff',
        },
        
        // Lore, Regeneration, Special Enemies
        'latent-purple': {
          light: '#BC86BA',
          DEFAULT: '#9E4EA5',
          dim: '#822B8A',
          deep: '#350E3A',
        },
        
        // Repair, Friendly AI, Constructive
        'service-cyan': {
          DEFAULT: '#00F0FF', 
          dim: '#008ba3',
        },
        
        // Warnings, Highlights, Interaction Focus
        'alert-yellow': {
          DEFAULT: '#eae747ff',
        },
        
        // Critical Failure, Enemies, Destruction
        'critical-red': {
          DEFAULT: '#FF003C', 
        },
        
        // Backgrounds and Structures
        'muted-gray': '#27282A',
        'void-black': '#050505',
        
        // --- LEGACY GAME TOKENS (Keep for Logic/Canvas referencing if needed) ---
        game: {
          turret: {
            base: '#78F654',
            glow: '#C2FE9A',
          },
          bullet: {
            plasma: '#FFFFFF', 
            trail: '#78F654',
          },
          enemy: {
            seeker: '#9E4EA5',
            eater: '#FF003C',
            boss: '#F7D277',
          },
          hud: {
            text: '#78F654',
            warning: '#FF003C',
          },
          vfx: {
            spark: '#FFFFFF',
            damage: '#FF003C',
          }
        }
      },
      fontFamily: {
        header: ['var(--font-montserrat)', 'sans-serif'],
        mono: ['Courier New', 'Courier', 'monospace'],
        tech: ['var(--font-jetbrains)', 'monospace'],
      },
      animation: {
        'spin-slow': 'spin 3s linear infinite',
        'spin-diamond': 'spin-diamond 3s linear infinite',
        'matrix-green': 'matrix-green 4s ease-in-out infinite',
        'matrix-purple': 'matrix-purple 2s ease-in-out infinite',
        'cursor-blink': 'cursor-blink 1.2s ease-in-out infinite',
      },
      keyframes: {
        'spin-diamond': {
          '0%': { transform: 'rotate(45deg)' },
          '100%': { transform: 'rotate(405deg)' },
        },
        'matrix-green': {
          '0%, 100%': { color: '#14630bff' },
          '50%': { color: '#0aa41cff' },
        },
        'matrix-purple': {
          '0%, 100%': { color: '#9E4EA5' }, 
          '33%': { color: '#BC86BA' },      
          '66%': { color: '#350E3A' },      
        },
        'cursor-blink': {
          '0%, 30%': { opacity: '1' }, 
          '50%': { opacity: '0' },     
          '100%': { opacity: '1' },    
        }
      }
    },
  },
  plugins: [],
}
export default config


=====================================
FILE: ./package.json
=====================================
{
  "name": "mesoelfy-site",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@react-three/drei": "^10.7.7",
    "@react-three/fiber": "^9.4.2",
    "@react-three/postprocessing": "^2.19.1",
    "clsx": "^2.1.0",
    "framer-motion": "^11.0.0",
    "lucide-react": "^0.300.0",
    "maath": "^0.10.0",
    "next": "^16.0.7",
    "react": "^19.2.1",
    "react-dom": "^19.2.1",
    "tailwind-merge": "^2.2.0",
    "three": "^0.181.2",
    "zustand": "^4.5.0"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@types/three": "^0.181.0",
    "autoprefixer": "^10.0.1",
    "eslint": "^9.39.1",
    "eslint-config-next": "^16.0.7",
    "postcss": "^8",
    "tailwindcss": "^3.3.0",
    "typescript": "^5"
  }
}


=====================================
FILE: ./tsconfig.json
=====================================
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./src/*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}


=====================================
FILE: ./postcss.config.js
=====================================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


=====================================
FILE: ./src/ui/molecules/SocialRow.tsx
=====================================
import { Twitter, Youtube, Github, Video, Crosshair, Image as ImageIcon, AlertTriangle } from 'lucide-react';
import socials from '@/data/socials.json';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { useGameStore } from '@/game/store/useGameStore';
import { clsx } from 'clsx';

const IconMap: Record<string, any> = {
  twitter: Twitter,
  youtube: Youtube,
  github: Github,
  video: Video,
  crosshair: Crosshair,
  image: ImageIcon,
};

export const SocialRow = () => {
  const panelState = useGameStore((state) => state.panels['social']);
  const isDestroyed = panelState ? panelState.isDestroyed : false;

  return (
    <div className={clsx(
        "grid grid-cols-3 gap-2 h-full content-center py-2 relative px-2",
        isDestroyed ? "pointer-events-none" : "" 
    )}>
      {socials.map((social, idx) => {
        const Icon = isDestroyed ? AlertTriangle : (IconMap[social.icon] || Crosshair);
        const isGlitch = isDestroyed && (idx % 2 === 0);
        
        return (
          <a
            key={social.name}
            href={isDestroyed ? undefined : social.url}
            target="_blank"
            rel="noopener noreferrer"
            onMouseEnter={() => !isDestroyed && AudioSystem.playHover()} 
            onClick={() => !isDestroyed && AudioSystem.playClick()}
            className={clsx(
                "group flex flex-col items-center justify-center p-2 border transition-all duration-200",
                isDestroyed 
                    ? "border-critical-red/20 bg-critical-red/5 grayscale" 
                    : "border-primary-green-dim/30 bg-black/40 hover:bg-alert-yellow/5 hover:border-alert-yellow hover:shadow-[0_0_15px_rgba(234,231,71,0.15)]"
            )}
          >
            <Icon 
              className={clsx(
                  "w-5 h-5 mb-1 transition-transform duration-200",
                  isDestroyed ? "text-critical-red animate-pulse" : "text-primary-green-dim group-hover:text-alert-yellow group-hover:scale-110",
                  isGlitch ? "translate-x-1" : ""
              )}
              style={!isDestroyed ? { filter: 'drop-shadow(0 0 2px rgba(0,0,0,0.5))' } : {}}
            />
            <span className={clsx(
                "text-[9px] uppercase tracking-wider font-mono transition-colors duration-200",
                isDestroyed ? "text-critical-red/60" : "text-primary-green-dim/60 group-hover:text-alert-yellow"
            )}>
              {isDestroyed ? (isGlitch ? "ERR_404" : "NULL") : social.name.split(' ')[0]}
            </span>
          </a>
        );
      })}
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/panel/BreachOverlay.tsx
=====================================
import { motion } from 'framer-motion';
import { ChevronUp } from 'lucide-react';
import { clsx } from 'clsx';

const ScrollingRow = ({ direction, text }: { direction: number, text: string }) => {
  return (
    <div className="flex whitespace-nowrap overflow-hidden select-none opacity-60">
      <motion.div 
        className="flex gap-4 font-header font-black text-xl md:text-2xl text-critical-red tracking-widest uppercase py-1"
        animate={{ x: direction === 1 ? ["-50%", "0%"] : ["0%", "-50%"] }} 
        transition={{ duration: 40, repeat: Infinity, ease: "linear" }}
      >
        {Array.from({ length: 12 }).map((_, i) => (
          <span key={i} className={i % 2 === 0 ? "text-critical-red" : "text-transparent stroke-critical-red stroke-1"}>
             {text}
          </span>
        ))}
      </motion.div>
    </div>
  );
};

interface BreachOverlayProps {
  progress: number;
  isVideo: boolean;
  showInteractive: boolean;
}

export const BreachOverlay = ({ progress, isVideo, showInteractive }: BreachOverlayProps) => {
  // Safety: Ensure progress is a valid number for CSS width
  const safeProgress = (Number.isFinite(progress) && !isNaN(progress)) 
    ? Math.max(0, Math.min(100, progress)) 
    : 0;

  return (
    <div className={clsx(
        "absolute inset-0 z-[70] flex flex-col items-center justify-center overflow-hidden",
        isVideo ? "bg-black/20 backdrop-blur-[2px]" : "bg-black/60 backdrop-blur-sm"
    )}>
        {/* Background Scrolling Text */}
        <div className="absolute inset-[-50%] flex flex-col justify-center rotate-[-12deg] opacity-30 pointer-events-none">
            <motion.div
               className="flex flex-col gap-8"
               animate={{ y: ["0%", "-50%"] }}
               transition={{ duration: 30, repeat: Infinity, ease: "linear" }}
            >
                {[0, 1].map((set) => (
                    <div key={set} className="flex flex-col gap-8">
                        {Array.from({ length: 6 }).map((_, i) => (
                            <ScrollingRow 
                                key={`${set}-${i}`} 
                                direction={i % 2 === 0 ? 1 : -1} 
                                text="SYSTEM BREACH // CRITICAL FAILURE // REBOOT REQUIRED //" 
                            />
                        ))}
                    </div>
                ))}
            </motion.div>
        </div>

        {/* Interactive Reboot UI */}
        {showInteractive && (
          <div className="relative z-20 flex flex-col items-center justify-center gap-2 cursor-crosshair transition-all duration-100">
              <div className="relative">
                  <div className="group-hover:opacity-0 transition-opacity duration-200 absolute inset-0 flex items-center justify-center">
                      <motion.div 
                          animate={{ y: [0, -10, 0] }}
                          transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }}
                          className="text-critical-red drop-shadow-md"
                      >
                          <ChevronUp size={64} strokeWidth={3} />
                      </motion.div>
                  </div>

                  <div className="opacity-0 group-hover:opacity-100 transition-opacity duration-200 absolute inset-0 flex items-center justify-center -translate-y-8">
                      <motion.div 
                          animate={{ scale: [1, 1.2, 1], filter: ["brightness(1)", "brightness(1.5)", "brightness(1)"] }}
                          transition={{ duration: 0.2, repeat: Infinity, ease: "easeInOut" }}
                          className="text-latent-purple drop-shadow-[0_0_15px_#9E4EA5]"
                      >
                          <ChevronUp size={64} strokeWidth={4} />
                      </motion.div>
                  </div>
                  
                  <div className="w-16 h-16 pointer-events-none opacity-0"><ChevronUp size={64} /></div>
              </div>

              <div className="flex flex-col items-center text-center">
                  <span className="text-sm font-header font-black tracking-widest text-critical-red group-hover:text-latent-purple transition-colors duration-200 drop-shadow-md">
                      HOLD TO REBOOT
                  </span>
                  
                  {/* Progress Bar Container */}
                  <div className="w-32 bg-gray-900/80 h-1.5 mt-2 rounded-full overflow-hidden border border-gray-700 shadow-lg">
                      <motion.div 
                          className="h-full bg-latent-purple shadow-[0_0_10px_#9E4EA5]" 
                          initial={{ width: "0%" }}
                          animate={{ width: `${safeProgress}%` }}
                          transition={{ type: "tween", duration: 0.1 }}
                      />
                  </div>
                  
                  <div className="text-[10px] font-mono text-latent-purple font-bold mt-1 opacity-0 group-hover:opacity-100 transition-opacity bg-black/60 px-2 rounded">
                      INTEGRITY: {Math.floor(safeProgress)}%
                  </div>
              </div>
          </div>
        )}
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/panel/RebootOverlay.tsx
=====================================
import { motion } from 'framer-motion';
import { Power } from 'lucide-react';

export const RebootOverlay = () => (
  <motion.div 
    initial={{ opacity: 0, scale: 0.8 }}
    animate={{ opacity: 1, scale: 1 }}
    exit={{ opacity: 0, scale: 1.1, filter: "blur(10px)" }}
    transition={{ duration: 0.4, ease: "backOut" }}
    className="absolute inset-0 z-[60] flex items-center justify-center bg-black/80 backdrop-blur-[2px]"
  >
    <div className="flex flex-col items-center gap-2 border-y-2 border-primary-green bg-primary-green/10 w-full py-4 relative overflow-hidden">
      <motion.div 
        className="absolute top-0 left-0 w-full h-full bg-gradient-to-b from-transparent via-primary-green/20 to-transparent"
        animate={{ top: ["-100%", "100%"] }}
        transition={{ duration: 1.5, ease: "linear", repeat: Infinity }}
      />
      <div className="relative z-10 flex items-center gap-3">
        <motion.div
          initial={{ rotate: -180, scale: 0 }}
          animate={{ rotate: 0, scale: 1 }}
          transition={{ type: "spring", stiffness: 200, delay: 0.1 }}
        >
            <Power className="text-primary-green w-8 h-8 md:w-10 md:h-10" />
        </motion.div>
        <div className="flex flex-col">
            <motion.span 
                initial={{ x: 20, opacity: 0 }}
                animate={{ x: 0, opacity: 1 }}
                transition={{ delay: 0.2 }}
                className="text-2xl md:text-3xl font-header font-black text-primary-green tracking-widest italic"
            >
                SYSTEM
            </motion.span>
            <motion.span 
                initial={{ x: -20, opacity: 0 }}
                animate={{ x: 0, opacity: 1 }}
                transition={{ delay: 0.3 }}
                className="text-xs md:text-sm font-mono font-bold text-primary-green-dim tracking-[0.3em]"
            >
                RESTORED
            </motion.span>
        </div>
      </div>
    </div>
  </motion.div>
);


=====================================
FILE: ./src/ui/molecules/panel/IntelligentHeader.tsx
=====================================
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useGameStore } from '@/game/store/useGameStore';
import { Skull, Zap, Power, RefreshCw, AlertTriangle, Check } from 'lucide-react';
import { clsx } from 'clsx';
import { AudioSystem } from '@/core/audio/AudioSystem';

const MAX_HEALTH = 1000;

interface IntelligentHeaderProps {
  title: string;
  health: number;
  isDestroyed: boolean;
  isGameOver: boolean;
  gameId?: string;
}

export const IntelligentHeader = ({ title, health, isDestroyed, isGameOver, gameId }: IntelligentHeaderProps) => {
  const interactionTarget = useGameStore(state => state.interactionTarget);
  const isInteracting = gameId && interactionTarget === gameId;
  
  let rawPercent = (health / MAX_HEALTH) * 100;
  if (!Number.isFinite(rawPercent) || isNaN(rawPercent)) rawPercent = 0;
  const healthPercent = Math.max(0, Math.min(100, rawPercent));

  const isDamaged = !isDestroyed && healthPercent < 100;

  const [showOptimal, setShowOptimal] = useState(false);

  useEffect(() => {
    if (health < MAX_HEALTH) {
      setShowOptimal(true);
    }
    if (health >= MAX_HEALTH && showOptimal) {
      AudioSystem.playSound('ui_optimal'); 
      const timer = setTimeout(() => setShowOptimal(false), 1500);
      return () => clearTimeout(timer);
    }
  }, [health, showOptimal]);

  let mainColor = "text-primary-green";
  let statusText = "SECURE";
  
  if (isGameOver) {
      mainColor = "text-critical-red";
      statusText = "SYSTEM_FAILURE";
  } else if (isDestroyed) {
      mainColor = isInteracting ? "text-latent-purple" : "text-critical-red";
      statusText = isInteracting ? "REBOOTING..." : "OFFLINE";
  } else if (isInteracting && isDamaged) {
      mainColor = "text-service-cyan";
      statusText = "HEALING...";
  } else if (isDamaged) {
      mainColor = "text-alert-yellow"; 
      statusText = "ATTENTION_REQ";
  } else if (!showOptimal) {
      mainColor = "text-primary-green-dim";
      statusText = "ONLINE";
  }

  return (
    <div className={clsx(
        "relative flex flex-col border-b transition-colors duration-300 shrink-0 z-10",
        isGameOver ? "bg-critical-red/10 border-critical-red/50" :
        isDestroyed ? (isInteracting ? "bg-latent-purple/10 border-latent-purple/50" : "bg-critical-red/10 border-critical-red/50") :
        (isInteracting && isDamaged) ? "bg-service-cyan/10 border-service-cyan/50" :
        isDamaged ? "bg-alert-yellow/10 border-alert-yellow/30" : 
        "bg-primary-green/5 border-primary-green-dim/30"
    )}>
        <div className="flex items-center justify-between px-3 py-1.5 h-8">
            <div className="flex items-baseline gap-2">
                <span className={clsx("text-sm md:text-base font-header font-bold uppercase tracking-wider drop-shadow-md transition-colors duration-300", mainColor)}>
                    {title}
                </span>
                <span className={clsx("text-[8px] font-mono tracking-widest opacity-80", mainColor)}>
                    [{statusText}]
                </span>
            </div>

            <div className="w-5 h-5 flex items-center justify-center">
                <AnimatePresence mode="wait">
                    {isGameOver ? (
                        <motion.div 
                            key="gameover"
                            initial={{ scale: 0, rotate: -90 }}
                            animate={{ scale: 1, rotate: 0 }}
                            className="text-critical-red drop-shadow-[0_0_8px_currentColor]"
                        >
                            <Skull size={16} />
                        </motion.div>
                    ) : isDestroyed ? (
                        isInteracting ? (
                            <motion.div 
                                key="rebooting"
                                initial={{ scale: 0 }}
                                animate={{ scale: 1 }}
                                className="w-4 h-4 bg-latent-purple rounded-full flex items-center justify-center shadow-[0_0_10px_currentColor]"
                            >
                                <motion.div animate={{ rotate: 360, opacity: [0.6, 1, 0.6] }} transition={{ duration: 0.5, repeat: Infinity }}>
                                    <Zap size={10} className="text-black fill-current" />
                                </motion.div>
                            </motion.div>
                        ) : (
                            <motion.div 
                                key="destroyed"
                                initial={{ scale: 0 }}
                                animate={{ scale: 1 }}
                                className="w-4 h-4 border border-latent-purple rounded-full flex items-center justify-center opacity-80"
                            >
                                <Power size={10} className="text-latent-purple" />
                            </motion.div>
                        )
                    ) : isInteracting && isDamaged ? (
                        <motion.div 
                            key="healing"
                            initial={{ scale: 0 }}
                            animate={{ scale: 1 }}
                            className="w-4 h-4 bg-service-cyan rounded-full flex items-center justify-center shadow-[0_0_10px_currentColor]"
                        >
                            <motion.div animate={{ rotate: 360 }} transition={{ duration: 1, repeat: Infinity, ease: "linear" }}>
                                <RefreshCw size={10} className="text-black" />
                            </motion.div>
                        </motion.div>
                    ) : isDamaged ? (
                        <motion.div 
                            key="damaged"
                            initial={{ opacity: 1, scale: 1 }}
                            animate={{ 
                                x: [-2, 2, -2, 2, -2, 2, 0, 0, 0, 0, 0, 0, 0], 
                                filter: [
                                    'drop-shadow(0 0 0px rgba(234,231,71,0))',
                                    'drop-shadow(0 0 8px rgba(234,231,71,1))', 
                                    'drop-shadow(0 0 0px rgba(234,231,71,0))'
                                ]
                            }}
                            transition={{ duration: 1.5, repeat: Infinity, ease: "linear" }}
                            className="text-alert-yellow"
                        >
                            <AlertTriangle size={16} />
                        </motion.div>
                    ) : showOptimal ? (
                        <motion.div 
                            key="optimal"
                            initial={{ scale: 0 }}
                            animate={{ scale: 1 }}
                            exit={{ scale: 0, opacity: 0 }}
                            className="w-4 h-4 bg-primary-green rounded-full flex items-center justify-center shadow-[0_0_5px_currentColor]"
                        >
                            <Check size={10} className="text-black stroke-[3px]" />
                        </motion.div>
                    ) : null}
                </AnimatePresence>
            </div>
        </div>

        {!isGameOver && (
            <div className="w-full h-1 bg-black/50 relative overflow-hidden">
                <motion.div 
                    className={clsx(
                        "h-full transition-colors duration-200",
                        (isDestroyed && isInteracting) ? "bg-latent-purple shadow-[0_0_10px_#9E4EA5]" :
                        isDestroyed ? "bg-transparent" : 
                        (isInteracting && isDamaged) ? "bg-service-cyan" :
                        isDamaged ? "bg-alert-yellow" : 
                        "bg-primary-green"
                    )}
                    initial={{ width: "100%" }}
                    animate={{ width: `${healthPercent}%` }}
                    transition={{ type: "tween", ease: "easeOut", duration: 0.1 }}
                />
            </div>
        )}
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/HoloCommLog.tsx
=====================================
import { useEffect, useState, useRef, useCallback } from 'react';
import { ExternalLink, Radio, WifiOff } from 'lucide-react';
import { useGameStore } from '@/game/store/useGameStore';
import { AudioSystem } from '@/core/audio/AudioSystem';

const VIDEO_POOL = [
  "oLALHbB3iXU", "A1dnxXrpN-o", "elyXcwunIYA", 
  "bHUcvHx9zlA", "Eq6EYcpWB_c", "sJyWgks1ZtA", 
  "dFlDRhvM4L0", "Ku5fgOHy1JY", "8-91y7BJ8QA"
];

const OfflineStatic = () => (
  <div className="absolute inset-0 z-[50] bg-black flex flex-col items-center justify-center border border-critical-red/20 overflow-hidden w-full h-full">
    <div className="absolute inset-0 bg-[url('https://media.giphy.com/media/oEI9uBYSzLpBK/giphy.gif')] opacity-40 bg-cover mix-blend-screen pointer-events-none" />
    <div className="relative z-10 animate-pulse text-critical-red font-mono text-[10px] bg-black/80 px-2 py-1 flex items-center gap-2">
        <WifiOff size={12} />
        <span>SIGNAL_LOST</span>
    </div>
  </div>
);

const VideoSlot = ({ 
  slotIndex, 
  initialVideo, 
  getNextVideo
}: { 
  slotIndex: number, 
  initialVideo: string, 
  getNextVideo: () => string
}) => {
  const [videoId, setVideoId] = useState(initialVideo);
  const [isMasked, setIsMasked] = useState(true); 

  const panelState = useGameStore((state) => state.panels['video']);
  const isOffline = panelState ? (panelState.isDestroyed || panelState.health <= 0) : false;
  
  const prevOffline = useRef(isOffline);

  useEffect(() => {
    if (isOffline && !prevOffline.current) {
        setIsMasked(true); 
    }
    
    if (!isOffline && prevOffline.current) {
        setVideoId(getNextVideo()); 
        setIsMasked(true); 
        
        const t = setTimeout(() => setIsMasked(false), 2000);
        
        prevOffline.current = isOffline;
        return () => clearTimeout(t);
    }

    if (!isOffline && isMasked) {
         const t = setTimeout(() => setIsMasked(false), 2000);
         return () => clearTimeout(t);
    }
    
    prevOffline.current = isOffline;
  }, [isOffline, getNextVideo]);

  useEffect(() => {
    if (isOffline) return; 

    const duration = 30000 + (Math.random() * 15000);
    
    const rotateTimer = setTimeout(() => {
      setIsMasked(true);
      
      const swapTimer = setTimeout(() => {
        setVideoId(getNextVideo());
        
        const unmaskTimer = setTimeout(() => {
            setIsMasked(false);
        }, 2000);
        
        return () => clearTimeout(unmaskTimer);
      }, 1000); 
      
      return () => clearTimeout(swapTimer);
    }, duration);

    return () => clearTimeout(rotateTimer);
  }, [videoId, isOffline, getNextVideo]);

  return (
    <div 
        className="relative w-full aspect-video min-h-[140px] md:min-h-0 border border-primary-green-dim/30 bg-black overflow-hidden group/video hover:border-alert-yellow hover:shadow-[0_0_15px_rgba(234,231,71,0.3)] transition-all"
        onMouseEnter={() => !isOffline && AudioSystem.playHover()}
    >
      
      {isOffline ? (
          <OfflineStatic />
      ) : (
        <>
          <div className="absolute inset-0 z-10">
            <iframe 
              key={videoId} 
              width="100%" 
              height="100%" 
              src={`https://www.youtube.com/embed/${videoId}?autoplay=1&mute=1&controls=0&showinfo=0&modestbranding=1&loop=1&playlist=${videoId}&vq=small`} 
              title="HOLO_COMM" 
              frameBorder="0" 
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
              className="w-full h-full object-cover grayscale"
            />
          </div>

          <div className="absolute inset-0 z-30 pointer-events-none bg-[linear-gradient(rgba(0,0,0,0)_50%,rgba(0,0,0,0.25)_50%)] bg-[length:100%_4px]" />
          
          <div className={`absolute inset-0 z-40 transition-opacity duration-500 flex items-center justify-center pointer-events-none ${isMasked ? 'opacity-100 bg-black' : 'opacity-0 group-hover/video:opacity-100 bg-black/40'}`}>
             {isMasked ? (
                <div className="flex flex-col items-center">
                    <Radio className="text-primary-green animate-pulse w-6 h-6 mb-2" />
                    <span className="text-[10px] font-mono text-primary-green animate-pulse">ESTABLISHING_UPLINK...</span>
                </div>
             ) : (
                 <div className="flex items-center gap-2 text-alert-yellow font-mono font-bold bg-black/80 px-3 py-1 border border-alert-yellow rounded-sm pointer-events-auto">
                    <span>OPEN_SOURCE</span>
                    <ExternalLink size={12} />
                 </div>
             )}
          </div>
          
          <a 
            href={`https://www.youtube.com/watch?v=${videoId}`}
            target="_blank"
            rel="noopener noreferrer"
            className="absolute inset-0 z-50 cursor-pointer"
            aria-label="Watch on YouTube"
            onClick={() => AudioSystem.playClick()}
          />

          <div className="absolute bottom-1 right-1 z-[60] text-[8px] text-primary-green font-mono bg-black/80 px-1 pointer-events-none group-hover/video:text-alert-yellow transition-colors">
             CAM_0{slotIndex + 1}
          </div>
        </>
      )}
      
      {isOffline && (
          <div className="absolute bottom-1 right-1 z-[60] text-[8px] text-critical-red font-mono bg-black/80 px-1 pointer-events-none">
             CAM_0{slotIndex + 1} [ERR]
          </div>
      )}
    </div>
  );
};

export const HoloCommLog = () => {
  const deckRef = useRef<string[]>([...VIDEO_POOL]);
  const [initialVideos, setInitialVideos] = useState<string[] | null>(null);

  useEffect(() => {
    deckRef.current = [...VIDEO_POOL];
    const init: string[] = [];
    for(let i=0; i<3; i++) {
      const randomIndex = Math.floor(Math.random() * deckRef.current.length);
      const vid = deckRef.current[randomIndex];
      deckRef.current.splice(randomIndex, 1);
      init.push(vid);
    }
    setInitialVideos(init);
  }, []);

  const getNextVideo = useCallback(() => {
    if (deckRef.current.length === 0) deckRef.current = [...VIDEO_POOL];
    const randomIndex = Math.floor(Math.random() * deckRef.current.length);
    const selected = deckRef.current[randomIndex];
    deckRef.current.splice(randomIndex, 1);
    return selected || VIDEO_POOL[0];
  }, []);

  if (!initialVideos) return <div className="h-full bg-black" />;

  return (
    <div className="flex flex-col h-full gap-2 overflow-hidden p-1 justify-center">
      {initialVideos.map((vid, i) => (
        <VideoSlot 
          key={i} 
          slotIndex={i} 
          initialVideo={vid} 
          getNextVideo={getNextVideo}
        />
      ))}
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/SystemOps.tsx
=====================================
import { useGameStore } from '@/game/store/useGameStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { Unplug, Biohazard, CircleDotDashed, AlertTriangle } from 'lucide-react';
import { UpgradeOption } from '@/game/types/game.types';

const SYSTEM_OPS: UpgradeOption[] = ['REPAIR_NANITES', 'RESTORE', 'PURGE'];

const OP_INFO: Record<string, { label: string, desc: string, icon: any }> = {
  'PURGE': { label: 'Purge', desc: 'Nuke Screen', icon: Biohazard },
  'RESTORE': { label: 'Restore', desc: 'Heal System', icon: CircleDotDashed },
  'REPAIR_NANITES': { label: 'Repair', desc: 'Heal Self', icon: Unplug }
};

interface SystemOpsProps {
  isPanelDead: boolean;
}

export const SystemOps = ({ isPanelDead }: SystemOpsProps) => {
  const upgradePoints = useGameStore(s => s.upgradePoints);
  const selectUpgrade = useGameStore(s => s.selectUpgrade);

  const handleUpgrade = (u: UpgradeOption) => {
      if (isPanelDead || upgradePoints <= 0) return; 
      AudioSystem.playClick();
      selectUpgrade(u);
  };

  if (upgradePoints <= 0) return null;

  return (
    <div className="flex flex-col gap-1.5 mt-4">
        <span className="text-[8px] font-bold text-alert-yellow/50 uppercase tracking-widest px-1">System_Ops</span>
        {SYSTEM_OPS.map(u => {
            const info = OP_INFO[u];
            const Icon = info.icon;
            
            return (
                <button
                    key={u}
                    onClick={() => handleUpgrade(u)}
                    onMouseEnter={() => !isPanelDead && AudioSystem.playHover()}
                    className="group relative flex items-center justify-between p-2 border border-alert-yellow/30 bg-alert-yellow/5 hover:border-alert-yellow transition-all duration-200 overflow-hidden"
                >
                    <div className="absolute inset-0 translate-x-[-100%] group-hover:translate-x-0 transition-transform duration-300 ease-out bg-alert-yellow opacity-20" />
                    
                    <div className="flex items-center gap-3 relative z-10">
                        <div className="p-1.5 rounded-sm bg-alert-yellow/10 text-alert-yellow group-hover:bg-alert-yellow group-hover:text-black">
                            <Icon size={14} />
                        </div>
                        <div className="flex flex-col items-start">
                            <span className="text-[10px] font-bold font-header tracking-wider uppercase text-alert-yellow">
                                {info.label}
                            </span>
                            <span className="text-[8px] text-gray-400 font-mono group-hover:text-white">
                                {info.desc}
                            </span>
                        </div>
                    </div>
                    
                    <AlertTriangle size={12} className="text-alert-yellow/50 group-hover:text-alert-yellow" />
                </button>
            );
        })}
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/UpgradeTerminal.tsx
=====================================
import { useGameStore } from '@/game/store/useGameStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { Zap, Swords, Wifi, GitFork, Gitlab, DoorOpen, Bot, ArrowUpCircle } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { UpgradeOption } from '@/game/types/game.types';

const CORE_UPGRADES: UpgradeOption[] = ['OVERCLOCK', 'EXECUTE', 'BANDWIDTH', 'FORK', 'SNIFFER', 'BACKDOOR', 'DAEMON'];

const UPGRADE_INFO: Record<string, { label: string, desc: string, icon: any }> = {
  'OVERCLOCK': { label: 'Overclock', desc: 'Fire Rate ++', icon: Zap },
  'EXECUTE': { label: 'Execute', desc: 'Damage ++', icon: Swords },
  'BANDWIDTH': { label: 'Bandwidth', desc: 'Size ++', icon: Wifi },
  'FORK': { label: 'Fork', desc: 'Multishot ++', icon: GitFork }, 
  'SNIFFER': { label: 'Sniffer', desc: 'Homing', icon: Gitlab }, 
  'BACKDOOR': { label: 'Backdoor', desc: 'Rear Guard', icon: DoorOpen }, 
  'DAEMON': { label: 'Daemon', desc: 'Summon Ally', icon: Bot },
};

interface UpgradeTerminalProps {
  isPanelDead: boolean;
}

export const UpgradeTerminal = ({ isPanelDead }: UpgradeTerminalProps) => {
  // Granular Selectors
  const upgradePoints = useGameStore(s => s.upgradePoints);
  const activeUpgrades = useGameStore(s => s.activeUpgrades);
  const selectUpgrade = useGameStore(s => s.selectUpgrade);

  const handleUpgrade = (u: UpgradeOption) => {
      if (isPanelDead || upgradePoints <= 0) return; 
      AudioSystem.playClick();
      selectUpgrade(u);
  };

  return (
    <AnimatePresence mode="wait">
      {upgradePoints > 0 ? (
        <motion.div 
            key="upgrades"
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            className="flex flex-col gap-4"
        >
            <div className="flex items-center gap-2 pb-1 border-b border-primary-green/20 pt-2">
                <ArrowUpCircle size={12} className="text-primary-green animate-bounce" />
                <span className="text-[9px] font-bold text-primary-green tracking-widest">
                    SYSTEM_UPGRADE_AVAILABLE [{upgradePoints}]
                </span>
            </div>

            <div className="flex flex-col gap-1.5">
                <span className="text-[8px] font-bold text-primary-green-dim/50 uppercase tracking-widest px-1">Kernel_Modules</span>
                {CORE_UPGRADES.map(u => {
                    const info = UPGRADE_INFO[u];
                    const Icon = info.icon;
                    const currentLvl = activeUpgrades[u] || 0;

                    return (
                        <button
                            key={u}
                            onClick={() => handleUpgrade(u)}
                            onMouseEnter={() => !isPanelDead && AudioSystem.playHover()}
                            className="group relative flex items-center justify-between p-2 border border-primary-green-dim/30 bg-black/40 hover:border-primary-green transition-all duration-200 overflow-hidden"
                        >
                            <div className="absolute inset-0 translate-x-[-100%] group-hover:translate-x-0 transition-transform duration-300 ease-out bg-primary-green opacity-20" />
                            
                            <div className="flex items-center gap-3 relative z-10">
                                <div className="p-1.5 rounded-sm bg-primary-green/10 text-primary-green group-hover:bg-primary-green group-hover:text-black">
                                    <Icon size={14} />
                                </div>
                                <div className="flex flex-col items-start">
                                    <span className="text-[10px] font-bold font-header tracking-wider uppercase text-primary-green">
                                        {info.label}
                                    </span>
                                    <span className="text-[8px] text-gray-400 font-mono group-hover:text-white">
                                        {info.desc}
                                    </span>
                                </div>
                            </div>

                            <div className="text-[9px] font-mono text-primary-green-dim border border-primary-green-dim/30 px-1.5 py-0.5 rounded bg-black/50 group-hover:border-primary-green group-hover:text-primary-green relative z-10">
                                v{currentLvl}
                            </div>
                        </button>
                    );
                })}
            </div>
        </motion.div>
      ) : (
        <motion.div 
            key="status"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            className="h-full flex flex-col justify-center items-center text-center opacity-40 font-mono space-y-2 p-4 rounded bg-black/20 marching-ants [--ant-color:rgba(255,255,255,0.1)]"
        >
            <div className="w-8 h-8 rounded-full border border-white/20 flex items-center justify-center animate-spin-slow">
                <div className="w-1 h-1 bg-white/50 rounded-full" />
            </div>
            <span className="text-[9px] tracking-widest">SYSTEM_OPTIMIZED</span>
            <span className="text-[8px]">WAITING FOR DATA...</span>
        </motion.div>
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/molecules/LiveArtGrid.tsx
=====================================
import { useEffect, useState } from 'react';
import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { motion, AnimatePresence } from 'framer-motion';
import { clsx } from 'clsx';

const randomId = () => Math.floor(Math.random() * 899) + 100;

export const LiveArtGrid = () => {
  const { openModal } = useStore();
  const [slots, setSlots] = useState<number[]>([]);
  
  const panelState = useGameStore((state) => state.panels['art']);
  const isDestroyed = panelState ? panelState.isDestroyed : false;

  useEffect(() => {
    setSlots(Array.from({ length: 12 }, randomId));

    const interval = setInterval(() => {
      setSlots(prev => {
        const newSlots = [...prev];
        const randomIndex = Math.floor(Math.random() * 12);
        newSlots[randomIndex] = randomId();
        return newSlots;
      });
    }, 800);

    return () => clearInterval(interval);
  }, []);

  return (
    <div className={clsx(
        "grid grid-cols-3 gap-1 w-full p-2 content-start transition-opacity duration-500",
        isDestroyed ? "pointer-events-none opacity-80" : ""
    )}>
      <AnimatePresence mode='popLayout'>
        {slots.map((id, index) => {
            const isCorrupt = isDestroyed;
            
            return (
              <motion.button
                key={`${index}-${id}`}
                layout
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                transition={{ duration: 0.2 }}
                
                onClick={() => {
                    if (isDestroyed) return;
                    AudioSystem.playClick();
                    openModal('gallery');
                }}
                onMouseEnter={() => !isDestroyed && AudioSystem.playHover()}
                
                className={clsx(
                    "w-full aspect-square relative border group overflow-hidden flex items-center justify-center rounded-[1px] transition-colors",
                    isCorrupt 
                        ? "bg-black border-critical-red/20" 
                        : "bg-black/50 border-primary-green-dim/30 hover:border-alert-yellow hover:shadow-[0_0_10px_rgba(247,210,119,0.2)]"
                )}
              >
                <div className={clsx(
                    "absolute inset-0 transition-colors",
                    isCorrupt ? "bg-critical-red/5" : "bg-primary-green/5 group-hover:bg-primary-green/10"
                )} />
                
                <span className={clsx(
                    "relative z-10 text-[9px] font-mono transition-colors",
                    isCorrupt ? "text-critical-red/50 animate-pulse" : "text-primary-green-dim group-hover:text-alert-yellow"
                )}>
                  {isCorrupt ? (Math.random() > 0.5 ? "0x00" : "ERR") : `IMG_${id}`}
                </span>

                {!isCorrupt && (
                    <div className="absolute top-0 right-0 w-1.5 h-1.5 border-t border-r border-primary-green-dim/50 group-hover:border-alert-yellow" />
                )}
              </motion.button>
            );
        })}
      </AnimatePresence>
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/IdentityFooter.tsx
=====================================
import { useStore } from '@/core/store/useStore';
import { AudioSystem } from '@/core/audio/AudioSystem';

interface IdentityFooterProps {
  isPanelDead: boolean;
}

export const IdentityFooter = ({ isPanelDead }: IdentityFooterProps) => {
  const { openModal } = useStore();

  const handleClick = (modal: 'about' | 'contact') => {
      if (isPanelDead) return;
      AudioSystem.playClick();
      openModal(modal);
  };

  return (
    <div className="flex-none grid grid-cols-2 gap-px bg-primary-green-dim/20 border-t border-primary-green-dim/30 mt-auto">
      <button 
        onClick={() => handleClick('about')} 
        onMouseEnter={() => !isPanelDead && AudioSystem.playHover()}
        className="py-3 bg-black/80 hover:bg-primary-green hover:text-black text-primary-green text-[10px] font-bold font-header uppercase transition-colors tracking-widest"
      >
        About_Me
      </button>
      <button 
        onClick={() => handleClick('contact')} 
        onMouseEnter={() => !isPanelDead && AudioSystem.playHover()}
        className="py-3 bg-black/80 hover:bg-alert-yellow hover:text-black text-alert-yellow text-[10px] font-bold font-header uppercase transition-colors tracking-widest"
      >
        Contact_Link
      </button>
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/IdentityHUD.tsx
=====================================
import { useGameStore } from '@/game/store/useGameStore';
import identity from '@/data/identity.json';
import { clsx } from 'clsx';

// Sub-components
import { VitalsRing } from '../atoms/VitalsRing';
import { UpgradeTerminal } from './UpgradeTerminal';
import { SystemOps } from './SystemOps';
import { IdentityFooter } from './IdentityFooter';

export const IdentityHUD = () => {
  
  // -- Vitals State (Heavy Updates) --
  const hp = useGameStore(s => s.playerHealth);
  const maxHp = useGameStore(s => s.maxPlayerHealth);
  const xp = useGameStore(s => s.xp);
  const nextXp = useGameStore(s => s.xpToNextLevel);
  const level = useGameStore(s => s.level);
  const rebootProgress = useGameStore(s => s.playerRebootProgress);
  
  // -- Panel State --
  const panel = useGameStore(s => s.panels['identity']);
  const isPanelDead = panel ? panel.isDestroyed : false;
  const isPlayerDead = hp <= 0;

  return (
    <div className={clsx(
        "flex flex-col h-full w-full relative overflow-hidden", 
        isPanelDead ? 'grayscale opacity-50 pointer-events-none' : ''
    )}>
      
      {/* TOP SECTION: Avatar & Stats */}
      <div className="flex-none flex flex-col items-center pt-4 relative z-10">
        
        {/* Vitals Ring (Atomic Component) */}
        <VitalsRing 
            health={hp}
            maxHealth={maxHp}
            xp={xp}
            xpToNext={nextXp}
            level={level}
            isDead={isPlayerDead}
            rebootProgress={rebootProgress}
        />

        {/* Identity Info */}
        <div className="text-center z-20 mb-2">
            <h2 className="text-xl font-header font-black text-primary-green tracking-wider drop-shadow-md">
                {identity.name}
            </h2>
            <div className="text-[8px] text-latent-purple-light uppercase tracking-[0.2em] opacity-80 bg-black/60 px-2 py-0.5 rounded-full border border-latent-purple/20">
                {identity.class}
            </div>
        </div>
      </div>

      {/* MIDDLE SECTION: Upgrade Terminal */}
      <div className="flex-1 min-h-0 w-full px-4 overflow-y-auto scrollbar-hide relative pb-4">
         {/* We pass isPanelDead/isPlayerDead to disable interaction inside */}
         {/* UpgradeTerminal handles its own subscriptions to points/upgrades */}
         <div className={isPlayerDead ? "opacity-50 pointer-events-none" : ""}>
             <UpgradeTerminal isPanelDead={isPanelDead} />
             <SystemOps isPanelDead={isPanelDead} />
         </div>
      </div>

      {/* BOTTOM SECTION: Footer Links */}
      <IdentityFooter isPanelDead={isPanelDead} />
    </div>
  );
};


=====================================
FILE: ./src/ui/atoms/SafePanelContent.tsx
=====================================
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { AlertTriangle } from 'lucide-react';

interface Props {
  children: ReactNode;
  fallbackId?: string;
}

interface State {
  hasError: boolean;
  errorMsg: string;
}

export class SafePanelContent extends Component<Props, State> {
  public state: State = {
    hasError: false,
    errorMsg: ''
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, errorMsg: error.message };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error(`[SafePanelContent] Crash in ${this.props.fallbackId}:`, error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return (
        <div className="absolute inset-0 flex flex-col items-center justify-center bg-black/80 z-[100] p-2 text-center border border-critical-red/50">
          <AlertTriangle className="text-critical-red mb-1 animate-pulse" size={24} />
          <span className="text-[10px] text-critical-red font-mono font-bold tracking-widest">
            VISUAL_CORE_ERR
          </span>
          <span className="text-[8px] text-critical-red/60 font-mono mt-1 max-w-[150px] truncate">
            {this.state.errorMsg}
          </span>
        </div>
      );
    }

    return this.props.children;
  }
}


=====================================
FILE: ./src/ui/atoms/ZenBomb.tsx
=====================================
import { motion, AnimatePresence } from 'framer-motion';
import { Bomb, Skull } from 'lucide-react';
import { useGameStore } from '@/game/store/useGameStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { useState } from 'react';

export const ZenBomb = () => {
  const isGameOver = useGameStore(state => state.systemIntegrity <= 0);
  const isZenMode = useGameStore(state => state.isZenMode);
  const activateZenMode = useGameStore(state => state.activateZenMode);
  const [clicked, setClicked] = useState(false);

  if (!isGameOver || isZenMode) return null;

  const handleClick = () => {
    setClicked(true);
    AudioSystem.playClick();
    
    setTimeout(() => {
        activateZenMode();
    }, 800);
  };

  return (
    <AnimatePresence>
      {!clicked && (
        <motion.button
          initial={{ y: -200, opacity: 0 }}
          animate={{ y: 0, opacity: 1 }}
          exit={{ scale: 3, opacity: 0, filter: "blur(20px)" }} 
          transition={{ type: "spring", stiffness: 100, damping: 15, delay: 1.0 }} 
          
          onClick={handleClick}
          // Z-30 is correct (behind Header z-40)
          className="fixed top-24 left-1/2 -translate-x-1/2 z-30 flex flex-col items-center group cursor-pointer"
        >
          {/* CONNECTOR LINE: Increased width and opacity for visibility */}
          <motion.div 
            initial={{ height: 0 }}
            animate={{ height: 160 }} 
            transition={{ delay: 1.0, duration: 0.8, ease: "easeOut" }}
            className="w-[2px] bg-critical-red/80 absolute -top-64 left-1/2 -translate-x-1/2 shadow-[0_0_8px_#FF003C]"
          />

          {/* THE BOMB BUTTON */}
          <div className="relative p-1 border border-critical-red bg-black/90 backdrop-blur-md shadow-[0_0_20px_#FF003C] overflow-hidden group-hover:shadow-[0_0_40px_#FF003C] transition-shadow duration-300 z-10">
             
             <div className="absolute inset-0 opacity-20 pointer-events-none" 
                  style={{ backgroundImage: 'repeating-linear-gradient(45deg, #FF003C 0, #FF003C 5px, transparent 5px, transparent 10px)' }} 
             />

             <div className="relative w-16 h-16 border border-critical-red/50 flex items-center justify-center bg-black hover:bg-critical-red transition-colors duration-300 group-hover:text-black text-critical-red">
                 <motion.div
                   animate={{ rotate: [0, -10, 10, 0] }}
                   transition={{ repeat: Infinity, duration: 0.3, repeatDelay: 2 }} 
                 >
                    <Bomb size={32} strokeWidth={2} />
                 </motion.div>
             </div>
          </div>

          {/* LABEL */}
          <div className="mt-4 flex items-center gap-2 px-3 py-1 bg-critical-red/10 border border-critical-red/50 backdrop-blur-md z-10">
             <Skull size={10} className="text-critical-red animate-pulse" />
             <span className="text-[10px] font-mono font-black text-critical-red tracking-widest uppercase group-hover:text-white transition-colors">
                PURGE_SYSTEM
             </span>
             <Skull size={10} className="text-critical-red animate-pulse" />
          </div>
          
          <span className="text-[8px] text-critical-red/60 font-mono mt-1 opacity-0 group-hover:opacity-100 transition-opacity">
            [ ENABLE_ZEN_MODE ]
          </span>
        </motion.button>
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/atoms/CustomCursor.tsx
=====================================
import { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useStore } from '@/core/store/useStore';
import { clsx } from 'clsx';

export const CustomCursor = () => {
  const [pos, setPos] = useState({ x: 0, y: 0 });
  const [isHovering, setIsHovering] = useState(false);
  const [isClicking, setIsClicking] = useState(false);
  
  const { bootState, activeModal, isDebugOpen } = useStore();
  
  // VISIBILITY LOGIC:
  // 1. If we are in STANDBY (Intro) or SANDBOX -> SHOW.
  // 2. If we are ACTIVE, only show if a Modal (Settings, etc) or Debug is open.
  
  const isGameActive = bootState === 'active';
  const isMenuOpen = activeModal !== 'none' || isDebugOpen;
  
  // If game is active, we rely on the 3D Reticle, unless a menu is overlaying it.
  const isVisible = !isGameActive || isMenuOpen;

  useEffect(() => {
    const move = (e: MouseEvent) => {
      setPos({ x: e.clientX, y: e.clientY });
      
      const target = e.target as HTMLElement;
      const isInteractive = target.closest('button, a, input, label, [data-interactive="true"]');
      setIsHovering(!!isInteractive);
    };

    const down = () => setIsClicking(true);
    const up = () => setIsClicking(false);

    window.addEventListener('mousemove', move);
    window.addEventListener('mousedown', down);
    window.addEventListener('mouseup', up);

    return () => {
      window.removeEventListener('mousemove', move);
      window.removeEventListener('mousedown', down);
      window.removeEventListener('mouseup', up);
    };
  }, []);

  return (
    <>
      <style jsx global>{`
        body, a, button, input, label, select, textarea { cursor: none !important; }
      `}</style>

      <motion.div
        className={clsx(
            "fixed top-0 left-0 pointer-events-none z-[20000]", 
            (isHovering && isVisible) ? "mix-blend-difference" : "" 
        )}
        animate={{ x: pos.x, y: pos.y }}
        transition={{ type: "tween", ease: "linear", duration: 0 }}
      >
        <AnimatePresence mode="wait">
          {isVisible && (
            <motion.div
              key="custom-cursor"
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              transition={{ duration: 0.2 }}
              className="relative"
            >
              <svg 
                width="24" 
                height="24" 
                viewBox="0 0 24 24" 
                className={`transition-transform duration-100 ${isClicking ? 'scale-90' : 'scale-100'}`}
                style={{ 
                    filter: isHovering ? 'drop-shadow(0 0 12px #eae747)' : 'drop-shadow(0 0 8px #78F654)',
                    fill: isHovering ? '#eae747' : '#78F654'
                }}
              >
                <path d="M5.5 3.21l12.32 12.32-4.5 1.12 3.5 3.5-2.12 2.12-3.5-3.5-1.12 4.5z" />
              </svg>
            </motion.div>
          )}
        </AnimatePresence>
      </motion.div>
    </>
  );
};


=====================================
FILE: ./src/ui/atoms/VirtualJoystick.tsx
=====================================
import { useState, useRef, useEffect } from 'react';
import { ServiceLocator } from '@/game/core/ServiceLocator';
import { InputSystem } from '@/game/systems/InputSystem';

export const VirtualJoystick = () => {
  const [active, setActive] = useState(false);
  const [pos, setPos] = useState({ x: 0, y: 0 });
  const stickRef = useRef<HTMLDivElement>(null);
  
  // Configuration
  const MAX_RADIUS = 40;

  const handlePointerDown = (e: React.PointerEvent) => {
    (e.target as HTMLElement).setPointerCapture(e.pointerId);
    setActive(true);
  };

  const handlePointerMove = (e: React.PointerEvent) => {
    if (!active) return;
    
    // Calculate delta from center
    // We assume the stick is centered in the 100x100 container
    // The event coords are relative to the button (the puck) if captured? 
    // Easier strategy: Use clientX/Y relative to the container center.
    
    const rect = stickRef.current?.parentElement?.getBoundingClientRect();
    if (!rect) return;
    
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    const dx = e.clientX - centerX;
    const dy = e.clientY - centerY;
    
    const distance = Math.sqrt(dx*dx + dy*dy);
    const clampedDist = Math.min(distance, MAX_RADIUS);
    
    const angle = Math.atan2(dy, dx);
    const x = Math.cos(angle) * clampedDist;
    const y = Math.sin(angle) * clampedDist;
    
    setPos({ x, y });

    // Send normalized vector to InputSystem
    // Note: Y is inverted in 3D world (Up is Positive), but Screen Y is Down Positive.
    // However, InputSystem logic in `update` adds to cursor. 
    // If I pull stick DOWN (Positive Y on Screen), I want cursor to go DOWN (Negative Y in World).
    // So we invert Y here.
    const normX = x / MAX_RADIUS;
    const normY = -(y / MAX_RADIUS); 
    
    try {
        const input = ServiceLocator.getSystem<InputSystem>('InputSystem');
        input.setJoystickVector(normX, normY);
    } catch {}
  };

  const handlePointerUp = (e: React.PointerEvent) => {
    setActive(false);
    setPos({ x: 0, y: 0 });
    try {
        const input = ServiceLocator.getSystem<InputSystem>('InputSystem');
        input.setJoystickVector(0, 0);
    } catch {}
  };

  return (
    <div className="fixed bottom-8 right-8 w-32 h-32 z-[90] touch-none select-none">
      {/* Base */}
      <div 
        className="w-full h-full rounded-full border-2 border-primary-green/30 bg-black/50 backdrop-blur-sm relative flex items-center justify-center"
        ref={stickRef}
      >
        {/* Stick */}
        <div 
          className="w-12 h-12 rounded-full bg-primary-green/80 shadow-[0_0_15px_#78F654] absolute cursor-pointer transition-transform duration-75 ease-linear"
          style={{ transform: `translate(${pos.x}px, ${pos.y}px)` }}
          onPointerDown={handlePointerDown}
          onPointerMove={handlePointerMove}
          onPointerUp={handlePointerUp}
          onPointerCancel={handlePointerUp}
        />
      </div>
      <div className="absolute -top-6 w-full text-center text-[10px] text-primary-green/50 font-mono tracking-widest">
          [ NAV ]
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/atoms/PanelSparks.tsx
=====================================
import { useEffect, useRef } from 'react';

interface Particle {
  x: number;
  y: number;
  vx: number;
  vy: number;
  life: number;
  maxLife: number;
  size: number;
  color: string;
}

interface PanelSparksProps {
  intensity?: 'normal' | 'extreme'; 
}

export const PanelSparks = ({ intensity }: PanelSparksProps) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || !canvas.parentElement) return;
    
    // Safety check: Don't initialize if container is collapsed
    const width = canvas.parentElement.clientWidth;
    const height = canvas.parentElement.clientHeight;
    
    if (width === 0 || height === 0) return;

    const ctx = canvas.getContext('2d', { alpha: true });
    if (!ctx) return;

    canvas.width = width;
    canvas.height = height;

    let particles: Particle[] = [];
    let animationFrameId: number;
    let isActive = true;

    const COLORS = ['#FF003C', '#CC0020', '#800010', '#FF4466'];
    
    // REVERTED: Back to 500 as requested
    const PARTICLE_COUNT = 500; 
    
    try {
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const edge = Math.floor(Math.random() * 3); 
            let x = 0, y = 0, vx = 0, vy = 0;

            if (edge === 0) { 
                x = Math.random() * width;
                y = 0;
                vx = (Math.random() - 0.5) * 8;
                vy = (Math.random() * 5) + 2; 
            } else if (edge === 1) { 
                x = 0;
                y = Math.random() * (height * 0.5); 
                vx = (Math.random() * 5) + 2; 
                vy = (Math.random() * 5) - 2;
            } else { 
                x = width;
                y = Math.random() * (height * 0.5);
                vx = -((Math.random() * 5) + 2); 
                vy = (Math.random() * 5) - 2;
            }

            particles.push({
                x, y, vx, vy,
                life: 1.0,
                maxLife: 1.0,
                size: Math.random() * 3 + 1,
                color: COLORS[Math.floor(Math.random() * COLORS.length)]
            });
        }
    } catch (e) {
        console.error("Error creating particles", e);
        return;
    }

    const loop = () => {
      if (!isActive) return;
      if (!canvas || canvas.width === 0) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      let activeParticles = false;

      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.15; 
        
        if (p.y > canvas.height) {
          p.y = canvas.height;
          p.vy *= -0.5; 
          p.vx *= 0.7;  
        }
        
        if (p.x < 0 || p.x > canvas.width) {
          p.vx *= -0.6;
          p.x = Math.max(0, Math.min(canvas.width, p.x));
        }

        p.life -= 0.005; 

        if (p.life > 0) {
            activeParticles = true;
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life; 
            ctx.beginPath();
            ctx.rect(p.x, p.y, p.size, p.size);
            ctx.fill();
        } else {
            particles.splice(i, 1);
        }
      }
      
      if (activeParticles) {
          animationFrameId = requestAnimationFrame(loop);
      } else {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    };

    loop();

    return () => {
      isActive = false;
      cancelAnimationFrame(animationFrameId);
    };
  }, [intensity]);

  return (
    <canvas 
      ref={canvasRef} 
      className="absolute inset-0 pointer-events-none z-0 mix-blend-screen"
    />
  );
};


=====================================
FILE: ./src/ui/atoms/GlassPanel.tsx
=====================================
import { clsx } from 'clsx';
import { motion, AnimatePresence, useAnimation } from 'framer-motion';
import { ReactNode, useEffect as useReactEffect, useState as useReactState, useRef as useReactRef } from 'react';
import { usePanelRegistry } from '@/game/hooks/usePanelRegistry';
import { useGameStore } from '@/game/store/useGameStore';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';
import { Skull } from 'lucide-react';
import { PanelSparks } from './PanelSparks';
import { useHeartbeat } from '@/game/hooks/useHeartbeat';

import { RebootOverlay } from '@/ui/molecules/panel/RebootOverlay';
import { IntelligentHeader } from '@/ui/molecules/panel/IntelligentHeader';
import { BreachOverlay } from '@/ui/molecules/panel/BreachOverlay';
import { SafePanelContent } from './SafePanelContent';

const MAX_HEALTH = 1000;

const panelVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { 
    opacity: 1, 
    y: 0,
    transition: { duration: 0.5, ease: "easeOut" }
  },
  shattered: (custom: number) => ({
    y: 350 + (custom * 50),
    opacity: 0.8,
    rotate: custom * 15,
    transition: { 
        duration: 1.5, 
        ease: "anticipate",
        delay: Math.abs(custom) * 0.1 
    }
  })
};

const pulseVariants = {
    heartbeat: {
        opacity: [0, 0.6, 0],
        scale: [1, 1.005, 1], 
        transition: { 
            duration: 0.8, 
            times: [0, 0.04, 1], 
            ease: "easeOut" 
        }
    }
};

interface GlassPanelProps {
  children: ReactNode;
  className?: string;
  title?: string;
  gameId?: string;
}

export const GlassPanel = ({ children, className, title, gameId }: GlassPanelProps) => {
  const registryRef = gameId ? usePanelRegistry(gameId) : null;
  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const interactionTarget = useGameStore(state => state.interactionTarget);
  const isInteracting = gameId && interactionTarget === gameId;

  const isGameOver = Math.floor(systemIntegrity) <= 0;
  const isCriticalGlobal = systemIntegrity < 30 && !isGameOver;

  const panelState = useGameStore((state) => gameId ? state.panels[gameId] : null);
  
  const health = panelState ? panelState.health : MAX_HEALTH;
  const isDestroyed = panelState ? panelState.isDestroyed : false;
  
  let rawPercent = (health / MAX_HEALTH) * 100;
  if (!Number.isFinite(rawPercent) || isNaN(rawPercent)) rawPercent = 0;
  const healthPercent = Math.max(0, Math.min(100, rawPercent));
  
  const isDamaged = !isDestroyed && health < MAX_HEALTH;

  const [showReboot, setShowReboot] = useReactState(false);
  const prevDestroyed = useReactRef(isDestroyed);
  
  const shakeControls = useAnimation();
  const heartbeatControls = useHeartbeat(); 

  const randSeed = (title?.length || 5) % 2 === 0 ? 1 : -1;

  useReactEffect(() => {
      if (isGameOver) {
          shakeControls.start("shattered");
      } else {
          shakeControls.start("visible");
      }
  }, [isGameOver, shakeControls]);

  useReactEffect(() => {
    if (prevDestroyed.current && !isDestroyed && !isGameOver) {
        setShowReboot(true);
        const timer = setTimeout(() => setShowReboot(false), 2000); 
        return () => clearTimeout(timer);
    }
    prevDestroyed.current = isDestroyed;
  }, [isDestroyed, isGameOver]);

  useReactEffect(() => {
      if (!gameId) return;
      const unsub = GameEventBus.subscribe(GameEvents.PANEL_DAMAGED, (p) => {
          if (p.id === gameId) {
              shakeControls.start({
                  x: [0, -5, 5, -5, 5, 0],
                  transition: { duration: 0.1 }
              });
          }
      });
      return unsub;
  }, [gameId, shakeControls]);

  let borderColor = "border-primary-green-dim/30";
  if (isDestroyed) {
      borderColor = isInteracting 
        ? "border-latent-purple shadow-[0_0_10px_#9E4EA5]" 
        : "border-critical-red animate-pulse"; 
  }
  else if (isInteracting && isDamaged) borderColor = "border-service-cyan shadow-[0_0_10px_#00F0FF]";
  else if (isDamaged) borderColor = "border-alert-yellow/50";

  const bgClass = isDestroyed ? "bg-black/20" : "bg-black";

  return (
    <motion.div 
      ref={registryRef}
      variants={panelVariants}
      initial="hidden"
      animate={shakeControls}
      custom={randSeed}
      className={clsx(
        "relative overflow-hidden flex flex-col group",
        bgClass, 
        "border",
        borderColor, 
        "rounded-sm",
        className
      )}
    >
      {isCriticalGlobal && (
          <motion.div 
            className="absolute inset-0 pointer-events-none z-50 border-2 border-critical-red/60 shadow-[inset_0_0_30px_#FF003C]"
            animate={heartbeatControls}
            variants={pulseVariants}
            initial={{ opacity: 0 }}
          />
      )}

      <div className="absolute inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(10,10,10,0.4)_50%)] z-0 bg-[length:100%_4px]" />
      
      {title && (
          <IntelligentHeader 
            title={title} 
            health={health} 
            isDestroyed={isDestroyed} 
            isGameOver={isGameOver}
            gameId={gameId}
          />
      )}

      <div className="relative z-10 p-4 h-full">
        {(isDestroyed || isGameOver) && (
            <SafePanelContent fallbackId={`sparks-${gameId}`}>
                <PanelSparks intensity={isGameOver ? 'extreme' : 'normal'} />
            </SafePanelContent>
        )}

        <div className={clsx("h-full flex flex-col relative z-20", isGameOver ? "invisible" : "visible")}>
            {children}
            
            {isDestroyed && !isGameOver && (
                <SafePanelContent fallbackId={`breach-${gameId}`}>
                    <BreachOverlay 
                        progress={healthPercent} 
                        isVideo={gameId === 'video'} 
                        showInteractive={true} 
                    />
                </SafePanelContent>
            )}
        </div>

        <AnimatePresence>
            {showReboot && <RebootOverlay key="reboot" />}
        </AnimatePresence>
        
        {isGameOver && (
            <div className="absolute inset-0 z-[100] flex flex-col items-center justify-center gap-4 bg-transparent pointer-events-none">
                <Skull className="text-critical-red animate-pulse w-20 h-20 drop-shadow-[0_0_15px_rgba(255,0,60,0.8)]" />
                <span className="text-critical-red font-header font-black text-2xl tracking-widest drop-shadow-lg">SYSTEM FAILURE</span>
            </div>
        )}
      </div>
    </motion.div>
  );
};


=====================================
FILE: ./src/ui/atoms/VitalsRing.tsx
=====================================
import { MiniCrystalCanvas } from '@/scene/props/MiniCrystalCanvas';
import { Unplug } from 'lucide-react';
import { clsx } from 'clsx';

interface VitalsRingProps {
  health: number;
  maxHealth: number;
  xp: number;
  xpToNext: number;
  level: number;
  isDead: boolean;
  rebootProgress: number;
}

export const VitalsRing = ({ 
  health, 
  maxHealth, 
  xp, 
  xpToNext, 
  level, 
  isDead, 
  rebootProgress 
}: VitalsRingProps) => {
  
  const hpPercent = Math.max(0, (health / maxHealth) * 100);
  const xpPercent = xpToNext > 0 ? Math.min(100, (xp / xpToNext) * 100) : 0;

  // --- SVG CONFIG ---
  const size = 160; 
  const center = size / 2;
  const radiusHp = 60;
  const radiusXp = 70;
  const stroke = 4;
  
  const circHp = 2 * Math.PI * radiusHp;
  const circXp = 2 * Math.PI * radiusXp;

  const displayHpPercent = isDead ? rebootProgress : hpPercent;
  const displayHpColor = isDead ? "#eae747" : (hpPercent < 30 ? "#FF003C" : "#78F654"); 

  const offsetHp = circHp - (displayHpPercent / 100 * circHp);
  const offsetXp = circXp - (xpPercent / 100 * circXp);

  return (
    <div className="relative w-40 h-40 shrink-0 group mb-1"> 
        
        {/* 3D Canvas */}
        <div className={clsx(
            "absolute inset-0 rounded-full bg-black/50 overflow-hidden transition-opacity duration-500 clip-circle",
            isDead ? "opacity-60 grayscale" : "opacity-100"
        )}>
           <MiniCrystalCanvas />
        </div>

        {/* Status Overlays */}
        {isDead && (
            <div className="absolute inset-0 flex items-center justify-center pointer-events-none z-20">
                {rebootProgress > 0 ? (
                    <div className="flex flex-col items-center">
                        <span className="text-2xl font-header font-black text-alert-yellow drop-shadow-md animate-pulse">
                            {Math.floor(rebootProgress)}%
                        </span>
                        <span className="text-[8px] text-alert-yellow font-mono tracking-widest bg-black/80 px-2 mt-1">REBOOTING</span>
                    </div>
                ) : (
                    <div className="animate-pulse flex flex-col items-center">
                        <Unplug className="text-white/50 w-8 h-8 mb-1" />
                        <span className="text-[8px] text-critical-red font-mono bg-black/80 px-2">SIGNAL_LOST</span>
                    </div>
                )}
            </div>
        )}

        {/* SVG RINGS */}
        <svg className="absolute inset-0 w-full h-full pointer-events-none overflow-visible" viewBox={`0 0 ${size} ${size}`}>
          <circle cx={center} cy={center} r={radiusHp} stroke="#1a1a1a" strokeWidth={stroke} fill="transparent" />
          <circle cx={center} cy={center} r={radiusXp} stroke="#1a1a1a" strokeWidth={stroke} fill="transparent" strokeDasharray="2 4" />
          
          <circle 
            cx={center} cy={center} r={radiusHp} 
            stroke={displayHpColor} 
            strokeWidth={stroke} fill="transparent"
            strokeDasharray={circHp}
            strokeDashoffset={offsetHp}
            strokeLinecap="round"
            transform={`rotate(-90 ${center} ${center})`}
            className="transition-all duration-100 ease-linear"
          />
          
          <circle 
            cx={center} cy={center} r={radiusXp} 
            stroke="#9E4EA5" 
            strokeWidth={stroke} fill="transparent"
            strokeDasharray={circXp}
            strokeDashoffset={offsetXp}
            strokeLinecap="round"
            transform={`rotate(-90 ${center} ${center})`}
            className="transition-all duration-500 ease-out"
          />

          <defs>
              <path id="levelCurve" d="M 25,80 A 55,55 0 0,0 135,80" /> 
          </defs>
          
          <text fontSize="10" fontFamily="monospace" fontWeight="bold" letterSpacing="3" fill="#9E4EA5" style={{ filter: 'drop-shadow(0 0 2px #9E4EA5)' }}>
              <textPath href="#levelCurve" startOffset="50%" textAnchor="middle" side="right">
                  LVL_{level.toString().padStart(2, '0')}
              </textPath>
          </text>
        </svg>
    </div>
  );
};


=====================================
FILE: ./src/ui/overlays/GlobalBackdrop.tsx
=====================================
import { motion, AnimatePresence } from 'framer-motion';
import { useStore } from '@/core/store/useStore';
import { AudioSystem } from '@/core/audio/AudioSystem';

export const GlobalBackdrop = () => {
  const { activeModal, isDebugOpen, isDebugMinimized, closeModal, toggleDebugMenu } = useStore();

  // Show if any modal is open OR debug is open (but not minimized)
  const isVisible = (activeModal !== 'none') || (isDebugOpen && !isDebugMinimized);

  const handleDismiss = () => {
    AudioSystem.playSound('ui_menu_close');
    if (isDebugOpen) {
        toggleDebugMenu();
    } else {
        closeModal();
    }
  };

  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: 0.3 }}
          onClick={handleDismiss}
          // Z-INDEX 150: Above Game (60) AND Intro (100). Below Modals/Settings (200).
          className="fixed inset-0 z-[150] bg-black/60 backdrop-blur-sm cursor-pointer"
        />
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/overlays/ErrorBoundary.tsx
=====================================
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { AlertTriangle, RefreshCw } from 'lucide-react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class WebGLErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null,
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("WebGL Context Crash:", error, errorInfo);
  }

  private handleReload = () => {
    window.location.reload();
  };

  public render() {
    if (this.state.hasError) {
      return (
        <div className="absolute inset-0 z-[100] flex flex-col items-center justify-center bg-black text-critical-red p-8 text-center font-mono">
          <div className="border border-critical-red/50 bg-critical-red/10 p-8 max-w-lg shadow-[0_0_50px_rgba(255,0,60,0.2)]">
            <div className="flex justify-center mb-4">
               <AlertTriangle size={48} className="animate-pulse" />
            </div>
            <h2 className="text-2xl font-black tracking-widest mb-4">GRAPHICS_CORE_FAILURE</h2>
            <p className="text-sm mb-6 text-critical-red/80">
              The neural interface encountered a critical WebGL error.
              <br/>
              <span className="text-xs opacity-50 mt-2 block font-mono">{this.state.error?.message}</span>
            </p>
            <button 
              onClick={this.handleReload}
              className="flex items-center justify-center gap-2 w-full py-3 bg-critical-red text-black font-bold tracking-widest hover:bg-white transition-colors"
            >
              <RefreshCw size={16} />
              REBOOT_SYSTEM
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}


=====================================
FILE: ./src/ui/overlays/ModalContainer.tsx
=====================================
import { useStore } from '@/core/store/useStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { motion, AnimatePresence } from 'framer-motion';
import { X } from 'lucide-react';

interface ModalContainerProps {
  children: React.ReactNode;
  title: string;
  type: string;
}

export const ModalContainer = ({ children, title, type }: ModalContainerProps) => {
  const { activeModal, closeModal } = useStore();
  const isOpen = activeModal === type;

  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 z-[200] flex items-center justify-center p-4 md:p-10 pointer-events-none">
          
          <motion.div
            initial={{ scale: 0.9, opacity: 0, y: 20 }}
            animate={{ scale: 1, opacity: 1, y: 0 }}
            exit={{ scale: 0.95, opacity: 0, y: 10 }}
            transition={{ type: "spring", bounce: 0, duration: 0.3 }}
            className="relative w-full max-w-5xl h-full max-h-[90vh] bg-black border border-primary-green/50 shadow-[0_0_50px_rgba(0,255,65,0.1)] flex flex-col overflow-hidden pointer-events-auto"
          >
            <div className="flex items-center justify-between px-4 py-3 bg-primary-green/10 border-b border-primary-green/30">
              <div className="flex items-center gap-2">
                <div className="w-3 h-3 bg-critical-red rounded-full animate-pulse" />
                <span className="font-header font-black text-primary-green text-lg md:text-xl tracking-widest">
                  {title}
                </span>
              </div>
              <button 
                onClick={() => { closeModal(); AudioSystem.playSound('ui_menu_close'); }}
                onMouseEnter={() => AudioSystem.playHover()} 
                className="p-1 hover:bg-critical-red hover:text-black text-primary-green transition-colors"
              >
                <X />
              </button>
            </div>

            <div className="flex-1 overflow-auto p-6 relative scrollbar-thin scrollbar-thumb-primary-green scrollbar-track-black">
              <div className="absolute inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.1)_50%)] bg-[length:100%_4px] opacity-20" />
              <div className="relative z-10">
                {children}
              </div>
            </div>

            <div className="px-4 py-1 bg-black border-t border-primary-green/30 text-xs text-primary-green-dim font-mono text-right">
              MODE: SECURE // ENCRYPTION: ENABLED
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/organisms/Footer.tsx
=====================================
import { useEffect, useState, useRef } from 'react';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';
import { AnimatePresence, motion } from 'framer-motion';
import { useGameStore } from '@/game/store/useGameStore';
import { clsx } from 'clsx';

const IDLE_MESSAGES = [
  "SYSTEM_MONITORING...",
  "SCANNING_LATENT_SECTORS...",
  "ENCRYPTION_ACTIVE...",
  "PACKET_STREAM_STABLE...",
  "PINGING_NEURAL_NET...",
  "RENDERING_CONTEXT...",
];

export const Footer = () => {
  const commitHash = process.env.NEXT_PUBLIC_COMMIT_HASH || 'UNKNOWN';
  const actionsUrl = "https://github.com/mesoelfy/mesoelfy.github.io/actions";
  
  // GLOBAL STATE FOR COLORS
  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const isGameOver = systemIntegrity <= 0;
  const isCritical = systemIntegrity < 30;
  const isWarning = systemIntegrity < 60;

  let globalColor = "text-primary-green-dim border-primary-green-dim/30";
  if (isGameOver) globalColor = "text-critical-red border-critical-red/50";
  else if (isCritical) globalColor = "text-critical-red border-critical-red/30";
  else if (isWarning) globalColor = "text-alert-yellow border-alert-yellow/30";

  const [log, setLog] = useState<{ text: string, type: 'info' | 'warn' | 'crit' }>({ 
      text: "SYSTEM_ONLINE", type: 'info' 
  });
  
  const lockUntilRef = useRef(0);

  useEffect(() => {
    // Helper to check if we should update log
    const canUpdate = () => {
        const state = useGameStore.getState();
        if (state.systemIntegrity <= 0) return false; // DEAD SILENCE
        return Date.now() > lockUntilRef.current;
    };

    // 1. Event Listeners
    const unsubHit = GameEventBus.subscribe(GameEvents.PLAYER_HIT, () => {
        if (!canUpdate()) return;
        setLog({ text: ">> WARNING: HULL BREACH DETECTED", type: 'warn' });
        lockUntilRef.current = Date.now() + 1000;
    });

    const unsubDamage = GameEventBus.subscribe(GameEvents.PANEL_DAMAGED, (p) => {
        if (!canUpdate()) return;
        setLog({ text: `>> ALERT: SECTOR [${p.id.toUpperCase()}] SUSTAINING DAMAGE`, type: 'warn' });
        lockUntilRef.current = Date.now() + 1500;
    });

    const unsubDestroy = GameEventBus.subscribe(GameEvents.PANEL_DESTROYED, (p) => {
        // Critical messages can override lock unless game over
        if (useGameStore.getState().systemIntegrity <= 0) return;
        setLog({ text: `⚠ CRITICAL: SECTOR [${p.id.toUpperCase()}] OFFLINE ⚠`, type: 'crit' });
        lockUntilRef.current = Date.now() + 3000;
    });

    const unsubGameOver = GameEventBus.subscribe(GameEvents.GAME_OVER, () => {
        // FORCE OVERRIDE
        setLog({ text: "⚠ SYSTEM FAILURE // CONNECTION LOST ⚠", type: 'crit' });
        lockUntilRef.current = Date.now() + 999999999; 
    });

    const unsubSpawn = GameEventBus.subscribe(GameEvents.ENEMY_SPAWNED, (p) => {
        if (!canUpdate()) return;
        if (Math.random() > 0.9) {
            setLog({ text: `>> SENSOR: NEW SIGNAL [${p.type.toUpperCase()}] DETECTED`, type: 'info' });
        }
    });
    
    const unsubHeal = GameEventBus.subscribe(GameEvents.PANEL_HEALED, (p) => {
        if (!canUpdate()) return;
        setLog({ text: `>> MAINTENANCE: RESTORING [${p.id.toUpperCase()}]`, type: 'info' });
    });

    // 2. Idle Loop
    const interval = setInterval(() => {
        if (canUpdate()) {
            const msg = IDLE_MESSAGES[Math.floor(Math.random() * IDLE_MESSAGES.length)];
            setLog({ text: msg, type: 'info' });
        }
    }, 4000);

    return () => {
        unsubHit(); unsubDamage(); unsubDestroy(); unsubSpawn(); unsubHeal(); unsubGameOver();
        clearInterval(interval);
    };
  }, []);

  // Force update immediately on React state change for Game Over to ensure UI sync
  useEffect(() => {
      if (isGameOver) {
          setLog({ text: "⚠ SYSTEM FAILURE // CONNECTION LOST ⚠", type: 'crit' });
      }
  }, [isGameOver]);

  return (
    <footer className={clsx(
        "w-full h-8 border-t bg-black flex items-center justify-between px-4 z-40 shrink-0 text-[10px] font-mono overflow-hidden transition-colors duration-500",
        globalColor
    )}>
      
      {/* LEFT: System Log */}
      <div className="flex-1 flex items-center gap-2 overflow-hidden mr-4">
        <span className="shrink-0 font-bold">LOG:</span>
        <AnimatePresence mode="wait">
            <motion.span 
                key={log.text}
                initial={{ opacity: 0, y: 5 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -5 }}
                transition={{ duration: 0.2 }}
                className={clsx(
                    "whitespace-nowrap font-bold tracking-wider truncate",
                    // If Game Over, FORCE Red. Otherwise respect message type colors
                    isGameOver ? "text-critical-red animate-pulse" : 
                    log.type === 'crit' ? "text-critical-red animate-pulse" : 
                    log.type === 'warn' ? "text-alert-yellow" : 
                    "text-primary-green"
                )}
            >
                {log.text}
            </motion.span>
        </AnimatePresence>
      </div>

      {/* RIGHT: Version */}
      <div className="flex items-center gap-2 shrink-0 opacity-50 hover:opacity-100 transition-opacity">
        <span>VER:</span>
        <a 
          href={actionsUrl}
          target="_blank" 
          rel="noopener noreferrer"
          className="hover:text-white transition-colors decoration-dashed underline underline-offset-2"
        >
          {commitHash}
        </a>
      </div>
    </footer>
  );
};


=====================================
FILE: ./src/ui/organisms/Header.tsx
=====================================
import { Volume2, VolumeX, Music, Activity, Wind, Settings } from 'lucide-react';
import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { useEffect, useState } from 'react';
import { clsx } from 'clsx';
import { motion } from 'framer-motion';
import { useHeartbeat } from '@/game/hooks/useHeartbeat';
import { AudioSystem } from '@/core/audio/AudioSystem';

const Radar = ({ active, panic, color }: { active: boolean, panic: boolean, color: string }) => (
  <div className={`relative w-8 h-8 rounded-full border border-current flex items-center justify-center overflow-hidden bg-black/50 ${color}`}>
    <div className="absolute inset-0 border-current opacity-20" 
         style={{ backgroundImage: 'radial-gradient(circle, currentColor 1px, transparent 1px)', backgroundSize: '8px 8px' }} />
    <div className="absolute w-full h-[1px] bg-current opacity-40" />
    <div className="absolute h-full w-[1px] bg-current opacity-40" />
    <motion.div 
      className="absolute inset-0 origin-bottom-right opacity-40"
      style={{ background: 'conic-gradient(from 0deg, transparent 270deg, currentColor 360deg)' }}
      animate={{ rotate: 360 }}
      transition={{ repeat: Infinity, ease: "linear", duration: panic ? 1.0 : 4.0 }}
    />
    <div className={`w-1 h-1 rounded-full bg-current ${active ? 'animate-pulse' : ''}`} />
  </div>
);

const ToggleBtn = ({ active, onClick, children, color }: any) => (
  <button 
    onClick={onClick}
    className={clsx(
      "flex items-center justify-center w-8 h-7 transition-all duration-200 border rounded-sm",
      active 
        ? `hover:text-alert-yellow bg-white/5 border-white/20 ${color}`
        : `${color} border-transparent opacity-40 hover:text-critical-red hover:opacity-100`
    )}
  >
    {children}
  </button>
);

export const Header = () => {
  const { audioSettings, toggleMaster, toggleMusic, toggleSfx, toggleAmbience, toggleSettings } = useStore();
  
  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const isPlaying = useGameStore(state => state.isPlaying);
  const score = useGameStore(state => state.score);

  const [mounted, setMounted] = useState(false);
  useEffect(() => setMounted(true), []);

  const isCritical = systemIntegrity < 30;
  const isWarning = systemIntegrity < 60;
  const isGameOver = systemIntegrity <= 0;
  
  let statusColor = "text-primary-green";
  if (isCritical) statusColor = "text-critical-red";
  else if (isWarning) statusColor = "text-alert-yellow";

  const heartbeatControls = useHeartbeat();

  const textVariants = {
      heartbeat: {
          scale: [1, 1.05, 1],
          textShadow: [
              "0 0 0px #FF003C",
              "0 0 25px #FF003C", 
              "0 0 0px #FF003C"
          ],
          transition: { 
              duration: 0.8, 
              times: [0, 0.04, 1], 
              ease: "easeOut" 
          }
      }
  };

  const barVariants = {
      heartbeat: {
          filter: [
              "brightness(1) drop-shadow(0 0 0px #FF003C)",
              "brightness(2) drop-shadow(0 0 10px #FF003C)",
              "brightness(1) drop-shadow(0 0 0px #FF003C"
          ],
          transition: { 
              duration: 0.8, 
              times: [0, 0.04, 1], 
              ease: "easeOut" 
          }
      }
  };

  return (
    <header className="relative w-full h-12 bg-black/90 backdrop-blur-md flex items-center justify-between px-4 z-40 shrink-0 border-b border-white/5 transition-colors duration-300">
      
      {/* LEFT: Identity */}
      <div className="flex items-center gap-4">
        <motion.span 
            animate={isCritical ? heartbeatControls : undefined}
            variants={textVariants}
            className={clsx(
                "font-header font-black text-xl md:text-2xl tracking-wide transition-colors duration-500",
                statusColor
            )}
        >
          MESOELFY_OS
        </motion.span>
        
        {mounted && (
          <div className={`hidden md:flex items-center gap-4 text-xs font-mono border-l border-white/10 pl-4 ${statusColor}`}>
            <Radar active={isPlaying} panic={isCritical || (isPlaying && isCritical)} color={statusColor} />
            <div className="flex flex-col leading-none">
                <span className="text-[8px] opacity-60 tracking-wider">THREAT_NEUTRALIZED</span>
                <span className="font-bold text-lg tabular-nums tracking-widest">
                    {score.toString().padStart(4, '0')}
                </span>
            </div>
          </div>
        )}
      </div>

      {/* RIGHT: Status & Audio Controls */}
      <div className="flex items-center gap-4">
        <div className="flex items-center gap-1 border-l border-white/10 pl-4">
            
            <ToggleBtn active={audioSettings.ambience} onClick={toggleAmbience} color={statusColor}>
                <Wind size={14} />
            </ToggleBtn>
            
            <ToggleBtn active={audioSettings.sfx} onClick={toggleSfx} color={statusColor}>
                <span className="text-[10px] font-mono font-bold tracking-tighter decoration-1 underline-offset-2">SFX</span>
            </ToggleBtn>
            
            <ToggleBtn active={audioSettings.music} onClick={toggleMusic} color={statusColor}>
                {audioSettings.music ? <Music size={14} /> : <Music size={14} className="opacity-50" />}
            </ToggleBtn>
            
            <div className="w-[1px] h-4 bg-white/10 mx-1" />
            
            <ToggleBtn active={audioSettings.master} onClick={toggleMaster} color={statusColor}>
                {audioSettings.master ? <Volume2 size={14} /> : <VolumeX size={14} />}
            </ToggleBtn>

            <div className="w-[1px] h-4 bg-white/10 mx-1" />

            <button 
                onClick={() => { toggleSettings(); AudioSystem.playSound('ui_menu_open'); }}
                className={clsx(
                  "flex items-center justify-center p-1.5 transition-all duration-200 border border-transparent rounded-sm hover:text-alert-yellow hover:bg-white/5",
                  statusColor
                )}
            >
                <Settings size={14} className="animate-spin-slow" />
            </button>

        </div>
      </div>

      {!isGameOver && (
        <div className="absolute bottom-[-1px] left-0 right-0 h-[2px] bg-gray-900">
          <motion.div 
            animate={isCritical ? heartbeatControls : undefined}
            variants={barVariants}
            className={clsx("h-full transition-all duration-500 ease-out shadow-[0_0_10px_currentColor]", 
                isCritical ? "bg-critical-red" : isWarning ? "bg-alert-yellow" : "bg-primary-green"
            )} 
            style={{ width: `${systemIntegrity}%` }}
          />
        </div>
      )}
      
      <div className={clsx(
          "absolute bottom-[-14px] right-2 text-[8px] font-mono flex items-center gap-1 transition-colors duration-300",
          isCritical ? "text-critical-red" : isWarning ? "text-alert-yellow" : "text-primary-green-dim"
      )}>
        <Activity size={8} className={isCritical ? "animate-pulse" : ""} />
        <span>OS_INTEGRITY: {Math.floor(systemIntegrity)}%</span>
      </div>

    </header>
  );
};


=====================================
FILE: ./src/core/audio/AudioSystem.ts
=====================================
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';
import { useStore } from '@/core/store/useStore';
import { AUDIO_CONFIG, SoundRecipe } from '@/game/config/AudioConfig';

class AudioSystemController {
  private ctx: AudioContext | null = null;
  private masterGain: GainNode | null = null;
  private sfxGain: GainNode | null = null;
  private musicGain: GainNode | null = null;
  
  private ambienceGain: GainNode | null = null;
  private ambiencePanner: StereoPannerNode | null = null;
  private ambienceLFO: OscillatorNode | null = null;
  private ambiencePanConstraint: GainNode | null = null;
  
  private ambienceFilter: BiquadFilterNode | null = null;
  private ambienceDepthLFO: OscillatorNode | null = null;
  private ambienceDepthGain: GainNode | null = null;
  
  private currentAmbienceNode: AudioBufferSourceNode | null = null;
  private currentAmbienceKey: string | null = null;
  
  private musicElement: HTMLAudioElement | null = null;
  private buffers: Map<string, AudioBuffer> = new Map();
  
  public isReady = false;
  private hasInteracted = false; 
  private isMusicStarted = false; 

  public async init() {
    if (this.isReady) {
        if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume().catch(() => {});
        return;
    }

    const AudioContextClass = (window as any).AudioContext || (window as any).webkitAudioContext;
    this.ctx = new AudioContextClass();
    if (!this.ctx) return;

    this.masterGain = this.ctx.createGain();
    this.sfxGain = this.ctx.createGain();
    this.musicGain = this.ctx.createGain();
    this.ambienceGain = this.ctx.createGain();
    this.ambiencePanner = this.ctx.createStereoPanner();
    this.ambiencePanConstraint = this.ctx.createGain();
    this.ambienceLFO = this.ctx.createOscillator();
    this.ambienceFilter = this.ctx.createBiquadFilter(); 
    this.ambienceDepthLFO = this.ctx.createOscillator(); 
    this.ambienceDepthGain = this.ctx.createGain();      

    this.sfxGain.connect(this.masterGain);
    this.musicGain.connect(this.masterGain);
    this.masterGain.connect(this.ctx.destination);

    this.ambienceGain.connect(this.ambienceFilter);
    this.ambienceFilter.connect(this.ambiencePanner);
    this.ambiencePanner.connect(this.masterGain);

    this.ambienceLFO.type = 'sine';
    this.ambienceLFO.connect(this.ambiencePanConstraint);
    this.ambiencePanConstraint.connect(this.ambiencePanner.pan);
    
    this.ambienceFilter.type = 'lowpass';
    this.ambienceDepthLFO.type = 'sine';
    this.ambienceDepthLFO.connect(this.ambienceDepthGain);
    this.ambienceDepthGain.connect(this.ambienceFilter.frequency);

    this.ambienceLFO.start();
    this.ambienceDepthLFO.start();

    this.updateVolumes(); 

    await this.generateAllSounds();
    
    this.setupEventListeners();
    this.setupGlobalInteraction();

    this.isReady = true;
    console.log('[AudioSystem] Synthesized and Ready.');

    if (this.isMusicStarted) {
        this.playAmbience('ambience_core');
    }
  }

  private setupGlobalInteraction() {
      const wakeUp = () => {
          if (this.hasInteracted) return;
          this.hasInteracted = true; 
          if (this.ctx && this.ctx.state === 'suspended') {
              this.ctx.resume().catch(() => {});
          }
          if (!this.currentAmbienceKey) {
              this.playAmbience('ambience_core');
          }
          window.removeEventListener('pointerdown', wakeUp);
          window.removeEventListener('keydown', wakeUp);
      };
      window.addEventListener('pointerdown', wakeUp);
      window.addEventListener('keydown', wakeUp);
  }

  public updateVolumes() {
      if (!this.masterGain || !this.sfxGain || !this.musicGain) return;
      const s = useStore.getState().audioSettings;
      
      this.masterGain.gain.value = s.master ? (s.volumeMaster * 0.5) : 0;
      this.musicGain.gain.value = s.music ? (s.volumeMusic * 0.4) : 0;
      this.sfxGain.gain.value = s.sfx ? (s.volumeSfx * 0.8) : 0;
      
      if (this.ambienceGain) {
          this.ambienceGain.gain.value = s.ambience ? s.volumeAmbience : 0.0;
      }

      if (this.ambienceFilter && this.ambienceLFO && this.ambiencePanConstraint && this.ambienceDepthLFO && this.ambienceDepthGain) {
          const filter = s.ambFilter ?? 0.5;
          const speed = s.ambSpeed ?? 0.5;
          const width = s.ambWidth ?? 0.5;
          const modSpeed = s.ambModSpeed ?? 0.5;
          const modDepth = s.ambModDepth ?? 0.5;

          this.ambienceFilter.frequency.value = 300 * Math.pow(10, (filter - 0.5) * 2);
          this.ambienceLFO.frequency.value = 0.05 * Math.pow(10, (speed - 0.5) * 2);
          this.ambiencePanConstraint.gain.value = Math.pow(width, 3) * 0.8;
          this.ambienceDepthLFO.frequency.value = 0.2 * Math.pow(10, (modSpeed - 0.5) * 2);
          this.ambienceDepthGain.gain.value = 10 * Math.pow(10, (modDepth - 0.5) * 2);
      }
  }

  private async generateAllSounds() {
      const promises = Object.entries(AUDIO_CONFIG).map(([key, recipe]) => {
          return this.synthesizeSound(recipe).then(buffer => {
              if (buffer) this.buffers.set(key, buffer);
          });
      });
      await Promise.all(promises);
  }

  private makeDistortionCurve(amount: number) {
    const k = typeof amount === 'number' ? amount : 50;
    const n_samples = 44100;
    const curve = new Float32Array(n_samples);
    const deg = Math.PI / 180;
    for (let i = 0; i < n_samples; ++i) {
      const x = (i * 2) / n_samples - 1;
      curve[i] = ((3 + k) * x * 20 * deg) / (Math.PI + k * Math.abs(x));
    }
    return curve;
  }

  private async synthesizeSound(recipe: SoundRecipe): Promise<AudioBuffer | null> {
      if (!this.ctx) return null;
      
      const sampleRate = 44100;
      const length = sampleRate * recipe.duration;
      const offline = new OfflineAudioContext(1, length, sampleRate);

      const mainGain = offline.createGain();
      mainGain.connect(offline.destination);
      
      const attack = recipe.attack || 0.005; 
      
      if (recipe.attack !== undefined) {
          mainGain.gain.setValueAtTime(0, 0);
          mainGain.gain.linearRampToValueAtTime(recipe.volume, recipe.attack);
      } else {
          mainGain.gain.setValueAtTime(recipe.volume, 0);
      }
      
      if (recipe.duration < 10.0) {
          mainGain.gain.exponentialRampToValueAtTime(0.01, recipe.duration);
      } else {
          mainGain.gain.setValueAtTime(recipe.volume, recipe.duration);
      }

      let outputNode: AudioNode = mainGain;

      if (recipe.distortion) {
          const shaper = offline.createWaveShaper();
          shaper.curve = this.makeDistortionCurve(recipe.distortion);
          shaper.connect(outputNode);
          outputNode = shaper; 
      }

      if (recipe.tremolo) {
          const tremoloNode = offline.createGain();
          tremoloNode.connect(outputNode);
          outputNode = tremoloNode;

          const lfo = offline.createOscillator();
          lfo.type = recipe.tremolo.wave || 'sine';
          lfo.frequency.value = recipe.tremolo.rate;
          
          const lfoGain = offline.createGain();
          lfoGain.gain.value = recipe.tremolo.depth; 
          
          tremoloNode.gain.value = 1.0 - (recipe.tremolo.depth / 2);
          lfo.connect(lfoGain);
          lfoGain.connect(tremoloNode.gain);
          
          lfo.start();
      }

      if (recipe.type === 'oscillator') {
          const osc = offline.createOscillator();
          osc.type = recipe.wave || 'sine';
          osc.frequency.setValueAtTime(recipe.frequency[0], 0);
          if (recipe.frequency[1] !== recipe.frequency[0]) {
              osc.frequency.exponentialRampToValueAtTime(recipe.frequency[1], recipe.duration);
          }

          if (recipe.fm) {
             const modOsc = offline.createOscillator();
             const modGain = offline.createGain();
             modOsc.type = recipe.fm.modType;
             modOsc.frequency.value = recipe.fm.modFreq;
             modGain.gain.value = recipe.fm.modIndex;
             modOsc.connect(modGain);
             modGain.connect(osc.frequency); 
             modOsc.start();
          }

          osc.connect(outputNode);
          osc.start();
      } 
      else if (recipe.type === 'noise') {
          const bufferSize = sampleRate * recipe.duration;
          const noiseBuffer = offline.createBuffer(1, bufferSize, sampleRate);
          const data = noiseBuffer.getChannelData(0);
          for (let i = 0; i < bufferSize; i++) {
              data[i] = Math.random() * 2 - 1;
          }
          const noise = offline.createBufferSource();
          noise.buffer = noiseBuffer;

          if (recipe.filter) {
              const filter = offline.createBiquadFilter();
              filter.type = 'lowpass';
              filter.frequency.setValueAtTime(recipe.filter[0], 0);
              filter.frequency.exponentialRampToValueAtTime(recipe.filter[1], recipe.duration);
              noise.connect(filter);
              filter.connect(outputNode);
          } else {
              noise.connect(outputNode);
          }
          noise.start();
      }

      return await offline.startRendering();
  }

  public playAmbience(key: string) {
      if (!this.ctx || !this.ambienceGain) return;
      
      if (this.currentAmbienceKey === key && this.currentAmbienceNode) {
          return; 
      }

      if (this.currentAmbienceNode) {
          const oldNode = this.currentAmbienceNode;
          try { oldNode.stop(this.ctx.currentTime + 0.5); } catch {}
          this.currentAmbienceNode = null;
      }

      const buffer = this.buffers.get(key);
      if (!buffer) return;

      const source = this.ctx.createBufferSource();
      source.buffer = buffer;
      source.loop = true;
      
      const gain = this.ctx.createGain();
      gain.gain.setValueAtTime(0, this.ctx.currentTime);
      gain.gain.linearRampToValueAtTime(1.0, this.ctx.currentTime + 2.0); 

      source.connect(gain);
      gain.connect(this.ambienceGain); 
      source.start();
      
      this.currentAmbienceNode = source;
      this.currentAmbienceKey = key;
  }

  public playSound(key: string) {
      if (!this.ctx || !this.sfxGain) return;
      const buffer = this.buffers.get(key);
      const recipe = AUDIO_CONFIG[key];
      if (!buffer || !recipe) return;

      const source = this.ctx.createBufferSource();
      source.buffer = buffer;
      
      if (recipe.pitchVariance > 0) {
          const detune = (Math.random() * recipe.pitchVariance * 2) - recipe.pitchVariance;
          source.detune.value = detune;
      }

      source.connect(this.sfxGain);
      source.start();
  }

  private setupEventListeners() {
    GameEventBus.subscribe(GameEvents.PLAYER_FIRED, () => this.playSound('fx_player_fire'));
    GameEventBus.subscribe(GameEvents.ENEMY_DESTROYED, (p) => { 
        if (p.type === 'kamikaze') this.playSound('fx_impact_heavy');
        else this.playSound('fx_impact_light');
    });
    GameEventBus.subscribe(GameEvents.PLAYER_HIT, () => {
        this.playSound('fx_impact_heavy'); 
        this.duckMusic(0.7, 1.0);
    });
    GameEventBus.subscribe(GameEvents.GAME_OVER, () => {
        this.playSound('fx_impact_heavy');
        this.duckMusic(1.0, 3.0);
    });
    GameEventBus.subscribe(GameEvents.PANEL_HEALED, () => this.playSound('loop_heal'));
    GameEventBus.subscribe(GameEvents.UPGRADE_SELECTED, () => this.playSound('fx_level_up'));
    GameEventBus.subscribe(GameEvents.PANEL_DESTROYED, () => {
        this.playSound('fx_impact_heavy'); 
        this.duckMusic(0.8, 1.5);
    });
  }

  private duckMusic(intensity: number, duration: number) {
      if (!this.ctx || !this.musicGain) return;
      const settings = useStore.getState().audioSettings;
      if (!settings.music) return;
      
      const now = this.ctx.currentTime;
      const baseVol = 0.4;
      const targetVol = baseVol * (1.0 - intensity);
      
      this.musicGain.gain.cancelScheduledValues(now);
      this.musicGain.gain.setValueAtTime(this.musicGain.gain.value, now);
      this.musicGain.gain.linearRampToValueAtTime(targetVol, now + 0.05);
      this.musicGain.gain.exponentialRampToValueAtTime(baseVol, now + duration);
  }

  public startMusic() {
    this.isMusicStarted = true;
    if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume().catch(() => {});
    if (this.isReady) {
        this.playAmbience('ambience_core');
    }
    if (!this.musicElement) this.setupMusic();
    if (this.musicElement) this.musicElement.play().catch(() => {});
  }

  private setupMusic() {
    if (!this.ctx || !this.musicGain || this.musicElement) return;
    this.musicElement = new Audio('/assets/audio/bg_music_placeholder.mp3');
    this.musicElement.loop = true;
    this.musicElement.crossOrigin = "anonymous";
    const source = this.ctx.createMediaElementSource(this.musicElement);
    source.connect(this.musicGain);
  }

  public playClick() { this.playSound('ui_click'); }
  public playHover() { this.playSound('ui_hover'); }
  public playBootSequence() { this.playSound('fx_boot_sequence'); } 
  public playDrillSound() { this.playSound('loop_drill'); }
  public playRebootZap() { this.playSound('loop_reboot'); }
  
  public setMasterMute(m: boolean) { 
      useStore.setState(s => ({ audioSettings: { ...s.audioSettings, master: !m } }));
      this.updateVolumes();
  }
  public setMusicMute(m: boolean) { 
      useStore.setState(s => ({ audioSettings: { ...s.audioSettings, music: !m } }));
      this.updateVolumes();
  }
  public setSfxMute(m: boolean) { 
      useStore.setState(s => ({ audioSettings: { ...s.audioSettings, sfx: !m } }));
      this.updateVolumes();
  }
  public setAmbienceMute(m: boolean) {
      useStore.setState(s => ({ audioSettings: { ...s.audioSettings, ambience: !m } }));
      this.updateVolumes();
  }
}

export const AudioSystem = new AudioSystemController();


=====================================
FILE: ./src/core/store/useStore.ts
=====================================
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { useGameStore } from '@/game/store/useGameStore';
import { EnemyTypes } from '@/game/config/Identifiers';

// --- TYPES ---
interface AudioSettings {
  master: boolean;
  music: boolean;
  sfx: boolean;
  ambience: boolean;
  
  volumeMaster: number;
  volumeMusic: number;
  volumeSfx: number;
  volumeAmbience: number;
  
  ambFilter: number;   
  ambSpeed: number;    
  ambWidth: number;    
  ambModSpeed: number; 
  ambModDepth: number; 
}

const DEFAULT_AUDIO: AudioSettings = {
  master: true,
  music: false,
  sfx: true,
  ambience: true,
  volumeMaster: 1.0,
  volumeMusic: 1.0,
  volumeSfx: 1.0,
  volumeAmbience: 1.0,
  ambFilter: 0.5,
  ambSpeed: 0.5,
  ambWidth: 0.5,
  ambModSpeed: 0.5, 
  ambModDepth: 0.5, 
};

type ModalType = 'none' | 'about' | 'gallery' | 'feed' | 'contact' | 'settings';
type BootState = 'standby' | 'active' | 'sandbox';
type SandboxView = 'arena' | 'gallery' | 'audio';

interface DebugFlags {
  godMode: boolean;
  panelGodMode: boolean;
  peaceMode: boolean;
  showHitboxes: boolean;
  timeScale: number;
}

interface AppState {
  bootState: BootState;
  introDone: boolean;
  isBreaching: boolean;
  activeModal: ModalType;
  hoveredItem: string | null;
  
  sandboxView: SandboxView;
  galleryTarget: string;
  galleryAction: 'IDLE' | 'ATTACK';
  
  audioSettings: AudioSettings;
  screenShakeStrength: number; 
  
  isDebugOpen: boolean;
  isDebugMinimized: boolean;
  debugFlags: DebugFlags;
  
  setBootState: (state: BootState) => void;
  setIntroDone: (done: boolean) => void;
  startBreach: () => void;
  
  setSandboxView: (view: SandboxView) => void;
  setGalleryTarget: (target: string) => void;
  toggleGalleryAction: () => void;
  
  openModal: (modal: ModalType) => void;
  closeModal: () => void;
  toggleSettings: () => void;
  
  setHovered: (item: string | null) => void;
  resetApplication: () => void;
  
  toggleMaster: () => void;
  toggleMusic: () => void;
  toggleSfx: () => void;
  toggleAmbience: () => void;
  setVolume: (channel: keyof AudioSettings, value: number, max?: number) => void;
  resetAudioSettings: () => void;
  
  setScreenShake: (val: number) => void;
  
  toggleDebugMenu: () => void;
  toggleDebugMinimize: () => void;
  setDebugFlag: (key: keyof DebugFlags, value: any) => void;
  resetDebugFlags: () => void;
}

export const useStore = create<AppState>()(
  persist(
    (set, get) => ({
      bootState: 'standby',
      introDone: false,
      isBreaching: false,
      activeModal: 'none',
      hoveredItem: null,
      
      sandboxView: 'audio',
      galleryTarget: EnemyTypes.DRILLER,
      galleryAction: 'IDLE',
      
      audioSettings: { ...DEFAULT_AUDIO },
      
      screenShakeStrength: 1.0, 
      
      isDebugOpen: false,
      isDebugMinimized: false,
      debugFlags: {
        godMode: false,
        panelGodMode: false,
        peaceMode: false,
        showHitboxes: false,
        timeScale: 1.0,
      },

      setBootState: (bs) => set({ bootState: bs }),
      setIntroDone: (done) => set({ introDone: done }),
      startBreach: () => set({ isBreaching: true }),
      
      setSandboxView: (view) => set({ sandboxView: view }),
      setGalleryTarget: (target) => set({ galleryTarget: target }),
      toggleGalleryAction: () => set(state => ({ galleryAction: state.galleryAction === 'IDLE' ? 'ATTACK' : 'IDLE' })),
      
      // REMOVED AUDIO CALLS FROM HERE TO ALLOW UI CONTROL
      openModal: (modal) => set({ activeModal: modal }),
      closeModal: () => set({ activeModal: 'none' }),

      toggleSettings: () => {
          const current = get().activeModal;
          if (current === 'settings') get().closeModal();
          else get().openModal('settings');
      },
      
      setHovered: (item) => set({ hoveredItem: item }),
      
      resetApplication: () => {
          useGameStore.getState().stopGame();
          useGameStore.getState().resetGame(); 
          set({
              bootState: 'standby',
              introDone: false,
              isBreaching: false,
              activeModal: 'none',
              isDebugOpen: false,
              isDebugMinimized: false,
              sandboxView: 'audio',
              galleryTarget: EnemyTypes.DRILLER,
              galleryAction: 'IDLE'
          });
      },
      
      toggleMaster: () => {
          set(s => ({ audioSettings: { ...s.audioSettings, master: !s.audioSettings.master } }));
          AudioSystem.updateVolumes();
          if (get().audioSettings.master) AudioSystem.playClick(); 
      },
      toggleMusic: () => {
          set(s => ({ audioSettings: { ...s.audioSettings, music: !s.audioSettings.music } }));
          AudioSystem.updateVolumes();
          if (get().audioSettings.music) AudioSystem.playClick();
      },
      toggleSfx: () => {
          set(s => ({ audioSettings: { ...s.audioSettings, sfx: !s.audioSettings.sfx } }));
          AudioSystem.updateVolumes();
          if (get().audioSettings.sfx) AudioSystem.playClick();
      },
      toggleAmbience: () => {
          set(s => ({ audioSettings: { ...s.audioSettings, ambience: !s.audioSettings.ambience } }));
          AudioSystem.updateVolumes();
          if (get().audioSettings.ambience) AudioSystem.playClick();
      },
      
      setVolume: (channel, value, max = 2.0) => {
          const clamped = Math.max(0, Math.min(max, value));
          set(s => ({ audioSettings: { ...s.audioSettings, [channel]: clamped } }));
          AudioSystem.updateVolumes();
      },
      
      resetAudioSettings: () => {
          set({ audioSettings: { ...DEFAULT_AUDIO } });
          AudioSystem.updateVolumes();
          AudioSystem.playClick();
      },
      
      setScreenShake: (val) => set({ screenShakeStrength: val }),
      
      toggleDebugMenu: () => set(state => ({ isDebugOpen: !state.isDebugOpen })),
      toggleDebugMinimize: () => set(state => ({ isDebugMinimized: !state.isDebugMinimized })),
      setDebugFlag: (key, value) => set(state => ({ 
          debugFlags: { ...state.debugFlags, [key]: value } 
      })),
      resetDebugFlags: () => set({
          debugFlags: { godMode: false, panelGodMode: false, peaceMode: false, showHitboxes: false, timeScale: 1.0 }
      })
    }),
    {
      name: 'mesoelfy-ui-settings-v3',
      partialize: (state) => ({ 
          audioSettings: state.audioSettings,
          screenShakeStrength: state.screenShakeStrength,
          introDone: state.introDone
      }), 
    }
  )
);


=====================================
FILE: ./src/app/layout.tsx
=====================================
import type { Metadata, Viewport } from 'next';
import { Montserrat, JetBrains_Mono } from 'next/font/google';
import '@/styles/globals.css';

const montserrat = Montserrat({ 
  subsets: ['latin'],
  weight: ['400', '700', '900'], 
  variable: '--font-montserrat',
  display: 'swap',
});

const jetbrains = JetBrains_Mono({
  subsets: ['latin'],
  weight: ['400', '700'],
  variable: '--font-jetbrains',
  display: 'swap',
});

export const metadata: Metadata = {
  title: 'MESOELFY // LATENT SPACE BANDIT',
  description: 'The official digital HQ of Mesoelfy. Art, Lore, and Neural Network Injections.',
  icons: {
    icon: '/favicon.ico',
  },
  openGraph: {
    title: 'MESOELFY_OS',
    description: 'Access the terminal. View the art. Breach the firewall.',
    url: 'https://mesoelfy.github.io',
    siteName: 'MESOELFY',
    images: [
      {
        url: 'https://mesoelfy.github.io/assets/images/social-card.jpg',
        width: 1200,
        height: 630,
      },
    ],
    locale: 'en_US',
    type: 'website',
  },
  twitter: {
    card: 'summary_large_image',
    title: 'MESOELFY // LATENT SPACE BANDIT',
    description: 'Access the terminal. View the art. Breach the firewall.',
    images: ['https://mesoelfy.github.io/assets/images/social-card.jpg'],
  },
};

export const viewport: Viewport = {
  themeColor: '#000000',
  colorScheme: 'dark',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" className={`${montserrat.variable} ${jetbrains.variable}`}>
      <body 
        className="bg-black text-primary-green selection:bg-primary-green selection:text-black font-mono"
        style={{ backgroundColor: '#000000' }} // Hardcode black to prevent FOUC
      >
        <div className="relative w-full h-full">
          {children}
        </div>
      </body>
    </html>
  );
}


=====================================
FILE: ./src/app/page.tsx
=====================================
'use client';

import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { SceneCanvas } from '@/scene/canvas/SceneCanvas';
import { GlassPanel } from '@/ui/atoms/GlassPanel';
import { SocialRow } from '@/ui/molecules/SocialRow';
import { LiveArtGrid } from '@/ui/molecules/LiveArtGrid';
import { HoloCommLog } from '@/ui/molecules/HoloCommLog';
import { IdentityHUD } from '@/ui/molecules/IdentityHUD';
import { Header } from '@/ui/organisms/Header';
import { Footer } from '@/ui/organisms/Footer';
import { AboutModal } from '@/features/identity/AboutModal';
import { FeedModal } from '@/features/feed/FeedModal';
import { GalleryModal } from '@/features/gallery/GalleryModal';
import { ContactModal } from '@/features/contact/ContactModal';
import { SettingsModal } from '@/features/settings/SettingsModal';
import { MatrixBootSequence } from '@/features/intro/MatrixBootSequence';
import { GameOverlay } from '@/game/GameOverlay';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { CustomCursor } from '@/ui/atoms/CustomCursor';
import { ZenBomb } from '@/ui/atoms/ZenBomb';
import { DebugOverlay } from '@/features/debug/DebugOverlay';
import { SimulationHUD } from '@/features/sandbox/SimulationHUD';
import { WebGLErrorBoundary } from '@/ui/overlays/ErrorBoundary';
import { GlobalBackdrop } from '@/ui/overlays/GlobalBackdrop'; // NEW
import { clsx } from 'clsx';

export default function Home() {
  const { openModal, setIntroDone, bootState, setBootState, isBreaching, startBreach } = useStore(); 
  const startGame = useGameStore(s => s.startGame);
  const recalcIntegrity = useGameStore(s => s.recalculateIntegrity);
  const systemIntegrity = useGameStore(s => s.systemIntegrity);
  const isZenMode = useGameStore(s => s.isZenMode);
  
  const isGameOver = systemIntegrity <= 0;
  const isSandbox = bootState === 'sandbox';

  useEffect(() => {
      AudioSystem.init();
  }, []);

  const handleBreachStart = () => {
    AudioSystem.playSound('initialize_impact');
    startBreach();
  };

  const handleBootComplete = () => {
    setTimeout(() => {
      setBootState('active');
      setIntroDone(true);
      AudioSystem.startMusic(); 
      startGame();
    }, 200);
  };

  useEffect(() => {
    if (bootState !== 'active') return;
    const interval = setInterval(recalcIntegrity, 500);
    return () => clearInterval(interval);
  }, [bootState, recalcIntegrity]);

  const isSceneVisible = bootState !== 'standby' || isBreaching;

  return (
    <div id="global-app-root" className="relative w-full h-screen overflow-hidden cursor-none bg-black">
      
      <CustomCursor />
      
      {/* GLOBAL BACKDROP HANDLES DIMMING FOR ALL MODALS */}
      <GlobalBackdrop />
      
      <DebugOverlay />

      <main className="relative w-full h-full flex flex-col overflow-hidden text-primary-green selection:bg-primary-green selection:text-black font-mono">
        
        <WebGLErrorBoundary>
            <SceneCanvas className={clsx("blur-0 transition-opacity duration-[2000ms]", isSceneVisible ? "opacity-100" : "opacity-0")} />
            
            <div className={clsx("absolute inset-0 z-[60] transition-opacity duration-[2000ms] pointer-events-none", isSceneVisible ? "opacity-100" : "opacity-0")}>
                <GameOverlay />
            </div>
        </WebGLErrorBoundary>

        {isSandbox && <SimulationHUD />}

        {!isSandbox && (
            <>
                <AboutModal />
                <FeedModal />
                <GalleryModal />
                <ContactModal />
                <SettingsModal />
                <ZenBomb />
            </>
        )}

        {bootState === 'standby' && (
          <MatrixBootSequence 
             onComplete={handleBootComplete} 
             onBreachStart={handleBreachStart} 
          />
        )}

        {!isSandbox && (
            <div className={`relative z-10 flex-1 flex flex-col h-full transition-all duration-1000 ease-in-out ${bootState === 'active' ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-4'}`}>
              <Header />

              <div className="flex-1 min-h-0 relative w-full max-w-[1600px] mx-auto p-4 md:p-6">
                <AnimatePresence>
                  {!isZenMode && (
                    <motion.div 
                      className={clsx(
                          "grid grid-cols-1 md:grid-cols-12 gap-4 md:gap-6 h-full w-full scrollbar-thin scrollbar-thumb-primary-green scrollbar-track-black",
                          isGameOver ? "overflow-visible" : "overflow-y-auto md:overflow-hidden"
                      )}
                      initial="hidden"
                      animate="visible"
                      exit={{ opacity: 0, scale: 0.95, transition: { duration: 0.5 } }}
                      variants={{
                        hidden: { opacity: 0 },
                        visible: { 
                          opacity: 1, 
                          transition: { 
                            staggerChildren: 0.3,
                            delayChildren: 0.2 
                          } 
                        }
                      }}
                    >
                      {/* IDENTITY COLUMN */}
                      <div className="md:col-span-4 flex flex-col gap-4 md:gap-6 h-auto">
                        <GlassPanel title="IDENTITY_CORE" className="flex-1 min-h-0" gameId="identity">
                          <IdentityHUD />
                        </GlassPanel>

                        <GlassPanel title="SOCIAL_UPLINK" className="h-52 shrink-0" gameId="social">
                           <SocialRow />
                        </GlassPanel>
                      </div>

                      {/* CONTENT COLUMN */}
                      <div className="md:col-span-8 flex flex-col gap-4 md:gap-6 h-auto">
                        <GlassPanel title="LATEST_LOGS" className="h-48 md:h-64 shrink-0" gameId="feed">
                          <div className="w-full h-full flex items-center justify-center p-4">
                            <div className="flex flex-col items-center justify-center gap-4 bg-black/20 p-8 w-full max-w-lg marching-ants [--ant-color:rgba(27,185,48,0.3)]">
                              <p className="animate-pulse text-primary-green-dim text-xs tracking-widest font-bold">&gt; ESTABLISHING UPLINK...</p>
                              <button 
                                onClick={() => { AudioSystem.playClick(); openModal('feed'); }} 
                                onMouseEnter={() => AudioSystem.playHover()}
                                className="group w-full py-3 border border-primary-green-dim/50 text-primary-green font-header font-black text-lg tracking-[0.2em] uppercase transition-all duration-300 hover:border-alert-yellow hover:text-alert-yellow hover:shadow-[0_0_20px_rgba(234,231,71,0.3)] hover:bg-alert-yellow/5 relative overflow-hidden"
                              >
                                <span className="relative z-10 group-hover:translate-x-1 transition-transform duration-300 inline-block">
                                    [ ACCESS_TERMINAL ]
                                </span>
                              </button>
                            </div>
                          </div>
                        </GlassPanel>

                        <div className="flex flex-col md:flex-row gap-4 md:gap-6 items-start h-auto">
                          <GlassPanel title="ART_DB" className="flex-1 h-auto" gameId="art">
                             <LiveArtGrid />
                          </GlassPanel>

                          <GlassPanel title="HOLO_COMM" className="w-full md:w-[45%] shrink-0 h-auto" gameId="video">
                             <HoloCommLog />
                          </GlassPanel>
                        </div>
                      </div>
                    </motion.div>
                  )}
                </AnimatePresence>
              </div>
              
              <Footer />
            </div>
        )}
      </main>
    </div>
  );
}


=====================================
FILE: ./src/features/settings/tabs/SoundTab.tsx
=====================================
import { useStore } from '@/core/store/useStore';
import { RangeSlider } from '../components/RangeSlider';
import { RotateCcw, Info } from 'lucide-react';

export const SoundTab = () => {
  const { audioSettings, setVolume, resetAudioSettings } = useStore();

  return (
    <div className="space-y-8 animate-in fade-in slide-in-from-bottom-4 duration-500 pb-10">
      
      {/* SECTION 1: GLOBAL MIXER */}
      <div className="space-y-4">
        <h3 className="text-sm font-header font-black text-primary-green border-b border-primary-green/30 pb-2 mb-4 tracking-widest flex justify-between items-center">
          <span>GLOBAL_MIXER</span>
          <span className="text-[9px] font-mono opacity-50">HEADROOM: 300%</span>
        </h3>
        
        <div className="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-6">
          <RangeSlider 
            label="MASTER_GAIN" 
            value={audioSettings.volumeMaster} 
            max={3.0}
            displayMax={300}
            onChange={(v) => setVolume('volumeMaster', v, 3.0)} 
          />
          <RangeSlider 
            label="MUSIC_LEVEL" 
            value={audioSettings.volumeMusic} 
            max={3.0}
            displayMax={300}
            onChange={(v) => setVolume('volumeMusic', v, 3.0)} 
          />
          <RangeSlider 
            label="SFX_LEVEL" 
            value={audioSettings.volumeSfx} 
            max={3.0}
            displayMax={300}
            onChange={(v) => setVolume('volumeSfx', v, 3.0)} 
          />
          <RangeSlider 
            label="AMBIENCE_LEVEL" 
            value={audioSettings.volumeAmbience} 
            max={3.0}
            displayMax={300}
            onChange={(v) => setVolume('volumeAmbience', v, 3.0)} 
          />
        </div>
      </div>

      {/* SECTION 2: AMBIENCE LAB (CALIBRATED) */}
      <div className="space-y-4 pt-4 border-t border-white/10">
        <div className="flex items-center justify-between border-b border-alert-yellow/30 pb-2 mb-4">
            <h3 className="text-sm font-header font-black text-alert-yellow tracking-widest">
              AMBIENCE_LAB // NOISE_FLOOR_SYNTH
            </h3>
            <div className="flex items-center gap-2 text-[9px] text-alert-yellow opacity-70">
                <Info size={12} />
                <span>PROCEDURAL_GENERATION</span>
            </div>
        </div>

        <p className="text-[10px] font-mono text-gray-400 mb-6 max-w-2xl leading-relaxed">
          The "Noise Floor" prevents digital silence. 
          Modify the physics below to reshape the room acoustics in real-time.
        </p>

        {/* ROW 1: TONE & SPACE */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mb-6">
          <RangeSlider 
            label="DENSITY (FILTER)" 
            value={audioSettings.ambFilter * 100} 
            max={100}
            markerValue={50}
            onChange={(v) => setVolume('ambFilter', v / 100, 1.0)} 
            color="accent-alert-yellow"
            // Math: 300 * 10^((val-0.5)*2)
            format={(v) => {
                const norm = v / 100;
                const hz = 300 * Math.pow(10, (norm - 0.5) * 2);
                return `${hz.toFixed(0)} Hz`;
            }}
          />
          <RangeSlider 
            label="WIDTH (STEREO)" 
            value={audioSettings.ambWidth * 100}
            max={100} 
            markerValue={50}
            onChange={(v) => setVolume('ambWidth', v / 100, 1.0)} 
            color="accent-alert-yellow"
            format={(v) => {
                const norm = v / 100;
                return `${(Math.pow(norm, 3) * 80).toFixed(0)}% Sep`;
            }}
          />
        </div>

        {/* ROW 2: MOVEMENT */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
          <RangeSlider 
            label="CIRCULATION (SPEED)" 
            value={audioSettings.ambSpeed * 100} 
            max={100}
            markerValue={50}
            onChange={(v) => setVolume('ambSpeed', v / 100, 1.0)} 
            color="accent-alert-yellow"
            format={(v) => {
                const norm = v / 100;
                const hz = 0.05 * Math.pow(10, (norm - 0.5) * 2);
                return `${(1/hz).toFixed(1)}s`;
            }}
          />
          <RangeSlider 
            label="FLUCTUATION (MOD)" 
            value={audioSettings.ambModSpeed * 100} 
            max={100}
            markerValue={50}
            onChange={(v) => setVolume('ambModSpeed', v / 100, 1.0)} 
            color="accent-alert-yellow"
            format={(v) => {
                const norm = v / 100;
                const hz = 0.2 * Math.pow(10, (norm - 0.5) * 2);
                return `${(1/hz).toFixed(1)}s`;
            }}
          />
          <RangeSlider 
            label="INSTABILITY (DEPTH)" 
            value={audioSettings.ambModDepth * 100} 
            max={100}
            markerValue={50}
            onChange={(v) => setVolume('ambModDepth', v / 100, 1.0)} 
            color="accent-alert-yellow"
            format={(v) => `+/- ${(10 * Math.pow(10, (v/100 - 0.5) * 2)).toFixed(0)} Hz`}
          />
        </div>
      </div>

      {/* SECTION 3: ACTIONS */}
      <div className="pt-8 flex justify-end">
        <button 
          onClick={resetAudioSettings}
          className="flex items-center gap-2 px-4 py-2 border border-critical-red/50 text-critical-red hover:bg-critical-red hover:text-black font-mono text-xs font-bold transition-all"
        >
          <RotateCcw size={14} />
          FACTORY_RESET
        </button>
      </div>

    </div>
  );
};


=====================================
FILE: ./src/features/settings/components/RangeSlider.tsx
=====================================
import { clsx } from 'clsx';
import { AudioSystem } from '@/core/audio/AudioSystem';

interface RangeSliderProps {
  label: string;
  value: number; 
  onChange: (val: number) => void;
  max?: number; 
  displayMax?: number; 
  format?: (val: number) => string;
  markerValue?: number; 
}

export const RangeSlider = ({ 
  label, 
  value, 
  onChange, 
  max = 3.0,
  displayMax = 300,
  markerValue = 1.0,
  format
}: RangeSliderProps) => {
  
  const currentPercent = (value / max) * 100;
  const uiValue = value * (displayMax / max);
  const markerPercent = (markerValue / max) * 100;

  let trackColor = "bg-primary-green";
  let glowColor = "shadow-[0_0_10px_#78F654]";
  
  if (value > 2.0) {
      trackColor = "bg-critical-red";
      glowColor = "shadow-[0_0_15px_#FF003C]";
  } else if (value > 1.0) {
      trackColor = "bg-alert-yellow";
      glowColor = "shadow-[0_0_10px_#eae747]";
  }

  const displayString = format ? format(value) : `${Math.round(uiValue)}%`;

  return (
    <div 
        className="flex flex-col gap-1.5 w-full group"
        onMouseEnter={() => AudioSystem.playHover()}
    >
      <div className="flex justify-between items-end">
        <span className="text-[10px] font-bold font-mono tracking-wider opacity-80 text-gray-400 group-hover:text-white transition-colors">{label}</span>
        <span className={clsx("text-xs font-mono font-bold transition-colors", 
            value > 2.0 ? "text-critical-red animate-pulse" : 
            value > 1.0 ? "text-alert-yellow" : "text-primary-green"
        )}>
            {displayString}
        </span>
      </div>
      
      <div className="relative h-6 flex items-center">
        <div className="absolute inset-x-0 h-1.5 bg-gray-900 rounded-full overflow-hidden border border-white/10">
             <div 
                className={clsx("h-full transition-all duration-75 ease-out", trackColor, glowColor)} 
                style={{ width: `${currentPercent}%` }}
             />
        </div>

        <div 
            className="absolute top-0 bottom-0 w-[2px] bg-white/20 z-0 pointer-events-none group-hover:bg-white/50 transition-colors" 
            style={{ left: `${markerPercent}%` }}
        >
            <div className="absolute -top-1 left-1/2 -translate-x-1/2 w-1 h-1 bg-white/50 rounded-full" />
        </div>
        
        <input 
          type="range"
          min="0" 
          max={displayMax} 
          step="1"
          value={uiValue}
          onChange={(e) => {
              const raw = parseFloat(e.target.value);
              const logicVal = (raw / displayMax) * max;
              onChange(logicVal);
          }}
          className="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-20"
          data-interactive="true"
        />
        
        <div 
            className="absolute h-3 w-1 bg-white z-10 pointer-events-none shadow-sm"
            style={{ left: `calc(${currentPercent}% - 2px)` }}
        />
      </div>
    </div>
  );
};


=====================================
FILE: ./src/features/settings/SettingsModal.tsx
=====================================
import { useStore } from '@/core/store/useStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { motion, AnimatePresence } from 'framer-motion';
import { X, Settings, Volume2, Cpu, Monitor } from 'lucide-react';
import { clsx } from 'clsx';
import { useState } from 'react';
import { SoundTab } from './tabs/SoundTab';

const TABS = [
  { id: 'SOUND', label: 'AUDIO_CONFIG', icon: Volume2 },
  { id: 'GRAPHICS', label: 'DISPLAY', icon: Monitor }, 
  { id: 'SYSTEM', label: 'SYSTEM', icon: Cpu },       
];

export const SettingsModal = () => {
  const { activeModal, closeModal } = useStore();
  const [activeTab, setActiveTab] = useState('SOUND');
  const isOpen = activeModal === 'settings';

  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 z-[200] flex items-center justify-center p-4 md:p-10 pointer-events-none">
          
          <motion.div
            initial={{ scale: 0.95, opacity: 0, y: 10 }}
            animate={{ scale: 1, opacity: 1, y: 0 }}
            exit={{ scale: 0.95, opacity: 0, y: 10 }}
            transition={{ type: "spring", bounce: 0, duration: 0.2 }}
            className="relative w-full max-w-5xl h-full max-h-[85vh] bg-black border border-primary-green shadow-[0_0_50px_rgba(0,255,65,0.1)] flex flex-col overflow-hidden pointer-events-auto"
          >
            <div className="flex items-center justify-between px-6 py-4 border-b border-primary-green/30 bg-primary-green/5 shrink-0">
              <div className="flex items-center gap-3">
                <Settings className="text-primary-green animate-spin-slow" size={24} />
                <span className="font-header font-black text-2xl text-primary-green tracking-widest">
                  SYSTEM_SETTINGS
                </span>
              </div>
              <button 
                onClick={() => { closeModal(); AudioSystem.playSound('ui_menu_close'); }}
                onMouseEnter={() => AudioSystem.playHover()} 
                className="p-2 hover:bg-critical-red hover:text-black text-primary-green transition-colors border border-transparent hover:border-critical-red"
              >
                <X size={24} />
              </button>
            </div>

            <div className="flex-1 flex overflow-hidden">
                <div className="w-64 border-r border-primary-green/30 flex flex-col bg-black/50">
                    {TABS.map(tab => (
                        <button
                            key={tab.id}
                            onClick={() => {
                                setActiveTab(tab.id);
                                AudioSystem.playClick();
                            }}
                            onMouseEnter={() => AudioSystem.playHover()}
                            className={clsx(
                                "flex items-center gap-3 px-6 py-4 text-sm font-bold tracking-wider transition-all border-l-4",
                                activeTab === tab.id
                                    ? "bg-primary-green/10 text-primary-green border-primary-green"
                                    : "border-transparent text-primary-green-dim hover:text-primary-green hover:bg-primary-green/5"
                            )}
                        >
                            <tab.icon size={18} />
                            {tab.label}
                        </button>
                    ))}
                </div>

                <div className="flex-1 overflow-y-auto p-8 relative scrollbar-thin scrollbar-thumb-primary-green scrollbar-track-black">
                    <div className="absolute inset-0 pointer-events-none opacity-10 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-primary-green/20 via-black to-black" />
                    
                    <div className="relative z-10">
                        {activeTab === 'SOUND' && <SoundTab />}
                        
                        {activeTab !== 'SOUND' && (
                            <div className="flex flex-col items-center justify-center h-64 text-primary-green-dim font-mono">
                                <span className="animate-pulse">[ MODULE_OFFLINE ]</span>
                            </div>
                        )}
                    </div>
                </div>
            </div>

            <div className="px-6 py-2 bg-black border-t border-primary-green/30 flex justify-between items-center text-[10px] font-mono text-primary-green-dim shrink-0">
              <div className="flex gap-4">
                  <span className="flex items-center gap-2">
                      <span className="border border-primary-green/30 px-1.5 py-0.5 rounded text-primary-green">ESC</span> 
                      CLOSE_MENU
                  </span>
                  <span className="flex items-center gap-2">
                      <span className="border border-primary-green/30 px-1.5 py-0.5 rounded text-primary-green">~</span> 
                      DEBUG_CONSOLE
                  </span>
              </div>
              <div className="opacity-50">FIRMWARE v2.0.4</div>
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/features/contact/ContactModal.tsx
=====================================
import { ModalContainer } from '@/ui/overlays/ModalContainer';
import { Send } from 'lucide-react';

export const ContactModal = () => {
  return (
    <ModalContainer title="ENCRYPTED_UPLINK // CONTACT" type="contact">
      <div className="max-w-2xl mx-auto h-full flex flex-col justify-center">
        
        {/* Added Triangles and Font-Header for the Warning */}
        <div className="p-2 border border-alert-yellow/30 bg-alert-yellow/5 mb-6 text-center flex items-center justify-center gap-3">
          <span className="text-alert-yellow animate-pulse">⚠</span>
          <p className="text-xs text-alert-yellow font-header font-bold tracking-wider">
            WARNING: TRANSMISSIONS ARE MONITORED BY THE AI OVERLORD.
          </p>
          <span className="text-alert-yellow animate-pulse">⚠</span>
        </div>

        <form 
          action="https://formspree.io/f/xkgdbkpz" 
          method="POST"
          className="space-y-6"
        >
          <div className="space-y-1">
            <label className="text-sm text-primary-green-dim uppercase tracking-wider font-header font-bold">Codename</label>
            <input 
              type="text" 
              name="name"
              required
              placeholder="Enter your handle..."
              className="w-full bg-black border border-primary-green-dim/50 p-3 text-primary-green font-mono focus:border-primary-green focus:outline-none focus:shadow-[0_0_10px_rgba(120,246,84,0.2)] transition-all"
            />
          </div>

          <div className="space-y-1">
            <label className="text-sm text-primary-green-dim uppercase tracking-wider font-header font-bold">Frequency (Email)</label>
            <input 
              type="email" 
              name="email"
              required
              placeholder="Enter return frequency..."
              className="w-full bg-black border border-primary-green-dim/50 p-3 text-primary-green font-mono focus:border-primary-green focus:outline-none focus:shadow-[0_0_10px_rgba(120,246,84,0.2)] transition-all"
            />
          </div>

          <div className="space-y-1">
            <label className="text-sm text-primary-green-dim uppercase tracking-wider font-header font-bold">Payload</label>
            <textarea 
              name="message"
              required
              rows={5}
              placeholder="Type your message..."
              className="w-full bg-black border border-primary-green-dim/50 p-3 text-primary-green font-mono focus:border-primary-green focus:outline-none focus:shadow-[0_0_10px_rgba(120,246,84,0.2)] transition-all resize-none"
            />
          </div>

          <button 
            type="submit"
            className="w-full py-4 bg-primary-green text-black font-header font-black uppercase tracking-widest hover:bg-white transition-colors flex items-center justify-center gap-2 group"
          >
            <span>Send Transmission</span>
            <Send size={16} className="group-hover:translate-x-1 transition-transform" />
          </button>
        </form>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/features/identity/AboutModal.tsx
=====================================
import { ModalContainer } from '@/ui/overlays/ModalContainer';
import identity from '@/data/identity.json';

export const AboutModal = () => {
  return (
    <ModalContainer title="IDENTITY_DATABASE // ELFY" type="about">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-8 h-full">
        
        {/* LEFT: The Avatar Grid */}
        <div className="space-y-4">
          <div className="aspect-square w-full border border-latent-purple-light/50 bg-latent-purple-deep/30 relative overflow-hidden group shadow-[0_0_20px_rgba(188,134,186,0.2)]">
            <div className="absolute inset-0 flex items-center justify-center text-latent-purple-light/50 font-bold text-2xl group-hover:text-latent-purple-light transition-colors font-header font-black tracking-widest text-center p-4">
              [ COMPOSITE_IMAGE LOADING ]
            </div>
            <div className="absolute top-0 left-0 w-4 h-4 border-t-2 border-l-2 border-latent-purple-light" />
            <div className="absolute bottom-0 right-0 w-4 h-4 border-b-2 border-r-2 border-latent-purple-light" />
          </div>
          
          <div className="grid grid-cols-4 gap-2">
            {[1,2,3,4].map(i => (
              <div key={i} className="aspect-square border border-latent-purple-dim/30 hover:bg-latent-purple-light/20 hover:border-latent-purple-light cursor-pointer transition-colors" />
            ))}
          </div>
        </div>

        {/* RIGHT: The Data */}
        <div className="space-y-6">
          <div>
            {/* Header: Montserrat */}
            <h2 className="text-4xl font-header font-black text-primary-green mb-2 tracking-wide">HI, I'M ELFY.</h2>
            <div className="h-1 w-20 bg-latent-purple-light mb-4" />
            
            {/* Body: Courier (font-mono) for ease of reading/typewriter feel */}
            <p className="text-lg text-white/90 leading-relaxed font-mono">
              {identity.bio}
            </p>
          </div>

          <div className="space-y-2">
            <h3 className="text-latent-purple-light font-header font-bold uppercase tracking-wider text-sm">Capabilities</h3>
            <ul className="space-y-1">
              {identity.abilities.map((ability, i) => (
                 <li key={i} className="flex items-center gap-2 text-primary-green font-mono">
                   <span className="text-latent-purple-light">&gt;</span> {ability}
                 </li>
              ))}
            </ul>
          </div>

          <div className="p-4 border border-latent-purple-dim/30 bg-latent-purple-deep/20 text-sm text-latent-purple-light font-mono">
            <p>&gt; SYSTEM NOTE: Generated via Latent Space Injection.</p>
            <p>&gt; STATUS: 100% Hype.</p>
          </div>
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/features/intro/MatrixBootSequence.tsx
=====================================
import { useEffect, useRef, useState, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { ShieldAlert, Cpu, Unlock, Lock, Skull } from 'lucide-react';

interface Props {
  onComplete: () => void;
  onBreachStart: () => void;
}

const ASCII_TITLE = `
 ███▄ ▄███▓▓█████  ██████  ▒█████  ▓█████  ██▓      █████▒▓██   ██▓
▓██▒▀█▀ ██▒▓█   ▀▒██    ▒ ▒██▒  ██▒▓█   ▀ ▓██▒    ▒▓█   ▒  ▒██  ██▒
▓██    ▓██░▒███  ░ ▓██▄   ▒██░  ██▒▒███   ▒██░    ▒▓███ ░   ▒██ ██░
▒██    ▒██ ▒▓█  ▄  ▒   ██▒▒██   ██░▒▓█  ▄ ▒██░    ░▓█▒  ░   ░ ▐██░░
▒██▒   ░██▒░▒████▒██████▒▒░ ████▓▒░░▒████▒░██████▒░▒█░      ░ ██▒░░
░ ▒░   ░  ░░░ ▒░ ░ ▒░▒  ░ ░ ▒░▒░▒░ ░░ ▒░ ░░ ▒░▒  ░ ▒ ░       ██▒▒▒
░  ░      ░ ░ ░  ░ ░ ▒  ░   ░ ▒ ▒░  ░ ░  ░░ ░ ▒  ░ ░       ▓██ ░▒░ 
░      ░      ░    ░ ░    ░ ░ ░ ▒     ░     ░ ░    ░ ░     ▒ ▒ ░░  
       ░      ░  ░   ░  ░     ░ ░     ░  ░    ░  ░         ░ ░     
`;

// --- RESTORED ASCII RENDERER ---
const AsciiRenderer = () => {
  const renderedChars = useMemo(() => {
    return ASCII_TITLE.split('').map((char, i) => {
      if (char === '\n') return <br key={i} />;
      if (char === ' ') return <span key={i}> </span>;

      let animClass = '';
      
      if (['█', '▀', '▄', '▌', '▐'].includes(char)) {
        animClass = 'animate-matrix-green text-primary-green-dark';
      } else if (['░', '▒', '▓'].includes(char)) {
        animClass = 'animate-matrix-purple text-latent-purple';
      } else {
        animClass = 'text-primary-green-dark';
      }

      const delay = Math.random() * 2 + 's';

      return (
        <span 
          key={i} 
          className={animClass} 
          style={{ animationDelay: delay }}
        >
          {char}
        </span>
      );
    });
  }, []);

  return (
    <div className="font-mono font-bold leading-[1.1] whitespace-pre text-center select-none overflow-hidden text-[9px] md:text-[11px] shrink-0">
      {renderedChars}
    </div>
  );
};

const BootHeader = ({ step }: { step: number }) => {
  const isUnsafe = step === 3;
  const isBypass = step === 4;
  const isSecure = step >= 5;

  let color = "text-primary-green-dim";
  let statusText = "ESTABLISHING...";
  let bgClass = "bg-primary-green/5";
  
  if (isUnsafe) {
      color = "text-critical-red";
      statusText = "SIGNAL_CORRUPTED";
      bgClass = "bg-critical-red/10 border-critical-red/30";
  } else if (isBypass) {
      color = "text-latent-purple-light";
      statusText = "INJECTING_PAYLOAD";
      bgClass = "bg-latent-purple/10 border-latent-purple/30";
  } else if (isSecure) {
      color = "text-primary-green";
      statusText = "UPLINK_STABLE";
      bgClass = "bg-primary-green/10 border-primary-green/30";
  } else if (step >= 1) {
      statusText = "HANDSHAKING...";
  }

  return (
    <div className={`flex shrink-0 items-center justify-between border-b border-white/10 ${bgClass} px-3 py-2 mb-2 select-none relative z-20 transition-all duration-300`}>
      <div className="flex flex-col leading-none gap-1.5 mt-0.5">
          <span className={`text-[10px] font-mono tracking-widest uppercase ${color} transition-colors duration-300 font-bold`}>
            BOOT_LOADER.SYS
          </span>
          <span className="text-[8px] text-gray-500 font-mono tracking-wider opacity-80">{statusText}</span>
      </div>
      
      <div className="flex gap-1 items-end h-3">
        {[1, 2, 3, 4].map(i => {
           let heightClass = "h-1";
           let animClass = "";
           let barColor = isUnsafe ? "bg-critical-red" : isBypass ? "bg-latent-purple-light" : "bg-primary-green";
           
           if (isUnsafe) {
               heightClass = i % 2 === 0 ? "h-3" : "h-1";
               animClass = "animate-pulse";
           } else if (isBypass) {
               heightClass = (step + i) % 2 === 0 ? "h-3" : "h-2";
           } else if (isSecure) {
               heightClass = "h-3"; 
           } else {
               heightClass = step >= (i-1) ? "h-2" : "h-0.5";
               animClass = step >= (i-1) ? "animate-pulse" : "";
           }

           return (
               <div 
                 key={i} 
                 className={`w-1 rounded-sm transition-all duration-300 ${barColor} ${animClass} ${heightClass}`} 
                 style={{ opacity: isSecure ? 1 : 0.7 }} 
               />
           );
        })}
      </div>
    </div>
  );
};

const CoreHeader = ({ step }: { step: number }) => {
  const isUnsafe = step === 3;
  const isBypass = step === 4;
  const isDecrypted = step === 5;
  const isCaution = step >= 6;

  const [showCpu, setShowCpu] = useState(false);

  useEffect(() => {
    if (step === 5) {
      setShowCpu(false);
      const timer = setTimeout(() => {
        setShowCpu(true);
      }, 700); 
      return () => clearTimeout(timer);
    }
  }, [step]);

  let borderColor = "border-primary-green/30";
  let bgColor = "bg-primary-green/10";
  let textColor = "text-primary-green";

  if (isUnsafe) {
    borderColor = "border-critical-red/50";
    bgColor = "bg-critical-red/10";
    textColor = "text-critical-red";
  } else if (isBypass) {
    borderColor = "border-latent-purple/50";
    bgColor = "bg-latent-purple/10";
    textColor = "text-latent-purple-light";
  }

  return (
    <motion.div 
      className={`flex shrink-0 items-center justify-between border-b px-3 py-2 mb-2 select-none transition-colors duration-500 ${!isCaution ? `${borderColor} ${bgColor}` : ''}`}
      animate={isCaution ? {
        borderColor: ['rgba(120,246,84,0.3)', 'rgba(234,231,71,0.6)', 'rgba(120,246,84,0.3)'],
        backgroundColor: ['rgba(120,246,84,0.1)', 'rgba(234,231,71,0.15)', 'rgba(120,246,84,0.1)'],
      } : {}}
      transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }}
    >
      <motion.span 
        className={`text-sm font-mono font-bold tracking-widest uppercase ${!isCaution ? textColor : ''}`}
        animate={isCaution ? {
            color: ['#78F654', '#eae747', '#78F654']
        } : {}}
        transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }}
      >
        MESOELFY_CORE
      </motion.span>
      
      <div className="relative w-6 h-6 flex items-center justify-center">
         <AnimatePresence mode="wait">
            {isUnsafe ? (
                <motion.div 
                    key="unsafe"
                    initial={{ scale: 0 }} 
                    animate={{ scale: 1, x: [-2, 2, -2, 2, 0] }}
                    exit={{ scale: 0 }}
                    transition={{ x: { repeat: Infinity, duration: 0.1 } }}
                >
                    <ShieldAlert size={18} className="text-critical-red" />
                </motion.div>
            ) : isBypass ? (
                <motion.div 
                    key="bypass"
                    initial={{ opacity: 0, scale: 0.8 }} 
                    animate={{ opacity: 1, scale: 1.1 }} 
                    exit={{ opacity: 0, scale: 0, transition: { duration: 0.2, repeat: 0 } }}
                    transition={{ repeat: Infinity, repeatType: "reverse", duration: 0.8 }}
                >
                     <Unlock size={18} className="text-latent-purple-light" />
                </motion.div>
            ) : isCaution ? (
                <motion.div 
                    key="caution"
                    initial={{ scale: 0, opacity: 0 }} 
                    animate={{ scale: 1, opacity: 1 }}
                >
                    <motion.div
                       animate={{
                           filter: ['drop-shadow(0 0 8px rgba(120,246,84,0.8))', 'drop-shadow(0 0 15px rgba(234,231,71,1))', 'drop-shadow(0 0 8px rgba(120,246,84,0.8))'],
                           color: ['#78F654', '#eae747', '#78F654'],
                           rotate: [0, 8, -8, 0] 
                       }}
                       transition={{ duration: 2.0, repeat: Infinity, ease: "easeInOut" }}
                    >
                         <Skull size={18} />
                    </motion.div>
                </motion.div>
            ) : isDecrypted ? (
                !showCpu ? (
                    <motion.div 
                        key="locked"
                        initial={{ scale: 1.5, opacity: 0 }} 
                        animate={{ scale: 1, opacity: 1 }} 
                        exit={{ scale: 0, opacity: 0, transition: { duration: 0.2 } }}
                        transition={{ type: "spring", stiffness: 400, damping: 20 }}
                    >
                         <Lock size={18} className="text-primary-green drop-shadow-[0_0_8px_rgba(120,246,84,0.8)]" />
                    </motion.div>
                ) : (
                    <motion.div 
                        key="cpu"
                        initial={{ scale: 0, rotate: -45 }} 
                        animate={{ scale: 1, rotate: 0 }} 
                        exit={{ scale: 0, opacity: 0, transition: { duration: 0.2 } }}
                        transition={{ duration: 0.4, ease: "backOut" }}
                    >
                         <Cpu size={18} className="text-primary-green drop-shadow-[0_0_8px_rgba(120,246,84,0.8)]" />
                    </motion.div>
                )
            ) : (
                <motion.div 
                    key="loading"
                    initial={{ opacity: 0 }} 
                    animate={{ opacity: 1, rotate: 360 }} 
                    exit={{ opacity: 0 }}
                    transition={{ rotate: { repeat: Infinity, duration: 2, ease: "linear" } }}
                >
                     <div className="w-4 h-4 border-2 border-primary-green border-t-transparent rounded-full" />
                </motion.div>
            )}
         </AnimatePresence>
      </div>
    </motion.div>
  );
};

const TypedLog = ({ text, color, speed = 20, showDots = false, isActive = false, isPast = false }: any) => {
  const [displayed, setDisplayed] = useState("");
  const [isDoneTyping, setIsDoneTyping] = useState(false);
  
  useEffect(() => {
    let i = 0;
    setDisplayed("");
    setIsDoneTyping(false);
    const interval = setInterval(() => {
      setDisplayed(text.substring(0, i + 1));
      i++;
      if (i >= text.length) {
        setIsDoneTyping(true);
        clearInterval(interval);
      }
    }, speed);
    return () => clearInterval(interval);
  }, [text, speed]);

  if (isPast && displayed !== text) {
    setDisplayed(text);
    setIsDoneTyping(true);
  }

  return (
    <div className={`whitespace-nowrap font-mono ${color} flex items-center shrink-0`}>
      <span>{displayed}</span>
      {isDoneTyping && showDots && <span>{isPast ? '...' : (Math.floor(Date.now() / 300) % 4 === 0 ? '' : '...')}</span>}
      {isActive && <span className="ml-1 animate-cursor-blink text-primary-green font-bold">_</span>}
    </div>
  );
};

const LOG_DATA = [
  { text: "> INITIALIZE NEURAL_LACE", color: "text-primary-green-dim", speed: 40, hasDots: true },
  { text: "> CONNECTED TO LATENT_SPACE.", color: "text-primary-green", speed: 20, hasDots: false },
  { text: "> MOUNT MESOELFY_CORE", color: "text-primary-green-dim", speed: 40, hasDots: true },
  { text: "> ⚠ UNSAFE CONNECTION DETECTED ⚠", color: "text-critical-red", speed: 20, hasDots: false },
  { text: "> BYPASSING SENTINEL_NODES", color: "text-latent-purple-light", speed: 40, hasDots: true },
  { text: "> DECRYPTED.", color: "text-primary-green", speed: 20, hasDots: false },
  { text: "> ⚠ PROCEED WITH CAUTION ⚠", color: "text-alert-yellow", speed: 20, hasDots: false },
];

export const MatrixBootSequence = ({ onComplete, onBreachStart }: Props) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [step, setStep] = useState(0); 
  const stepRef = useRef(0);
  const [isBreaching, setIsBreaching] = useState(false);
  const logsToShow = LOG_DATA.slice(0, step + 1);
  
  const showMatrix = step >= 1;       
  const showPayloadWindow = step >= 2; 
  const showWarningBox = step >= 3;    
  const showButton = step >= 6;        

  useEffect(() => {
    stepRef.current = step;
  }, [step]);

  useEffect(() => {
    const sequence = [
      { t: 3000, step: 1 }, 
      { t: 4000, step: 2 }, 
      { t: 8000, step: 3 }, 
      { t: 9500, step: 4 }, 
      { t: 11500, step: 5 }, 
      { t: 13500, step: 6 }, 
    ];
    const timeouts = sequence.map(({ t, step: s }) => setTimeout(() => {
      if (!isBreaching) setStep(s);
    }, t));
    return () => timeouts.forEach(clearTimeout);
  }, [isBreaching]);

  useEffect(() => {
    if (!showMatrix && !isBreaching) return;
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const cols = Math.floor(canvas.width / 20);
    const ypos = Array(cols).fill(0).map(() => Math.random() * -1000);

    const matrixEffect = () => {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; 
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.font = '14px "Courier New"';

      const currentStep = stepRef.current;
      const isUnsafePhase = currentStep >= 3;
      
      ypos.forEach((y, ind) => {
        const charSet = Math.random() > 0.5 ? 0x16A0 : 0x2200; 
        const text = String.fromCharCode(charSet + Math.random() * 64);
        const x = ind * 20;

        const isPurple = Math.random() > 0.6;
        const isRed = isUnsafePhase && Math.random() > 0.6; 
        
        let color = '#0F0';
        let blur = 0;

        if (isRed) {
            color = '#FF003C';
            blur = 8;
        } else if (isPurple) {
            color = '#9E4EA5';
            blur = 8;
        }

        ctx.fillStyle = color;
        ctx.shadowBlur = blur;
        ctx.shadowColor = color;

        ctx.fillText(text, x, y);
        ctx.shadowBlur = 0;

        const speed = isBreaching ? 100 : 20; 
        if (y > canvas.height + Math.random() * 10000) ypos[ind] = 0;
        else ypos[ind] = y + speed;
      });
    };
    const interval = setInterval(matrixEffect, 50);
    return () => clearInterval(interval);
  }, [showMatrix, isBreaching]); 

  // NOTE: REMOVED KEYDOWN LISTENER HERE (It is now in DebugOverlay)

  const handleInitialize = () => {
    if (isBreaching) return;
    setIsBreaching(true);
    
    onBreachStart();

    AudioSystem.init();
    AudioSystem.playBootSequence();
    AudioSystem.startMusic();
    
    setStep(6);
    setTimeout(onComplete, 800); 
  };

  return (
    <motion.div 
      ref={containerRef}
      animate={{ backgroundColor: isBreaching ? "rgba(0,0,0,0)" : "rgba(0,0,0,1)" }}
      transition={{ duration: 0.5, ease: "easeInOut" }}
      className="fixed inset-0 z-[100] flex flex-col items-center justify-start pt-[20vh] md:pt-[25vh] font-mono overflow-hidden outline-none cursor-none"
    >
      <canvas ref={canvasRef} className={`absolute inset-0 z-0 transition-opacity duration-300 ${showMatrix && !isBreaching ? 'opacity-30' : 'opacity-0'}`} />

      <motion.div 
        className="relative z-10 flex flex-col gap-4 items-center w-full max-w-2xl px-4"
        animate={isBreaching ? { scale: 15, opacity: 0, filter: "blur(10px)" } : { scale: 1, opacity: 1, filter: "blur(0px)" }}
        transition={{ scale: { duration: 0.8, ease: "easeIn" }, opacity: { duration: 0.2, ease: "easeIn" }, filter: { duration: 0.2 } }}
      >
        <motion.div initial={{ y: -20, opacity: 0 }} animate={{ y: 0, opacity: 1 }} className="w-full bg-black/90 border border-primary-green-dim/50 shadow-[0_0_20px_rgba(0,255,65,0.1)] overflow-hidden shrink-0">
          <BootHeader step={step} />
          <div className="p-4 pt-2 h-40 flex flex-col justify-start text-xs md:text-sm font-mono relative z-10 leading-relaxed">
            {logsToShow.map((line, i) => (
              <TypedLog key={i} text={line.text} color={line.color} speed={line.speed} showDots={line.hasDots} isActive={i === step && !isBreaching} isPast={i < step} />
            ))}
          </div>
        </motion.div>

        <AnimatePresence>
          {showPayloadWindow && (
            <motion.div 
              initial={{ y: 50, opacity: 0, height: 0 }}
              animate={{ y: 0, opacity: 1, height: "auto" }}
              transition={{ type: "spring", stiffness: 120, damping: 20 }}
              className="w-full bg-black/90 border border-primary-green shadow-[0_0_40px_rgba(0,255,65,0.15)] overflow-hidden shrink-0"
            >
              <CoreHeader step={step} />
              
              <div className="p-6 flex flex-col items-center gap-4">
                <AsciiRenderer />
                {showWarningBox && (
                  <motion.div 
                    initial={{ opacity: 0, scale: 0.9 }}
                    animate={{ 
                      opacity: 1, scale: 1,
                      boxShadow: ["0 0 10px rgba(255, 0, 60, 0.2)", "0 0 40px rgba(255, 0, 60, 0.6)", "0 0 10px rgba(255, 0, 60, 0.2)"]
                    }}
                    transition={{ opacity: { duration: 0.3 }, scale: { duration: 0.3 }, boxShadow: { duration: 2.5, repeat: Infinity, ease: "easeInOut" } }}
                    className="relative border border-critical-red bg-critical-red/10 w-fit mx-auto flex items-center justify-center gap-4 py-2 px-6 select-none shrink-0"
                  >
                    <motion.span animate={{ opacity: [1, 0.2, 1] }} transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }} className="text-3xl text-critical-red">⚠</motion.span>
                    <span className="text-sm font-header font-black tracking-widest text-center text-critical-red whitespace-nowrap pb-0.5">UNSAFE CONNECTION DETECTED</span>
                    <motion.span animate={{ opacity: [1, 0.2, 1] }} transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }} className="text-3xl text-critical-red">⚠</motion.span>
                  </motion.div>
                )}
                {showButton && (
                  <motion.div initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5, ease: "easeOut" }} className="shrink-0">
                    <button 
                      onClick={handleInitialize}
                      onMouseEnter={() => AudioSystem.playHover()}
                      className="group relative px-8 py-2 overflow-hidden border border-primary-green transition-all hover:shadow-[0_0_30px_rgba(0,255,65,0.6)] cursor-none"
                    >
                      <div className="absolute inset-0 bg-primary-green translate-y-full group-hover:translate-y-0 transition-transform duration-300 ease-out" />
                      <span className="relative z-10 font-mono font-bold text-xl md:text-3xl text-primary-green group-hover:text-black transition-colors block tracking-widest whitespace-nowrap">
                        [ INITIALIZE_SYSTEM.EXE ]
                      </span>
                    </button>
                  </motion.div>
                )}
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </motion.div>
    </motion.div>
  );
};


=====================================
FILE: ./src/features/gallery/GalleryModal.tsx
=====================================
import { ModalContainer } from '@/ui/overlays/ModalContainer';
import gallery from '@/data/gallery.json';
import { ExternalLink, Image as ImageIcon } from 'lucide-react';
import { useState } from 'react';

export const GalleryModal = () => {
  const [filter, setFilter] = useState('ALL');
  
  // Get unique categories
  const categories = ['ALL', ...Array.from(new Set(gallery.map(item => item.category)))];

  const filteredGallery = filter === 'ALL' 
    ? gallery 
    : gallery.filter(item => item.category === filter);

  return (
    <ModalContainer title="ART_DATABASE // VISUALS" type="gallery">
      <div className="flex flex-col h-full gap-6">
        
        {/* Category Tabs */}
        <div className="flex gap-2 overflow-x-auto pb-2 border-b border-primary-green-dim/30">
          {categories.map(cat => (
            <button
              key={cat}
              onClick={() => setFilter(cat)}
              className={`px-4 py-1 font-mono text-sm border transition-all ${
                filter === cat 
                  ? 'bg-primary-green text-black border-primary-green' 
                  : 'text-primary-green-dim border-primary-green-dim/30 hover:text-primary-green hover:border-primary-green'
              }`}
            >
              [{cat}]
            </button>
          ))}
        </div>

        {/* The Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {filteredGallery.map((item) => (
            <a
              key={item.id}
              href={item.url}
              target="_blank"
              rel="noopener noreferrer"
              className="group relative aspect-video bg-black border border-primary-green-dim/30 hover:border-primary-green transition-all overflow-hidden"
            >
              {/* Placeholder Graphic (Since we have no images yet) */}
              <div className="absolute inset-0 flex flex-col items-center justify-center bg-primary-green-dark/10 group-hover:bg-primary-green-dark/20 transition-colors">
                <ImageIcon className="w-12 h-12 text-primary-green-dim/20 group-hover:text-primary-green group-hover:scale-110 transition-all duration-500" />
                <span className="mt-2 text-xs text-primary-green-dim/40 font-mono">ENCRYPTED_IMG</span>
              </div>

              {/* Overlay Info */}
              <div className="absolute inset-x-0 bottom-0 p-3 bg-black/80 backdrop-blur-sm border-t border-primary-green-dim/30 translate-y-full group-hover:translate-y-0 transition-transform duration-300">
                <h4 className="text-primary-green font-bold text-sm">{item.title}</h4>
                <div className="flex items-center gap-1 text-[10px] text-latent-purple-light mt-1">
                  <span>OPEN_ON_X</span>
                  <ExternalLink size={10} />
                </div>
              </div>
              
              {/* Corner accent */}
              <div className="absolute top-0 right-0 w-0 h-0 border-t-[20px] border-t-primary-green/20 border-l-[20px] border-l-transparent" />
            </a>
          ))}
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/features/sandbox/SimulationHUD.tsx
=====================================
import { useStore } from '@/core/store/useStore';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';
import { ServiceLocator } from '@/game/core/ServiceLocator';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { AUDIO_CONFIG } from '@/game/config/AudioConfig';
import { Bug, Clock, Crosshair, Box, ScanEye, Play, Speaker, Settings2, Wind, Terminal, Zap, Shield, HelpCircle } from 'lucide-react';
import { clsx } from 'clsx';
import { useState, useMemo } from 'react';

export const SimulationHUD = () => {
  const { debugFlags, setDebugFlag, sandboxView, setSandboxView } = useStore();
  const [lastPlayed, setLastPlayed] = useState<string | null>(null);
  
  const playSound = (key: string) => {
      if (key.includes('ambience')) {
          AudioSystem.playAmbience(key);
      } else {
          AudioSystem.playSound(key);
      }
      setLastPlayed(key);
      setTimeout(() => setLastPlayed(null), 200);
  };

  const library = useMemo(() => {
      const allKeys = Object.keys(AUDIO_CONFIG);
      const usedKeys = new Set<string>();

      const defineGroup = (keys: string[]) => {
          keys.forEach(k => usedKeys.add(k));
          return keys.filter(k => allKeys.includes(k));
      };

      // 1. UI & FEEDBACK
      const uiKeys = defineGroup([
          'ui_click', 'ui_hover', 'ui_menu_open', 'ui_menu_close', 
          'ui_optimal', 'ui_error', 'ui_chirp'
      ]);

      // 2. COMBAT & FX
      const combatKeys = defineGroup([
          'fx_player_fire', 'fx_enemy_fire', 'fx_boot_sequence',
          'fx_impact_light', 'fx_impact_heavy', 'fx_player_death',
          'fx_level_up', 'fx_reboot_success', 'fx_teleport'
      ]);

      // 3. LOOPS & AMBIENCE
      const loopKeys = defineGroup([
          'ambience_core', 
          'loop_heal', 'loop_reboot', 'loop_warning', 'loop_drill'
      ]);

      // 4. SYNTHESIS LAB (Protos)
      const synKeys = defineGroup(
          allKeys.filter(k => k.startsWith('syn_'))
      );

      // 5. CATCH ALL
      const unusedKeys = allKeys.filter(k => !usedKeys.has(k));

      return {
          UI: { keys: uiKeys, icon: Terminal, color: 'text-primary-green', border: 'border-primary-green' },
          COMBAT: { keys: combatKeys, icon: Zap, color: 'text-critical-red', border: 'border-critical-red' },
          LOOPS: { keys: loopKeys, icon: Wind, color: 'text-service-cyan', border: 'border-service-cyan' },
          SYNTHS: { keys: synKeys, icon: Box, color: 'text-alert-yellow', border: 'border-alert-yellow' },
          MISC_UNTESTED: { keys: unusedKeys, icon: HelpCircle, color: 'text-gray-400', border: 'border-gray-500' }
      };
  }, []);

  return (
    <div className="absolute inset-0 pointer-events-none z-50">
      {/* HEADER */}
      <div className="absolute top-0 left-0 right-0 h-12 bg-black/80 backdrop-blur-md border-b border-service-cyan/30 flex items-center justify-between px-6 pointer-events-auto">
        <div className="flex items-center gap-3 text-service-cyan">
            <Box size={20} />
            <span className="font-header font-black tracking-widest text-lg">HOLO_DECK // SIMULATION</span>
        </div>
        {sandboxView === 'arena' && (
            <div className="flex items-center gap-4 bg-service-cyan/5 px-4 py-1 rounded border border-service-cyan/20">
                <Clock size={16} className="text-service-cyan" />
                <input 
                    type="range" 
                    min="0.0" max="2.0" step="0.1"
                    value={debugFlags.timeScale}
                    onChange={(e) => setDebugFlag('timeScale', parseFloat(e.target.value))}
                    className="w-32 accent-service-cyan h-1.5 bg-gray-800 rounded-lg cursor-pointer"
                />
                <span className="w-12 text-right font-mono font-bold text-service-cyan text-xs">{debugFlags.timeScale.toFixed(1)}x</span>
            </div>
        )}
      </div>

      {/* LEFT SIDEBAR (NAVIGATION) */}
      <div className="absolute left-6 top-24 flex flex-col gap-2 pointer-events-auto w-40">
         <button 
            onClick={() => setSandboxView('audio')}
            className={clsx("flex items-center gap-3 px-4 py-3 border transition-all font-mono text-xs font-bold", sandboxView === 'audio' ? "bg-service-cyan text-black border-service-cyan shadow-[0_0_15px_rgba(0,240,255,0.3)]" : "bg-black/50 text-service-cyan border-service-cyan/30 hover:bg-service-cyan/10")}
         >
            <Speaker size={16} /> SOUND_TEST
         </button>
         <button 
            onClick={() => setSandboxView('arena')}
            className={clsx("flex items-center gap-3 px-4 py-3 border transition-all font-mono text-xs font-bold", sandboxView === 'arena' ? "bg-service-cyan text-black border-service-cyan" : "bg-black/50 text-service-cyan border-service-cyan/30 hover:bg-service-cyan/10")}
         >
            <Crosshair size={16} /> ARENA_MODE
         </button>
         <button 
            onClick={() => setSandboxView('gallery')}
            className={clsx("flex items-center gap-3 px-4 py-3 border transition-all font-mono text-xs font-bold", sandboxView === 'gallery' ? "bg-service-cyan text-black border-service-cyan" : "bg-black/50 text-service-cyan border-service-cyan/30 hover:bg-service-cyan/10")}
         >
            <ScanEye size={16} /> GALLERY_VIEW
         </button>
      </div>

      {/* AUDIO WORKBENCH */}
      {sandboxView === 'audio' && (
          <div className="absolute left-52 top-24 bottom-6 right-6 flex gap-6 pointer-events-auto">
              
              {/* CENTER: WORKBENCH */}
              <div className="flex-1 bg-black/80 backdrop-blur-md border border-white/20 p-6 flex flex-col gap-6 overflow-y-auto">
                  <div className="flex items-center gap-2 border-b border-white/20 pb-2 mb-2">
                      <Settings2 className="text-white" size={20} />
                      <h3 className="font-header font-black text-xl text-white tracking-widest">AUDIO_MATRIX</h3>
                  </div>
                  
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                      <div className="space-y-2">
                          <h4 className="text-xs font-bold text-primary-green border-b border-primary-green/30 pb-1">UI_FEEDBACK</h4>
                          <div className="grid grid-cols-2 gap-2">
                              {library.UI.keys.map(key => (
                                  <button key={key} onClick={() => playSound(key)} className="px-3 py-2 border border-primary-green/30 hover:bg-primary-green/10 text-[10px] text-primary-green text-left transition-colors truncate">
                                      {key}
                                  </button>
                              ))}
                          </div>
                      </div>

                      <div className="space-y-2">
                          <h4 className="text-xs font-bold text-critical-red border-b border-critical-red/30 pb-1">COMBAT_FX</h4>
                          <div className="grid grid-cols-2 gap-2">
                              {library.COMBAT.keys.map(key => (
                                  <button key={key} onClick={() => playSound(key)} className="px-3 py-2 border border-critical-red/30 hover:bg-critical-red/10 text-[10px] text-critical-red text-left transition-colors truncate">
                                      {key}
                                  </button>
                              ))}
                          </div>
                      </div>
                  </div>
                  
                  <div className="mt-4 p-4 border border-service-cyan/30 bg-service-cyan/5">
                      <h4 className="text-xs font-bold text-service-cyan mb-2 flex items-center gap-2">
                          <Wind size={14} /> AMBIENCE_LOOPS
                      </h4>
                      <div className="grid grid-cols-3 gap-3">
                          {library.LOOPS.keys.map(key => (
                              <button key={key} onClick={() => playSound(key)} className="flex flex-col items-center justify-center p-3 border border-service-cyan/30 hover:bg-service-cyan/10 transition-colors">
                                  <span className="text-[10px] text-service-cyan font-bold">{key}</span>
                              </button>
                          ))}
                      </div>
                  </div>

              </div>

              {/* RIGHT: FULL LIBRARY (Categorized) */}
              <div className="w-72 bg-black/90 backdrop-blur-md border border-gray-800 flex flex-col overflow-hidden">
                  <div className="p-3 border-b border-gray-800 bg-gray-900/50">
                      <span className="font-mono font-bold text-xs text-gray-400 tracking-widest">ASSET_BROWSER</span>
                  </div>
                  <div className="flex-1 overflow-y-auto p-3 space-y-6 scrollbar-thin scrollbar-thumb-gray-700 scrollbar-track-black">
                      {Object.entries(library).map(([name, group]) => (
                          <div key={name} className={group.keys.length === 0 ? 'hidden' : ''}>
                              <div className={clsx("flex items-center gap-2 text-[9px] font-bold mb-2 pb-1 border-b uppercase tracking-wider opacity-80", group.color, group.border)}>
                                  <group.icon size={10} />
                                  {name}
                              </div>
                              <div className="grid grid-cols-1 gap-1">
                                  {group.keys.map(key => {
                                      const isPlaying = lastPlayed === key;
                                      return (
                                          <button 
                                              key={key} 
                                              onClick={() => playSound(key)}
                                              className={clsx(
                                                  "flex items-center justify-between px-2 py-1.5 border text-[9px] font-mono transition-all",
                                                  isPlaying 
                                                      ? `${group.border} bg-white text-black` 
                                                      : `border-transparent hover:border-white/10 bg-white/5 text-gray-400 hover:text-white`
                                              )}
                                          >
                                              <span className="truncate w-full text-left">{key}</span>
                                              <Play size={8} className={isPlaying ? "fill-black" : "opacity-0 group-hover:opacity-100"} />
                                          </button>
                                      );
                                  })}
                              </div>
                          </div>
                      ))}
                  </div>
              </div>
          </div>
      )}
    </div>
  );
};


=====================================
FILE: ./src/features/feed/FeedModal.tsx
=====================================
import { ModalContainer } from '@/ui/overlays/ModalContainer';
import feed from '@/data/feed.json';
import { ExternalLink } from 'lucide-react';

export const FeedModal = () => {
  return (
    <ModalContainer title="SYSTEM_LOGS // FEED" type="feed">
      <div className="space-y-6 font-mono">
        {feed.map((post) => (
          <div key={post.id} className="border-l-2 border-primary-green-dim pl-4 py-2 hover:bg-primary-green/5 transition-colors group">
            <div className="flex items-center gap-4 mb-2">
              <span className="text-xs text-primary-green-dim bg-primary-green-dark/30 px-2 py-1 rounded">
                [{post.date}]
              </span>
              <h3 className="text-xl font-bold text-primary-green group-hover:text-alert-yellow transition-colors">
                {post.title}
              </h3>
            </div>
            
            <p className="text-primary-green-dim/80 mb-3 max-w-2xl">
              {post.desc}
            </p>

            <a 
              href={post.link}
              target="_blank"
              rel="noopener noreferrer"
              className="inline-flex items-center gap-2 text-sm text-latent-purple-light hover:text-primary-green underline decoration-latent-purple-dim decoration-dashed underline-offset-4"
            >
              <span>VIEW_SOURCE</span>
              <ExternalLink size={14} />
            </a>
          </div>
        ))}
        
        {/* End of Log Marker */}
        <div className="text-center py-8 text-primary-green-dim/30 animate-pulse">
          -- END OF STREAM --
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/features/debug/tabs/OverridesTab.tsx
=====================================
import { Play, Sparkles, Trash2, Skull, RefreshCw, Crown, Ghost, Shield, Crosshair } from 'lucide-react';
import { clsx } from 'clsx';
import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { PanelRegistry } from '@/game/systems/PanelRegistrySystem';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';
import { AudioSystem } from '@/core/audio/AudioSystem';

interface OverridesTabProps {
  closeDebug: () => void;
}

export const OverridesTab = ({ closeDebug }: OverridesTabProps) => {
  const { setIntroDone, setBootState, bootState, resetApplication, debugFlags, setDebugFlag, resetDebugFlags } = useStore();
  const { startGame, stopGame, activateZenMode } = useGameStore();

  const areAllGodModesOn = debugFlags.godMode && debugFlags.panelGodMode && debugFlags.peaceMode;

  const handleSkipBoot = () => {
    resetDebugFlags();
    setIntroDone(true);
    setBootState('active');
    AudioSystem.init();
    AudioSystem.startMusic();
    startGame();
    closeDebug(); 
  };

  const executeCrash = () => {
    useGameStore.setState({ systemIntegrity: 0 });
    PanelRegistry.destroyAll();
    GameEventBus.emit(GameEvents.GAME_OVER, { score: 0 });
    stopGame();
  };

  const handleForceCrash = () => {
    if (bootState === 'standby') {
        setIntroDone(true);
        setBootState('active');
        AudioSystem.init();
        setTimeout(() => {
            executeCrash();
        }, 100);
    } else {
        executeCrash();
    }
    closeDebug();
  };

  const handleReboot = () => {
    useGameStore.setState({ playerHealth: 100, playerRebootProgress: 0 });
    const panels = PanelRegistry.getAllPanels();
    panels.forEach(p => PanelRegistry.healPanel(p.id, 1000));
    closeDebug();
  };

  const handleZenModeWrapper = () => {
      if (bootState === 'standby') {
          setIntroDone(true);
          setBootState('active');
          AudioSystem.init();
          AudioSystem.startMusic();
      }
      activateZenMode();
      closeDebug();
  };

  const handleSystemFormat = () => {
      resetApplication();
  };

  const toggleGodSuite = () => {
      const newState = !areAllGodModesOn;
      // Play sound before state change
      if (newState) {
          AudioSystem.playSound('powerup');
      } else {
          AudioSystem.playSound('ui_click');
      }
      setDebugFlag('godMode', newState);
      setDebugFlag('panelGodMode', newState);
      setDebugFlag('peaceMode', newState);
  };

  const btnClass = "flex items-center justify-center gap-2 p-3 border transition-all text-xs font-bold";

  return (
    <div className="space-y-6">
      
      <div className="space-y-3">
        <h3 className="text-xs text-primary-green-dim border-b border-primary-green-dim/30 pb-1 mb-2">SCENE_SELECT</h3>
        <div className="grid grid-cols-2 gap-3">
          <button 
            onClick={handleSkipBoot} 
            onMouseEnter={() => AudioSystem.playHover()}
            className={`${btnClass} border-primary-green/50 hover:bg-primary-green hover:text-black`}
          >
            <Play size={14} /> SKIP_BOOT
          </button>
          
          <button 
            onClick={handleZenModeWrapper} 
            onMouseEnter={() => AudioSystem.playHover()}
            className="relative flex items-center justify-center gap-2 p-3 overflow-hidden group transition-all duration-300 border border-transparent hover:border-white/50"
          >
            <div className="absolute inset-0 opacity-20 group-hover:opacity-40 bg-gradient-to-r from-red-500 via-yellow-500 via-green-500 via-blue-500 to-purple-500 animate-gradient-xy transition-opacity" />
            <div className="relative z-10 flex items-center gap-2 text-transparent bg-clip-text bg-gradient-to-r from-red-400 via-yellow-400 to-blue-400 font-bold tracking-widest text-xs group-hover:text-white transition-colors">
                <Sparkles size={14} className="text-yellow-300" /> ZEN_MODE
            </div>
          </button>
          <button 
            onClick={handleSystemFormat} 
            onMouseEnter={() => AudioSystem.playHover()}
            className="col-span-2 flex items-center justify-center gap-2 p-3 border border-gray-500/50 text-gray-400 hover:bg-white hover:text-black transition-all text-xs font-bold"
          >
            <Trash2 size={14} /> SYSTEM_FORMAT
          </button>
        </div>
      </div>

      <div className="space-y-3">
        <h3 className="text-xs text-primary-green-dim border-b border-primary-green-dim/30 pb-1 mb-2">STATE_OVERRIDES</h3>
        <div className="grid grid-cols-2 gap-3">
          <button 
            onClick={handleForceCrash} 
            onMouseEnter={() => AudioSystem.playHover()}
            className={`${btnClass} border-critical-red/50 text-critical-red hover:bg-critical-red hover:text-black`}
          >
            <Skull size={14} /> FORCE_CRASH
          </button>
          <button 
            onClick={handleReboot} 
            onMouseEnter={() => AudioSystem.playHover()}
            className={`${btnClass} border-latent-purple/50 text-latent-purple hover:bg-latent-purple hover:text-black`}
          >
            <RefreshCw size={14} /> REBOOT_CORE
          </button>
        </div>
      </div>

      <div className="space-y-3">
        <h3 className="text-xs text-primary-green-dim border-b border-primary-green-dim/30 pb-1 mb-2">GOD_SUITE</h3>
        
        <button 
          onClick={toggleGodSuite}
          onMouseEnter={() => AudioSystem.playHover()}
          className={clsx(
              "w-full flex items-center justify-center gap-2 p-2 mb-3 text-xs font-bold transition-all border",
              areAllGodModesOn
                  ? "bg-primary-green text-black border-primary-green shadow-[0_0_10px_rgba(0,255,65,0.4)]" 
                  : "bg-primary-green/10 text-primary-green border-primary-green/50 hover:bg-primary-green hover:text-black"
          )}
        >
          <Crown size={14} className={areAllGodModesOn ? "fill-black" : ""} />
          {areAllGodModesOn ? "DISABLE_ALL" : "ENABLE_MAX_POWER"}
        </button>

        <label 
          data-interactive="true"
          onMouseEnter={() => AudioSystem.playHover()}
          className="flex items-center justify-between p-3 border border-primary-green/30 hover:border-primary-green hover:bg-primary-green/20 cursor-pointer transition-all select-none"
        >
          <span className="text-xs font-bold flex items-center gap-2"><Ghost size={14} /> GHOST_MODE (Player Invincible)</span>
          <input 
            type="checkbox" 
            checked={debugFlags.godMode} 
            onChange={(e) => setDebugFlag('godMode', e.target.checked)}
            className="accent-primary-green cursor-pointer"
          />
        </label>

        <label 
          data-interactive="true"
          onMouseEnter={() => AudioSystem.playHover()}
          className="flex items-center justify-between p-3 border border-primary-green/30 hover:border-primary-green hover:bg-primary-green/20 cursor-pointer transition-all select-none"
        >
          <span className="text-xs font-bold flex items-center gap-2"><Shield size={14} /> FORTRESS_MODE (Panels Invincible)</span>
          <input 
            type="checkbox" 
            checked={debugFlags.panelGodMode} 
            onChange={(e) => setDebugFlag('panelGodMode', e.target.checked)}
            className="accent-primary-green cursor-pointer"
          />
        </label>

        <label 
          data-interactive="true"
          onMouseEnter={() => AudioSystem.playHover()}
          className="flex items-center justify-between p-3 border border-primary-green/30 hover:border-primary-green hover:bg-primary-green/20 cursor-pointer transition-all select-none"
        >
          <span className="text-xs font-bold flex items-center gap-2"><Crosshair size={14} /> PEACE_PROTOCOL (No Spawns)</span>
          <input 
            type="checkbox" 
            checked={debugFlags.peaceMode} 
            onChange={(e) => setDebugFlag('peaceMode', e.target.checked)}
            className="accent-primary-green cursor-pointer"
          />
        </label>
      </div>

    </div>
  );
};


=====================================
FILE: ./src/features/debug/tabs/ConsoleTab.tsx
=====================================
import { useEffect, useRef, useState } from 'react';
import { Copy, Check } from 'lucide-react';
import { AudioSystem } from '@/core/audio/AudioSystem';

interface ConsoleTabProps {
  logs: { time: string, msg: string, type: string }[];
}

export const ConsoleTab = ({ logs }: ConsoleTabProps) => {
  const logEndRef = useRef<HTMLDivElement>(null);
  const [copied, setCopied] = useState(false);

  useEffect(() => {
    if (logEndRef.current) {
        logEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [logs]);

  const handleCopy = () => {
      const text = logs.map(l => `[${l.time}] ${l.msg}`).join('\n');
      navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
      AudioSystem.playClick();
  };

  return (
    <div className="h-full flex flex-col relative">
        <div className="flex-1 overflow-y-auto font-mono text-[10px] space-y-1 pr-2 pb-8">
            {logs.length === 0 && (
                <div className="text-primary-green-dim opacity-50 italic mt-4">-- NO SIGNIFICANT EVENTS --</div>
            )}
            {logs.map((l, i) => (
                <div key={i} className="flex gap-2 opacity-80 hover:opacity-100 border-b border-white/5 py-0.5">
                    <span className="text-primary-green-dim shrink-0">[{l.time}]</span>
                    <span className={l.type.includes('ERROR') || l.type.includes('CRITICAL') ? 'text-critical-red font-bold' : 'text-primary-green break-all'}>{l.msg}</span>
                </div>
            ))}
            <div ref={logEndRef} />
        </div>
        
        <button 
            onClick={handleCopy}
            onMouseEnter={() => AudioSystem.playHover()}
            className="absolute bottom-0 right-0 flex items-center gap-2 bg-primary-green/10 hover:bg-primary-green/20 border border-primary-green/30 text-primary-green px-3 py-1.5 text-xs font-bold transition-all backdrop-blur-sm"
        >
            {copied ? <Check size={12} /> : <Copy size={12} />}
            {copied ? "COPIED" : "COPY LOG"}
        </button>
    </div>
  );
};


=====================================
FILE: ./src/features/debug/tabs/StatsTab.tsx
=====================================
import { Cpu, Database, LayoutTemplate } from 'lucide-react';
import { useStore } from '@/core/store/useStore';
import { AudioSystem } from '@/core/audio/AudioSystem';

interface StatsTabProps {
  stats: { active: number, pooled: number, total: number, fps: number };
}

export const StatsTab = ({ stats }: StatsTabProps) => {
  const { toggleDebugMinimize } = useStore();
  
  return (
    <div className="space-y-6">
      <div className="space-y-3">
        <h3 className="text-xs text-primary-green-dim border-b border-primary-green-dim/30 pb-1 mb-2">ENTITY_REGISTRY</h3>
        <div className="grid grid-cols-2 gap-4">
          <div className="bg-primary-green/5 p-4 border border-primary-green/20">
              <div className="flex items-center gap-2 text-primary-green-dim mb-2 text-xs"><Cpu size={14} /> ACTIVE ENTITIES</div>
              <div className="text-3xl font-bold text-primary-green">{stats.active}</div>
          </div>
          <div className="bg-primary-green/5 p-4 border border-primary-green/20">
              <div className="flex items-center gap-2 text-primary-green-dim mb-2 text-xs"><Database size={14} /> MEMORY POOL</div>
              <div className="text-3xl font-bold text-primary-green-dim">{stats.pooled} <span className="text-xs font-normal opacity-50">/ {stats.total}</span></div>
          </div>
        </div>
      </div>
      <div className="space-y-3">
        <h3 className="text-xs text-primary-green-dim border-b border-primary-green-dim/30 pb-1 mb-2">RENDER_PIPELINE</h3>
        <div className="p-4 border border-primary-green/20 bg-black">
            <div className="flex justify-between items-end">
                <span className="text-xs text-primary-green-dim">FRAME_RATE</span>
                <span className="text-xl font-bold text-primary-green">{stats.fps} FPS</span>
            </div>
            <div className="w-full h-1 bg-gray-900 mt-2">
                <div className="h-full bg-primary-green" style={{ width: `${Math.min(100, (stats.fps / 60) * 100)}%` }} />
            </div>
        </div>
      </div>
      
      <div className="mt-8 flex justify-center">
          <button 
            onClick={() => { toggleDebugMinimize(); AudioSystem.playSound('ui_menu_close'); }}
            onMouseEnter={() => AudioSystem.playHover()}
            className="flex items-center gap-2 text-xs text-primary-green hover:text-white transition-colors border border-primary-green/50 px-4 py-2 hover:bg-primary-green/10"
          >
              <LayoutTemplate size={14} /> SWITCH TO MINI_MODE
          </button>
      </div>
    </div>
  );
};


=====================================
FILE: ./src/features/debug/tabs/SandboxTab.tsx
=====================================
import { Box } from 'lucide-react';
import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { ServiceLocator } from '@/game/core/ServiceLocator';
import { AudioSystem } from '@/core/audio/AudioSystem';

interface SandboxTabProps {
  closeDebug: () => void;
}

export const SandboxTab = ({ closeDebug }: SandboxTabProps) => {
  const { setIntroDone, setBootState } = useStore();
  const { startGame } = useGameStore();

  const enterSandbox = () => {
      AudioSystem.init();
      AudioSystem.startMusic();
      setIntroDone(true);
      setBootState('sandbox');
      try {
          const reg = ServiceLocator.getRegistry();
          if (reg) reg.clear();
      } catch {}
      startGame();
      closeDebug();
  };

  return (
    <div className="h-full flex flex-col items-center justify-center gap-6 text-center">
        <Box size={64} className="text-primary-green animate-pulse" />
        <div>
            <h2 className="text-xl font-bold mb-2">INITIALIZE_SIMULATION?</h2>
            <p className="text-xs text-primary-green-dim max-w-xs mx-auto">
                Loads the 'Holo-Deck' simulation environment. The main OS will be suspended.
            </p>
        </div>
        <button 
            onClick={enterSandbox}
            onMouseEnter={() => AudioSystem.playHover()}
            className="px-8 py-3 bg-primary-green text-black font-bold tracking-widest hover:bg-white transition-colors"
        >
            [ ENTER_HOLO_DECK ]
        </button>
    </div>
  );
};


=====================================
FILE: ./src/features/debug/DebugOverlay.tsx
=====================================
import { useEffect, useState } from 'react';
import { useStore } from '@/core/store/useStore';
import { ServiceLocator } from '@/game/core/ServiceLocator';
import { TimeSystem } from '@/game/systems/TimeSystem';
import { Terminal, Box, Activity, Shield, MinusSquare, X, Maximize2, Cpu, Database } from 'lucide-react';
import { clsx } from 'clsx';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';
import { AudioSystem } from '@/core/audio/AudioSystem';

import { OverridesTab } from './tabs/OverridesTab';
import { SandboxTab } from './tabs/SandboxTab';
import { StatsTab } from './tabs/StatsTab';
import { ConsoleTab } from './tabs/ConsoleTab';

type Tab = 'OVERRIDES' | 'SANDBOX' | 'STATS' | 'CONSOLE';

const TABS: { id: Tab, label: string, icon: any }[] = [
  { id: 'OVERRIDES', label: 'ROOT_ACCESS', icon: Shield },
  { id: 'SANDBOX', label: 'HOLO_DECK', icon: Box },
  { id: 'STATS', label: 'TELEMETRY', icon: Activity },
  { id: 'CONSOLE', label: 'KERNEL_LOG', icon: Terminal },
];

const IGNORED_EVENTS = new Set([
    GameEvents.PLAYER_FIRED,
    GameEvents.PLAYER_HIT,
    GameEvents.ENEMY_DAMAGED,
    GameEvents.ENEMY_SPAWNED,
    GameEvents.PANEL_DAMAGED,
    GameEvents.PROJECTILE_CLASH,
    GameEvents.SPAWN_FX,
]);

export const DebugOverlay = () => {
  const { isDebugOpen, isDebugMinimized, toggleDebugMenu, setDebugFlag, bootState, resetApplication, toggleSettings, activeModal, closeModal, openModal } = useStore();
  const [activeTab, setActiveTab] = useState<Tab>('OVERRIDES');
  const [stats, setStats] = useState({ active: 0, pooled: 0, total: 0, fps: 0 });
  const [logs, setLogs] = useState<{ time: string, msg: string, type: string }[]>([]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === '`' || e.key === '~') {
        const willBeOpen = !isDebugOpen && !isDebugMinimized;
        
        if (willBeOpen) {
            setDebugFlag('godMode', true);
            setDebugFlag('panelGodMode', true);
            setDebugFlag('peaceMode', true);
        }

        if (activeModal === 'settings') {
            closeModal();
            useStore.setState({ isDebugOpen: true, isDebugMinimized: false });
            AudioSystem.playSound('ui_menu_open');
        } 
        else if (isDebugMinimized) {
             useStore.setState({ isDebugMinimized: false, isDebugOpen: true });
             AudioSystem.playSound('ui_menu_open');
        } 
        else {
             toggleDebugMenu();
             AudioSystem.playSound(!isDebugOpen ? 'ui_menu_open' : 'ui_menu_close');
        }
      } 
      
      else if (e.key === 'Escape') {
          if (isDebugOpen) {
              toggleDebugMenu();
              openModal('settings');
              AudioSystem.playSound('ui_menu_open'); 
          } else if (activeModal !== 'none') {
              closeModal();
              AudioSystem.playSound('ui_menu_close');
          } else {
              toggleSettings();
              AudioSystem.playSound('ui_menu_open');
          }
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [toggleDebugMenu, isDebugMinimized, isDebugOpen, setDebugFlag, activeModal, toggleSettings, closeModal, openModal]);

  useEffect(() => {
    const handlers = Object.values(GameEvents).map(evt => {
        return GameEventBus.subscribe(evt as any, (payload) => {
            if (IGNORED_EVENTS.has(evt as GameEvents)) return;

            const time = new Date().toLocaleTimeString().split(' ')[0];
            let msg = `${evt}`;
            
            if (evt === GameEvents.LOG_DEBUG && payload && (payload as any).msg) {
                const p = payload as any;
                msg = p.source ? `[${p.source}] ${p.msg}` : p.msg;
            } else if (payload && (payload as any).type) {
                msg += ` [${(payload as any).type}]`;
            } else if (payload && (payload as any).id) {
                msg += ` [ID:${(payload as any).id}]`;
            }
            
            setLogs(prev => [...prev.slice(-99), { time, msg, type: evt }]);
        });
    });

    const pollInterval = setInterval(() => {
        if (!isDebugOpen && !isDebugMinimized) return;
        let fps = 0;
        let regStats = { active: 0, pooled: 0, totalAllocated: 0 };
        try {
            const timeSys = ServiceLocator.getSystem<TimeSystem>('TimeSystem');
            fps = timeSys.fps;
            const reg = ServiceLocator.getRegistry();
            if (reg) regStats = reg.getStats();
        } catch {}

        setStats({
            active: regStats.active,
            pooled: regStats.pooled,
            total: regStats.totalAllocated,
            fps: fps
        });
    }, 250); 

    return () => {
        handlers.forEach(unsub => unsub());
        clearInterval(pollInterval);
    };
  }, [isDebugOpen, isDebugMinimized]);

  if (!isDebugOpen && !isDebugMinimized) return null;

  if (bootState === 'sandbox') {
      return (
        <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/60 backdrop-blur-sm font-mono pointer-events-auto">
            <div className="bg-black border border-service-cyan p-8 w-96 shadow-[0_0_50px_rgba(0,240,255,0.2)] text-center">
                <h2 className="text-xl font-bold text-service-cyan mb-6 tracking-widest">SIMULATION_PAUSED</h2>
                <div className="flex flex-col gap-4">
                    <button onClick={toggleDebugMenu} onMouseEnter={() => AudioSystem.playHover()} className="p-3 border border-primary-green text-primary-green hover:bg-primary-green hover:text-black font-bold tracking-wider transition-colors">RESUME</button>
                    <button onClick={resetApplication} onMouseEnter={() => AudioSystem.playHover()} className="p-3 border border-critical-red text-critical-red hover:bg-critical-red hover:text-black font-bold tracking-wider transition-colors">EXIT_TO_BOOT</button>
                </div>
            </div>
        </div>
      );
  }

  if (isDebugMinimized) {
      return (
        <div className="fixed top-1/2 -translate-y-1/2 left-0 z-[10000] p-2 pointer-events-auto">
            <div className="bg-black/90 border border-primary-green/30 p-3 rounded-r shadow-[0_0_15px_rgba(0,255,65,0.1)] flex flex-col gap-2 min-w-[140px] pointer-events-auto cursor-default">
                <div className="flex items-center justify-between border-b border-primary-green/20 pb-1 mb-1">
                    <span className="text-[10px] font-bold text-primary-green tracking-wider">DEBUG_LIVE</span>
                    <button 
                        onClick={() => { useStore.setState({ isDebugMinimized: false, isDebugOpen: true }); AudioSystem.playSound('ui_menu_open'); }} 
                        onMouseEnter={() => AudioSystem.playHover()}
                        className="text-primary-green hover:text-white bg-white/10 p-1 rounded hover:bg-white/20 transition-colors"
                    >
                        <Maximize2 size={12} />
                    </button>
                </div>
                <div className="flex items-center justify-between text-[10px] font-mono text-primary-green-dim"><span className="flex items-center gap-1"><Activity size={10} /> FPS</span><span className="text-primary-green font-bold">{stats.fps}</span></div>
                <div className="flex items-center justify-between text-[10px] font-mono text-primary-green-dim"><span className="flex items-center gap-1"><Cpu size={10} /> ENT</span><span className="text-primary-green font-bold">{stats.active}</span></div>
                <button 
                    onClick={() => { useStore.setState({ isDebugMinimized: false, isDebugOpen: false }); AudioSystem.playSound('ui_menu_close'); }} 
                    onMouseEnter={() => AudioSystem.playHover()}
                    className="text-[9px] bg-critical-red/10 border border-critical-red/30 text-critical-red hover:bg-critical-red hover:text-black py-1.5 uppercase font-bold transition-colors w-full flex justify-center"
                >
                    CLOSE_DEBUG
                </button>
            </div>
        </div>
      );
  }

  return (
    <div className="fixed inset-0 z-[10000] flex items-center justify-center bg-black/80 backdrop-blur-md font-mono text-primary-green p-4 pointer-events-auto">
      <div className="w-full max-w-3xl bg-black border border-primary-green shadow-[0_0_50px_rgba(0,255,65,0.2)] flex flex-col h-[600px] overflow-hidden relative">
        <div className="h-10 border-b border-primary-green/50 bg-primary-green/10 flex items-center justify-center relative px-4 shrink-0">
          <div className="flex items-center gap-2"><Terminal size={16} /><span className="font-bold tracking-widest">KERNEL_ROOT_ACCESS // DEBUG_SUITE</span></div>
          <div className="absolute right-4 flex items-center gap-2">
             <button 
                onClick={() => { useStore.setState({ isDebugMinimized: true, isDebugOpen: false }); AudioSystem.playSound('ui_menu_close'); }} 
                onMouseEnter={() => AudioSystem.playHover()}
                className="hover:text-white transition-colors p-1"
             >
                <MinusSquare size={16} />
             </button>
             <button 
                onClick={() => { toggleDebugMenu(); AudioSystem.playSound('ui_menu_close'); }} 
                onMouseEnter={() => AudioSystem.playHover()}
                className="hover:text-white transition-colors p-1"
             >
                <X size={16} />
             </button>
          </div>
        </div>
        <div className="flex flex-1 min-h-0">
          <div className="w-48 border-r border-primary-green/30 bg-black/50 flex flex-col">
            {TABS.map(tab => (
              <button 
                key={tab.id} 
                onClick={() => { setActiveTab(tab.id); AudioSystem.playClick(); }} 
                onMouseEnter={() => AudioSystem.playHover()}
                className={clsx("p-3 text-left text-xs font-bold tracking-wider border-b border-primary-green/10 flex items-center gap-2 transition-all hover:bg-primary-green/20", activeTab === tab.id ? "bg-primary-green text-black" : "text-primary-green-dim")}
              >
                <tab.icon size={14} />{tab.label}
              </button>
            ))}
          </div>
          <div className="flex-1 p-6 overflow-y-auto scrollbar-thin scrollbar-thumb-primary-green scrollbar-track-black">
            {activeTab === 'OVERRIDES' && <OverridesTab closeDebug={() => { toggleDebugMenu(); AudioSystem.playSound('ui_menu_close'); }} />}
            {activeTab === 'SANDBOX' && <SandboxTab closeDebug={() => { toggleDebugMenu(); AudioSystem.playSound('ui_menu_close'); }} />}
            {activeTab === 'STATS' && <StatsTab stats={stats} />}
            {activeTab === 'CONSOLE' && <ConsoleTab logs={logs} />}
          </div>
        </div>
        <div className="h-6 bg-primary-green/5 border-t border-primary-green/30 flex items-center px-4 text-[9px] text-primary-green-dim">
          <span>ROOT_ACCESS_GRANTED // EVENTS_FILTERED</span>
        </div>
      </div>
    </div>
  );
};


=====================================
FILE: ./src/game/types/game.types.ts
=====================================
export interface RegisteredPanel {
  id: string;
  element: HTMLElement;
  health: number;
  isDestroyed: boolean;
}

export type UpgradeOption = 
  | 'OVERCLOCK'      // Attack Speed
  | 'EXECUTE'        // Damage (Renamed from ROOT)
  | 'BANDWIDTH'      // Width
  | 'FORK'           // Multishot
  | 'SNIFFER'        // Homing Independent
  | 'BACKDOOR'       // Rear Gun
  | 'REPAIR_NANITES'; // Heal

export interface GameState {
  isPlaying: boolean;
  score: number;
  threatLevel: number;
  panels: Record<string, RegisteredPanel>;
  
  startGame: () => void;
  stopGame: () => void;
  registerPanel: (id: string, element: HTMLElement) => void;
  unregisterPanel: (id: string) => void;
  damagePanel: (id: string, amount: number) => void;
  healPanel: (id: string, amount: number) => void;
}

export interface Entity {
  id: number;
  x: number;
  y: number;
  radius: number;
  active: boolean;
  spawnTime: number; 
}


=====================================
FILE: ./src/game/core/ComponentBuilder.ts
=====================================
import { TransformComponent } from '../components/data/TransformComponent';
import { MotionComponent } from '../components/data/MotionComponent';
import { HealthComponent } from '../components/data/HealthComponent';
import { IdentityComponent } from '../components/data/IdentityComponent';
import { LifetimeComponent } from '../components/data/LifetimeComponent';
import { CombatComponent } from '../components/data/CombatComponent';
import { StateComponent } from '../components/data/StateComponent';
import { ColliderComponent } from '../components/data/ColliderComponent';
import { TargetComponent } from '../components/data/TargetComponent';
import { OrbitalComponent } from '../components/data/OrbitalComponent';
import { Component } from './ecs/Component';

type ComponentFactory = (data: any) => Component;

export const ComponentBuilder: Record<string, ComponentFactory> = {
  Transform: (data) => new TransformComponent(data.x || 0, data.y || 0, data.rotation || 0, data.scale || 1),
  Motion: (data) => new MotionComponent(data.vx || 0, data.vy || 0, data.friction || 0, data.angularVelocity || 0),
  Health: (data) => new HealthComponent(data.max, data.invincibilityTime || 0),
  Identity: (data) => new IdentityComponent(data.variant),
  Lifetime: (data) => new LifetimeComponent(data.remaining, data.total || data.remaining),
  Combat: (data) => new CombatComponent(data.damage, data.cooldown || 0, data.range || 0),
  State: (data) => new StateComponent(data.current, data.timers || {}, data.data || {}),
  Collider: (data) => new ColliderComponent(data.radius, data.layer, data.mask),
  Target: (data) => new TargetComponent(data.id, data.type, data.x, data.y, data.locked),
  Orbital: (data) => new OrbitalComponent(data.parentId, data.radius, data.speed, data.angle, data.active)
};


=====================================
FILE: ./src/game/core/ObjectPool.ts
=====================================
type FactoryFn<T> = () => T;
type ResetFn<T> = (item: T) => void;

export class ObjectPool<T> {
  private available: T[] = [];
  private factory: FactoryFn<T>;
  private resetFn: ResetFn<T>;
  private _totalCreated = 0;

  constructor(factory: FactoryFn<T>, resetFn: ResetFn<T>, initialSize: number = 100) {
    this.factory = factory;
    this.resetFn = resetFn;
    this.expand(initialSize);
  }

  private expand(amount: number) {
    // console.log(`[ObjectPool] Expanding by ${amount}. Total: ${this._totalCreated + amount}`);
    for (let i = 0; i < amount; i++) {
      this.available.push(this.factory());
    }
    this._totalCreated += amount;
  }

  public acquire(): T {
    if (this.available.length === 0) {
      // Dynamic expansion: Double current size or add 50, whichever is safer
      const expandAmount = Math.max(50, Math.floor(this._totalCreated * 0.5)); 
      this.expand(expandAmount);
    }

    const item = this.available.pop()!;
    this.resetFn(item); 
    return item;
  }

  public release(item: T) {
    // Optimization: In production, skip the .includes check for speed.
    // In dev, it saves sanity.
    // this.available.push(item);
    
    // Check duplication only if pool is small-ish to avoid O(N) lag? 
    // Actually, EntityRegistry manages active vs inactive, so we trust it.
    this.available.push(item);
  }

  public get totalSize() {
    return this._totalCreated;
  }
  
  public get availableSize() {
      return this.available.length;
  }
}


=====================================
FILE: ./src/game/core/GameBootstrapper.ts
=====================================
import { ServiceLocator } from './ServiceLocator';
import { GameEngineCore } from './GameEngine';
import { EntityRegistry } from './ecs/EntityRegistry';
import { EntitySpawner } from './EntitySpawner';

import { TimeSystem } from '../systems/TimeSystem';
import { InputSystem } from '../systems/InputSystem';
import { PhysicsSystem } from '../systems/PhysicsSystem';
import { LifeCycleSystem } from '../systems/LifeCycleSystem';
import { BehaviorSystem } from '../systems/BehaviorSystem';
import { CollisionSystem } from '../systems/CollisionSystem';
import { CombatSystem } from '../systems/CombatSystem';
import { WaveSystem } from '../systems/WaveSystem';
import { PlayerSystem } from '../systems/PlayerSystem';
import { InteractionSystem } from '../systems/InteractionSystem';
import { ShakeSystem } from '../systems/ShakeSystem'; 
import { PanelRegistry } from '../systems/PanelRegistrySystem'; 
import { GameStateSystem } from '../systems/GameStateSystem'; 
import { UISyncSystem } from '../systems/UISyncSystem'; 
import { TargetingSystem } from '../systems/TargetingSystem'; 
import { GuidanceSystem } from '../systems/GuidanceSystem'; 
import { OrbitalSystem } from '../systems/OrbitalSystem'; // NEW

export const GameBootstrapper = () => {
  ServiceLocator.reset();

  const registry = new EntityRegistry();
  const spawner = new EntitySpawner(registry);
  const engine = new GameEngineCore(registry);
  
  ServiceLocator.registerRegistry(registry);
  ServiceLocator.registerSpawner(spawner);

  // Instantiate
  const timeSys = new TimeSystem();
  const inputSys = new InputSystem();
  const physicsSys = new PhysicsSystem();
  const lifeSys = new LifeCycleSystem();
  const behaviorSys = new BehaviorSystem();
  const collisionSys = new CollisionSystem();
  const combatSys = new CombatSystem();
  const waveSys = new WaveSystem();
  const playerSys = new PlayerSystem();
  const interactionSys = new InteractionSystem();
  const shakeSys = new ShakeSystem(); 
  const gameSys = new GameStateSystem(); 
  const syncSys = new UISyncSystem(); 
  const panelSys = PanelRegistry; 
  const targetingSys = new TargetingSystem(); 
  const guidanceSys = new GuidanceSystem(); 
  const orbitalSys = new OrbitalSystem(); // NEW

  // Register
  const systems = {
      'TimeSystem': timeSys,
      'InputSystem': inputSys,
      'PhysicsSystem': physicsSys,
      'LifeCycleSystem': lifeSys,
      'BehaviorSystem': behaviorSys,
      'CollisionSystem': collisionSys,
      'CombatSystem': combatSys,
      'WaveSystem': waveSys,
      'PlayerSystem': playerSys,
      'InteractionSystem': interactionSys,
      'ShakeSystem': shakeSys, 
      'GameStateSystem': gameSys,
      'UISyncSystem': syncSys,
      'PanelRegistrySystem': panelSys,
      'TargetingSystem': targetingSys,
      'GuidanceSystem': guidanceSys,
      'OrbitalSystem': orbitalSys // NEW
  };

  Object.entries(systems).forEach(([key, sys]) => ServiceLocator.registerSystem(key, sys));
  
  // Update Loop
  engine.registerSystem(timeSys);
  engine.registerSystem(inputSys);
  engine.registerSystem(panelSys);
  engine.registerSystem(gameSys);
  engine.registerSystem(interactionSys); 
  engine.registerSystem(waveSys); 
  
  engine.registerSystem(targetingSys); 
  
  engine.registerSystem(orbitalSys); // Update orbital positions before logic
  engine.registerSystem(playerSys); 
  engine.registerSystem(behaviorSys); 
  engine.registerSystem(guidanceSys); 

  engine.registerSystem(physicsSys); 
  engine.registerSystem(collisionSys); 
  engine.registerSystem(lifeSys); 
  engine.registerSystem(shakeSys); 
  engine.registerSystem(syncSys); 
  
  // Setup
  Object.values(systems).forEach(sys => sys.setup(ServiceLocator));
  
  engine.setup(ServiceLocator);

  spawner.spawnPlayer();

  return engine;
};


=====================================
FILE: ./src/game/core/ecs/Component.ts
=====================================
export abstract class Component {
  // Use a static property for the type key to enforce consistency
  static readonly TYPE: string;
  abstract readonly _type: string;
}


=====================================
FILE: ./src/game/core/ecs/Entity.ts
=====================================
import { EntityID, Tag } from './types';
import { Component } from './Component';

export class Entity {
  public id: EntityID; 
  public readonly tags = new Set<Tag>();
  public active = true;
  
  // Flag to track if in pool or in use
  public pooled = false;

  public components = new Map<string, Component>();

  constructor(id: EntityID) {
    this.id = id;
  }

  public addComponent(component: Component): this {
    this.components.set(component._type, component);
    return this;
  }

  public getComponent<T extends Component>(type: string): T | undefined {
    return this.components.get(type) as T;
  }
  
  public requireComponent<T extends Component>(type: string): T {
    const c = this.components.get(type);
    if (!c) throw new Error(`Entity ${this.id} missing required component: ${type}`);
    return c as T;
  }

  public hasComponent(type: string): boolean {
    return this.components.has(type);
  }

  public addTag(tag: Tag): this {
    this.tags.add(tag);
    return this;
  }

  public hasTag(tag: Tag): boolean {
    return this.tags.has(tag);
  }

  // Called when pulled FROM the pool
  public reset(newId: EntityID) {
      this.id = newId;
      this.active = true;
      this.pooled = false;
      this.tags.clear();
      this.components.clear();
  }

  // Called when pushed TO the pool
  public release() {
      this.active = false;
      this.pooled = true;
      this.components.clear(); // Wipe refs to help GC
      this.tags.clear();
  }
}


=====================================
FILE: ./src/game/core/ecs/types.ts
=====================================
// Nominal typing to prevent mixing up IDs with math numbers
export type EntityID = number & { __brand: 'EntityID' };

export const createEntityID = (id: number): EntityID => id as EntityID;

export enum Tag {
  PLAYER = 'PLAYER',
  ENEMY = 'ENEMY',
  BULLET = 'BULLET',
  PARTICLE = 'PARTICLE',
  OBSTACLE = 'OBSTACLE'
}


=====================================
FILE: ./src/game/core/ecs/EntityRegistry.ts
=====================================
import { EntityID, createEntityID, Tag } from './types';
import { Entity } from './Entity';
import { ObjectPool } from '../ObjectPool';
import { IEntityRegistry } from '../interfaces';

export class EntityRegistry implements IEntityRegistry {
  private entities = new Map<EntityID, Entity>();
  private nextId = 0;
  
  private tagCache = new Map<Tag, Set<EntityID>>();
  private entityPool: ObjectPool<Entity>;

  constructor() {
      // Pool init: 1000 entities pre-allocated
      this.entityPool = new ObjectPool<Entity>(
          () => new Entity(createEntityID(0)),
          (e) => {}, // Reset is handled manually in createEntity
          1000 
      );
  }

  public createEntity(): Entity {
    const newId = createEntityID(++this.nextId);
    const entity = this.entityPool.acquire();
    
    // Strict Reset
    entity.reset(newId);
    
    this.entities.set(newId, entity);
    return entity;
  }

  public destroyEntity(id: number) {
    const eid = id as EntityID;
    const entity = this.entities.get(eid);
    
    // ZOMBIE CHECK: If entity is missing or already inactive, do nothing.
    if (!entity || !entity.active) return;

    // 1. Mark inactive immediately
    entity.active = false;
    
    // 2. Clean up cache
    this.removeFromCache(entity);
    this.entities.delete(eid);
    
    // 3. Prepare for pool
    entity.release();
    this.entityPool.release(entity);
  }

  public getEntity(id: number): Entity | undefined {
    return this.entities.get(id as EntityID);
  }

  public getAll(): IterableIterator<Entity> {
    return this.entities.values();
  }

  public getByTag(tag: string): Entity[] {
    const t = tag as Tag;
    if (!this.tagCache.has(t)) {
        this.rebuildTagCache(t);
    }
    const ids = this.tagCache.get(t)!;
    const results: Entity[] = [];
    
    // Filter active entities only
    for (const id of ids) {
        const e = this.entities.get(id);
        if (e && e.active) results.push(e);
    }
    return results;
  }
  
  public updateCache(entity: Entity) {
      for (const tag of entity.tags) {
          if (!this.tagCache.has(tag)) this.tagCache.set(tag, new Set());
          this.tagCache.get(tag)!.add(entity.id);
      }
  }

  private removeFromCache(entity: Entity) {
      for (const tag of entity.tags) {
          if (this.tagCache.has(tag)) {
              this.tagCache.get(tag)!.delete(entity.id);
          }
      }
  }
  
  private rebuildTagCache(tag: Tag) {
      const set = new Set<EntityID>();
      for (const entity of this.entities.values()) {
          if (entity.hasTag(tag)) set.add(entity.id);
      }
      this.tagCache.set(tag, set);
  }

  public clear() {
      // Bulk return to pool
      for (const entity of this.entities.values()) {
          entity.release();
          this.entityPool.release(entity);
      }
      this.entities.clear();
      this.tagCache.clear();
      this.nextId = 0;
  }
  
  public getStats() {
      return {
          active: this.entities.size,
          pooled: this.entityPool.availableSize,
          totalAllocated: this.entityPool.totalSize
      };
  }
}


=====================================
FILE: ./src/game/core/EntitySpawner.ts
=====================================
import { IEntitySpawner, IEntityRegistry } from './interfaces';
import { Entity } from './ecs/Entity';
import { Tag } from './ecs/types';
import { TransformComponent } from '../components/data/TransformComponent';
import { MotionComponent } from '../components/data/MotionComponent';
import { HealthComponent } from '../components/data/HealthComponent';
import { LifetimeComponent } from '../components/data/LifetimeComponent';
import { CombatComponent } from '../components/data/CombatComponent';
import { StateComponent } from '../components/data/StateComponent';
import { ColliderComponent } from '../components/data/ColliderComponent'; 
import { IdentityComponent } from '../components/data/IdentityComponent';
import { PLAYER_CONFIG } from '../config/PlayerConfig';
import { PhysicsConfig, CollisionLayers } from '../config/PhysicsConfig';
import { EntityRegistry } from './ecs/EntityRegistry';
import { EnemyTypes } from '../config/Identifiers';
import { ARCHETYPES } from '../data/Archetypes';
import { ComponentBuilder } from './ComponentBuilder';

export class EntitySpawner implements IEntitySpawner {
  private registry: EntityRegistry;

  constructor(registry: IEntityRegistry) {
    this.registry = registry as EntityRegistry;
  }

  public spawnPlayer(): Entity {
    const e = this.registry.createEntity();
    e.addTag(Tag.PLAYER);
    e.addComponent(new TransformComponent(0, 0, 0, 1));
    e.addComponent(new MotionComponent(0, 0, 0.9)); 
    e.addComponent(new HealthComponent(PLAYER_CONFIG.maxHealth));
    e.addComponent(new StateComponent('IDLE')); 
    e.addComponent(new ColliderComponent(PhysicsConfig.HITBOX.PLAYER, CollisionLayers.PLAYER, PhysicsConfig.MASKS.PLAYER));
    this.registry.updateCache(e);
    return e;
  }

  public spawnEnemy(type: string, x: number, y: number): Entity {
    const archetype = ARCHETYPES[type];
    if (!archetype) {
        console.warn(`[EntitySpawner] Unknown archetype: ${type}`);
        return this.registry.createEntity();
    }

    const e = this.registry.createEntity();
    archetype.tags.forEach(tag => e.addTag(tag));

    for (const compDef of archetype.components) {
        if (compDef.type === 'Transform') continue;
        const builder = ComponentBuilder[compDef.type];
        if (builder) {
            const freshData = JSON.parse(JSON.stringify(compDef.data || {}));
            e.addComponent(builder(freshData));
        }
    }

    e.addComponent(new TransformComponent(x, y, 0, 1));
    this.registry.updateCache(e);
    return e;
  }

  // UPDATED: Accepts Damage and Width Multiplier
  public spawnBullet(
      x: number, y: number, 
      vx: number, vy: number, 
      isEnemy: boolean, 
      life: number,
      damage: number = 1,
      widthMult: number = 1.0
  ): Entity {
    const e = this.registry.createEntity();
    e.addTag(Tag.BULLET);
    if (isEnemy) e.addTag(Tag.ENEMY); else e.addTag(Tag.PLAYER); 
    
    // Transform with Width Scaling
    const t = new TransformComponent(x, y, Math.atan2(vy, vx), 1);
    
    // NOTE: We don't have separate ScaleX/Y in TransformComponent yet (it uses uniform 'scale').
    // BUT we can use the 'scale' property for width if we assume length is handled by the renderer geometry.
    // Actually, BulletRenderer uses PlaneGeometry(1.2, 1.2).
    // Let's overload 'scale' to mean Width Multiplier for Bullets.
    t.scale = widthMult; 
    
    e.addComponent(t);
    e.addComponent(new MotionComponent(vx, vy, 0));
    e.addComponent(new LifetimeComponent(life, life));
    
    // Health = Damage (Mass)
    e.addComponent(new HealthComponent(damage));
    e.addComponent(new CombatComponent(damage)); 

    const layer = isEnemy ? CollisionLayers.ENEMY_PROJECTILE : CollisionLayers.PLAYER_PROJECTILE;
    const mask = isEnemy ? PhysicsConfig.MASKS.ENEMY_PROJECTILE : PhysicsConfig.MASKS.PLAYER_PROJECTILE;
    
    // Collider Radius scales with Width
    const baseRadius = isEnemy ? PhysicsConfig.HITBOX.HUNTER_BULLET : PhysicsConfig.HITBOX.BULLET;
    const radius = baseRadius * widthMult;

    e.addComponent(new ColliderComponent(radius, layer, mask));
    this.registry.updateCache(e);
    return e;
  }

  public spawnParticle(x: number, y: number, color: string, vx: number, vy: number, life: number): void {
    const e = this.registry.createEntity();
    e.addTag(Tag.PARTICLE);
    e.addComponent(new TransformComponent(x, y, 0, 1));
    e.addComponent(new MotionComponent(vx, vy, 0.05));
    e.addComponent(new LifetimeComponent(life, life));
    e.addComponent(new IdentityComponent(color));
    this.registry.updateCache(e);
  }
}


=====================================
FILE: ./src/game/core/index.ts
=====================================
export * from './GameBootstrapper';
export * from './GameEngine';
export * from './EntitySpawner';
export * from './ServiceLocator';
export * from './ObjectPool';
export * from './SpatialGrid';
export * from './interfaces';


=====================================
FILE: ./src/game/core/ServiceLocator.ts
=====================================
import { IServiceLocator, IGameSystem, IAudioService, IInputService, IEntityRegistry, IEntitySpawner } from './interfaces';

class ServiceLocatorImpl implements IServiceLocator {
  private systems = new Map<string, IGameSystem>();
  private audioService?: IAudioService;
  private inputService?: IInputService;
  private registry?: IEntityRegistry;
  private spawner?: IEntitySpawner;

  public getSystem<T extends IGameSystem>(id: string): T {
    const sys = this.systems.get(id);
    if (!sys) throw new Error(`System not registered: ${id}`);
    return sys as T;
  }

  public registerSystem(id: string, system: IGameSystem): void {
    this.systems.set(id, system);
    if (id === 'InputSystem') this.inputService = system as unknown as IInputService;
  }

  public registerRegistry(registry: IEntityRegistry) {
      this.registry = registry;
  }

  public registerSpawner(spawner: IEntitySpawner) {
      this.spawner = spawner;
  }

  public getAudioService(): IAudioService {
    return { playSound: () => {}, playMusic: () => {}, setVolume: () => {} }; 
  }

  public getInputService(): IInputService {
    if (!this.inputService) throw new Error("InputService not registered");
    return this.inputService;
  }
  
  public getRegistry(): IEntityRegistry {
      if (!this.registry) throw new Error("Registry not registered");
      return this.registry;
  }

  public getSpawner(): IEntitySpawner {
      if (!this.spawner) throw new Error("Spawner not registered");
      return this.spawner;
  }
  
  public reset(): void {
    this.systems.clear();
    this.audioService = undefined;
    this.inputService = undefined;
    this.registry = undefined;
    this.spawner = undefined;
  }
}

export const ServiceLocator = new ServiceLocatorImpl();


=====================================
FILE: ./src/game/core/SpatialGrid.ts
=====================================
import { EntityID } from './ecs/types';

export class SpatialGrid {
  private cellSize: number;
  private buckets = new Map<string, EntityID[]>(); // Changed Set to Array for faster iteration

  constructor(cellSize: number = 4) {
    this.cellSize = cellSize;
  }

  private getKey(x: number, y: number): string {
    const cx = Math.floor(x / this.cellSize);
    const cy = Math.floor(y / this.cellSize);
    return `${cx}:${cy}`;
  }

  public clear() {
    this.buckets.clear();
  }

  public insert(id: EntityID, x: number, y: number) {
    const key = this.getKey(x, y);
    let bucket = this.buckets.get(key);
    if (!bucket) {
      bucket = []; // Simple array, cleaner than Set for iteration
      this.buckets.set(key, bucket);
    }
    bucket.push(id);
  }

  /**
   * Zero-Allocation Query.
   * Populates the provided 'outResults' Set with neighbors.
   */
  public query(x: number, y: number, radius: number, outResults: Set<EntityID>) {
    outResults.clear();
    
    // Calculate range of cells to check
    const startX = Math.floor((x - radius) / this.cellSize);
    const endX = Math.floor((x + radius) / this.cellSize);
    const startY = Math.floor((y - radius) / this.cellSize);
    const endY = Math.floor((y + radius) / this.cellSize);

    for (let cx = startX; cx <= endX; cx++) {
      for (let cy = startY; cy <= endY; cy++) {
        const key = `${cx}:${cy}`;
        const bucket = this.buckets.get(key);
        if (bucket) {
          const len = bucket.length;
          for (let i = 0; i < len; i++) {
            outResults.add(bucket[i]);
          }
        }
      }
    }
  }
}


=====================================
FILE: ./src/game/core/interfaces.ts
=====================================
import { GameEvents, GameEventPayloads } from '../events/GameEvents';
import { Entity } from './ecs/Entity';
import { SpatialGrid } from './SpatialGrid';
import { WorldRect } from '../utils/ViewportHelper';

export interface IGameSystem {
  setup(locator: IServiceLocator): void;
  update(delta: number, time: number): void;
  teardown(): void;
}

export interface IServiceLocator {
  getSystem<T extends IGameSystem>(id: string): T;
  registerSystem(id: string, system: IGameSystem): void;
  
  getAudioService(): IAudioService;
  getInputService(): IInputService;
  getRegistry(): IEntityRegistry;
  getSpawner(): IEntitySpawner;
}

// --- CORE CONTRACTS ---

export interface IEntityRegistry {
  createEntity(): Entity;
  destroyEntity(id: number): void;
  getEntity(id: number): Entity | undefined;
  getAll(): IterableIterator<Entity>;
  getByTag(tag: string): Entity[];
  clear(): void;
  getStats(): { active: number; pooled: number; totalAllocated: number };
}

export interface IEntitySpawner {
  spawnPlayer(): Entity;
  spawnEnemy(type: string, x: number, y: number): Entity;
  spawnBullet(x: number, y: number, vx: number, vy: number, isEnemy: boolean, life: number, damage?: number, widthMult?: number): Entity;
  spawnParticle(x: number, y: number, color: string, vx: number, vy: number, life: number): void;
}

export interface IAudioService {
  playSound(key: string, volume?: number): void;
  playMusic(key: string): void;
  setVolume(volume: number): void;
}

export interface IInputService {
  getCursor(): { x: number, y: number };
  isPressed(action: string): boolean;
  updateCursor(x: number, y: number): void;
  updateBounds(width: number, height: number): void; // Added for InputSystem sync
}

// --- SYSTEM CONTRACTS ---

export interface IPhysicsSystem extends IGameSystem {
  spatialGrid: SpatialGrid;
}

export interface ICombatSystem extends IGameSystem {
  resolveCollision(e1: Entity, e2: Entity): void;
}

export interface IInteractionSystem extends IGameSystem {
  repairState: 'IDLE' | 'HEALING' | 'REBOOTING';
  hoveringPanelId: string | null;
}

export interface IGameStateSystem extends IGameSystem {
  playerHealth: number;
  maxPlayerHealth: number;
  playerRebootProgress: number;
  score: number;
  xp: number;
  level: number;
  xpToNextLevel: number;
  upgradePoints: number;
  activeUpgrades: Record<string, number>;
  isGameOver: boolean;
  
  damagePlayer(amount: number): void;
  healPlayer(amount: number): void;
  addScore(amount: number): void;
  addXp(amount: number): void;
  tickReboot(amount: number): void;
  decayReboot(amount: number): void;
}

export interface IPanelSystem extends IGameSystem {
  systemIntegrity: number;
  damagePanel(id: string, amount: number): void;
  healPanel(id: string, amount: number): void;
  getPanelRect(id: string): WorldRect | undefined;
}


=====================================
FILE: ./src/game/core/GameEngine.ts
=====================================
import { IGameSystem, IServiceLocator, IEntityRegistry } from './interfaces';
import { useGameStore } from '../store/useGameStore';
import { useStore } from '@/core/store/useStore';
import { FXManager } from '../systems/FXManager';
import { ViewportHelper } from '../utils/ViewportHelper';
import { PanelRegistrySystem } from '../systems/PanelRegistrySystem'; 
import { GameStateSystem } from '../systems/GameStateSystem';
import { WorldConfig } from '../config/WorldConfig';
import { TimeSystem } from '../systems/TimeSystem';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';

export class GameEngineCore implements IGameSystem {
  private systems: IGameSystem[] = [];
  private locator!: IServiceLocator;
  public registry: IEntityRegistry; 
  
  private accumulator: number = 0;
  private simulationTime: number = 0;

  constructor(registry: IEntityRegistry) {
      this.registry = registry;
  }

  setup(locator: IServiceLocator): void {
    this.locator = locator;
    FXManager.init();
  }

  public registerSystem(system: IGameSystem) {
    this.systems.push(system);
  }

  update(renderDelta: number, renderTime: number): void {
    const store = useStore.getState();
    const gameStore = useGameStore.getState();
    
    if (store.bootState === 'standby') return;
    if (store.activeModal === 'settings' || store.isDebugOpen) return;

    const gameSys = this.locator.getSystem<GameStateSystem>('GameStateSystem');
    
    if (gameStore.isPlaying && gameStore.systemIntegrity <= 0) {
        gameStore.stopGame();
        FXManager.addTrauma(1.0);
        gameSys.isGameOver = true; 
        return;
    }

    if (!gameStore.isPlaying) {
        gameSys.isGameOver = true;
    }

    // --- TIME MANAGEMENT ---
    
    let timeScale = 1.0;
    try {
        const timeSys = this.locator.getSystem<TimeSystem>('TimeSystem');
        
        // 1. Tick Real Time (Updates Freeze Timer)
        timeSys.tickRealTime(renderDelta);

        // 2. Determine if Frozen
        if (timeSys.isFrozen()) {
            timeScale = 0.0;
        } else {
            timeScale = timeSys.timeScale;
        }
    } catch {}

    const debugScale = store.debugFlags.timeScale;
    
    // 3. Accumulate Game Time
    const effectiveDelta = renderDelta * timeScale * debugScale;
    
    this.accumulator += effectiveDelta;

    if (this.accumulator > WorldConfig.time.maxAccumulator) {
        this.accumulator = WorldConfig.time.maxAccumulator;
    }

    const fixedStep = WorldConfig.time.fixedDelta;

    // 4. Run Physics Steps
    // If frozen, effectiveDelta is 0, accumulator doesn't grow, loop doesn't run.
    // But since tickRealTime ran above, freezeTimer decreases, and eventually
    // isFrozen() becomes false, effectiveDelta becomes > 0, and the game resumes.
    while (this.accumulator >= fixedStep) {
        for (const sys of this.systems) {
            try {
                sys.update(fixedStep, this.simulationTime);
            } catch (e: any) {
                console.error("System Update Error:", e);
                GameEventBus.emit(GameEvents.LOG_DEBUG, { 
                    msg: `CRASH IN SYSTEM: ${e.message}`, 
                    source: 'GameEngine' 
                });
            }
        }

        this.simulationTime += fixedStep;
        this.accumulator -= fixedStep;
    }
  }

  teardown(): void {
    for (const sys of this.systems) {
      sys.teardown();
    }
    this.systems = [];
  }
  
  public updateViewport(vpW: number, vpH: number, screenW: number, screenH: number) {
    ViewportHelper.update(vpW, vpH, screenW, screenH);
    try {
        const panelSys = this.locator.getSystem<PanelRegistrySystem>('PanelRegistrySystem');
        panelSys.refreshAll();
    } catch (e) {
    }
  }
}


=====================================
FILE: ./src/game/GameOverlay.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { PlayerAvatar } from './components/PlayerAvatar';
import { GameDirector } from './components/GameDirector';
import { EnemyRenderer } from './components/EnemyRenderer';
import { BulletRenderer } from './components/BulletRenderer';
import { EnemyBulletRenderer } from './components/EnemyBulletRenderer';
import { HunterChargeRenderer } from './components/HunterChargeRenderer';
import { ParticleRenderer } from './components/ParticleRenderer';
import { ScreenShaker } from './components/ScreenShaker';
import { ProjectileTrails } from './components/ProjectileTrails'; 
import { GalleryStage } from './components/GalleryStage';
import { DaemonRenderer } from './components/DaemonRenderer'; 
import { DaemonChargeRenderer } from './components/DaemonChargeRenderer';
import { DaemonBulletRenderer } from './components/DaemonBulletRenderer'; // NEW
import { VirtualJoystick } from '@/ui/atoms/VirtualJoystick';
import { useStore } from '@/core/store/useStore';
import { useEffect, useState } from 'react';

export const GameOverlay = () => {
  const { bootState, sandboxView } = useStore();
  const isGallery = bootState === 'sandbox' && sandboxView === 'gallery';
  const [isTouch, setIsTouch] = useState(false);
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
      setMounted(true);
      const onTouch = () => setIsTouch(true);
      window.addEventListener('touchstart', onTouch, { once: true });
      return () => window.removeEventListener('touchstart', onTouch);
  }, []);

  if (!mounted) return null;

  return (
    <>
        <div className="fixed inset-0 z-[60] w-full h-full pointer-events-none overflow-hidden">
          <Canvas
            orthographic={!isGallery}
            camera={isGallery ? { position: [5, 5, 10], fov: 45 } : { zoom: 40, position: [0, 0, 100] }}
            gl={{ 
              alpha: true, 
              antialias: true,
              stencil: false,
              powerPreference: "high-performance"
            }}
            eventSource={document.body}
            eventPrefix="client"
          >
            {isGallery ? (
                <GalleryStage />
            ) : (
                <>
                    <GameDirector />
                    <ScreenShaker />
                    <ProjectileTrails />
                    <PlayerAvatar />
                    <DaemonRenderer /> 
                    <DaemonChargeRenderer />
                    <DaemonBulletRenderer /> {/* NEW */}
                    <BulletRenderer />
                    <HunterChargeRenderer /> 
                    <EnemyBulletRenderer />
                    <EnemyRenderer />
                    <ParticleRenderer /> 
                </>
            )}
          </Canvas>
        </div>
        
        {isTouch && !isGallery && <VirtualJoystick />}
    </>
  );
};


=====================================
FILE: ./src/game/config/AIConfig.ts
=====================================
export const AI_CONFIG = {
  HUNTER: {
    ORBIT_SPEED: 0.5,
    TARGET_RADIUS: 10.0,
    AIM_LERP: 0.05,
    CHARGE_LERP: 0.15,
    SPIN_SPEED_IDLE: 2.0,
    SPIN_SPEED_CHARGE: -8.0,
    PROJECTILE_SPEED: 25,
    OFFSET_DIST: 1.6,
    RECOIL_FORCE: 2.0
  },
  KAMIKAZE: {
    ROTATION_SPEED: 10.0,
    ENGAGEMENT_DIST: 0.1
  },
  DRILLER: {
    SNAP_THRESHOLD: 0.1,
    TIP_OFFSET: 0.4, // Based on Model Height
    AUDIO_INTERVAL: 0.25
  },
  DAEMON: {
    SHIELD_CHARGE_TIME: 2.0,
    COOLDOWN_TIME: 0.5,
    RECOVERY_TIME: 2.0,
    ORBIT_RADIUS: 4.0,
    ORBIT_SPEED_MIN: 1.5,
    ROTATION_SPEED: {
      CHARGING: 15.0,
      READY: 3.0,
      FIRE: 20.0,
      COOLDOWN: -5.0,
      BROKEN: 30.0
    }
  }
};


=====================================
FILE: ./src/game/config/ModelConfig.ts
=====================================
export const MODEL_CONFIG = {
  DRILLER: {
    height: 0.8, // Total length of the cone
    radius: 0.3, // Width of the base
    segments: 4  // 4-sided pyramid style
  },
  KAMIKAZE: {
    radius: 0.6,
    detail: 0
  },
  HUNTER: {
    scale: 2.0 // Scale factor for the spear model
  }
};


=====================================
FILE: ./src/game/config/PlayerConfig.ts
=====================================
export const PLAYER_CONFIG = {
  maxHealth: 100,
  fireRate: 0.15, 
  bulletSpeed: 45,
  bulletRadius: 0.2,
  bulletLife: 1.5,
  
  // Scoring & Progression
  scoreMultiplier: 1,
  baseXpRequirement: 100,
  xpScalingFactor: 1.5, // Next level = base * (scaling ^ level)
};


=====================================
FILE: ./src/game/config/EnemyConfig.ts
=====================================
import { EnemyTypes } from './Identifiers';

export const ENEMY_CONFIG = {
  [EnemyTypes.DRILLER]: { // RENAMED
    hp: 2,
    baseSpeed: 8,
    radius: 0.5,
    damage: 15,
    score: 10
  },
  [EnemyTypes.KAMIKAZE]: {
    hp: 3,
    baseSpeed: 12,
    radius: 0.5,
    damage: 10,
    score: 20
  },
  [EnemyTypes.HUNTER]: {
    hp: 3,
    baseSpeed: 12,
    radius: 0.5,
    score: 50,
    orbitRadius: 12.5,
    orbitDuration: 2.0,
    chargeDuration: 1.0,
    fireRange: 12.0,
    offsetDistance: 1.6 
  }
};

export const WAVE_CONFIG = {
  baseSpawnInterval: 0.8,
  difficultyScaler: 1.0 
};


=====================================
FILE: ./src/game/config/AudioConfig.ts
=====================================
export type SoundType = 'oscillator' | 'noise';

export interface SoundRecipe {
  type: SoundType;
  wave?: OscillatorType; 
  frequency: [number, number]; 
  duration: number; 
  volume: number; 
  pitchVariance: number; 
  filter?: [number, number]; 
  distortion?: number; 
  attack?: number; 
  fm?: {
    modFreq: number; 
    modIndex: number; 
    modType: OscillatorType;
  };
  tremolo?: {
    rate: number; 
    depth: number; 
    wave?: OscillatorType;
  };
}

export const AUDIO_CONFIG: Record<string, SoundRecipe> = {
  // ==========================================
  // UI & INTERFACE
  // ==========================================
  'ui_click': { type: 'oscillator', wave: 'square', frequency: [400, 400], duration: 0.05, volume: 0.1, pitchVariance: 0 },
  'ui_hover': { type: 'oscillator', wave: 'sine', frequency: [800, 800], duration: 0.03, volume: 0.05, pitchVariance: 50 },
  'ui_menu_open': { type: 'oscillator', wave: 'sine', frequency: [440, 660], duration: 0.15, volume: 0.1, pitchVariance: 0, attack: 0.02 },
  'ui_menu_close': { type: 'oscillator', wave: 'sine', frequency: [660, 440], duration: 0.15, volume: 0.1, pitchVariance: 0, attack: 0.02 },
  'ui_optimal': { type: 'oscillator', wave: 'sine', frequency: [1200, 1200], duration: 0.4, volume: 0.15, pitchVariance: 0, attack: 0.01 },
  'ui_error': { type: 'oscillator', wave: 'sawtooth', frequency: [150, 50], duration: 0.2, volume: 0.2, pitchVariance: 0, distortion: 50 },
  'ui_chirp': { type: 'oscillator', wave: 'triangle', frequency: [400, 600], duration: 0.1, volume: 0.1, pitchVariance: 0 },

  // ==========================================
  // GAMEPLAY FX (ONE SHOT)
  // ==========================================
  'fx_player_fire': { type: 'oscillator', wave: 'sawtooth', frequency: [880, 110], duration: 0.15, volume: 0.15, pitchVariance: 100 },
  'fx_enemy_fire': { type: 'oscillator', wave: 'square', frequency: [440, 220], duration: 0.2, volume: 0.15, pitchVariance: 50 },
  'fx_impact_light': { type: 'noise', frequency: [0, 0], filter: [1000, 100], duration: 0.4, volume: 0.3, pitchVariance: 200, distortion: 20 },
  'fx_impact_heavy': { type: 'noise', frequency: [0, 0], filter: [600, 50], duration: 1.5, volume: 0.5, pitchVariance: 0, distortion: 50 },
  'fx_boot_sequence': { type: 'noise', frequency: [0, 0], filter: [1500, 50], duration: 2.0, volume: 0.6, pitchVariance: 0, distortion: 30 },
  'fx_player_death': { type: 'noise', frequency: [0,0], filter: [500, 500], duration: 2.0, volume: 0.6, pitchVariance: 0, distortion: 200, tremolo: { rate: 12, depth: 1.0, wave: 'square' } },
  'fx_level_up': { type: 'oscillator', wave: 'triangle', frequency: [440, 880], duration: 0.4, volume: 0.2, pitchVariance: 0 },
  'fx_reboot_success': { type: 'oscillator', wave: 'triangle', frequency: [440, 880], duration: 0.3, volume: 0.3, pitchVariance: 0, attack: 0.01, tremolo: { rate: 10, depth: 1.0, wave: 'square' } },
  'fx_teleport': { type: 'oscillator', wave: 'sine', frequency: [100, 1500], duration: 0.3, volume: 0.2, pitchVariance: 0 },

  // ==========================================
  // LOOPS & STATES (CONTINUOUS)
  // ==========================================
  'loop_heal': { type: 'oscillator', wave: 'sine', frequency: [300, 600], duration: 0.2, volume: 0.1, pitchVariance: 0 },
  'loop_reboot': { type: 'oscillator', wave: 'sine', frequency: [100, 200], duration: 0.2, volume: 0.2, pitchVariance: 0 },
  'loop_warning': { type: 'oscillator', wave: 'sine', frequency: [55, 55], duration: 0.8, volume: 0.7, pitchVariance: 0, attack: 0.03, fm: { modType: 'sine', modFreq: 10, modIndex: 25 } },
  'loop_drill': { type: 'noise', frequency: [0,0], filter: [300, 50], duration: 0.25, volume: 0.5, pitchVariance: 50, distortion: 60 },

  // ==========================================
  // AMBIENCE
  // ==========================================
  'ambience_core': { type: 'noise', frequency: [0,0], filter: [800, 800], duration: 40.0, volume: 0.05, pitchVariance: 0 },

  // ==========================================
  // SYNTHESIS LAB (RENAMED PROTOS)
  // ==========================================
  'syn_fm_scream': { type: 'oscillator', wave: 'sawtooth', frequency: [800, 1200], duration: 0.5, volume: 0.15, pitchVariance: 50, fm: { modType: 'sine', modFreq: 150, modIndex: 300 } },
  'syn_data_burst': { type: 'oscillator', wave: 'square', frequency: [25, 20], duration: 0.4, volume: 0.4, pitchVariance: 0, distortion: 50 },
  'syn_bass_drop': { type: 'oscillator', wave: 'triangle', frequency: [150, 100], duration: 0.6, volume: 0.3, pitchVariance: 20, fm: { modType: 'square', modFreq: 57, modIndex: 1000 } },
  'syn_alarm_chirp': { type: 'oscillator', wave: 'sawtooth', frequency: [400, 50], duration: 0.3, volume: 0.3, pitchVariance: 50, distortion: 100 },
  'syn_static_burst': { type: 'noise', frequency: [0, 0], filter: [800, 2000], duration: 0.4, volume: 0.3, pitchVariance: 0, distortion: 400 },
  'syn_wobble_bass': { type: 'oscillator', wave: 'sine', frequency: [50, 50], duration: 0.5, volume: 0.6, pitchVariance: 0, fm: { modType: 'sine', modFreq: 10, modIndex: 50 } },
  'syn_grind_loop': { type: 'noise', frequency: [0,0], filter: [200, 100], duration: 3.0, volume: 0.5, pitchVariance: 0, distortion: 50, tremolo: { rate: 2, depth: 0.8, wave: 'sine' } },
  'syn_insect_swarm': { type: 'noise', frequency: [0,0], filter: [1500, 800], duration: 3.0, volume: 0.3, pitchVariance: 0, distortion: 10, tremolo: { rate: 12, depth: 1.0, wave: 'sawtooth' } },
  'syn_interference': { type: 'noise', frequency: [0,0], filter: [800, 400], duration: 3.0, volume: 0.4, pitchVariance: 0, distortion: 100, tremolo: { rate: 6, depth: 0.6, wave: 'square' } },
  'syn_wind_howl': { type: 'noise', frequency: [0,0], filter: [100, 1000], duration: 3.0, volume: 0.4, pitchVariance: 0, distortion: 20, tremolo: { rate: 15, depth: 0.5, wave: 'sine' } },
  'syn_robot_chatter': { type: 'noise', frequency: [0,0], filter: [500, 500], duration: 3.0, volume: 0.5, pitchVariance: 0, distortion: 200, tremolo: { rate: 8, depth: 1.0, wave: 'square' } },
  'syn_deep_hum': { type: 'noise', frequency: [0,0], filter: [80, 40], duration: 3.0, volume: 0.8, pitchVariance: 0, distortion: 20, tremolo: { rate: 0.5, depth: 0.9, wave: 'sine' } },
  'syn_sine_rise': { type: 'oscillator', wave: 'sine', frequency: [200, 400], duration: 1.0, volume: 0.3, pitchVariance: 0 },
  'syn_saw_rise': { type: 'oscillator', wave: 'sawtooth', frequency: [100, 800], duration: 1.0, volume: 0.2, pitchVariance: 0, fm: { modType: 'sine', modFreq: 50, modIndex: 200 } },
  'syn_sqr_rise': { type: 'oscillator', wave: 'square', frequency: [60, 60], duration: 1.0, volume: 0.2, pitchVariance: 0, fm: { modType: 'triangle', modFreq: 15, modIndex: 100 } },
  'syn_siren_wail': { type: 'oscillator', wave: 'sine', frequency: [60, 20], duration: 2.5, volume: 0.6, pitchVariance: 0, distortion: 20 },
  'syn_alert_pulse': { type: 'oscillator', wave: 'square', frequency: [400, 350], duration: 1.0, volume: 0.3, pitchVariance: 0, fm: { modType: 'square', modFreq: 8, modIndex: 50 } },
  'syn_static_wash': { type: 'noise', frequency: [0, 0], filter: [2000, 200], duration: 1.5, volume: 0.4, pitchVariance: 0, distortion: 100 },
};


=====================================
FILE: ./src/game/config/Identifiers.ts
=====================================
import { GameEvents as NewGameEvents } from '../events/GameEvents';

export const EnemyTypes = {
  DRILLER: 'driller',
  KAMIKAZE: 'kamikaze',
  HUNTER: 'hunter',
  DAEMON: 'daemon', // NEW
} as const;

export type EnemyType = typeof EnemyTypes[keyof typeof EnemyTypes];
export const GameEvents = NewGameEvents;


=====================================
FILE: ./src/game/config/PhysicsConfig.ts
=====================================
export const CollisionLayers = {
  NONE: 0,
  PLAYER: 1,
  ENEMY: 2,
  PLAYER_PROJECTILE: 4,
  ENEMY_PROJECTILE: 8,
  PANEL: 16,
  PICKUP: 32
} as const;

export const PhysicsConfig = {
  HITBOX: {
    PLAYER: 0.6,
    DRILLER: 0.5,
    KAMIKAZE: 0.6,
    HUNTER: 0.7,
    BULLET: 0.25,
    HUNTER_BULLET: 0.4
  },
  MASKS: {
    PLAYER: 42,
    ENEMY: 5,
    PLAYER_PROJECTILE: 10,
    ENEMY_PROJECTILE: 1
  }
};


=====================================
FILE: ./src/game/config/WorldConfig.ts
=====================================
export const WorldConfig = {
  bounds: {
    width: 32, // World Units
    height: 18,
    depth: 5
  },
  physics: {
    friction: 0.95,
    maxVelocity: 20
  },
  time: {
    fixedDelta: 1 / 60, // Logic runs at 60hz (0.0166s per tick)
    maxAccumulator: 0.1 // Prevent "Spiral of Death" if CPU lags hard
  }
};


=====================================
FILE: ./src/game/logic/ai/KamikazeLogic.ts
=====================================
import { Entity } from '../../core/ecs/Entity';
import { EnemyLogic, AIContext } from './types';
import { TransformComponent } from '../../components/data/TransformComponent';
import { MotionComponent } from '../../components/data/MotionComponent';
import { TargetComponent } from '../../components/data/TargetComponent';
import { StateComponent } from '../../components/data/StateComponent';
import { ENEMY_CONFIG } from '../../config/EnemyConfig';
import { EnemyTypes } from '../../config/Identifiers';
import { AI_CONFIG } from '../../config/AIConfig';

const getPos = (e: Entity) => e.requireComponent<TransformComponent>('Transform');
const getMotion = (e: Entity) => e.requireComponent<MotionComponent>('Motion');
const getTarget = (e: Entity) => e.requireComponent<TargetComponent>('Target');
const getState = (e: Entity) => e.requireComponent<StateComponent>('State');

export const KamikazeLogic: EnemyLogic = {
  update: (e: Entity, ctx: AIContext) => {
    const pos = getPos(e);
    const motion = getMotion(e);
    const target = getTarget(e);
    const state = getState(e);

    if (state.current === 'SPAWN') {
        state.timers.spawn -= ctx.delta;
        if (state.timers.spawn <= 0) {
            state.current = 'MOVING';
        }
        return; 
    }

    const dx = target.x - pos.x;
    const dy = target.y - pos.y;
    const dist = Math.sqrt(dx*dx + dy*dy);

    if (dist > AI_CONFIG.KAMIKAZE.ENGAGEMENT_DIST) {
      const speed = ENEMY_CONFIG[EnemyTypes.KAMIKAZE].baseSpeed;
      motion.vx = (dx / dist) * speed;
      motion.vy = (dy / dist) * speed;
      
      pos.rotation += AI_CONFIG.KAMIKAZE.ROTATION_SPEED * ctx.delta; 
    }
  }
};


=====================================
FILE: ./src/game/logic/ai/HunterLogic.ts
=====================================
import { Entity } from '../../core/ecs/Entity';
import { EnemyLogic, AIContext } from './types';
import { TransformComponent } from '../../components/data/TransformComponent';
import { MotionComponent } from '../../components/data/MotionComponent';
import { StateComponent } from '../../components/data/StateComponent';
import { TargetComponent } from '../../components/data/TargetComponent';
import { ENEMY_CONFIG } from '../../config/EnemyConfig';
import { EnemyTypes } from '../../config/Identifiers';
import { AI_CONFIG } from '../../config/AIConfig';

const getPos = (e: Entity) => e.requireComponent<TransformComponent>('Transform');
const getMotion = (e: Entity) => e.requireComponent<MotionComponent>('Motion');
const getState = (e: Entity) => e.requireComponent<StateComponent>('State');
const getTarget = (e: Entity) => e.requireComponent<TargetComponent>('Target');

function rotateTowards(current: number, target: number, speed: number): number {
    let diff = target - current;
    while (diff > Math.PI) diff -= Math.PI * 2;
    while (diff < -Math.PI) diff += Math.PI * 2;
    return current + diff * speed;
}

function lerp(start: number, end: number, t: number): number {
    return start * (1 - t) + end * t;
}

export const HunterLogic: EnemyLogic = {
  update: (e: Entity, ctx: AIContext) => {
    const pos = getPos(e);
    const motion = getMotion(e);
    const state = getState(e);
    const target = getTarget(e);

    if (state.data.spinVelocity === undefined) {
        state.data.spinVelocity = AI_CONFIG.HUNTER.SPIN_SPEED_IDLE;
        state.data.spinAngle = 0;
    }
    if (state.current === 'SPAWN' || state.current === 'IDLE') {
        state.current = 'HUNT';
        state.timers.action = 3.0; 
        state.data.offsetAngle = (e.id.valueOf() % 10) * 0.6; 
    }

    let targetSpinSpeed = AI_CONFIG.HUNTER.SPIN_SPEED_IDLE; 

    // --- STATES ---

    if (state.current === 'HUNT') {
        // ... Orbit Logic ...
        const currentAngle = (ctx.time * AI_CONFIG.HUNTER.ORBIT_SPEED) + state.data.offsetAngle;
        const tx = target.x + Math.cos(currentAngle) * AI_CONFIG.HUNTER.TARGET_RADIUS;
        const ty = target.y + Math.sin(currentAngle) * AI_CONFIG.HUNTER.TARGET_RADIUS;

        const dx = tx - pos.x;
        const dy = ty - pos.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const speed = ENEMY_CONFIG[EnemyTypes.HUNTER].baseSpeed; 
        
        if (dist > 1.0) {
            motion.vx += (dx / dist) * speed * ctx.delta * 2.0;
            motion.vy += (dy / dist) * speed * ctx.delta * 2.0;
        }
        
        motion.vx *= 0.92;
        motion.vy *= 0.92;

        const aimDx = target.x - pos.x;
        const aimDy = target.y - pos.y;
        const aimAngle = Math.atan2(aimDy, aimDx) - Math.PI/2;
        pos.rotation = rotateTowards(pos.rotation, aimAngle, AI_CONFIG.HUNTER.AIM_LERP);

        state.timers.action -= ctx.delta;
        if (state.timers.action <= 0) {
            state.current = 'CHARGE';
            state.timers.action = ENEMY_CONFIG[EnemyTypes.HUNTER].chargeDuration;
            motion.vx *= 0.1; 
            motion.vy *= 0.1;
        }
    } 
    
    else if (state.current === 'CHARGE') {
        // Charging...
        state.timers.action -= ctx.delta;
        motion.vx *= 0.8;
        motion.vy *= 0.8;

        // Hard Lock Aim
        const dx = target.x - pos.x;
        const dy = target.y - pos.y;
        const targetAngle = Math.atan2(dy, dx) - Math.PI/2;
        pos.rotation = rotateTowards(pos.rotation, targetAngle, AI_CONFIG.HUNTER.CHARGE_LERP);

        targetSpinSpeed = AI_CONFIG.HUNTER.SPIN_SPEED_CHARGE; 

        if (state.timers.action <= 0) {
            state.current = 'FIRE';
        }
    }
    
    else if (state.current === 'FIRE') {
        const dx = target.x - pos.x;
        const dy = target.y - pos.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        const dirX = dist > 0 ? dx/dist : 0;
        const dirY = dist > 0 ? dy/dist : 1;
        
        const offset = AI_CONFIG.HUNTER.OFFSET_DIST;
        
        const spawnX = pos.x + (dirX * offset);
        const spawnY = pos.y + (dirY * offset);

        ctx.spawnProjectile(spawnX, spawnY, dirX * AI_CONFIG.HUNTER.PROJECTILE_SPEED, dirY * AI_CONFIG.HUNTER.PROJECTILE_SPEED);
        ctx.spawnLaunchSparks(spawnX, spawnY, pos.rotation);

        state.current = 'HUNT';
        state.timers.action = 2.0 + Math.random() * 2.0;
    }

    state.data.spinVelocity = lerp(state.data.spinVelocity, targetSpinSpeed, ctx.delta * 2.0);
    state.data.spinAngle += state.data.spinVelocity * ctx.delta;
  }
};


=====================================
FILE: ./src/game/logic/ai/types.ts
=====================================
import { Entity } from '../../core/ecs/Entity';

export interface AIContext {
  delta: number;
  time: number;
  daemonMaxDamage?: number;
  spawnProjectile: (x, y: number, vx: number, vy: number) => void;
  spawnDrillSparks: (x: number, y: number, angle: number) => void; 
  spawnLaunchSparks: (x: number, y: number, angle: number) => void; 
  damagePanel: (id: string, amount: number) => void;
  // --- NEW ---
  playSound: (key: string) => void;
}

export interface EnemyLogic {
  update(entity: Entity, ctx: AIContext): void;
}


=====================================
FILE: ./src/game/logic/ai/DaemonLogic.ts
=====================================
import { Entity } from '../../core/ecs/Entity';
import { EnemyLogic, AIContext } from './types';
import { TransformComponent } from '../../components/data/TransformComponent';
import { StateComponent } from '../../components/data/StateComponent';
import { TargetComponent } from '../../components/data/TargetComponent';
import { OrbitalComponent } from '../../components/data/OrbitalComponent';
import { AI_CONFIG } from '../../config/AIConfig';

const getPos = (e: Entity) => e.requireComponent<TransformComponent>('Transform');
const getState = (e: Entity) => e.requireComponent<StateComponent>('State');
const getTarget = (e: Entity) => e.requireComponent<TargetComponent>('Target');
const getOrbital = (e: Entity) => e.requireComponent<OrbitalComponent>('Orbital');

export const DaemonLogic: EnemyLogic = {
  update: (e: Entity, ctx: AIContext) => {
    const pos = getPos(e);
    const state = getState(e);
    const target = getTarget(e);
    const orbital = getOrbital(e);

    const maxShield = ctx.daemonMaxDamage || 10;

    if (typeof state.data.shieldHP !== 'number') {
        state.data.shieldHP = 0;
    }
    state.data.maxShield = maxShield; 

    // --- STATE MACHINE ---

    if (state.current === 'SPAWN' || state.current === 'ORBIT') {
        state.current = 'CHARGING';
        state.data.shieldHP = 0; 
    }

    // 1. CHARGING (Accumulate Shield)
    if (state.current === 'CHARGING') {
        orbital.active = true;
        
        if (state.data.shieldHP <= 0 && state.data.wasHit) {
             state.current = 'BROKEN';
             state.timers.action = AI_CONFIG.DAEMON.RECOVERY_TIME;
             return;
        }

        const chargeRate = maxShield / AI_CONFIG.DAEMON.SHIELD_CHARGE_TIME; 
        state.data.shieldHP = Math.min(maxShield, state.data.shieldHP + (chargeRate * ctx.delta));

        if (state.data.shieldHP >= maxShield) {
            state.current = 'READY';
        }
    } 
    
    // 2. READY (Holding Charge)
    else if (state.current === 'READY') {
        orbital.active = true;
        
        if (state.data.shieldHP <= 0) {
             state.current = 'BROKEN';
             state.timers.action = AI_CONFIG.DAEMON.RECOVERY_TIME;
             return;
        }

        if (target.id === 'ENEMY_LOCKED') state.current = 'FIRE';
    }
    
    // 3. FIRE (Launch Shield as Bullet)
    else if (state.current === 'FIRE') {
        const dx = target.x - pos.x;
        const dy = target.y - pos.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const dirX = dist > 0 ? dx/dist : 0;
        const dirY = dist > 0 ? dy/dist : 1;
        
        pos.rotation = Math.atan2(dy, dx) - Math.PI/2;

        ctx.spawnProjectile(pos.x, pos.y, dirX * 35, dirY * 35);

        state.data.shieldHP = 0; 
        state.current = 'COOLDOWN';
        state.timers.action = AI_CONFIG.DAEMON.COOLDOWN_TIME;
    }
    
    // 4. COOLDOWN
    else if (state.current === 'COOLDOWN') {
        orbital.active = true;
        state.timers.action -= ctx.delta;
        if (state.timers.action <= 0) {
            state.current = 'CHARGING';
            state.data.wasHit = false;
        }
    }

    // 5. BROKEN (Shield Destroyed)
    else if (state.current === 'BROKEN') {
        state.data.shieldHP = 0;
        state.timers.action -= ctx.delta;
        
        pos.rotation += ctx.delta * AI_CONFIG.DAEMON.ROTATION_SPEED.BROKEN;

        if (state.timers.action <= 0) {
            state.current = 'CHARGING';
            state.data.wasHit = false;
        }
    }
  }
};


=====================================
FILE: ./src/game/logic/ai/DrillerLogic.ts
=====================================
import { Entity } from '../../core/ecs/Entity';
import { EnemyLogic, AIContext } from './types';
import { TransformComponent } from '../../components/data/TransformComponent';
import { MotionComponent } from '../../components/data/MotionComponent';
import { StateComponent } from '../../components/data/StateComponent';
import { TargetComponent } from '../../components/data/TargetComponent';
import { PanelRegistry } from '../../systems/PanelRegistrySystem'; 
import { ENEMY_CONFIG } from '../../config/EnemyConfig';
import { EnemyTypes } from '../../config/Identifiers';
import { AI_CONFIG } from '../../config/AIConfig';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';

const getPos = (e: Entity) => e.requireComponent<TransformComponent>('Transform');
const getMotion = (e: Entity) => e.requireComponent<MotionComponent>('Motion');
const getState = (e: Entity) => e.requireComponent<StateComponent>('State');
const getTarget = (e: Entity) => e.requireComponent<TargetComponent>('Target');

export const DrillerLogic: EnemyLogic = {
  update: (e: Entity, ctx: AIContext) => {
    const pos = getPos(e);
    const motion = getMotion(e);
    const state = getState(e);
    const target = getTarget(e);

    if (typeof state.data.audioTimer === 'undefined') state.data.audioTimer = 0;
    if (typeof state.data.damageTimer === 'undefined') state.data.damageTimer = 0;

    let destX = target.x;
    let destY = target.y;
    
    if (target.type === 'PANEL' && target.id) {
        const rect = PanelRegistry.getPanelRect(target.id);
        if (rect) {
            destX = Math.max(rect.left, Math.min(pos.x, rect.right));
            destY = Math.max(rect.bottom, Math.min(pos.y, rect.top));
        }
    }

    const dx = destX - pos.x;
    const dy = destY - pos.y;
    const distSq = dx*dx + dy*dy;
    const dist = Math.sqrt(distSq);
    const angle = Math.atan2(dy, dx) - Math.PI/2;
    
    if (dist <= AI_CONFIG.DRILLER.TIP_OFFSET + AI_CONFIG.DRILLER.SNAP_THRESHOLD && target.id !== null) {
        state.current = 'DRILLING';
        
        if (dist > 0.001) {
            const normX = dx / dist;
            const normY = dy / dist;
            pos.x = destX - (normX * AI_CONFIG.DRILLER.TIP_OFFSET);
            pos.y = destY - (normY * AI_CONFIG.DRILLER.TIP_OFFSET);
        }

        motion.vx = 0;
        motion.vy = 0;
        pos.rotation = angle;

        ctx.spawnDrillSparks(destX, destY, angle);

        state.data.audioTimer -= ctx.delta;
        if (state.data.audioTimer <= 0) {
            ctx.playSound('loop_drill');
            state.data.audioTimer = AI_CONFIG.DRILLER.AUDIO_INTERVAL + Math.random() * 0.1; 
        }

        state.data.damageTimer -= ctx.delta;
        if (state.data.damageTimer <= 0) {
             if (target.type === 'PANEL' && target.id) {
                 const dmg = ENEMY_CONFIG[EnemyTypes.DRILLER].damage; 
                 ctx.damagePanel(target.id, dmg);
                 state.data.damageTimer = 0.2; 
             }
        }

    } else {
        state.current = 'MOVING';
        state.data.audioTimer = 0;
        state.data.damageTimer = 0;

        const speed = ENEMY_CONFIG[EnemyTypes.DRILLER].baseSpeed;
        if (dist > 0.001) {
            motion.vx = (dx / dist) * speed;
            motion.vy = (dy / dist) * speed;
            pos.rotation = angle;
        }
    }
  }
};


=====================================
FILE: ./src/game/utils/TextureGen.ts
=====================================
import * as THREE from 'three';

// Helper: Exponential Falloff for natural light
// x is 0..1 (distance from center)
const falloff = (x: number, power: number = 2) => {
  return Math.pow(Math.max(0, 1 - x), power);
};

// 1. High Quality Comet Trail
export const createCometTexture = () => {
  const w = 64;
  const h = 256; // Higher resolution vertical
  const canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext('2d')!;
  
  ctx.clearRect(0, 0, w, h);

  // We draw manually pixel-by-pixel or using complex gradients for better control
  // Gradient: Bottom (Head) -> Top (Tail)
  const gradient = ctx.createLinearGradient(0, h, 0, 0);
  
  // Exponential fade:
  // 0.0 (Head): 100% Opacity
  // 0.2 (Body): 60% Opacity
  // 1.0 (Tail): 0% Opacity
  gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)'); 
  gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.4)');
  gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

  ctx.fillStyle = gradient;

  // Shape: Tapered Triangle
  ctx.beginPath();
  ctx.moveTo(w * 0.1, h);       // Bottom Left (pinched slightly)
  ctx.lineTo(w * 0.9, h);       // Bottom Right
  ctx.lineTo(w * 0.5, 0);       // Top Tip
  ctx.closePath();
  ctx.fill();

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
};

// 2. Player Bullet (Glowing Bar)
export const createGlowingBarTexture = () => {
  const w = 64;
  const h = 128;
  const canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext('2d')!;

  // Clear
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, w, h);

  // Glow (Soft Rect)
  const cx = w / 2;
  const cy = h / 2;
  
  // Radial glow around the bar isn't ideal, let's use shadow blur
  ctx.shadowColor = "white";
  ctx.shadowBlur = 20;
  ctx.fillStyle = "white";
  
  // Draw Core (Slim Rectangle)
  // Leave padding for the glow/shadow to bleed
  ctx.fillRect(24, 20, 16, 88); 

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
};

// 3. Hunter Orb (Exponential Glow)
export const createExponentialBallTexture = () => {
  const size = 128;
  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d')!;
  
  const cx = size / 2;
  const cy = size / 2;
  const radius = size / 2;

  const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
  
  // Sharp Core, Soft Bloom
  gradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); 
  gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.9)'); // Solid Core
  gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)'); // Mid Bloom
  gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Fade out

  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, size, size);

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
};

// 4. Soft Glow (Backgrounds - Legacy/Enemies)
export const createGlowTexture = () => {
  const canvas = document.createElement('canvas');
  canvas.width = 64;
  canvas.height = 64;
  const ctx = canvas.getContext('2d')!;
  
  const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
  gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
  gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 64, 64);

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
};


=====================================
FILE: ./src/game/utils/Noise.ts
=====================================
// Simple 1D Gradient Noise
// Returns value between -1 and 1 based on input 'x'
export function noise(x: number): number {
  const i = Math.floor(x);
  const f = x - i;
  const u = f * f * (3.0 - 2.0 * f); // Cubic smoothing
  return mix(hash(i), hash(i + 1), u);
}

function hash(n: number): number {
  return (Math.sin(n) * 43758.5453) % 1.0;
}

function mix(a: number, b: number, t: number): number {
  return a * (1 - t) + b * t;
}


=====================================
FILE: ./src/game/utils/ViewportHelper.ts
=====================================
export interface WorldRect {
  id: string;
  x: number;
  y: number;
  width: number;
  height: number;
  left: number;
  right: number;
  top: number;
  bottom: number;
}

export class ViewportHelperCore {
  public viewport = { width: 1, height: 1 }; // R3F Viewport units
  public screenSize = { width: 1, height: 1 }; // Window Pixels

  public update(vpW: number, vpH: number, screenW: number, screenH: number) {
    this.viewport = { width: vpW, height: vpH };
    this.screenSize = { width: screenW, height: screenH };
  }

  // Pure Math: Converts Pixel Rect -> World Rect
  public domToWorld(id: string, domRect: DOMRect): WorldRect {
    const sw = this.screenSize.width || 1;
    const sh = this.screenSize.height || 1;
    
    const vw = this.viewport.width;
    const vh = this.viewport.height;
    
    const cx = domRect.left + domRect.width / 2;
    const cy = domRect.top + domRect.height / 2;
    
    // Screen (Pixels) -> World (Orthographic Units)
    // 0,0 is center of screen in World
    const wx = (cx / sw) * vw - (vw / 2);
    const wy = -((cy / sh) * vh - (vh / 2));
    
    const wWidth = (domRect.width / sw) * vw;
    const wHeight = (domRect.height / sh) * vh;

    return {
      id: id,
      x: wx, y: wy,
      width: wWidth, height: wHeight,
      left: wx - wWidth / 2, right: wx + wWidth / 2,
      top: wy + wHeight / 2, bottom: wy - wHeight / 2,
    };
  }
}

export const ViewportHelper = new ViewportHelperCore();


=====================================
FILE: ./src/game/utils/GeometryUtils.ts
=====================================
import * as THREE from 'three';

export const addBarycentricCoordinates = (bufferGeometry: THREE.BufferGeometry, removeEdge: boolean = false) => {
  const geometry = bufferGeometry.toNonIndexed();
  const count = geometry.attributes.position.count;
  const centers = new Float32Array(count * 3);

  for (let i = 0; i < count; i += 3) {
    centers[i * 3] = 1;
    centers[i * 3 + 1] = 0;
    centers[i * 3 + 2] = 0;

    centers[i * 3 + 3] = 0;
    centers[i * 3 + 4] = 1;
    centers[i * 3 + 5] = 0;

    centers[i * 3 + 6] = 0;
    centers[i * 3 + 7] = 0;
    centers[i * 3 + 8] = 1;
  }

  geometry.setAttribute('barycentric', new THREE.BufferAttribute(centers, 3));
  return geometry;
};

// NEW: Tri-Wing "Paper Airplane" Spear
export const createHunterSpear = () => {
  const positions: number[] = [];
  
  // We build 3 "Wings" (thin triangles)
  const numWings = 3;
  const length = 1.2;
  const wingWidth = 0.4;
  const wingThickness = 0.05; // Give it slight 3D thickness

  for(let i=0; i<numWings; i++) {
      const angle = (i / numWings) * Math.PI * 2;
      
      // We build a triangle in the Y/X plane, then rotate it around Y
      // Tip at (0, length/2, 0)
      // Base Outer at (width, -length/2, 0)
      // Base Inner at (0, -length/2, 0)
      
      const tipY = length / 2;
      const baseY = -length / 2;
      
      // Define vertices for a "Thick" triangle (Wedge)
      // P1: Tip
      // P2: Base Outer Left
      // P3: Base Outer Right
      // P4: Base Center (Axis)
      
      // Let's manually push triangles for a "Fin"
      // Fin stands on the +X axis
      
      const pTip = [0, tipY, 0];
      const pBaseOut = [wingWidth, baseY, 0];
      const pBaseInBack = [0, baseY, -wingThickness];
      const pBaseInFront = [0, baseY, wingThickness];
      
      // Helper to rotate point around Y axis
      const rotateY = (p: number[], rad: number) => {
          const x = p[0];
          const z = p[2];
          return [
              x * Math.cos(rad) - z * Math.sin(rad),
              p[1], // Y unchanged
              x * Math.sin(rad) + z * Math.cos(rad)
          ];
      };

      // Push Triangles
      // 1. Face Front
      let v1 = rotateY(pTip, angle);
      let v2 = rotateY(pBaseOut, angle);
      let v3 = rotateY(pBaseInFront, angle);
      positions.push(...v1, ...v2, ...v3);
      
      // 2. Face Back
      v1 = rotateY(pTip, angle);
      v2 = rotateY(pBaseInBack, angle);
      v3 = rotateY(pBaseOut, angle);
      positions.push(...v1, ...v2, ...v3);
      
      // 3. Base Cap (optional, but good for solidity)
      // ... skipping for wireframe aesthetic
  }
  
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  geometry.computeVertexNormals();
  
  return addBarycentricCoordinates(geometry);
};


=====================================
FILE: ./src/game/utils/ai/StateMachine.ts
=====================================
import { Entity } from '../../core/ecs/Entity';

export interface State {
  name: string;
  enter?: (entity: Entity, data?: any) => void;
  update?: (entity: Entity, delta: number, time: number, data?: any) => void;
  exit?: (entity: Entity, data?: any) => void;
}

export class StateMachine {
  private states = new Map<string, State>();
  private currentState: State | null = null;

  public addState(state: State) {
    this.states.set(state.name, state);
    return this;
  }

  public setState(name: string, entity: Entity, data?: any) {
    if (this.currentState && this.currentState.name === name) return;

    if (this.currentState && this.currentState.exit) {
      this.currentState.exit(entity, data);
    }

    this.currentState = this.states.get(name) || null;

    if (this.currentState && this.currentState.enter) {
      this.currentState.enter(entity, data);
    }
  }

  public update(entity: Entity, delta: number, time: number, data?: any) {
    if (this.currentState && this.currentState.update) {
      this.currentState.update(entity, delta, time, data);
    }
  }

  public getCurrentState() {
    return this.currentState?.name || null;
  }
}


=====================================
FILE: ./src/game/utils/coords.ts
=====================================
// Camera Zoom level defined in GameOverlay
const ZOOM = 40; 

export const screenToWorld = (screenX: number, screenY: number, screenW: number, screenH: number) => {
  // DOM: 0,0 is Top-Left. +Y is Down.
  // THREE: 0,0 is Center. +Y is Up.
  
  const worldX = (screenX - screenW / 2) / ZOOM;
  const worldY = -(screenY - screenH / 2) / ZOOM; // Invert Y
  
  return { x: worldX, y: worldY };
};

export const domRectToWorldRect = (rect: { x: number, y: number, width: number, height: number }, screenW: number, screenH: number) => {
  // Get center of DOM element
  const centerX = rect.x + rect.width / 2;
  const centerY = rect.y + rect.height / 2;
  
  const centerWorld = screenToWorld(centerX, centerY, screenW, screenH);
  
  return {
    x: centerWorld.x,
    y: centerWorld.y,
    width: rect.width / ZOOM,
    height: rect.height / ZOOM,
    left: centerWorld.x - (rect.width / ZOOM / 2),
    right: centerWorld.x + (rect.width / ZOOM / 2),
    top: centerWorld.y + (rect.height / ZOOM / 2),
    bottom: centerWorld.y - (rect.height / ZOOM / 2),
  };
};


=====================================
FILE: ./src/game/components/DaemonChargeRenderer.tsx
=====================================
import { useMemo } from 'react';
import * as THREE from 'three';
import { Tag } from '../core/ecs/types';
import { EnemyTypes } from '../config/Identifiers';
import { InstancedActor } from './common/InstancedActor';
import { IdentityComponent } from '../data/IdentityComponent';
import { StateComponent } from '../data/StateComponent';
import { TransformComponent } from '../data/TransformComponent';

const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0); }`;
const fragmentShader = `
  varying vec2 vUv; uniform vec3 uColor;
  void main() {
    float dist = distance(vUv, vec2(0.5));
    float core = 1.0 - smoothstep(0.2, 0.25, dist);
    float glow = pow(1.0 - smoothstep(0.25, 0.5, dist), 3.0);
    gl_FragColor = vec4(mix(uColor, vec3(1.0), core), max(core, glow));
  }
`;

export const DaemonChargeRenderer = () => {
  const geometry = useMemo(() => new THREE.PlaneGeometry(4.0, 4.0), []);
  const material = useMemo(() => new THREE.ShaderMaterial({
    vertexShader, fragmentShader,
    uniforms: { uColor: { value: new THREE.Color('#00F0FF') } }, 
    transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
  }), []);

  return (
    <InstancedActor
      tag={Tag.PLAYER}
      geometry={geometry}
      material={material}
      maxCount={10}
      filter={(e) => {
          const id = e.getComponent<IdentityComponent>('Identity');
          const state = e.getComponent<StateComponent>('State');
          // Hide if BROKEN
          return id?.variant === EnemyTypes.DAEMON && (state?.current === 'CHARGING' || state?.current === 'READY');
      }}
      updateEntity={(e, obj) => {
          const transform = e.getComponent<TransformComponent>('Transform');
          const state = e.getComponent<StateComponent>('State');
          
          if (transform && state) {
              obj.position.copy(new THREE.Vector3(transform.x, transform.y, 0.1));
              obj.rotation.set(0,0,0);

              // SCALE BASED ON SHIELD HP
              const maxShield = state.data.maxShield || 10;
              const currentShield = state.data.shieldHP || 0;
              const healthRatio = Math.max(0, currentShield / maxShield);
              
              if (state.current === 'READY') {
                  // Pulse at full current size
                  const pulse = 1.0 + Math.sin(performance.now() * 0.01) * 0.1;
                  obj.scale.setScalar(healthRatio * pulse);
              } else {
                  obj.scale.setScalar(healthRatio);
              }
          }
      }}
    />
  );
};


=====================================
FILE: ./src/game/components/PlayerAvatar.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import { GAME_THEME } from '../theme';
import { ServiceLocator } from '../core/ServiceLocator';
import { useGameStore } from '../store/useGameStore';
import { useStore } from '@/core/store/useStore';
import { InteractionSystem, RepairState } from '../systems/InteractionSystem'; 
import { EntitySystem } from '../systems/EntitySystem';
import * as THREE from 'three';

export const PlayerAvatar = () => {
  const groupRef = useRef<THREE.Group>(null);
  const ringRef = useRef<THREE.Mesh>(null);
  const coreRef = useRef<THREE.Mesh>(null);
  const glowRef = useRef<THREE.Sprite>(null);
  const { viewport } = useThree();
  
  const { introDone } = useStore(); 

  const colorTurret = new THREE.Color(GAME_THEME.turret.base); 
  const colorRepair = new THREE.Color(GAME_THEME.turret.repair); 
  const colorReboot = new THREE.Color('#9E4EA5'); 
  const colorDead = new THREE.Color('#FF003C'); 

  const isDead = useGameStore(state => state.playerHealth <= 0);
  const isGameOver = useGameStore(state => state.systemIntegrity <= 0);
  
  // GEOMETRIES
  const aliveGeo = new THREE.CircleGeometry(0.1, 16);
  // Reverted: Use Circle with 3 segments for Triangle, size 0.12
  const deadGeo = new THREE.CircleGeometry(0.12, 3); 
  
  const animScale = useRef(0);

  useFrame((state, delta) => {
    if (!groupRef.current) return;

    // FADE IN LOGIC
    const targetScale = introDone ? 1 : 0;
    animScale.current = THREE.MathUtils.lerp(animScale.current, targetScale, delta * 2.0);
    
    if (animScale.current < 0.01) {
        groupRef.current.visible = false;
        return;
    }
    groupRef.current.visible = true;

    // 1. Position
    const x = (state.pointer.x * viewport.width) / 2;
    const y = (state.pointer.y * viewport.height) / 2;
    groupRef.current.position.x = x;
    groupRef.current.position.y = y;

    try { ServiceLocator.getInputService().updateCursor(x, y); } catch {}

    // 2. State
    let repairState: RepairState = 'IDLE';
    let entitySys: EntitySystem | null = null;
    try {
        repairState = ServiceLocator.getSystem<InteractionSystem>('InteractionSystem').repairState;
        entitySys = ServiceLocator.getSystem<EntitySystem>('EntitySystem');
    } catch {}
    
    let targetColor = colorTurret;
    if (repairState === 'HEALING') targetColor = colorRepair; 
    if (repairState === 'REBOOTING') targetColor = colorReboot; 

    // 3. Visuals
    if (ringRef.current && coreRef.current && glowRef.current) {
        let currentBaseScale = 1.0;

        if (isDead || isGameOver) {
            // DEAD STATE: Red Triangle
            ringRef.current.visible = false;
            glowRef.current.visible = false;
            
            coreRef.current.geometry = deadGeo;
            coreRef.current.material.color.set(colorDead);
            coreRef.current.material.wireframe = true; 
            
            // ANIMATION LOGIC
            const isRebooting = repairState === 'REBOOTING';
            
            if (isRebooting) {
                // Fast Counter-Clockwise Spin
                coreRef.current.rotation.z -= delta * 10.0;
                
                // Particle Spray
                if (entitySys && Math.random() > 0.5) { // 30fps emission rate
                    const pColor = Math.random() > 0.5 ? '#FF003C' : '#F7D277';
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 3;
                    
                    entitySys.spawnParticle(x, y, pColor, 1, speed, 0.4);
                }
            } else {
                // Slow Clockwise Idle Spin
                coreRef.current.rotation.z += delta * 1.5; 
            }
            
        } else {
            // ALIVE STATE
            ringRef.current.visible = true;
            glowRef.current.visible = true;
            coreRef.current.geometry = aliveGeo;
            coreRef.current.material.wireframe = false;
            
            if (repairState !== 'IDLE') {
                ringRef.current.rotation.z += 0.4; 
                ringRef.current.material.color.lerp(targetColor, 0.4);
                coreRef.current.material.color.lerp(targetColor, 0.4);
                glowRef.current.material.color.lerp(targetColor, 0.4);
                
                const pulse = 1.2 + Math.sin(state.clock.elapsedTime * 20) * 0.2;
                currentBaseScale = pulse;
            } else {
                ringRef.current.rotation.z -= 0.02; 
                ringRef.current.material.color.lerp(colorTurret, 0.1);
                coreRef.current.material.color.lerp(colorTurret, 0.1);
                glowRef.current.material.color.lerp(colorTurret, 0.1);
            }
        }
        
        groupRef.current.scale.setScalar(animScale.current);
        coreRef.current.scale.setScalar(currentBaseScale);
        ringRef.current.scale.setScalar(currentBaseScale); 
    }
  });

  return (
    <group ref={groupRef}>
      <mesh ref={coreRef}>
        <bufferGeometry />
        <meshBasicMaterial color={GAME_THEME.turret.base} />
      </mesh>

      <mesh ref={ringRef} rotation={[0, 0, Math.PI / 4]}>
        <ringGeometry args={[0.4, 0.45, 4]} /> 
        <meshBasicMaterial color={GAME_THEME.turret.base} transparent opacity={0.8} />
      </mesh>

      <sprite ref={glowRef} scale={[2, 2, 1]}>
        <spriteMaterial 
          color={GAME_THEME.turret.glow} 
          transparent 
          opacity={0.3}
          blending={THREE.AdditiveBlending}
        />
      </sprite>
    </group>
  );
};


=====================================
FILE: ./src/game/components/BulletRenderer.tsx
=====================================
import { useMemo } from 'react';
import * as THREE from 'three';
import { Tag } from '../core/ecs/types';
import { GAME_THEME } from '../theme';
import { InstancedActor } from './common/InstancedActor';
import { HealthComponent } from '../components/data/HealthComponent';

const vertexShader = `
  varying vec2 vUv;
  void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0); }
`;
const fragmentShader = `
  varying vec2 vUv;
  uniform vec3 uColor;
  float sdBox(vec2 p, vec2 b) { vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }
  void main() {
    vec2 p = vUv - 0.5;
    // Box shape adapts to UVs, we rely on mesh scaling for width
    float d = sdBox(p, vec2(0.2, 0.4)); 
    float core = 1.0 - smoothstep(0.0, 0.02, d);
    float glow = exp(-20.0 * max(0.0, d));
    vec3 color = mix(uColor, vec3(1.0), core);
    gl_FragColor = vec4(color, max(core, glow));
  }
`;

export const BulletRenderer = () => {
  const geometry = useMemo(() => new THREE.PlaneGeometry(1.0, 1.0), []); 
  const material = useMemo(() => new THREE.ShaderMaterial({
    vertexShader, fragmentShader,
    uniforms: { uColor: { value: new THREE.Color(GAME_THEME.bullet.plasma) } },
    transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
  }), []);

  return (
    <InstancedActor 
      tag={Tag.BULLET} 
      geometry={geometry} 
      material={material} 
      maxCount={500} 
      filter={(e) => !e.hasTag(Tag.ENEMY)}
      updateEntity={(e, obj) => {
         const transform = e.getComponent<any>('Transform');
         const hp = e.getComponent<HealthComponent>('Health');
         
         // 1. Durability Fade
         let hpScale = 1.0;
         if (hp && hp.max > 1) {
             hpScale = 0.6 + (0.4 * (hp.current / hp.max));
         }
         
         // 2. Width Scaling (from Upgrade)
         // We scale X (width) based on the upgrade factor passed in transform.scale
         const widthScale = transform ? transform.scale : 1.0;
         
         // Base length is longer than width
         obj.scale.set(widthScale * hpScale, 1.5 * hpScale, 1); 
         obj.rotation.z = transform.rotation - (Math.PI / 2);
      }}
    />
  );
};


=====================================
FILE: ./src/game/components/ParticleRenderer.tsx
=====================================
import { useMemo } from 'react';
import * as THREE from 'three';
import { Tag } from '../core/ecs/types';
import { InstancedActor } from './common/InstancedActor';
import { LifetimeComponent } from '../components/data/LifetimeComponent';

export const ParticleRenderer = () => {
  const geometry = useMemo(() => new THREE.PlaneGeometry(0.3, 0.3), []);
  const material = useMemo(() => new THREE.ShaderMaterial({
    vertexShader: `
      #ifndef USE_INSTANCING_COLOR
      attribute vec3 instanceColor;
      #endif
      varying vec2 vUv;
      varying vec3 vColor;
      void main() { vUv = uv; vColor = instanceColor; gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0); }
    `,
    fragmentShader: `
      varying vec2 vUv;
      varying vec3 vColor;
      void main() {
        float dist = distance(vUv, vec2(0.5));
        float alpha = pow(1.0 - smoothstep(0.0, 0.5, dist), 3.0);
        if (alpha < 0.01) discard;
        gl_FragColor = vec4(vColor, alpha);
      }
    `,
    vertexColors: true, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
  }), []);

  return (
    <InstancedActor 
      tag={Tag.PARTICLE} 
      geometry={geometry} 
      material={material} 
      maxCount={1000}
      colorSource="identity"
      updateEntity={(e, obj, color) => {
         const life = e.getComponent<LifetimeComponent>('Lifetime');
         if (life) {
             const scale = life.remaining / life.total;
             obj.scale.setScalar(scale);
             
             // VOLUMETRIC EFFECT:
             // Enemies are at Z=5.0. 
             // We split particles 50/50 to be In Front (6.0) or Behind (4.0).
             // Using ID ensures it doesn't flicker frame-to-frame.
             const isInFront = (e.id as number) % 2 === 0;
             obj.position.z = isInFront ? 6.0 : 4.0;
         }
      }}
    />
  );
};


=====================================
FILE: ./src/game/components/EnemyBulletRenderer.tsx
=====================================
import { useMemo } from 'react';
import * as THREE from 'three';
import { Tag } from '../core/ecs/types';
import { GAME_THEME } from '../theme';
import { InstancedActor } from './common/InstancedActor';
import { HealthComponent } from '../components/data/HealthComponent';

const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0); }`;
const fragmentShader = `
  varying vec2 vUv; uniform vec3 uColor;
  void main() {
    float dist = distance(vUv, vec2(0.5));
    float core = 1.0 - smoothstep(0.2, 0.25, dist);
    float glow = pow(1.0 - smoothstep(0.25, 0.5, dist), 3.0);
    gl_FragColor = vec4(mix(uColor, vec3(1.0), core), max(core, glow));
  }
`;

export const EnemyBulletRenderer = () => {
  const geometry = useMemo(() => new THREE.PlaneGeometry(2.0, 2.0), []); 
  const material = useMemo(() => new THREE.ShaderMaterial({
    vertexShader, fragmentShader,
    uniforms: { uColor: { value: new THREE.Color(GAME_THEME.bullet.hunter) } },
    transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
  }), []);

  return (
    <InstancedActor 
      tag={Tag.BULLET} 
      geometry={geometry} 
      material={material} 
      maxCount={200}
      filter={(e) => e.hasTag(Tag.ENEMY)}
      updateEntity={(e, obj) => {
          // Scale based on Health (Mass)
          const hp = e.getComponent<HealthComponent>('Health');
          let scale = 1.0;
          
          if (hp) {
              // Hunter Orbs are 3HP max.
              // 3/3 = 1.0
              // 2/3 = 0.8
              // 1/3 = 0.6
              scale = 0.4 + (0.6 * (hp.current / hp.max));
          }

          obj.rotation.set(0,0,0);
          obj.scale.setScalar(scale);
      }}
    />
  );
};


=====================================
FILE: ./src/game/components/HunterChargeRenderer.tsx
=====================================
import { useMemo } from 'react';
import * as THREE from 'three';
import { Tag } from '../core/ecs/types';
import { GAME_THEME } from '../theme';
import { EnemyTypes } from '../config/Identifiers';
import { InstancedActor } from './common/InstancedActor';
import { IdentityComponent } from '../data/IdentityComponent';
import { StateComponent } from '../data/StateComponent';
import { TransformComponent } from '../data/TransformComponent';
import { ENEMY_CONFIG } from '../config/EnemyConfig';

const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0); }`;
const fragmentShader = `
  varying vec2 vUv; uniform vec3 uColor;
  void main() {
    float dist = distance(vUv, vec2(0.5));
    float core = 1.0 - smoothstep(0.2, 0.25, dist);
    float glow = pow(1.0 - smoothstep(0.25, 0.5, dist), 3.0);
    gl_FragColor = vec4(mix(uColor, vec3(1.0), core), max(core, glow));
  }
`;

export const HunterChargeRenderer = () => {
  const geometry = useMemo(() => new THREE.PlaneGeometry(2.0, 2.0), []);
  const material = useMemo(() => new THREE.ShaderMaterial({
    vertexShader, fragmentShader,
    uniforms: { uColor: { value: new THREE.Color(GAME_THEME.bullet.hunter) } },
    transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
  }), []);

  return (
    <InstancedActor
      tag={Tag.ENEMY}
      geometry={geometry}
      material={material}
      maxCount={50}
      filter={(e) => {
          const id = e.getComponent<IdentityComponent>('Identity');
          const state = e.getComponent<StateComponent>('State');
          return id?.variant === EnemyTypes.HUNTER && state?.current === 'CHARGE';
      }}
      updateEntity={(e, obj) => {
          const transform = e.getComponent<TransformComponent>('Transform');
          const state = e.getComponent<StateComponent>('State');
          
          if (transform && state) {
              const maxDuration = ENEMY_CONFIG[EnemyTypes.HUNTER].chargeDuration;
              const remaining = state.timers.action || 0;
              
              // Progress: 0.0 (Start) -> 1.0 (Ready to Fire)
              const progress = 1.0 - (remaining / maxDuration);
              
              // Exponential Growth for "Swell" effect
              const scale = Math.pow(progress, 2) * 1.2;
              
              // Rumble: Jitter intensity increases with progress
              const rumble = progress > 0.8 ? (progress - 0.8) * 0.3 : 0;
              const jitterX = (Math.random() - 0.5) * rumble;
              const jitterY = (Math.random() - 0.5) * rumble;

              const offset = 1.6;
              // +PI/2 because Rotation 0 is Right, but Model points Up.
              const dirX = Math.cos(transform.rotation + Math.PI/2);
              const dirY = Math.sin(transform.rotation + Math.PI/2);
              
              obj.position.x = transform.x + (dirX * offset) + jitterX;
              obj.position.y = transform.y + (dirY * offset) + jitterY;
              obj.position.z = 0.1; 
              
              obj.scale.setScalar(scale);
              obj.rotation.set(0,0,0); // Billboarding
          }
      }}
    />
  );
};


=====================================
FILE: ./src/game/components/GalleryStage.tsx
=====================================
import { useMemo, useRef, useState } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import { OrbitControls, Grid } from '@react-three/drei';
import * as THREE from 'three';
import { useStore } from '@/core/store/useStore';
import { EnemyTypes } from '@/game/config/Identifiers';
import { GAME_THEME } from '@/game/theme';
import { addBarycentricCoordinates, createHunterSpear } from '@/game/utils/GeometryUtils';

// --- SHADERS (Enemy Body - Wireframe Glow) ---
const bodyVertexShader = `
  attribute vec3 barycentric;
  varying vec3 vBarycentric;
  void main() {
    vBarycentric = barycentric;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const bodyFragmentShader = `
  uniform vec3 uColor;
  uniform float uGlow;
  varying vec3 vBarycentric;
  
  float edgeFactor(vec3 bary, float width) {
    vec3 d = fwidth(bary);
    vec3 a3 = smoothstep(vec3(0.0), d * width, bary);
    return min(min(a3.x, a3.y), a3.z);
  }

  void main() {
    float width = 1.5; 
    float edge = edgeFactor(vBarycentric, width);
    float glow = 1.0 - edge;
    glow = pow(glow, 0.4) + uGlow; 
    
    vec3 coreColor = uColor;
    vec3 edgeColor = vec3(1.0); // Always white edges
    vec3 finalColor = mix(coreColor, edgeColor, 1.0 - smoothstep(0.0, 0.1, edge));
    
    // Add inner glow
    finalColor += coreColor * uGlow * 0.5;

    gl_FragColor = vec4(finalColor, 1.0);
  }
`;

// --- SHADERS (Projectile/VFX - Billboard Glow) ---
const vfxVertexShader = `
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const vfxFragmentShader = `
  varying vec2 vUv;
  uniform vec3 uColor;
  
  void main() {
    float dist = distance(vUv, vec2(0.5));
    // Soft glow ball
    float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
    alpha = pow(alpha, 2.0);
    
    // Bright core
    float core = 1.0 - smoothstep(0.0, 0.15, dist);
    
    vec3 color = mix(uColor, vec3(1.0), core);
    
    if (alpha < 0.05) discard;
    gl_FragColor = vec4(color, alpha);
  }
`;

// --- LOCAL VFX COMPONENT ---
const GalleryVFX = ({ type, isAttacking }: { type: string, isAttacking: boolean }) => {
  const particlesRef = useRef<THREE.InstancedMesh>(null);
  const projectileRef = useRef<THREE.Mesh>(null);
  const orbRef = useRef<THREE.Mesh>(null);
  const dummy = useMemo(() => new THREE.Object3D(), []);
  const { camera } = useThree();

  const projectileMat = useMemo(() => new THREE.ShaderMaterial({
      vertexShader: vfxVertexShader,
      fragmentShader: vfxFragmentShader,
      uniforms: { uColor: { value: new THREE.Color(GAME_THEME.bullet.hunter) } },
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      side: THREE.DoubleSide
  }), []);

  useFrame((state) => {
    const time = state.clock.elapsedTime;
    
    // Billboard Logic: Make VFX face camera
    if (orbRef.current) orbRef.current.lookAt(camera.position);
    if (projectileRef.current) projectileRef.current.lookAt(camera.position);

    // --- PARTICLE SYSTEM ---
    if (particlesRef.current) {
        let count = 0;
        
        if (type === EnemyTypes.DRILLER && isAttacking) {
            // DRILLER SPARKS (From Tip Down)
            for(let i=0; i<8; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 0.8;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const speed = (time * 10 + i) % 1.0;
                
                // Tip is at Y=2.0 (approx)
                dummy.position.set(x, 2.0 - (speed * 2.0), z);
                dummy.scale.setScalar(0.2 * (1.0 - speed));
                dummy.rotation.set(Math.random(), Math.random(), Math.random());
                dummy.updateMatrix();
                particlesRef.current.setMatrixAt(i, dummy.matrix);
                count++;
            }
        } 
        else if (type === EnemyTypes.KAMIKAZE && isAttacking) {
            // EXPLOSION (Pulse)
            const cycle = time % 2.0; 
            if (cycle > 1.5) { // Boom phase
                const progress = (cycle - 1.5) * 2.0; // 0..1
                const expansion = progress * 6.0;
                
                for(let i=0; i<30; i++) {
                    const angle = (i / 30) * Math.PI * 2 + (Math.random() * 0.5);
                    const yDir = (Math.random() - 0.5) * 2.0;
                    
                    dummy.position.set(
                        Math.cos(angle) * expansion, 
                        yDir * expansion, 
                        Math.sin(angle) * expansion
                    );
                    dummy.scale.setScalar(0.5 * (1.0 - progress));
                    dummy.updateMatrix();
                    particlesRef.current.setMatrixAt(i, dummy.matrix);
                    count++;
                }
            }
        }
        
        particlesRef.current.count = count;
        particlesRef.current.instanceMatrix.needsUpdate = true;
    }

    // --- HUNTER PROJECTILES ---
    if (type === EnemyTypes.HUNTER) {
        // Timeline: 2s Cycle. 0-1s Charge, 1-1.2s Fire, 1.2-2s Cooldown
        const cycle = time % 2.0; 
        
        // CHARGE ORB (Tip at Y=1.5 approx)
        if (orbRef.current) {
            if (isAttacking && cycle < 1.0) {
                const scale = cycle * 1.5; // Grow
                orbRef.current.visible = true;
                orbRef.current.scale.setScalar(scale);
                orbRef.current.position.set(0, 1.8, 0); // At tip
            } else {
                orbRef.current.visible = false;
            }
        }

        // BULLET (Fires Upward Y+)
        if (projectileRef.current) {
            if (isAttacking && cycle > 1.0 && cycle < 1.5) {
                projectileRef.current.visible = true;
                const travel = (cycle - 1.0) * 15.0; // Fast
                projectileRef.current.position.set(0, 1.8 + travel, 0);
                projectileRef.current.scale.set(1.5, 1.5, 1.5);
            } else {
                projectileRef.current.visible = false;
            }
        }
    }
  });

  return (
    <>
      <instancedMesh ref={particlesRef} args={[new THREE.PlaneGeometry(0.5, 0.5), undefined, 50]}>
        <meshBasicMaterial color="#FFF" transparent opacity={0.8} blending={THREE.AdditiveBlending} side={THREE.DoubleSide} />
      </instancedMesh>
      
      {type === EnemyTypes.HUNTER && (
          <>
            <mesh ref={orbRef}>
                <planeGeometry args={[1.5, 1.5]} />
                <primitive object={projectileMat} attach="material" />
            </mesh>
            <mesh ref={projectileRef}>
                <planeGeometry args={[1.0, 2.0]} />
                <primitive object={projectileMat} attach="material" />
            </mesh>
          </>
      )}
    </>
  );
};

export const GalleryStage = () => {
  const { galleryTarget, galleryAction } = useStore();
  const meshRef = useRef<THREE.Mesh>(null);
  const materialRef = useRef<THREE.ShaderMaterial>(null);

  // --- GEOMETRY ---
  const drillerGeo = useMemo(() => addBarycentricCoordinates(new THREE.ConeGeometry(1.5, 4.0, 4)), []);
  const kamikazeGeo = useMemo(() => addBarycentricCoordinates(new THREE.IcosahedronGeometry(2.5, 1)), []); // Detail 1 for better wireframe
  const hunterGeo = useMemo(() => createHunterSpear().scale(2, 2, 2), []); 

  // --- SHADER MAT ---
  const shaderMaterial = useMemo(() => new THREE.ShaderMaterial({
    vertexShader: bodyVertexShader,
    fragmentShader: bodyFragmentShader,
    uniforms: {
        uColor: { value: new THREE.Color('#FFFFFF') }, // Default white to ensure visibility if prop fails
        uGlow: { value: 0.0 }
    },
    side: THREE.DoubleSide,
    extensions: { derivatives: true },
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false, // Helps with "Hologram" feel
  }), []);

  useFrame((state, delta) => {
    if (!meshRef.current || !materialRef.current) return;

    const time = state.clock.elapsedTime;
    const isAttack = galleryAction === 'ATTACK';

    // 1. BEHAVIOR ANIMATIONS
    if (galleryTarget === EnemyTypes.DRILLER) {
        // Idle: Slow Float | Attack: Fast Spin + Shake
        const speed = isAttack ? 20.0 : 1.0;
        meshRef.current.rotation.y += speed * delta;
        
        if (isAttack) {
            meshRef.current.position.x = (Math.random() - 0.5) * 0.1;
            meshRef.current.position.z = (Math.random() - 0.5) * 0.1;
        } else {
            meshRef.current.position.set(0, 0, 0);
            // Bobbing
            meshRef.current.position.y = Math.sin(time) * 0.2;
        }
    } 
    else if (galleryTarget === EnemyTypes.KAMIKAZE) {
        // Idle: Tumble | Attack: Violent Shake + Expansion Pulse
        const tumbleSpeed = isAttack ? 5.0 : 0.5;
        meshRef.current.rotation.x += tumbleSpeed * delta;
        meshRef.current.rotation.z += tumbleSpeed * delta;

        if (isAttack) {
            const cycle = time % 2.0; // 2s cycle
            // Shake (0 - 1.5s)
            if (cycle < 1.5) {
                const shake = (cycle / 1.5) * 0.5; // Shake gets harder
                meshRef.current.position.x = (Math.random() - 0.5) * shake;
                meshRef.current.position.y = (Math.random() - 0.5) * shake;
                meshRef.current.scale.setScalar(1.0 + (shake * 0.5)); // Swell
            } 
            // Boom (1.5 - 2.0s) -> Shrink/Hide
            else {
                meshRef.current.scale.setScalar(0.01);
            }
        } else {
            meshRef.current.position.set(0,0,0);
            meshRef.current.scale.setScalar(1.0);
        }
    } 
    else if (galleryTarget === EnemyTypes.HUNTER) {
        // Idle: Spin Y | Attack: Face Front, Charge, Recoil
        if (isAttack) {
            meshRef.current.rotation.set(0,0,0); // Reset
            const cycle = time % 2.0;
            
            // Recoil Effect at 1.0s (Fire)
            if (cycle > 1.0 && cycle < 1.3) {
                meshRef.current.position.y = -1.0; // Kick down (since firing up)
            } else {
                meshRef.current.position.y = THREE.MathUtils.lerp(meshRef.current.position.y, 0, delta * 5);
            }
        } else {
            meshRef.current.rotation.y += delta;
            meshRef.current.position.y = Math.sin(time) * 0.3;
        }
    }

    // 2. COLOR UPDATES
    let baseColor = new THREE.Color();
    let glow = 0.2;

    if (galleryTarget === EnemyTypes.DRILLER) {
        baseColor.set(GAME_THEME.enemy.muncher);
        if (isAttack) glow = 0.8;
    } 
    else if (galleryTarget === EnemyTypes.KAMIKAZE) {
        baseColor.set(GAME_THEME.enemy.kamikaze);
        if (isAttack) {
            const flash = Math.sin(time * 30) > 0;
            if (flash) baseColor.set('#FFFFFF'); // Strobe
            glow = 1.0;
        }
    } 
    else if (galleryTarget === EnemyTypes.HUNTER) {
        baseColor.set(GAME_THEME.enemy.hunter);
        if (isAttack) {
            // Charge up color
            const cycle = time % 2.0;
            if (cycle < 1.0) glow = cycle; 
        }
    }

    materialRef.current.uniforms.uColor.value.copy(baseColor);
    materialRef.current.uniforms.uGlow.value = glow;
  });

  const activeGeo = useMemo(() => {
      switch(galleryTarget) {
          case EnemyTypes.DRILLER: return drillerGeo;
          case EnemyTypes.KAMIKAZE: return kamikazeGeo;
          case EnemyTypes.HUNTER: return hunterGeo;
          default: return drillerGeo;
      }
  }, [galleryTarget, drillerGeo, kamikazeGeo, hunterGeo]);

  return (
    <>
        <OrbitControls makeDefault minDistance={5} maxDistance={20} />
        
        {/* FLOOR GRID */}
        <Grid 
            position={[0, -4, 0]} 
            args={[20, 20]} 
            sectionColor="#00F0FF" 
            cellColor="#001a33" 
            fadeDistance={20}
        />

        {/* ENEMY MODEL */}
        <mesh ref={meshRef} geometry={activeGeo} material={shaderMaterial} />
        
        {/* VFX LAYER */}
        <GalleryVFX type={galleryTarget} isAttacking={galleryAction === 'ATTACK'} />
    </>
  );
};


=====================================
FILE: ./src/game/components/DaemonRenderer.tsx
=====================================
import { useMemo, useRef } from 'react';
import * as THREE from 'three';
import { Tag } from '../core/ecs/types';
import { EnemyTypes } from '../config/Identifiers';
import { InstancedActor } from './common/InstancedActor';
import { IdentityComponent } from '../data/IdentityComponent';
import { StateComponent } from '../data/StateComponent';

export const DaemonRenderer = () => {
  const geometry = useMemo(() => new THREE.OctahedronGeometry(0.6, 0), []);
  const material = useMemo(() => new THREE.MeshBasicMaterial({ 
      color: '#00F0FF', 
      wireframe: true,
      transparent: true,
      opacity: 0.8
  }), []);
  
  const brokenColor = useMemo(() => new THREE.Color('#FF003C'), []);
  const baseColor = useMemo(() => new THREE.Color('#00F0FF'), []);

  return (
    <InstancedActor 
      tag={Tag.PLAYER} 
      geometry={geometry} 
      material={material} 
      maxCount={5}
      filter={(e) => e.getComponent<IdentityComponent>('Identity')?.variant === EnemyTypes.DAEMON}
      updateEntity={(e, obj, color, delta) => {
          const state = e.getComponent<StateComponent>('State');
          
          // Reset color
          color.copy(baseColor);

          if (state) {
              // --- SPIN PHYSICS ---
              if (typeof state.data.visualSpin !== 'number') state.data.visualSpin = 0;
              let targetSpeed = 1.0;

              if (state.current === 'CHARGING') targetSpeed = 15.0;
              else if (state.current === 'READY') targetSpeed = 3.0;
              else if (state.current === 'FIRE') targetSpeed = 20.0;
              else if (state.current === 'COOLDOWN') targetSpeed = -5.0;
              else if (state.current === 'BROKEN') {
                  targetSpeed = 30.0; 
                  color.copy(brokenColor);
                  // Shake effect
                  obj.position.x += (Math.random() - 0.5) * 0.2;
                  obj.position.y += (Math.random() - 0.5) * 0.2;
              }

              if (typeof state.data.currentSpinSpeed !== 'number') state.data.currentSpinSpeed = 1.0;
              
              // Smoothly interpolate spin speed (Inertia)
              state.data.currentSpinSpeed = THREE.MathUtils.lerp(state.data.currentSpinSpeed, targetSpeed, delta * 5.0);
              state.data.visualSpin += state.data.currentSpinSpeed * delta;
              obj.rotation.y = state.data.visualSpin;

              // --- SCALE / ANIMATION LOGIC ---
              
              if (state.current === 'FIRE') {
                  // Instant Impact Squish
                  obj.scale.set(1.2, 0.5, 1.2);
              }
              else if (state.current === 'COOLDOWN') {
                  // Recover: Squish (1.2, 0.5, 1.2) -> Normal (1.0)
                  const maxTime = 0.5;
                  const remaining = Math.max(0, state.timers.action);
                  const progress = 1.0 - (remaining / maxTime); 
                  
                  if (progress < 0.2) {
                      obj.scale.set(1.2, 0.5, 1.2);
                  } else {
                      const recoverT = (progress - 0.2) / 0.8;
                      const elastic = 1 + Math.sin(recoverT * Math.PI * 3) * Math.pow(1 - recoverT, 2) * 0.2;
                      
                      const sY = THREE.MathUtils.lerp(0.5, 1.0, recoverT) * elastic;
                      const sXZ = THREE.MathUtils.lerp(1.2, 1.0, recoverT);
                      obj.scale.set(sXZ, sY, sXZ);
                  }
              } 
              else if (state.current === 'CHARGING') {
                  // Grow based on SHIELD HP (0% -> 100%)
                  // This ensures it starts exactly at 1.0 (where Cooldown left off)
                  // and grows to 1.6 (max size)
                  const maxShield = state.data.maxShield || 10;
                  const currentShield = state.data.shieldHP || 0;
                  const ratio = Math.min(1.0, Math.max(0, currentShield / maxShield));
                  
                  // Lerp 1.0 -> 1.6
                  const scale = 1.0 + (ratio * 0.6); 
                  obj.scale.setScalar(scale);
              }
              else if (state.current === 'READY') {
                  // Pulse at max size (1.6 base)
                  const pulse = 1.6 + Math.sin(performance.now() * 0.005) * 0.05;
                  obj.scale.setScalar(pulse);
              }
              else if (state.current === 'BROKEN') {
                  // Shrivel / Glitch
                  const twitch = 0.7 + (Math.random() * 0.1);
                  obj.scale.setScalar(twitch);
              }
              else {
                  obj.scale.setScalar(1.0);
              }
          }
      }}
    />
  );
};


=====================================
FILE: ./src/game/components/DaemonBulletRenderer.tsx
=====================================
import { useMemo } from 'react';
import * as THREE from 'three';
import { Tag } from '../core/ecs/types';
import { InstancedActor } from './common/InstancedActor';
import { IdentityComponent } from '../data/IdentityComponent';

const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0); }`;
const fragmentShader = `
  varying vec2 vUv; uniform vec3 uColor;
  void main() {
    float dist = distance(vUv, vec2(0.5));
    float core = 1.0 - smoothstep(0.2, 0.25, dist);
    float glow = pow(1.0 - smoothstep(0.25, 0.5, dist), 3.0);
    gl_FragColor = vec4(mix(uColor, vec3(1.0), core), max(core, glow));
  }
`;

export const DaemonBulletRenderer = () => {
  // UPDATED: Scaled down by 20% (5.0 -> 4.0)
  const geometry = useMemo(() => new THREE.PlaneGeometry(4.0, 4.0), []); 
  const material = useMemo(() => new THREE.ShaderMaterial({
    vertexShader, fragmentShader,
    uniforms: { uColor: { value: new THREE.Color('#00F0FF') } }, // CYAN
    transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
  }), []);

  return (
    <InstancedActor 
      tag={Tag.BULLET} 
      geometry={geometry} 
      material={material} 
      maxCount={50}
      filter={(e) => {
          if (e.hasTag(Tag.ENEMY)) return false;
          const id = e.getComponent<IdentityComponent>('Identity');
          return id?.variant === 'DAEMON_SHOT';
      }}
      updateEntity={(e, obj) => {
          obj.rotation.set(0,0,0);
          obj.scale.setScalar(1.0);
      }}
    />
  );
};


=====================================
FILE: ./src/game/components/common/InstancedActor.tsx
=====================================
import { useRef, useLayoutEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { ActiveEngine } from '../GameDirector';
import { TransformComponent } from '../data/TransformComponent';
import { IdentityComponent } from '../data/IdentityComponent';
import { Entity } from '@/game/core/ecs/Entity';

const tempObj = new THREE.Object3D();
const tempColor = new THREE.Color();

interface InstancedActorProps {
  tag: string;
  geometry: THREE.BufferGeometry;
  material: THREE.Material;
  maxCount: number;
  updateEntity?: (entity: Entity, obj: THREE.Object3D, color: THREE.Color, delta: number) => void;
  filter?: (entity: Entity) => boolean;
  baseColor?: string;
  colorSource?: 'identity' | 'base'; 
}

export const InstancedActor = ({ 
  tag, 
  geometry, 
  material, 
  maxCount, 
  updateEntity, 
  filter, 
  baseColor = '#FFFFFF',
  colorSource = 'identity' 
}: InstancedActorProps) => {
  const meshRef = useRef<THREE.InstancedMesh>(null);

  // FIX: Initialize the color buffer!
  useLayoutEffect(() => {
    if (meshRef.current) {
        meshRef.current.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxCount * 3), 3);
    }
  }, [maxCount]);

  useFrame((state, delta) => {
    if (!meshRef.current || !ActiveEngine) return;

    const entities = ActiveEngine.registry.getByTag(tag);
    let count = 0;

    for (const entity of entities) {
      if (count >= maxCount) break;
      if (filter && !filter(entity)) continue;

      const transform = entity.getComponent<TransformComponent>('Transform');
      if (!transform) continue;

      // 1. Base Transform
      tempObj.position.set(transform.x, transform.y, 0);
      tempObj.rotation.set(0, 0, transform.rotation);
      tempObj.scale.set(transform.scale, transform.scale, 1);

      // 2. Color Logic
      const identity = entity.getComponent<IdentityComponent>('Identity');
      
      if (colorSource === 'identity' && identity) {
          tempColor.set(identity.variant); 
      } else {
          tempColor.set(baseColor); 
      }

      // 3. Custom Logic
      if (updateEntity) {
        updateEntity(entity, tempObj, tempColor, delta);
      }

      // 4. Apply
      tempObj.updateMatrix();
      meshRef.current.setMatrixAt(count, tempObj.matrix);
      
      // Safe to set color now because we initialized it in useLayoutEffect
      if (meshRef.current.instanceColor) {
        meshRef.current.setColorAt(count, tempColor);
      }
      
      count++;
    }

    meshRef.current.count = count;
    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor) meshRef.current.instanceColor.needsUpdate = true;
  });

  return (
    <instancedMesh 
      ref={meshRef} 
      args={[geometry, material, maxCount]} 
      frustumCulled={false}
    />
  );
};


=====================================
FILE: ./src/game/components/EnemyRenderer.tsx
=====================================
import { useMemo } from 'react';
import * as THREE from 'three';
import { Tag } from '../core/ecs/types';
import { GAME_THEME } from '../theme';
import { EnemyTypes } from '../config/Identifiers';
import { InstancedActor } from './common/InstancedActor';
import { addBarycentricCoordinates, createHunterSpear } from '../utils/GeometryUtils';
import { IdentityComponent } from '../data/IdentityComponent';
import { StateComponent } from '../data/StateComponent';
import { MODEL_CONFIG } from '../config/ModelConfig';

const vertexShader = `
  #ifndef USE_INSTANCING_COLOR
  attribute vec3 instanceColor;
  #endif
  attribute vec3 barycentric;
  varying vec3 vColor;
  varying vec3 vBarycentric;
  void main() {
    vColor = instanceColor;
    vBarycentric = barycentric;
    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
  }
`;

const fragmentShader = `
  varying vec3 vColor;
  varying vec3 vBarycentric;
  float edgeFactor(vec3 bary, float width) {
    vec3 d = fwidth(bary);
    vec3 a3 = smoothstep(vec3(0.0), d * width, bary);
    return min(min(a3.x, a3.y), a3.z);
  }
  void main() {
    float width = 1.5; 
    float edge = edgeFactor(vBarycentric, width);
    float glow = pow(1.0 - edge, 0.4); 
    vec3 coreColor = vColor;
    vec3 edgeColor = mix(vColor, vec3(1.0), 0.8);
    gl_FragColor = vec4(mix(coreColor, edgeColor, glow), 1.0);
  }
`;

export const EnemyRenderer = () => {
  const drillerGeo = useMemo(() => {
      const { radius, height, segments } = MODEL_CONFIG.DRILLER;
      return addBarycentricCoordinates(new THREE.ConeGeometry(radius, height, segments));
  }, []);

  // RESTORED: IcosahedronGeometry (Detail 0)
  const kamikazeGeo = useMemo(() => {
      return addBarycentricCoordinates(new THREE.IcosahedronGeometry(0.6, 0));
  }, []);

  const hunterGeo = useMemo(() => createHunterSpear(), []);

  const material = useMemo(() => new THREE.ShaderMaterial({
    vertexShader, fragmentShader, uniforms: {}, vertexColors: true,
    extensions: { derivatives: true }, side: THREE.DoubleSide,
  }), []);

  const chargeColor = useMemo(() => new THREE.Color(GAME_THEME.enemy.charge), []);

  const applySpawnEffect = (obj: THREE.Object3D, state?: StateComponent) => {
      if (state && state.current === 'SPAWN') {
          const progress = 1.0 - (state.timers.spawn / 1.5);
          const eased = Math.pow(progress, 2); 
          obj.scale.setScalar(eased);
          obj.position.x += (Math.random() - 0.5) * 0.1 * (1-progress);
      }
  };

  return (
    <>
      <InstancedActor 
        tag={Tag.ENEMY}
        geometry={drillerGeo}
        material={material}
        maxCount={500}
        baseColor={GAME_THEME.enemy.muncher}
        colorSource="base" 
        filter={e => e.getComponent<IdentityComponent>('Identity')?.variant === EnemyTypes.DRILLER}
        updateEntity={(e, obj, color, delta) => {
            const state = e.getComponent<StateComponent>('State');
            const speed = (state && state.current === 'DRILLING') ? 20.0 : 5.0;
            obj.position.z = 5.0;
            obj.rotateY(performance.now() * 0.001 * speed); 
            
            // FIX: Ensure base scale is 1.0 before applying spawn effect
            obj.scale.setScalar(1.0); 
            applySpawnEffect(obj, state);
        }}
      />

      <InstancedActor 
        tag={Tag.ENEMY}
        geometry={kamikazeGeo}
        material={material}
        maxCount={200}
        baseColor={GAME_THEME.enemy.kamikaze}
        colorSource="base"
        filter={e => e.getComponent<IdentityComponent>('Identity')?.variant === EnemyTypes.KAMIKAZE}
        updateEntity={(e, obj, color, delta) => {
            const state = e.getComponent<StateComponent>('State');
            const time = performance.now() * 0.001;
            obj.position.z = 5.0;
            obj.rotation.set(time * 2, time, 0); 
            
            // FIX: Ensure base scale is 1.0
            obj.scale.setScalar(1.0);
            applySpawnEffect(obj, state);
        }}
      />

      <InstancedActor 
        tag={Tag.ENEMY}
        geometry={hunterGeo}
        material={material}
        maxCount={100}
        baseColor={GAME_THEME.enemy.hunter}
        colorSource="base"
        filter={e => e.getComponent<IdentityComponent>('Identity')?.variant === EnemyTypes.HUNTER}
        updateEntity={(e, obj, color, delta) => {
            const state = e.getComponent<StateComponent>('State');
            const time = performance.now() * 0.001;
            if (state && state.current === 'CHARGE') {
                const alpha = (Math.sin(time * 20) + 1) / 2;
                color.lerp(chargeColor, alpha);
            }
            const spin = state?.data?.spinAngle || 0;
            obj.position.z = 5.0;
            obj.rotation.set(0, spin, 0);
            
            // FIX: Ensure base scale is 1.0
            obj.scale.setScalar(1.0);
            applySpawnEffect(obj, state);
        }}
      />
    </>
  );
};


=====================================
FILE: ./src/game/components/GameDirector.tsx
=====================================
import { useFrame, useThree } from '@react-three/fiber';
import { useEffect, useRef } from 'react';
import { GameBootstrapper } from '../core/GameBootstrapper';
import { GameEngineCore } from '../core/GameEngine';
import { ServiceLocator } from '../core/ServiceLocator';
import { InputSystem } from '../systems/InputSystem';
import { PanelRegistry } from '../systems/PanelRegistrySystem';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';

export let ActiveEngine: GameEngineCore | null = null;

export const GameDirector = () => {
  const { viewport, size } = useThree();
  const engineRef = useRef<GameEngineCore | null>(null);

  useEffect(() => {
    const engine = GameBootstrapper();
    engineRef.current = engine;
    ActiveEngine = engine;

    engine.updateViewport(viewport.width, viewport.height, size.width, size.height);
    
    try {
        const input = ServiceLocator.getSystem<InputSystem>('InputSystem');
        input.updateBounds(viewport.width, viewport.height);
    } catch {}
    
    const refreshInterval = setInterval(() => {
        PanelRegistry.refreshAll();
    }, 500);

    let initialPolls = 0;
    const fastPoll = setInterval(() => {
        PanelRegistry.refreshAll();
        initialPolls++;
        if (initialPolls > 20) clearInterval(fastPoll); 
    }, 100);

    return () => {
      clearInterval(refreshInterval);
      clearInterval(fastPoll);
      engine.teardown();
      engineRef.current = null;
      ActiveEngine = null;
    };
  }, []); 

  useEffect(() => {
    if (engineRef.current) {
      engineRef.current.updateViewport(viewport.width, viewport.height, size.width, size.height);
      try {
        const input = ServiceLocator.getSystem<InputSystem>('InputSystem');
        input.updateBounds(viewport.width, viewport.height);
      } catch {}
    }
  }, [viewport, size]);

  useFrame((state, delta) => {
    if (engineRef.current) {
      try {
          const input = ServiceLocator.getSystem<InputSystem>('InputSystem');
          const x = (state.pointer.x * viewport.width) / 2;
          const y = (state.pointer.y * viewport.height) / 2;
          input.updateCursor(x, y);

          // Render Loop
          engineRef.current.update(delta, state.clock.elapsedTime);
          
      } catch (e: any) {
          console.error("Game Loop Critical Failure:", e);
          GameEventBus.emit(GameEvents.LOG_DEBUG, { 
              msg: `CRITICAL LOOP FAIL: ${e.message}`, 
              source: 'GameDirector' 
          });
      }
    }
  });

  return null;
};


=====================================
FILE: ./src/game/components/index.ts
=====================================
export * from './BulletRenderer';
export * from './EnemyBulletRenderer';
export * from './EnemyRenderer';
export * from './GameDirector';
export * from './HunterChargeRenderer';
export * from './ParticleRenderer';
export * from './PlayerAvatar';
export * from './ProjectileTrails';
export * from './ScreenShaker';
export * from './GalleryStage';


=====================================
FILE: ./src/game/components/ScreenShaker.tsx
=====================================
import { useFrame, useThree } from '@react-three/fiber';
import { ServiceLocator } from '../core/ServiceLocator';
import { ShakeSystem } from '../systems/ShakeSystem';

export const ScreenShaker = () => {
  const { camera } = useThree();
  
  useFrame(() => {
    try {
        const sys = ServiceLocator.getSystem<ShakeSystem>('ShakeSystem');
        const { x, y, r } = sys.currentOffset;

        // Apply shake offset
        // We use the raw values calculated by ShakeSystem.
        camera.position.x = x;
        camera.position.y = y;
        camera.rotation.z = r;
        
    } catch {
        // System not ready yet
    }
  });

  return null;
};


=====================================
FILE: ./src/game/components/data/HealthComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class HealthComponent extends Component {
  readonly _type = 'Health';

  public current: number;

  constructor(
    public max: number,
    public invincibilityTime: number = 0
  ) {
    super();
    this.current = max;
  }
}


=====================================
FILE: ./src/game/components/data/MotionComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class MotionComponent extends Component {
  readonly _type = 'Motion';

  constructor(
    public vx: number = 0,
    public vy: number = 0,
    public friction: number = 0, // 0 = no friction, 1 = stop instantly
    public angularVelocity: number = 0
  ) {
    super();
  }
}


=====================================
FILE: ./src/game/components/data/IdentityComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

// This holds specific game logic identifiers (MUNCHER, HUNTER)
export class IdentityComponent extends Component {
  readonly _type = 'Identity';

  constructor(
    public variant: string // e.g. 'muncher', 'hunter', 'boss'
  ) {
    super();
  }
}


=====================================
FILE: ./src/game/components/data/StateComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class StateComponent extends Component {
  readonly _type = 'State';

  constructor(
    public current: string = 'IDLE',
    public timers: Record<string, number> = {},
    public data: Record<string, any> = {}
  ) {
    super();
  }

  public set(state: string) {
    this.current = state;
  }
}


=====================================
FILE: ./src/game/components/data/ColliderComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class ColliderComponent extends Component {
  readonly _type = 'Collider';

  constructor(
    public radius: number,
    public layer: number,
    public mask: number
  ) {
    super();
  }
}


=====================================
FILE: ./src/game/components/data/LifetimeComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

// Used for bullets and particles that die after N seconds
export class LifetimeComponent extends Component {
  readonly _type = 'Lifetime';

  constructor(
    public remaining: number, // Seconds
    public total: number
  ) {
    super();
  }
}


=====================================
FILE: ./src/game/components/data/OrbitalComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class OrbitalComponent extends Component {
  readonly _type = 'Orbital';

  constructor(
    public parentId: number | null = null, // Entity ID to orbit (Player)
    public radius: number = 3.0,
    public speed: number = 2.0,
    public angle: number = 0,
    public active: boolean = true // Can pause orbiting to aim
  ) {
    super();
  }
}


=====================================
FILE: ./src/game/components/data/TransformComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class TransformComponent extends Component {
  readonly _type = 'Transform';

  constructor(
    public x: number = 0,
    public y: number = 0,
    public rotation: number = 0,
    public scale: number = 1
  ) {
    super();
  }
}


=====================================
FILE: ./src/game/components/data/CombatComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class CombatComponent extends Component {
  readonly _type = 'Combat';

  constructor(
    public damage: number,
    public cooldown: number = 0, // Time until next attack
    public range: number = 0
  ) {
    super();
  }
}


=====================================
FILE: ./src/game/components/data/TargetComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export type TargetType = 'PLAYER' | 'PANEL' | 'LOCATION';

export class TargetComponent extends Component {
  readonly _type = 'Target';

  constructor(
    public id: string | null = null, // Entity ID or Panel ID
    public type: TargetType = 'PLAYER',
    public x: number = 0, // Last known position (for memory)
    public y: number = 0,
    public locked: boolean = false // If true, won't switch targets easily
  ) {
    super();
  }
}


=====================================
FILE: ./src/game/components/EffectsLayer.tsx
=====================================
import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';

export const EffectsLayer = () => {
  return (
    <EffectComposer disableNormalPass>
      {/* 
        BLOOM: Adds the "Neon" glow.
        luminanceThreshold: Only bright colors glow.
        intensity: How strong the glow is.
      */}
      <Bloom 
        luminanceThreshold={0.2} 
        mipmapBlur 
        intensity={1.5} 
        radius={0.4} 
      />
      
      {/* VIGNETTE: Darkens corners for focus */}
      <Vignette eskil={false} offset={0.1} darkness={0.5} />
    </EffectComposer>
  );
};


=====================================
FILE: ./src/game/components/ProjectileTrails.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { ActiveEngine } from './GameDirector';
import { Tag } from '../core/ecs/types';
import { TransformComponent } from '../components/data/TransformComponent';
import { MotionComponent } from '../components/data/MotionComponent';
import { LifetimeComponent } from '../components/data/LifetimeComponent';
import { GAME_THEME } from '../theme';

const MAX_TRAILS = 500; 

export const ProjectileTrails = () => {
  const meshRef = useRef<THREE.InstancedMesh>(null);
  const geometry = useMemo(() => {
      const geo = new THREE.PlaneGeometry(1, 1);
      geo.translate(0, 0.5, 0); 
      return geo;
  }, []);

  const shaderMaterial = useMemo(() => new THREE.ShaderMaterial({
    vertexShader: `
      #ifndef USE_INSTANCING_COLOR
      attribute vec3 instanceColor;
      #endif
      varying vec2 vUv;
      varying vec3 vColor;
      void main() {
        vUv = uv;
        vColor = instanceColor; 
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      varying vec2 vUv;
      varying vec3 vColor;
      void main() {
        float distFromCenter = abs(vUv.x - 0.5) * 2.0;
        float beam = 1.0 - pow(distFromCenter, 3.0);
        float tailDecay = 1.0 - vUv.y;
        tailDecay = pow(tailDecay, 2.0);
        float headFade = smoothstep(0.0, 0.1, vUv.y);
        float alpha = beam * tailDecay * headFade;
        vec3 finalColor = mix(vColor, vec3(1.0), beam * 0.8); 
        if (alpha < 0.01) discard;
        gl_FragColor = vec4(finalColor, alpha * 0.8);
      }
    `,
    uniforms: {}, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
  }), []);

  useFrame(() => {
    if (!meshRef.current || !ActiveEngine) return;
    const tempObj = new THREE.Object3D();
    const tempColor = new THREE.Color();
    let count = 0;
    const bullets = ActiveEngine.registry.getByTag(Tag.BULLET);

    for (const b of bullets) {
        if (count >= MAX_TRAILS) break;
        const t = b.getComponent<TransformComponent>('Transform');
        const m = b.getComponent<MotionComponent>('Motion');
        const life = b.getComponent<LifetimeComponent>('Lifetime');
        if (!t || !m || !life) continue;
        const isEnemy = b.hasTag(Tag.ENEMY);
        const trailWidth = isEnemy ? 1.0 : 0.4;
        const speed = Math.sqrt(m.vx * m.vx + m.vy * m.vy);
        const age = life.total - life.remaining;
        const maxLen = isEnemy ? 4.0 : 3.0; 
        const targetLength = Math.min(speed * 0.12, maxLen);
        const currentLength = Math.min(targetLength, age * 10.0); 
        tempObj.position.set(t.x, t.y, -0.2); 
        tempObj.rotation.z = t.rotation + (Math.PI / 2);
        tempObj.scale.set(trailWidth, currentLength, 1);
        const colorHex = isEnemy ? GAME_THEME.bullet.hunter : GAME_THEME.bullet.trail;
        tempColor.set(colorHex);
        tempObj.updateMatrix();
        meshRef.current.setMatrixAt(count, tempObj.matrix);
        meshRef.current.setColorAt(count, tempColor);
        count++;
    }
    meshRef.current.count = count;
    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor) meshRef.current.instanceColor.needsUpdate = true;
  });

  return (
    <instancedMesh ref={meshRef} args={[geometry, shaderMaterial, MAX_TRAILS]} renderOrder={-1} />
  );
};


=====================================
FILE: ./src/game/hooks/usePanelRegistry.ts
=====================================
import { useEffect, useRef } from 'react';
import { useGameStore } from '../store/useGameStore';
import { PanelRegistry } from '../systems/PanelRegistrySystem';

export const usePanelRegistry = (id: string) => {
  const elementRef = useRef<HTMLDivElement>(null);
  
  const registerPanel = useGameStore((state) => state.registerPanel);
  const unregisterPanel = useGameStore((state) => state.unregisterPanel);

  useEffect(() => {
    const el = elementRef.current;
    if (!el) return;

    // 1. Register Logic (Health/Store)
    registerPanel(id, el);

    // 2. Register Spatial (Singleton)
    // This works immediately, even if game hasn't started
    PanelRegistry.register(id, el);

    // 3. Resize Observer
    const observer = new ResizeObserver(() => {
        PanelRegistry.refreshSingle(id);
    });
    observer.observe(el);

    return () => {
      observer.disconnect();
      unregisterPanel(id);
      PanelRegistry.unregister(id);
    };
  }, [id, registerPanel, unregisterPanel]);

  return elementRef;
};


=====================================
FILE: ./src/game/hooks/useTransientRef.ts
=====================================
import { useEffect, useRef } from 'react';
import { useGameStore } from '../store/useGameStore';

/**
 * Registers a DOM element to the store so the GameLoop can write to it directly.
 * Useful for Score, Health, and Timers to avoid React Re-renders.
 */
export const useTransientRef = (id: string, type: 'text' | 'width' | 'css-var') => {
  // We use a generic HTMLSpanElement, but it works for divs too
  const ref = useRef<any>(null);
  const register = useGameStore(s => s.registerTransientElement);
  const unregister = useGameStore(s => s.unregisterTransientElement);

  useEffect(() => {
    if (ref.current) {
      register(id, ref.current, type);
    }
    return () => unregister(id);
  }, [id, type, register, unregister]);

  return ref;
};


=====================================
FILE: ./src/game/hooks/useHeartbeat.ts
=====================================
import { useEffect } from 'react';
import { useAnimation, AnimationControls } from 'framer-motion';
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';

export const useHeartbeat = (): AnimationControls => {
  const controls = useAnimation();

  useEffect(() => {
    const unsub = GameEventBus.subscribe(GameEvents.HEARTBEAT, (payload) => {
        // We trigger the 'heartbeat' variant defined in the component.
        // We pass the urgency as a 'custom' prop to the variant if needed.
        controls.start("heartbeat");
    });

    return () => unsub();
  }, [controls]);

  return controls;
};


=====================================
FILE: ./src/game/theme.ts
=====================================
export const GAME_THEME = {
  turret: {
    base: '#78F654',
    glow: '#C2FE9A',
    repair: '#00F0FF',
  },
  bullet: {
    plasma: '#FFFFFF',
    trail: '#78F654',
    hunter: '#F7D277', // Specific color for Hunter shots
  },
  enemy: {
    muncher: '#9E4EA5',
    kamikaze: '#FF003C',
    hunter: '#F7D277',
    charge: '#FFFFFF',  // Telegraph flash
  },
  hud: {
    text: '#78F654',
    warning: '#FF003C',
  },
  vfx: {
    spark: '#FFFFFF',
    damage: '#FF003C',
    heal: '#00F0FF',
    clash: '#F7D277',
  }
};


=====================================
FILE: ./src/game/events/GameEvents.ts
=====================================
export enum GameEvents {
  PLAYER_FIRED = 'PLAYER_FIRED',
  PLAYER_HIT = 'PLAYER_HIT',
  ENEMY_SPAWNED = 'ENEMY_SPAWNED',
  ENEMY_DAMAGED = 'ENEMY_DAMAGED',
  ENEMY_DESTROYED = 'ENEMY_DESTROYED',
  PROJECTILE_CLASH = 'PROJECTILE_CLASH',
  PANEL_DAMAGED = 'PANEL_DAMAGED',
  PANEL_HEALED = 'PANEL_HEALED',
  PANEL_DESTROYED = 'PANEL_DESTROYED',
  GAME_START = 'GAME_START',
  GAME_OVER = 'GAME_OVER',
  THREAT_LEVEL_UP = 'THREAT_LEVEL_UP',
  UPGRADE_SELECTED = 'UPGRADE_SELECTED',
  ZEN_MODE_ENABLED = 'ZEN_MODE_ENABLED',
  DEBUG_SPAWN = 'DEBUG_SPAWN',
  TRAUMA_ADDED = 'TRAUMA_ADDED',
  SCENE_READY = 'SCENE_READY',
  SPAWN_FX = 'SPAWN_FX',
  SPAWN_DAEMON = 'SPAWN_DAEMON',
  HEARTBEAT = 'HEARTBEAT',
  
  // NEW: Debug Logging Channel
  LOG_DEBUG = 'LOG_DEBUG'
}

export type FXVariant = 
  | 'EXPLOSION_PURPLE' 
  | 'EXPLOSION_YELLOW' 
  | 'EXPLOSION_RED'
  | 'IMPACT_WHITE'
  | 'IMPACT_RED'
  | 'IMPACT_YELLOW'
  | 'DRILL_SPARKS'
  | 'HUNTER_RECOIL'
  | 'CLASH_YELLOW';

export interface GameEventPayloads {
  [GameEvents.PLAYER_FIRED]: { x: number; y: number };
  [GameEvents.PLAYER_HIT]: { damage: number };
  [GameEvents.ENEMY_SPAWNED]: { type: string; id: number };
  [GameEvents.ENEMY_DAMAGED]: { id: number; damage: number; type: string };
  [GameEvents.ENEMY_DESTROYED]: { id: number; type: string; x: number; y: number };
  [GameEvents.PROJECTILE_CLASH]: { x: number; y: number };
  [GameEvents.PANEL_DAMAGED]: { id: string; amount: number; currentHealth: number };
  [GameEvents.PANEL_HEALED]: { id: string; amount: number };
  [GameEvents.PANEL_DESTROYED]: { id: string };
  [GameEvents.GAME_START]: null;
  [GameEvents.GAME_OVER]: { score: number };
  [GameEvents.THREAT_LEVEL_UP]: { level: number };
  [GameEvents.UPGRADE_SELECTED]: { option: string };
  [GameEvents.ZEN_MODE_ENABLED]: null;
  [GameEvents.DEBUG_SPAWN]: { type: string; count: number };
  [GameEvents.TRAUMA_ADDED]: { amount: number };
  [GameEvents.SCENE_READY]: null;
  [GameEvents.SPAWN_FX]: { type: FXVariant; x: number; y: number; angle?: number; count?: number; };
  [GameEvents.SPAWN_DAEMON]: null;
  [GameEvents.HEARTBEAT]: { urgency: number };
  
  // NEW
  [GameEvents.LOG_DEBUG]: { msg: string; source?: string };
}


=====================================
FILE: ./src/game/events/GameEventBus.ts
=====================================
import { GameEvents, GameEventPayloads } from './GameEvents';

type Handler<T extends GameEvents> = (payload: GameEventPayloads[T]) => void;

class GameEventBusController {
  // Use a mapped type for strict safety
  private listeners: { [K in GameEvents]?: Handler<K>[] } = {};
  
  private history: { event: string; payload: any; timestamp: number }[] = [];
  private readonly MAX_HISTORY = 50;

  public subscribe<T extends GameEvents>(event: T, handler: Handler<T>): () => void {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    // Force cast to generic array to satisfy TS compiler index signature
    (this.listeners[event] as Handler<T>[]).push(handler);

    return () => {
      if (!this.listeners[event]) return;
      this.listeners[event] = (this.listeners[event] as Handler<T>[]).filter(h => h !== handler) as any;
    };
  }

  public emit<T extends GameEvents>(event: T, payload: GameEventPayloads[T]): void {
    // 1. Log History (Debug only)
    if (process.env.NODE_ENV === 'development') {
        this.history.push({ event, payload, timestamp: Date.now() });
        if (this.history.length > this.MAX_HISTORY) this.history.shift();
    }

    // 2. Dispatch
    const handlers = this.listeners[event];
    if (handlers) {
        handlers.forEach(handler => handler(payload));
    }
  }

  public clear(): void {
    this.listeners = {};
    this.history = [];
  }
}

export const GameEventBus = new GameEventBusController();


=====================================
FILE: ./src/game/systems/CollisionSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IPhysicsSystem, ICombatSystem } from '../core/interfaces';
import { EntityRegistry } from '../core/ecs/EntityRegistry';
import { TransformComponent } from '../components/data/TransformComponent';
import { StateComponent } from '../components/data/StateComponent';
import { ColliderComponent } from '../components/data/ColliderComponent';
import { EntityID } from '../core/ecs/types';

export class CollisionSystem implements IGameSystem {
  private physicsSystem!: IPhysicsSystem;
  private registry!: EntityRegistry;
  private combatSystem!: ICombatSystem;

  private resultBuffer = new Set<EntityID>();
  private handledPairs = new Set<string>();

  setup(locator: IServiceLocator): void {
    // DEPENDENCY INJECTION VIA INTERFACE
    this.physicsSystem = locator.getSystem<IPhysicsSystem>('PhysicsSystem');
    this.combatSystem = locator.getSystem<ICombatSystem>('CombatSystem');
    this.registry = locator.getRegistry() as EntityRegistry;
  }

  update(delta: number, time: number): void {
    const spatial = this.physicsSystem.spatialGrid;
    const allEntities = this.registry.getAll();
    
    this.handledPairs.clear();

    for (const entity of allEntities) {
        if (!entity.active) continue;

        const collider = entity.getComponent<ColliderComponent>('Collider');
        const transform = entity.getComponent<TransformComponent>('Transform');

        if (!collider || !transform || collider.mask === 0) continue;

        const state = entity.getComponent<StateComponent>('State');
        if (state && state.current === 'SPAWN') continue;

        spatial.query(transform.x, transform.y, collider.radius + 1.0, this.resultBuffer);

        for (const otherId of this.resultBuffer) {
            if (otherId === entity.id) continue;
            
            const id1 = entity.id < (otherId as number) ? entity.id : otherId;
            const id2 = entity.id < (otherId as number) ? otherId : entity.id;
            const pairId = `${id1}:${id2}`;
            
            if (this.handledPairs.has(pairId)) continue;
            this.handledPairs.add(pairId);

            const other = this.registry.getEntity(otherId as number);
            if (!other || !other.active) continue;

            const otherCollider = other.getComponent<ColliderComponent>('Collider');
            const otherTransform = other.getComponent<TransformComponent>('Transform');
            
            if (!otherCollider || !otherTransform) continue;

            const aHitsB = (collider.mask & otherCollider.layer) !== 0;
            const bHitsA = (otherCollider.mask & collider.layer) !== 0;
            if (!aHitsB && !bHitsA) continue;

            const dx = transform.x - otherTransform.x;
            const dy = transform.y - otherTransform.y;
            const distSq = dx * dx + dy * dy;
            const radiusSum = collider.radius + otherCollider.radius;

            if (distSq < radiusSum * radiusSum) {
                this.combatSystem.resolveCollision(entity, other);
            }
        }
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/game/systems/UISyncSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { useGameStore } from '../store/useGameStore';
import { GameStateSystem } from './GameStateSystem';
import { PanelRegistry } from './PanelRegistrySystem';
import { InteractionSystem } from './InteractionSystem';

export class UISyncSystem implements IGameSystem {
  private gameSystem!: GameStateSystem;
  private interactionSystem!: InteractionSystem;
  
  private readonly SYNC_INTERVAL = 0.1;
  private timeSinceLastSync = 0;

  setup(locator: IServiceLocator): void {
    this.gameSystem = locator.getSystem<GameStateSystem>('GameStateSystem');
    this.interactionSystem = locator.getSystem<InteractionSystem>('InteractionSystem');
  }

  update(delta: number, time: number): void {
    this.timeSinceLastSync += delta;
    if (this.timeSinceLastSync < this.SYNC_INTERVAL) return;
    this.timeSinceLastSync = 0;
    this.sync();
  }

  teardown(): void {}

  private sync() {
    const store = useGameStore.getState();
    
    const formattedScore = this.gameSystem.score.toString().padStart(4, '0');
    store.updateTransient('score-display', formattedScore);
    
    const shouldSyncReact = 
        store.playerHealth !== this.gameSystem.playerHealth || 
        store.playerRebootProgress !== this.gameSystem.playerRebootProgress || 
        store.xp !== this.gameSystem.xp || 
        store.score !== this.gameSystem.score ||
        store.level !== this.gameSystem.level ||
        store.upgradePoints !== this.gameSystem.upgradePoints ||
        store.interactionTarget !== this.interactionSystem.hoveringPanelId ||
        Math.abs(store.systemIntegrity - PanelRegistry.systemIntegrity) > 1.0; 

    if (shouldSyncReact) {
        store.syncGameState({
            playerHealth: this.gameSystem.playerHealth, 
            playerRebootProgress: this.gameSystem.playerRebootProgress, 
            level: this.gameSystem.level,
            xp: this.gameSystem.xp,
            score: this.gameSystem.score,
            xpToNextLevel: this.gameSystem.xpToNextLevel,
            upgradePoints: this.gameSystem.upgradePoints,
            activeUpgrades: { ...this.gameSystem.activeUpgrades },
            systemIntegrity: PanelRegistry.systemIntegrity,
            interactionTarget: this.interactionSystem.hoveringPanelId 
        });
    }

    const uiPanels: Record<string, any> = {};
    const panels = PanelRegistry.getAllPanels();
    for(const p of panels) {
        uiPanels[p.id] = {
            id: p.id,
            health: p.health,
            isDestroyed: p.isDestroyed
        };
    }
    store.syncPanels(uiPanels);
  }
}


=====================================
FILE: ./src/game/systems/InteractionSystem.ts
=====================================
import { IInteractionSystem, IServiceLocator, IEntitySpawner, IGameStateSystem } from '../core/interfaces';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { PanelRegistry } from './PanelRegistrySystem'; 
import { AudioSystem } from '@/core/audio/AudioSystem';

export type RepairState = 'IDLE' | 'HEALING' | 'REBOOTING';

export class InteractionSystem implements IInteractionSystem {
  public repairState: RepairState = 'IDLE';
  public hoveringPanelId: string | null = null;
  
  private lastRepairTime = 0;
  private readonly REPAIR_RATE = 0.05;
  private locator!: IServiceLocator;
  private spawner!: IEntitySpawner;
  private gameSystem!: IGameStateSystem; 

  setup(locator: IServiceLocator): void {
    this.locator = locator;
    this.spawner = locator.getSpawner();
    this.gameSystem = locator.getSystem<IGameStateSystem>('GameStateSystem');
  }

  update(delta: number, time: number): void {
    this.repairState = 'IDLE';
    this.hoveringPanelId = null;
    
    if (this.gameSystem.isGameOver) return; 
    
    const cursor = this.locator.getInputService().getCursor();
    
    if (this.gameSystem.playerHealth <= 0) {
        this.handleRevival(cursor, time);
        if (this.repairState !== 'REBOOTING' && this.gameSystem.playerRebootProgress > 0) {
            this.gameSystem.decayReboot(delta * 15);
        }
        return; 
    }

    this.handlePanelRepair(cursor, time);
    
    if (time > this.lastRepairTime + this.REPAIR_RATE) {
        const panels = PanelRegistry.getAllPanels();
        for (const p of panels) {
            if (p.isDestroyed && p.health > 0) {
                 PanelRegistry.decayPanel(p.id, 5);
            }
        }
    }
  }

  teardown(): void {}

  private handleRevival(cursor: {x: number, y: number}, time: number) {
    const rect = PanelRegistry.getPanelRect('identity');
    if (!rect) return;
    const padding = 2.0; 
    const isHovering = 
        cursor.x >= rect.left - padding && 
        cursor.x <= rect.right + padding && 
        cursor.y >= rect.bottom - padding && 
        cursor.y <= rect.top + padding;

    if (isHovering) {
        this.hoveringPanelId = 'identity';
        this.repairState = 'REBOOTING';
        if (time > this.lastRepairTime + this.REPAIR_RATE) {
            this.gameSystem.tickReboot(2.5); 
            this.lastRepairTime = time;
            
            // Loop Sound for Player Reboot
            AudioSystem.playSound('loop_reboot'); 

            if (Math.random() > 0.3) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 2;
                this.spawner.spawnParticle(cursor.x, cursor.y, '#9E4EA5', Math.cos(angle)*speed, Math.sin(angle)*speed, 0.5);
            }
        }
    }
  }

  private handlePanelRepair(cursor: {x: number, y: number}, time: number) {
    const panels = PanelRegistry.getAllPanels();
    for (const p of panels) {
      if (cursor.x >= p.left && cursor.x <= p.right && cursor.y >= p.bottom && cursor.y <= p.top) {
        this.hoveringPanelId = p.id;
        
        if (!p.isDestroyed && p.health >= 1000) continue;

        this.repairState = p.isDestroyed ? 'REBOOTING' : 'HEALING';

        if (time > this.lastRepairTime + this.REPAIR_RATE) {
            PanelRegistry.healPanel(p.id, 10);
            this.lastRepairTime = time;
            
            if (p.isDestroyed) {
                // Low pitch loop for reboot
                AudioSystem.playSound('loop_reboot');
            } else {
                // High pitch heal
                GameEventBus.emit(GameEvents.PANEL_HEALED, { id: p.id, amount: 10 });
            }

            if (Math.random() > 0.3) {
                const color = p.isDestroyed ? '#9E4EA5' : '#00F0FF'; 
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 2;
                this.spawner.spawnParticle(cursor.x, cursor.y, color, Math.cos(angle)*speed, Math.sin(angle)*speed, 0.5);
            }
        }
        break; 
      }
    }
  }
}


=====================================
FILE: ./src/game/systems/PlayerSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IEntitySpawner, IGameStateSystem, IInteractionSystem } from '../core/interfaces';
import { EntityRegistry } from '../core/ecs/EntityRegistry';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { PLAYER_CONFIG } from '../config/PlayerConfig';
import { Tag } from '../core/ecs/types';
import { TransformComponent } from '../components/data/TransformComponent';
import { StateComponent } from '../components/data/StateComponent';
import { TargetComponent } from '../components/data/TargetComponent';

export class PlayerSystem implements IGameSystem {
  private lastFireTime = 0;
  private gameSystem!: IGameStateSystem;
  private registry!: EntityRegistry;
  private spawner!: IEntitySpawner;
  private locator!: IServiceLocator;

  setup(locator: IServiceLocator): void {
    this.locator = locator;
    // DEPENDENCY INJECTION VIA INTERFACE
    this.gameSystem = locator.getSystem<IGameStateSystem>('GameStateSystem');
    this.registry = locator.getRegistry() as EntityRegistry;
    this.spawner = locator.getSpawner();
    this.setupListeners();
  }

  update(delta: number, time: number): void {
    if (this.gameSystem.isGameOver || this.gameSystem.playerHealth <= 0) return;

    const players = this.registry.getByTag(Tag.PLAYER);
    const playerEntity = players[0]; 
    if (!playerEntity) return;

    const cursor = this.locator.getInputService().getCursor();
    const transform = playerEntity.getComponent<TransformComponent>('Transform');
    if (transform) {
        transform.x = cursor.x;
        transform.y = cursor.y;
    }

    const stateComp = playerEntity.getComponent<StateComponent>('State');
    if (stateComp) {
        try {
            const interact = this.locator.getSystem<IInteractionSystem>('InteractionSystem');
            if (interact && interact.repairState !== 'IDLE') {
                stateComp.current = 'REBOOTING';
            } else {
                stateComp.current = 'ACTIVE';
            }
        } catch {
            stateComp.current = 'ACTIVE';
        }
    }

    if (stateComp && (stateComp.current === 'ACTIVE' || stateComp.current === 'REBOOTING')) {
        const upgrades = this.gameSystem.activeUpgrades;
        const overclock = upgrades['OVERCLOCK'] || 0;
        const currentFireRate = PLAYER_CONFIG.fireRate / Math.pow(1.5, overclock);

        if (time > this.lastFireTime + currentFireRate) {
            this.attemptAutoFire(time, playerEntity, upgrades);
        }
    }
  }

  teardown(): void {}

  private setupListeners() {
    GameEventBus.subscribe(GameEvents.ENEMY_DESTROYED, (payload) => {
      this.gameSystem.addScore(1);
      this.gameSystem.addXp(10);
    });

    GameEventBus.subscribe(GameEvents.UPGRADE_SELECTED, (p) => {
        if (p.option === 'PURGE') {
            this.triggerPurge();
        }
    });
  }

  private triggerPurge() {
      const cursor = this.locator.getInputService().getCursor();
      const count = 360; 
      const speed = 45;  
      const damage = 100;
      const width = 3.0; 

      GameEventBus.emit(GameEvents.SPAWN_FX, { type: 'EXPLOSION_YELLOW', x: cursor.x, y: cursor.y });
      GameEventBus.emit(GameEvents.TRAUMA_ADDED, { amount: 1.0 }); 

      for (let i = 0; i < count; i++) {
          const angle = (Math.PI * 2 * i) / count;
          const vx = Math.cos(angle) * speed;
          const vy = Math.sin(angle) * speed;
          
          this.spawner.spawnBullet(
              cursor.x, cursor.y, 
              vx, vy, 
              false, 
              2.0,   
              damage, 
              width
          );
      }
  }

  private attemptAutoFire(time: number, player: any, upgrades: Record<string, number>) {
    const cursor = this.locator.getInputService().getCursor();
    const enemies = this.registry.getByTag(Tag.ENEMY);
    let nearestDist = Infinity;
    const RANGE = 14; 
    let targetEnemy: any = null;

    for (const e of enemies) {
      if (!e.active) continue;
      const state = e.getComponent<StateComponent>('State');
      if (state && state.current === 'SPAWN') continue;

      const t = e.getComponent<TransformComponent>('Transform');
      if (!t) continue;
      const dx = t.x - cursor.x;
      const dy = t.y - cursor.y;
      const dist = dx*dx + dy*dy; 
      if (dist < (RANGE * RANGE) && dist < nearestDist) {
          nearestDist = dist;
          targetEnemy = e;
      }
    }

    if (targetEnemy) {
      const forkLevel = upgrades['FORK'] || 0;
      const projectileCount = 1 + (forkLevel * 2);
      const dmgLevel = upgrades['EXECUTE'] || 0;
      const damage = 1 + dmgLevel;
      const widthLevel = upgrades['BANDWIDTH'] || 0;
      const width = 1.0 + (widthLevel * 0.5);
      const snifferLevel = upgrades['SNIFFER'] || 0;
      const backdoorLevel = upgrades['BACKDOOR'] || 0;

      const baseSpread = 0.15;
      const spreadAngle = baseSpread * width; 
      
      const tPos = targetEnemy.getComponent<TransformComponent>('Transform')!;
      const dx = tPos.x - cursor.x;
      const dy = tPos.y - cursor.y;
      const baseAngle = Math.atan2(dy, dx);
      const startAngle = baseAngle - ((projectileCount - 1) * spreadAngle) / 2;

      // 1. FORK (Main)
      for (let i = 0; i < projectileCount; i++) {
          const angle = startAngle + (i * spreadAngle);
          const vx = Math.cos(angle) * PLAYER_CONFIG.bulletSpeed;
          const vy = Math.sin(angle) * PLAYER_CONFIG.bulletSpeed;

          this.spawner.spawnBullet(cursor.x, cursor.y, vx, vy, false, PLAYER_CONFIG.bulletLife, damage, width);
      }

      // 2. BACKDOOR
      if (backdoorLevel > 0) {
          const rearAngle = baseAngle + Math.PI; 
          const vx = Math.cos(rearAngle) * PLAYER_CONFIG.bulletSpeed;
          const vy = Math.sin(rearAngle) * PLAYER_CONFIG.bulletSpeed;
          this.spawner.spawnBullet(cursor.x, cursor.y, vx, vy, false, PLAYER_CONFIG.bulletLife, damage, width);
      }

      // 3. SNIFFER
      if (snifferLevel > 0) {
          const angleStep = (Math.PI * 2) / snifferLevel;
          for(let i=0; i<snifferLevel; i++) {
              const angle = baseAngle + (i * angleStep);
              const vx = Math.cos(angle) * PLAYER_CONFIG.bulletSpeed;
              const vy = Math.sin(angle) * PLAYER_CONFIG.bulletSpeed;
              const bullet = this.spawner.spawnBullet(cursor.x, cursor.y, vx, vy, false, PLAYER_CONFIG.bulletLife, damage, width);
              bullet.addComponent(new TargetComponent(null, 'ENEMY'));
          }
      }
      
      GameEventBus.emit(GameEvents.PLAYER_FIRED, { x: cursor.x, y: cursor.y });
      this.lastFireTime = time;
    }
  }
}


=====================================
FILE: ./src/game/systems/OrbitalSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { EntityRegistry } from '../core/ecs/EntityRegistry';
import { TransformComponent } from '../components/data/TransformComponent';
import { OrbitalComponent } from '../components/data/OrbitalComponent';
import { Tag } from '../core/ecs/types';

export class OrbitalSystem implements IGameSystem {
  private registry!: EntityRegistry;

  setup(locator: IServiceLocator): void {
    this.registry = locator.getRegistry() as EntityRegistry;
  }

  update(delta: number, time: number): void {
    const orbitals = this.registry.getAll(); // Filter by component in loop for speed or tag?
    // Optimization: In a real ECS we'd query by component. Here we iterate.
    
    // Find Player Cache (Parent)
    const players = this.registry.getByTag(Tag.PLAYER);
    if (players.length === 0) return;
    const player = players[0];
    const pPos = player.getComponent<TransformComponent>('Transform');
    if (!pPos) return;

    for (const entity of orbitals) {
        if (!entity.active) continue;
        
        const orb = entity.getComponent<OrbitalComponent>('Orbital');
        const transform = entity.getComponent<TransformComponent>('Transform');

        if (!orb || !transform) continue;

        // Update Angle
        if (orb.active) {
            orb.angle += orb.speed * delta;
        }

        // Update Position (Parent Pos + Orbit Offset)
        transform.x = pPos.x + Math.cos(orb.angle) * orb.radius;
        transform.y = pPos.y + Math.sin(orb.angle) * orb.radius;
        
        // Rotate self to look outward (tangent) or just spin?
        // Let's spin the mesh in the renderer, keep physics rotation simple.
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/game/systems/TimeSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';

export class TimeSystem implements IGameSystem {
  public timeScale: number = 1.0;
  public elapsedTime: number = 0; // Game World Time
  
  private freezeTimer: number = 0; // Real World Time duration

  // FPS Counting
  public fps: number = 60;
  private frames: number = 0;
  private lastFpsTime: number = 0;

  setup(locator: IServiceLocator): void {
    this.reset();
  }

  // Called by GameEngine every render frame (Variable Interval)
  public tickRealTime(dt: number) {
      // 1. Handle Freeze Timer (Real Time)
      if (this.freezeTimer > 0) {
          this.freezeTimer -= dt;
          if (this.freezeTimer < 0) this.freezeTimer = 0;
      }

      // 2. FPS Calculation (Real Time)
      const now = performance.now() / 1000;
      this.frames++;
      if (now >= this.lastFpsTime + 1.0) {
          this.fps = this.frames;
          this.frames = 0;
          this.lastFpsTime = now;
      }
  }

  // Called by GameEngine only during simulation steps (Fixed Interval)
  update(delta: number, time: number): void {
    // This delta is always 0.0166 (Fixed Step)
    this.elapsedTime += delta;
  }

  teardown(): void {
    this.reset();
  }

  private reset() {
    this.timeScale = 1.0;
    this.elapsedTime = 0;
    this.freezeTimer = 0;
    this.frames = 0;
    this.lastFpsTime = 0;
    this.fps = 60;
  }
  
  public setScale(scale: number, duration?: number) {
    this.timeScale = scale;
    if (duration) {
      setTimeout(() => {
        this.timeScale = 1.0;
      }, duration * 1000);
    }
  }

  public freeze(duration: number) {
      this.freezeTimer = duration;
  }

  public isFrozen(): boolean {
      return this.freezeTimer > 0;
  }
}


=====================================
FILE: ./src/game/systems/ShakeSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { noise } from '../utils/Noise';
import { useStore } from '@/core/store/useStore';

export class ShakeSystem implements IGameSystem {
  private trauma = 0;
  private time = 0;
  
  // Public read-only state for Renderers
  public currentOffset = { x: 0, y: 0, r: 0 };

  // Configuration
  private readonly DECAY_RATE = 1.5; // Trauma drains fast
  private readonly MAX_OFFSET_X = 1.0; // World Units
  private readonly MAX_OFFSET_Y = 1.0;
  private readonly MAX_ROTATION = 0.05; // Radians (~3 degrees)
  private readonly NOISE_SPEED = 20.0; 
  private readonly PIXELS_PER_UNIT = 40; // Approx zoom scale for DOM sync

  setup(locator: IServiceLocator): void {
    this.setupListeners();
  }

  update(delta: number, time: number): void {
    const strength = useStore.getState().screenShakeStrength;
    
    // 1. Decay Trauma
    if (this.trauma > 0) {
      this.trauma = Math.max(0, this.trauma - (delta * this.DECAY_RATE));
    }

    // 2. Calculate Shake (Trauma^2 or Trauma^3 for "Juice")
    const shake = (this.trauma * this.trauma) * strength;
    
    if (shake > 0.001) {
        this.time += delta * this.NOISE_SPEED;
        
        // 3D Noise Sampling (Seed offsets: 0, 100, 200)
        const x = this.MAX_OFFSET_X * shake * noise(this.time);
        const y = this.MAX_OFFSET_Y * shake * noise(this.time + 100);
        const r = this.MAX_ROTATION * shake * noise(this.time + 200);
        
        this.currentOffset = { x, y, r };

        // 3. Sync to DOM (Global CSS Vars)
        // We invert X/Y because if Camera moves Right (+), World moves Left (-).
        // But if we translate DOM Right (+), UI moves Right (+).
        // To match "World Shake", if Cam moves +X, World moves -X. 
        // So DOM should also move -X (translate negative).
        // Scale by 40 to match Viewport zoom.
        const domX = -x * this.PIXELS_PER_UNIT;
        const domY = -y * this.PIXELS_PER_UNIT; // +Y is Up in 3D, Down in DOM. Invert again? 
        // 3D +Y moves Camera Up -> World moves Down.
        // DOM +Y translates Down. So they match direction naturally if we invert.
        
        const root = document.documentElement;
        root.style.setProperty('--shake-x', `${domX.toFixed(2)}px`);
        root.style.setProperty('--shake-y', `${-domY.toFixed(2)}px`); // Y is inverted in DOM vs 3D
        root.style.setProperty('--shake-r', `${r.toFixed(4)}rad`);
    } else {
        // Reset to exact zero to stop micro-jitters
        if (this.currentOffset.x !== 0) {
            this.currentOffset = { x: 0, y: 0, r: 0 };
            const root = document.documentElement;
            root.style.setProperty('--shake-x', '0px');
            root.style.setProperty('--shake-y', '0px');
            root.style.setProperty('--shake-r', '0rad');
        }
    }
  }

  private setupListeners() {
    GameEventBus.subscribe(GameEvents.TRAUMA_ADDED, (p) => this.addTrauma(p.amount));
    
    // Fallbacks just in case (though FXManager usually calls TRAUMA_ADDED now)
    GameEventBus.subscribe(GameEvents.PLAYER_HIT, (p) => {
        const amount = p.damage > 10 ? 0.6 : 0.3;
        this.addTrauma(amount);
    });
  }

  public addTrauma(amount: number) {
    this.trauma = Math.min(1.0, this.trauma + amount);
  }

  teardown(): void {
    const root = document.documentElement;
    root.style.removeProperty('--shake-x');
    root.style.removeProperty('--shake-y');
    root.style.removeProperty('--shake-r');
  }
}


=====================================
FILE: ./src/game/systems/FXManager.ts
=====================================
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents, FXVariant } from '../events/GameEvents';
import { ServiceLocator } from '../core/ServiceLocator';
import { TimeSystem } from './TimeSystem';
import { ShakeSystem } from './ShakeSystem'; // Updated Import
import { IEntitySpawner } from '../core/interfaces';

class FXManagerController {
  private initialized = false;
  private spawner!: IEntitySpawner;

  private readonly PURPLE_PALETTE = ['#9E4EA5', '#D0A3D8', '#E0B0FF', '#7A2F8F', '#B57EDC'];
  private readonly YELLOW_PALETTE = ['#F7D277', '#FFE5A0', '#FFA500', '#FFFFFF'];
  
  public init() {
    if (this.initialized) return;
    
    try {
        this.spawner = ServiceLocator.getSpawner();
    } catch (e) {
        return;
    }

    GameEventBus.subscribe(GameEvents.SPAWN_FX, (p) => this.handleFX(p.type, p.x, p.y, p.angle));

    GameEventBus.subscribe(GameEvents.PANEL_DESTROYED, () => {
        this.addTrauma(0.7);
        this.triggerHitStop(0.15); 
    });
    
    GameEventBus.subscribe(GameEvents.PLAYER_HIT, (p) => {
        const isBig = p.damage > 10;
        this.addTrauma(isBig ? 0.6 : 0.3);
        if (isBig) this.triggerHitStop(0.1);
    });
    
    GameEventBus.subscribe(GameEvents.GAME_OVER, () => {
        this.addTrauma(1.0);
        this.triggerHitStop(0.5);
    });
    
    this.initialized = true;
  }

  private handleFX(type: FXVariant, x: number, y: number, angle: number = 0) {
      if (!this.spawner) return;

      switch (type) {
          case 'DRILL_SPARKS':
              this.spawnDirectionalSparks(x, y, angle, this.PURPLE_PALETTE, 5, 6, 0.5);
              break;
          case 'HUNTER_RECOIL':
              this.spawnDirectionalSparks(x, y, angle, this.YELLOW_PALETTE, 12, 15, 0.8);
              break;
          case 'EXPLOSION_PURPLE':
              this.spawnRadialExplosion(x, y, '#9E4EA5');
              break;
          case 'EXPLOSION_YELLOW':
              this.spawnRadialExplosion(x, y, '#F7D277');
              break;
          case 'EXPLOSION_RED':
              this.spawnRadialExplosion(x, y, '#FF003C');
              break;
          case 'IMPACT_WHITE':
              this.spawner.spawnParticle(x, y, '#FFFFFF', 0, 0, 0.2);
              break;
          case 'IMPACT_RED':
              this.spawner.spawnParticle(x, y, '#FF003C', 0, 0, 0.5);
              break;
          case 'CLASH_YELLOW':
              this.spawner.spawnParticle(x, y, '#F7D277', 0, 0, 0.5);
              break;
      }
  }

  private spawnDirectionalSparks(x: number, y: number, facingAngle: number, palette: string[], count: number, speedBase: number, spreadFactor: number) {
      const baseEject = facingAngle - (Math.PI / 2);
      for(let i=0; i<count; i++) {
          const color = palette[Math.floor(Math.random() * palette.length)];
          const spread = (Math.random() - 0.5) * spreadFactor; 
          const a = baseEject + spread;
          const speed = speedBase + Math.random() * 5;
          const vx = Math.cos(a) * speed;
          const vy = Math.sin(a) * speed;
          const life = 0.1 + Math.random() * 0.15;
          this.spawner.spawnParticle(x, y, color, vx, vy, life);
      }
  }

  private spawnRadialExplosion(x: number, y: number, color: string) {
      for(let i=0; i<12; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 15;
          this.spawner.spawnParticle(x, y, color, Math.cos(angle)*speed, Math.sin(angle)*speed, 0.8);
      }
  }

  public addTrauma(amount: number) {
    try {
        const sys = ServiceLocator.getSystem<ShakeSystem>('ShakeSystem');
        sys.addTrauma(amount);
    } catch {}
  }

  private triggerHitStop(duration: number) {
    try {
        const time = ServiceLocator.getSystem<TimeSystem>('TimeSystem');
        time.freeze(duration);
    } catch {}
  }
}

export const FXManager = new FXManagerController();


=====================================
FILE: ./src/game/systems/GuidanceSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { EntityRegistry } from '../core/ecs/EntityRegistry';
import { TransformComponent } from '../components/data/TransformComponent';
import { MotionComponent } from '../components/data/MotionComponent';
import { TargetComponent } from '../components/data/TargetComponent';
import { Tag } from '../core/ecs/types';

export class GuidanceSystem implements IGameSystem {
  private registry!: EntityRegistry;

  setup(locator: IServiceLocator): void {
    this.registry = locator.getRegistry() as EntityRegistry;
  }

  update(delta: number, time: number): void {
    const bullets = this.registry.getByTag(Tag.BULLET);

    for (const b of bullets) {
        if (!b.active) continue;
        
        // Only guide if it has a Target Component and has found a target
        const target = b.getComponent<TargetComponent>('Target');
        const motion = b.getComponent<MotionComponent>('Motion');
        const transform = b.getComponent<TransformComponent>('Transform');

        if (!target || !motion || !transform || !target.id) continue;

        // STEERING LOGIC
        const dx = target.x - transform.x;
        const dy = target.y - transform.y;
        
        // Desired Angle
        const desiredAngle = Math.atan2(dy, dx);
        
        // Current Angle (from velocity)
        const currentAngle = Math.atan2(motion.vy, motion.vx);
        
        // Angular difference (shortest path)
        let diff = desiredAngle - currentAngle;
        while (diff > Math.PI) diff -= Math.PI * 2;
        while (diff < -Math.PI) diff += Math.PI * 2;

        // Turn Speed (Radians per second)
        // High turn speed = tighter homing
        const turnSpeed = 4.0; 
        
        // Apply Rotation
        const maxTurn = turnSpeed * delta;
        const actualTurn = Math.max(-maxTurn, Math.min(maxTurn, diff));
        
        const newAngle = currentAngle + actualTurn;
        
        // Maintain Speed, Change Direction
        const speed = Math.sqrt(motion.vx * motion.vx + motion.vy * motion.vy);
        motion.vx = Math.cos(newAngle) * speed;
        motion.vy = Math.sin(newAngle) * speed;
        
        // Update visual rotation to match velocity
        transform.rotation = newAngle;
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/game/systems/CombatSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { Entity } from '../core/ecs/Entity';
import { GameStateSystem } from './GameStateSystem';
import { EntityRegistry } from '../core/ecs/EntityRegistry';
import { HealthComponent } from '../components/data/HealthComponent';
import { IdentityComponent } from '../components/data/IdentityComponent';
import { TransformComponent } from '../components/data/TransformComponent';
import { ColliderComponent } from '../components/data/ColliderComponent';
import { StateComponent } from '../components/data/StateComponent';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents, FXVariant } from '../events/GameEvents';
import { EnemyTypes } from '../config/Identifiers';
import { CollisionLayers } from '../config/PhysicsConfig';

export class CombatSystem implements IGameSystem {
  private gameSystem!: GameStateSystem;
  private registry!: EntityRegistry;

  setup(locator: IServiceLocator): void {
    this.gameSystem = locator.getSystem<GameStateSystem>('GameStateSystem');
    this.registry = locator.getRegistry() as EntityRegistry;
  }

  update(delta: number, time: number): void {}

  public resolveCollision(e1: Entity, e2: Entity) {
      const col1 = e1.getComponent<ColliderComponent>('Collider');
      const col2 = e2.getComponent<ColliderComponent>('Collider');
      if (!col1 || !col2) return;

      let a = e1, b = e2;
      let layerA = col1.layer, layerB = col2.layer;

      if (layerA > layerB) {
          a = e2; b = e1;
          layerA = col2.layer; layerB = col1.layer;
      }

      // 1. PLAYER vs ENEMY (Crash)
      if (layerA === CollisionLayers.PLAYER && layerB === CollisionLayers.ENEMY) {
          const idA = a.getComponent<IdentityComponent>('Identity');
          
          if (idA?.variant === EnemyTypes.DAEMON) {
              this.resolveDaemonCollision(a, b);
          } else {
              const id = b.getComponent<IdentityComponent>('Identity');
              const damage = (id?.variant === EnemyTypes.KAMIKAZE) ? 25 : 10;
              this.damagePlayer(damage);
              this.destroyEnemy(b, true); 
          }
      }

      // 2. PLAYER vs ENEMY_PROJECTILE (Hit)
      else if (layerA === CollisionLayers.PLAYER && layerB === CollisionLayers.ENEMY_PROJECTILE) {
          const idA = a.getComponent<IdentityComponent>('Identity');
          if (idA?.variant === EnemyTypes.DAEMON) {
              this.resolveDaemonCollision(a, b, 5); 
          } else {
              this.damagePlayer(10);
              this.destroyProjectile(b, 'IMPACT_RED'); 
          }
      }

      // 3. ENEMY vs PLAYER_PROJECTILE (Damage)
      else if (layerA === CollisionLayers.ENEMY && layerB === CollisionLayers.PLAYER_PROJECTILE) {
          this.handleMassExchange(a, b, 'IMPACT_WHITE');
      }

      // 4. PROJECTILE vs PROJECTILE (Clash)
      else if (layerA === CollisionLayers.PLAYER_PROJECTILE && layerB === CollisionLayers.ENEMY_PROJECTILE) {
          this.handleMassExchange(a, b, 'CLASH_YELLOW');
      }
  }

  private resolveDaemonCollision(daemon: Entity, enemyOrBullet: Entity, fixedDamage?: number) {
      const state = daemon.getComponent<StateComponent>('State');
      if (!state) return;

      let incomingDamage = fixedDamage || 10;
      if (!fixedDamage) {
          const enemyHp = enemyOrBullet.getComponent<HealthComponent>('Health');
          const eId = enemyOrBullet.getComponent<IdentityComponent>('Identity');
          if (eId?.variant === EnemyTypes.KAMIKAZE) incomingDamage = 20;
          else if (enemyHp) incomingDamage = enemyHp.current * 5; 
      }

      const shield = state.data.shieldHP || 0;

      if (state.current === 'CHARGING' || state.current === 'READY') {
          if (shield > 0) {
              state.data.shieldHP = Math.max(0, shield - incomingDamage);
              state.data.wasHit = true; 
              
              if (enemyOrBullet.hasTag('ENEMY')) {
                  this.destroyEnemy(enemyOrBullet, true);
                  GameEventBus.emit(GameEvents.SPAWN_FX, { type: 'CLASH_YELLOW', x: 0, y: 0 });
              } else {
                  this.destroyProjectile(enemyOrBullet, 'IMPACT_WHITE');
              }
              return;
          }
      }

      if (enemyOrBullet.hasTag('ENEMY')) {
          this.destroyEnemy(enemyOrBullet, true);
      } else {
          this.destroyProjectile(enemyOrBullet, 'IMPACT_RED');
      }
  }

  private handleMassExchange(entityA: Entity, entityB: Entity, fx: FXVariant) {
      const hpA = entityA.getComponent<HealthComponent>('Health');
      const hpB = entityB.getComponent<HealthComponent>('Health');

      const healthA = hpA ? hpA.current : 1;
      const healthB = hpB ? hpB.current : 1;

      const impact = Math.min(healthA, healthB);

      // REFACTOR: Direct Data Manipulation (Pure ECS)
      if (hpA) hpA.current = Math.max(0, hpA.current - impact);
      if (hpB) hpB.current = Math.max(0, hpB.current - impact);

      const tA = entityA.getComponent<TransformComponent>('Transform');
      if (tA) GameEventBus.emit(GameEvents.SPAWN_FX, { type: fx, x: tA.x, y: tA.y });

      // REFACTOR: Check property directly
      if (hpA && hpA.current <= 0) {
          if (entityA.getComponent('Identity')) this.destroyEnemy(entityA, true);
          else this.destroyProjectile(entityA, 'IMPACT_WHITE');
      }
      
      if (hpB && hpB.current <= 0) {
          this.destroyProjectile(entityB, 'IMPACT_WHITE');
      }
  }

  private damagePlayer(amount: number) {
      this.gameSystem.damagePlayer(amount);
      GameEventBus.emit(GameEvents.PLAYER_HIT, { damage: amount });
  }

  private destroyEnemy(entity: Entity, explode: boolean) {
      const transform = entity.getComponent<TransformComponent>('Transform');
      const identity = entity.getComponent<IdentityComponent>('Identity');
      
      if (transform && identity) {
          GameEventBus.emit(GameEvents.ENEMY_DESTROYED, { 
              id: entity.id as number, 
              type: identity.variant,
              x: transform.x,
              y: transform.y
          });
      }

      this.registry.destroyEntity(entity.id);
      
      if (explode && transform && identity) {
          let fx: FXVariant = 'EXPLOSION_PURPLE';
          if (identity.variant === EnemyTypes.HUNTER) fx = 'EXPLOSION_YELLOW';
          if (identity.variant === EnemyTypes.KAMIKAZE) fx = 'EXPLOSION_RED';
          GameEventBus.emit(GameEvents.SPAWN_FX, { type: fx, x: transform.x, y: transform.y });
      }
  }

  private destroyProjectile(entity: Entity, fx: FXVariant) {
      this.registry.destroyEntity(entity.id);
      const t = entity.getComponent<TransformComponent>('Transform');
      if (t) {
          GameEventBus.emit(GameEvents.SPAWN_FX, { type: fx, x: t.x, y: t.y });
      }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/game/systems/InputSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IInputService } from '../core/interfaces';

export class InputSystem implements IGameSystem, IInputService {
  private _cursor = { x: 0, y: 0 };
  private _virtualVector = { x: 0, y: 0 };
  private _usingJoystick = false;
  
  // Bounds for clamping (updated by GameEngine/ViewportHelper)
  private _bounds = { width: 30, height: 20 }; 

  setup(locator: IServiceLocator): void {
    // Initial setup
  }

  update(delta: number, time: number): void {
    // If using joystick, move the cursor based on the vector
    if (this._usingJoystick) {
        const speed = 30.0; // Virtual cursor speed
        
        this._cursor.x += this._virtualVector.x * speed * delta;
        this._cursor.y += this._virtualVector.y * speed * delta;

        // Clamp to logical world bounds (approximate, refined by viewport)
        const halfW = this._bounds.width / 2;
        const halfH = this._bounds.height / 2;
        
        this._cursor.x = Math.max(-halfW, Math.min(halfW, this._cursor.x));
        this._cursor.y = Math.max(-halfH, Math.min(halfH, this._cursor.y));
    }
  }

  teardown(): void {}

  // --- IInputService Implementation ---
  
  public updateCursor(x: number, y: number) {
    // Mouse movement overrides joystick
    this._usingJoystick = false;
    this._cursor.x = x;
    this._cursor.y = y;
  }

  public setJoystickVector(x: number, y: number) {
      if (x === 0 && y === 0) {
          this._usingJoystick = false;
      } else {
          this._usingJoystick = true;
      }
      this._virtualVector.x = x;
      this._virtualVector.y = y;
  }
  
  public updateBounds(width: number, height: number) {
      this._bounds.width = width;
      this._bounds.height = height;
  }

  public getCursor() {
    return this._cursor;
  }

  public isPressed(action: string): boolean {
    // Placeholder for future button mapping
    return false;
  }
}


=====================================
FILE: ./src/game/systems/PanelRegistrySystem.ts
=====================================
import { IGameSystem, IServiceLocator, IPanelSystem } from '../core/interfaces';
import { ViewportHelper, WorldRect } from '../utils/ViewportHelper';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { useStore } from '@/core/store/useStore';
import { AudioSystem } from '@/core/audio/AudioSystem';

const MAX_PANEL_HEALTH = 1000;

interface PanelState {
  health: number;
  isDestroyed: boolean;
}

class PanelRegistrySystemClass implements IPanelSystem {
  private panelRects = new Map<string, WorldRect>();
  private observedElements = new Map<string, HTMLElement>();
  private panelStates = new Map<string, PanelState>();

  public systemIntegrity: number = 100;

  setup(locator: IServiceLocator): void {
    this.resetLogic();
    this.refreshAll();
    
    GameEventBus.subscribe(GameEvents.UPGRADE_SELECTED, (p) => {
        if (p.option === 'RESTORE') {
            this.triggerSystemRestore();
        }
    });
  }

  update(delta: number, time: number): void {}
  teardown(): void {}

  private triggerSystemRestore() {
      let restoredCount = 0;
      for (const [id, state] of this.panelStates) {
          if (state.isDestroyed) {
              state.isDestroyed = false;
              state.health = 500; 
              restoredCount++;
              
              const rect = this.panelRects.get(id);
              if (rect) {
                  GameEventBus.emit(GameEvents.SPAWN_FX, { type: 'EXPLOSION_PURPLE', x: rect.x, y: rect.y });
              }
          } else {
              if (state.health < MAX_PANEL_HEALTH) {
                  state.health = MAX_PANEL_HEALTH;
              }
          }
      }
      
      this.calculateIntegrity();
      if (restoredCount > 0) {
          GameEventBus.emit(GameEvents.TRAUMA_ADDED, { amount: 0.3 }); 
          AudioSystem.playSound('fx_reboot_success'); 
          GameEventBus.emit(GameEvents.LOG_DEBUG, { msg: `Restored ${restoredCount} panels`, source: 'PanelSystem' });
      }
  }

  public resetLogic() {
    for (const id of this.observedElements.keys()) {
        this.panelStates.set(id, { health: MAX_PANEL_HEALTH, isDestroyed: false });
    }
    this.calculateIntegrity();
  }

  public damagePanel(id: string, amount: number) {
    if (useStore.getState().debugFlags.panelGodMode) return;

    const state = this.panelStates.get(id);
    if (!state || state.isDestroyed) return;

    const oldHealth = state.health;
    state.health = Math.max(0, state.health - amount);
    
    if (state.health <= 0 && !state.isDestroyed) {
        state.isDestroyed = true;
        state.health = 0; 
        
        GameEventBus.emit(GameEvents.LOG_DEBUG, { msg: `PANEL DESTROYED: ${id}`, source: 'PanelSystem' });
        GameEventBus.emit(GameEvents.PANEL_DESTROYED, { id });
    } else {
        if (Math.floor(oldHealth / 100) > Math.floor(state.health / 100)) {
             // Debug log
        }
        GameEventBus.emit(GameEvents.PANEL_DAMAGED, { id, amount, currentHealth: state.health });
    }
    
    this.calculateIntegrity();
  }

  public healPanel(id: string, amount: number) {
    const state = this.panelStates.get(id);
    if (!state) return;

    const wasDestroyed = state.isDestroyed;
    state.health = Math.min(MAX_PANEL_HEALTH, state.health + amount);
    
    if (wasDestroyed && state.health >= MAX_PANEL_HEALTH) {
        state.isDestroyed = false;
        state.health = 500; 
        
        AudioSystem.playSound('fx_reboot_success');
        
        GameEventBus.emit(GameEvents.LOG_DEBUG, { msg: `Panel RESTORED: ${id}`, source: 'PanelSystem' });
    }
    
    this.calculateIntegrity();
  }

  public decayPanel(id: string, amount: number) {
     const state = this.panelStates.get(id);
     if (!state || !state.isDestroyed) return;
     state.health = Math.max(0, state.health - amount);
  }

  public destroyAll() {
      for (const [id, state] of this.panelStates) {
          state.health = 0;
          state.isDestroyed = true;
          GameEventBus.emit(GameEvents.PANEL_DESTROYED, { id });
      }
      this.calculateIntegrity();
  }

  private calculateIntegrity() {
    let current = 0;
    let max = 0;
    for (const state of this.panelStates.values()) {
        max += MAX_PANEL_HEALTH;
        if (!state.isDestroyed) current += state.health;
    }
    this.systemIntegrity = max > 0 ? (current / max) * 100 : 100;
  }

  public register(id: string, element: HTMLElement) {
    this.observedElements.set(id, element);
    if (!this.panelStates.has(id)) {
        this.panelStates.set(id, { health: MAX_PANEL_HEALTH, isDestroyed: false });
    }
    this.refreshSingle(id);
  }

  public unregister(id: string) {
    this.observedElements.delete(id);
    this.panelRects.delete(id);
    this.panelStates.delete(id);
  }

  public refreshSingle(id: string) {
    const el = this.observedElements.get(id);
    if (!el || !el.isConnected) return;
    const rect = el.getBoundingClientRect();
    if (rect.width === 0 && rect.height === 0) return;
    this.panelRects.set(id, ViewportHelper.domToWorld(id, rect));
  }

  public refreshAll() {
    const ids = Array.from(this.observedElements.keys());
    for (const id of ids) this.refreshSingle(id);
  }

  public getPanelRect(id: string): WorldRect | undefined {
    return this.panelRects.get(id);
  }

  public getPanelState(id: string): PanelState | undefined {
    return this.panelStates.get(id);
  }
  
  public getAllPanels() {
      const result = [];
      for(const [id, rect] of this.panelRects) {
          const state = this.panelStates.get(id) || { health: 0, isDestroyed: true };
          result.push({ ...rect, ...state });
      }
      return result;
  }
}

export const PanelRegistry = new PanelRegistrySystemClass();


=====================================
FILE: ./src/game/systems/index.ts
=====================================
export * from './BehaviorSystem';
export * from './CameraSystem';
export * from './CollisionSystem';
export * from './FXManager';
export * from './GameStateSystem';
export * from './InputSystem';
export * from './InteractionSystem';
export * from './LifeCycleSystem';
export * from './PanelRegistrySystem';
export * from './PhysicsSystem';
export * from './PlayerSystem';
export * from './TimeSystem';
export * from './UISyncSystem';
export * from './WaveSystem';


=====================================
FILE: ./src/game/systems/GameStateSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IGameStateSystem } from '../core/interfaces';
import { PLAYER_CONFIG } from '../config/PlayerConfig';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { useStore } from '@/core/store/useStore'; 
import { AudioSystem } from '@/core/audio/AudioSystem';
import { PanelRegistry } from './PanelRegistrySystem';

export class GameStateSystem implements IGameStateSystem {
  public playerHealth: number = PLAYER_CONFIG.maxHealth;
  public maxPlayerHealth: number = PLAYER_CONFIG.maxHealth;
  public playerRebootProgress: number = 0;
  
  public score: number = 0;
  public xp: number = 0;
  public level: number = 1;
  public xpToNextLevel: number = PLAYER_CONFIG.baseXpRequirement;
  public upgradePoints: number = 0;

  public activeUpgrades: Record<string, number> = {
    'OVERCLOCK': 0, 'EXECUTE': 0, 'BANDWIDTH': 0, 'FORK': 0,
    'SNIFFER': 0, 'BACKDOOR': 0, 'REPAIR_NANITES': 0
  };

  public isGameOver: boolean = false;
  
  private heartbeatTimer: number = 0;

  setup(locator: IServiceLocator): void {
    this.reset();
    GameEventBus.subscribe(GameEvents.UPGRADE_SELECTED, (p) => {
        this.applyUpgrade(p.option);
    });
  }

  update(delta: number, time: number): void {
      if (this.isGameOver) return;

      if (PanelRegistry.systemIntegrity < 30 && PanelRegistry.systemIntegrity > 0) {
          this.heartbeatTimer -= delta;
          
          if (this.heartbeatTimer <= 0) {
              const urgency = 1.0 - (PanelRegistry.systemIntegrity / 30);
              AudioSystem.playSound('loop_warning');
              GameEventBus.emit(GameEvents.HEARTBEAT, { urgency });
              this.heartbeatTimer = 1.4 - (urgency * 1.05); 
          }
      } else {
          this.heartbeatTimer = 0;
      }
  }

  teardown(): void {}

  public reset() {
    this.playerHealth = this.maxPlayerHealth;
    this.playerRebootProgress = 0;
    this.score = 0;
    this.xp = 0;
    this.level = 1;
    this.xpToNextLevel = PLAYER_CONFIG.baseXpRequirement;
    this.upgradePoints = 0;
    this.isGameOver = false;
    this.activeUpgrades = { 
        'OVERCLOCK': 0, 'EXECUTE': 0, 'BANDWIDTH': 0, 'FORK': 0,
        'SNIFFER': 0, 'BACKDOOR': 0, 'REPAIR_NANITES': 0
    };
  }

  public applyUpgrade(option: string) {
      if (this.upgradePoints > 0) {
          this.upgradePoints--;
          if (option === 'PURGE' || option === 'RESTORE') return;
          if (option === 'DAEMON') {
              GameEventBus.emit(GameEvents.SPAWN_DAEMON, null);
              return; 
          }
          this.activeUpgrades[option] = (this.activeUpgrades[option] || 0) + 1;
          if (option === 'REPAIR_NANITES') this.healPlayer(this.maxPlayerHealth * 0.2);
      }
  }

  public damagePlayer(amount: number) {
    if (this.isGameOver) return;
    const { godMode } = useStore.getState().debugFlags;
    if (godMode) return;
    
    if (this.playerHealth > 0) {
        this.playerHealth = Math.max(0, this.playerHealth - amount);
        if (this.playerHealth <= 0) AudioSystem.playSound('fx_player_death');
    } else {
        this.playerRebootProgress = Math.max(0, this.playerRebootProgress - (amount * 2));
    }
  }

  public healPlayer(amount: number) {
    this.playerHealth = Math.min(this.maxPlayerHealth, this.playerHealth + amount);
  }

  public addScore(amount: number) {
    this.score += amount;
  }

  public addXp(amount: number) {
    this.xp += amount;
    while (this.xp >= this.xpToNextLevel) {
        this.xp -= this.xpToNextLevel;
        this.level++;
        this.upgradePoints++;
        this.xpToNextLevel = Math.floor(this.xpToNextLevel * PLAYER_CONFIG.xpScalingFactor);
        GameEventBus.emit(GameEvents.THREAT_LEVEL_UP, { level: this.level });
    }
  }

  public tickReboot(amount: number) {
    if (this.playerHealth > 0) return;
    this.playerRebootProgress = Math.max(0, Math.min(100, this.playerRebootProgress + amount));
    
    if (this.playerRebootProgress >= 100) {
        this.playerHealth = this.maxPlayerHealth; 
        this.playerRebootProgress = 0;
        AudioSystem.playSound('fx_reboot_success'); 
    }
  }

  public decayReboot(amount: number) {
      if (this.playerHealth > 0) return; 
      this.playerRebootProgress = Math.max(0, this.playerRebootProgress - amount);
  }
}


=====================================
FILE: ./src/game/systems/TargetingSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { EntityRegistry } from '../core/ecs/EntityRegistry';
import { TransformComponent } from '../components/data/TransformComponent';
import { TargetComponent } from '../components/data/TargetComponent';
import { PanelRegistry } from './PanelRegistrySystem';
import { Tag } from '../core/ecs/types';

export class TargetingSystem implements IGameSystem {
  private registry!: EntityRegistry;
  private locator!: IServiceLocator;

  private playerCache: { x: number, y: number } | null = null;

  setup(locator: IServiceLocator): void {
    this.registry = locator.getRegistry() as EntityRegistry;
    this.locator = locator;
  }

  update(delta: number, time: number): void {
    this.updatePlayerCache();

    const entities = this.registry.getAll();
    
    for (const entity of entities) {
        if (!entity.active) continue;

        const target = entity.getComponent<TargetComponent>('Target');
        const transform = entity.getComponent<TransformComponent>('Transform');

        if (!target || !transform) continue;

        // Locked target validation
        if (target.locked && target.id) {
            if (target.type === 'PANEL') {
                const panel = PanelRegistry.getPanelState(target.id);
                if (!panel || panel.isDestroyed) {
                    target.locked = false;
                    target.id = null;
                } else {
                    const rect = PanelRegistry.getPanelRect(target.id);
                    if (rect) {
                        target.x = rect.x;
                        target.y = rect.y;
                    }
                }
            }
            // Validate Enemy Target (for Homing Bullets)
            else if (target.type === 'ENEMY') {
                // If target ID is generic 'PLAYER', skip check.
                // If it's a specific Entity ID (stringified), check if alive.
                // For now, we recalculate nearest enemy every frame for bullets 
                // because enemies die fast. Simple and robust.
                target.locked = false; 
            }
            else if (target.type === 'PLAYER' && this.playerCache) {
                target.x = this.playerCache.x;
                target.y = this.playerCache.y;
            }
            
            if (target.locked) continue; 
        }

        // --- FIND NEW TARGET ---

        if (target.type === 'PLAYER') {
            if (this.playerCache) {
                target.x = this.playerCache.x;
                target.y = this.playerCache.y;
                target.id = 'PLAYER';
            }
        }
        else if (target.type === 'PANEL') {
            const bestPanel = this.findNearestPanel(transform.x, transform.y);
            if (bestPanel) {
                target.id = bestPanel.id;
                target.x = bestPanel.x;
                target.y = bestPanel.y;
                target.locked = true; 
            } else {
                // Fallback to Player if no panels
                if (this.playerCache) {
                    target.x = this.playerCache.x;
                    target.y = this.playerCache.y;
                    target.id = 'PLAYER';
                }
            }
        }
        // NEW: Bullet Homing Logic
        else if (target.type === 'ENEMY') {
            const bestEnemy = this.findNearestEnemy(transform.x, transform.y);
            if (bestEnemy) {
                // We don't ID lock bullets, we just steer to coordinates
                target.x = bestEnemy.x;
                target.y = bestEnemy.y;
                target.id = 'ENEMY_LOCKED';
            } else {
                target.id = null; // No target found, fly straight
            }
        }
    }
  }

  private updatePlayerCache() {
      const players = this.registry.getByTag(Tag.PLAYER);
      if (players.length > 0) {
          const t = players[0].getComponent<TransformComponent>('Transform');
          if (t) {
              this.playerCache = { x: t.x, y: t.y };
              return;
          }
      }
      this.playerCache = null;
  }

  private findNearestPanel(x: number, y: number) {
      const panels = PanelRegistry.getAllPanels();
      let nearest: any = null;
      let minDist = Infinity;

      for (const p of panels) {
          if (p.isDestroyed) continue;
          const dx = p.x - x;
          const dy = p.y - y;
          const distSq = dx*dx + dy*dy;
          if (distSq < minDist) {
              minDist = distSq;
              nearest = p;
          }
      }
      return nearest;
  }

  private findNearestEnemy(x: number, y: number) {
      const enemies = this.registry.getByTag(Tag.ENEMY);
      let nearest: { x: number, y: number } | null = null;
      let minDist = Infinity;
      // Range limit for homing (don't target things across map)
      const MAX_RANGE_SQ = 15 * 15; 

      for (const e of enemies) {
          if (!e.active) continue;
          const t = e.getComponent<TransformComponent>('Transform');
          if (!t) continue;
          
          const dx = t.x - x;
          const dy = t.y - y;
          const distSq = dx*dx + dy*dy;
          
          if (distSq < minDist && distSq < MAX_RANGE_SQ) {
              minDist = distSq;
              nearest = { x: t.x, y: t.y };
          }
      }
      return nearest;
  }

  teardown(): void {}
}


=====================================
FILE: ./src/game/systems/BehaviorSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IEntitySpawner } from '../core/interfaces';
import { EntityRegistry } from '../core/ecs/EntityRegistry';
import { Tag } from '../core/ecs/types';
import { IdentityComponent } from '../components/data/IdentityComponent';
import { PanelRegistry } from './PanelRegistrySystem';
import { EnemyTypes } from '../config/Identifiers';
import { GameEventBus } from '../events/GameEventBus'; 
import { GameEvents } from '../events/GameEvents'; 
import { useGameStore } from '@/game/store/useGameStore';
import { AudioSystem } from '@/core/audio/AudioSystem'; // Import AudioSystem

import { DrillerLogic } from '../logic/ai/DrillerLogic';
import { KamikazeLogic } from '../logic/ai/KamikazeLogic';
import { HunterLogic } from '../logic/ai/HunterLogic';
import { DaemonLogic } from '../logic/ai/DaemonLogic'; 
import { AIContext, EnemyLogic } from '../logic/ai/types';
import { OrbitalComponent } from '../components/data/OrbitalComponent';

export class BehaviorSystem implements IGameSystem {
  private registry!: EntityRegistry;
  private spawner!: IEntitySpawner;

  private behaviors: Record<string, EnemyLogic> = {
      [EnemyTypes.DRILLER]: DrillerLogic,
      [EnemyTypes.KAMIKAZE]: KamikazeLogic,
      [EnemyTypes.HUNTER]: HunterLogic,
      [EnemyTypes.DAEMON]: DaemonLogic 
  };

  private readonly PURPLE_PALETTE = ['#9E4EA5', '#D0A3D8', '#E0B0FF', '#7A2F8F', '#B57EDC'];
  private readonly YELLOW_PALETTE = ['#F7D277', '#FFE5A0', '#FFA500', '#FFFFFF'];

  setup(locator: IServiceLocator): void {
    this.registry = locator.getRegistry() as EntityRegistry;
    this.spawner = locator.getSpawner();
    
    GameEventBus.subscribe(GameEvents.SPAWN_DAEMON, () => {
        const e = this.spawner.spawnEnemy(EnemyTypes.DAEMON, 0, 0);
        
        const orbital = e.getComponent<OrbitalComponent>('Orbital');
        if (orbital) {
            orbital.radius = 4.0;
            orbital.speed = 1.5 + Math.random() * 1.0; 
            orbital.angle = Math.random() * Math.PI * 2;
        }
    });
  }

  update(delta: number, time: number): void {
    const aiContext: AIContext = {
      delta,
      time,
      spawnProjectile: (x, y, vx, vy) => {
          this.spawner.spawnBullet(x, y, vx, vy, true, 3.0);
      },
      spawnDrillSparks: (x, y, angle) => this.spawnDirectionalSparks(x, y, angle, this.PURPLE_PALETTE, 5, 8),
      spawnLaunchSparks: (x, y, angle) => this.spawnDirectionalSparks(x, y, angle, this.YELLOW_PALETTE, 12, 15),
      damagePanel: (id, amount) => PanelRegistry.damagePanel(id, amount),
      // --- NEW: Audio Hook ---
      playSound: (key) => AudioSystem.playSound(key)
    };

    const upgrades = useGameStore.getState().activeUpgrades;
    const executeLevel = upgrades['EXECUTE'] || 0;
    const daemonDamage = 10 + executeLevel;

    const daemonContext: AIContext = {
      ...aiContext,
      daemonMaxDamage: daemonDamage,
      spawnProjectile: (x, y, vx, vy) => {
          const bullet = this.spawner.spawnBullet(x, y, vx, vy, false, 2.0, daemonDamage, 4.0);
          bullet.addComponent(new IdentityComponent('DAEMON_SHOT'));
          GameEventBus.emit(GameEvents.SPAWN_FX, { type: 'IMPACT_WHITE', x, y }); 
      }
    };

    const enemies = this.registry.getByTag(Tag.ENEMY);
    for (const entity of enemies) {
        if (!entity.active) continue;
        const identity = entity.getComponent<IdentityComponent>('Identity');
        if (identity && this.behaviors[identity.variant]) {
             this.behaviors[identity.variant].update(entity, aiContext);
        }
    }

    const daemons = this.registry.getAll(); 
    for (const entity of daemons) {
        if (!entity.active) continue;
        const identity = entity.getComponent<IdentityComponent>('Identity');
        if (identity && identity.variant === EnemyTypes.DAEMON) {
             this.behaviors[identity.variant].update(entity, daemonContext);
        }
    }
  }

  private spawnDirectionalSparks(x: number, y: number, facingAngle: number, palette: string[], count: number, speedBase: number) {
      const baseEject = facingAngle - (Math.PI / 2);
      for(let i=0; i<count; i++) {
          const color = palette[Math.floor(Math.random() * palette.length)];
          const spread = (Math.random() - 0.5) * 0.8; 
          const angle = baseEject + spread;
          const speed = speedBase + Math.random() * 5;
          const vx = Math.cos(angle) * speed;
          const vy = Math.sin(angle) * speed;
          const life = 0.2 + Math.random() * 0.2;
          this.spawner.spawnParticle(x, y, color, vx, vy, life);
      }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/game/systems/WaveSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IEntitySpawner } from '../core/interfaces';
import { useGameStore } from '../store/useGameStore';
import { useStore } from '@/core/store/useStore';
import { PanelRegistry } from './PanelRegistrySystem'; 
import { EnemyTypes } from '../config/Identifiers';

// UPDATED TIMELINE: Early Hunters
const WAVE_TIMELINE = [
  { at: 0,     type: 'driller', count: 3, interval: 0.1 }, 
  { at: 2,     type: 'hunter',  count: 1, interval: 0 },   // <--- Early Hunter
  { at: 5,     type: 'driller', count: 5, interval: 0.5 }, 
  { at: 8,     type: 'kamikaze', count: 2, interval: 1.0 },
  { at: 12,    type: 'driller', count: 8, interval: 0.2 }, 
  { at: 15,    type: 'hunter',  count: 2, interval: 2.0 }, // <--- More Hunters
  { at: 20,    type: 'kamikaze', count: 5, interval: 0.5 },
  { at: 25,    type: 'hunter',  count: 3, interval: 1.0 }, 
];

export class WaveSystem implements IGameSystem {
  private spawner!: IEntitySpawner;
  private waveTime = 0;
  private currentWaveIndex = 0;
  private spawnQueue: { type: string, time: number }[] = [];
  private loopCount = 0;

  setup(locator: IServiceLocator): void {
    this.spawner = locator.getSpawner();
    this.reset();
  }

  private reset() {
    this.waveTime = 0;
    this.currentWaveIndex = 0;
    this.spawnQueue = [];
    this.loopCount = 0;
  }

  update(delta: number, time: number): void {
    if (useGameStore.getState().isZenMode) return;
    if (useStore.getState().bootState === 'sandbox') return;

    this.waveTime += delta;
    
    if (!useStore.getState().debugFlags.peaceMode) {
        this.checkTimeline();
        this.processQueue(time);
    }

    this.handleBreaches(delta);
  }

  private handleBreaches(delta: number) {
      const flags = useStore.getState().debugFlags;
      if (flags.panelGodMode || flags.peaceMode) return;

      const allPanels = PanelRegistry.getAllPanels();
      const deadPanels = allPanels.filter(p => p.isDestroyed && p.width > 0);
      
      if (deadPanels.length === 0) return;

      const enemiesPerSecondPerPanel = 0.2 + (this.waveTime * 0.005);
      const spawnChance = enemiesPerSecondPerPanel * delta;

      for (const p of deadPanels) {
          if (Math.random() < spawnChance) {
              this.spawnBreachEnemy(p);
          }
      }
  }

  private spawnBreachEnemy(p: any) {
      const rand = Math.random();
      let type = EnemyTypes.DRILLER;
      if (rand > 0.85) type = EnemyTypes.HUNTER;
      else if (rand > 0.60) type = EnemyTypes.KAMIKAZE;

      const safeW = p.width * 0.7; 
      const safeH = p.height * 0.7;
      
      const offsetX = (Math.random() - 0.5) * safeW;
      const offsetY = (Math.random() - 0.5) * safeH;
      
      this.spawner.spawnEnemy(type, p.x + offsetX, p.y + offsetY);
  }

  private checkTimeline() {
    if (this.currentWaveIndex >= WAVE_TIMELINE.length) {
        this.waveTime = 0;
        this.currentWaveIndex = 0;
        this.loopCount++;
    }

    const nextWave = WAVE_TIMELINE[this.currentWaveIndex];
    if (nextWave && this.waveTime >= nextWave.at) {
        this.queueSpawns(nextWave);
        this.currentWaveIndex++;
    }
  }

  private queueSpawns(wave: any) {
    const count = wave.count + (this.loopCount * 2);
    for (let i = 0; i < count; i++) {
        this.spawnQueue.push({
            type: wave.type,
            time: this.waveTime + (i * wave.interval)
        });
    }
  }

  private processQueue(currentTime: number) {
    for (let i = this.spawnQueue.length - 1; i >= 0; i--) {
        const spawn = this.spawnQueue[i];
        if (this.waveTime >= spawn.time) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 25; 
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            this.spawner.spawnEnemy(spawn.type, x, y);
            this.spawnQueue.splice(i, 1);
        }
    }
  }

  teardown(): void {
    this.reset();
  }
}


=====================================
FILE: ./src/game/systems/LifeCycleSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { LifetimeComponent } from '../components/data/LifetimeComponent';
import { HealthComponent } from '../components/data/HealthComponent';
import { IdentityComponent } from '../components/data/IdentityComponent';
import { TransformComponent } from '../components/data/TransformComponent';
import { EntityRegistry } from '../core/ecs/EntityRegistry';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { IEntitySpawner } from '../core/interfaces';

export class LifeCycleSystem implements IGameSystem {
  private registry!: EntityRegistry;
  private spawner!: IEntitySpawner;

  setup(locator: IServiceLocator): void {
    this.registry = locator.getRegistry() as EntityRegistry;
    this.spawner = locator.getSpawner();
    
    GameEventBus.subscribe(GameEvents.ZEN_MODE_ENABLED, () => {
        this.registry.clear();
        this.spawnPurgeEffect();
    });
  }

  update(delta: number, time: number): void {
    for (const entity of this.registry.getAll()) {
      if (!entity.active) continue;

      const lifetime = entity.getComponent<LifetimeComponent>('Lifetime');
      if (lifetime) {
        lifetime.remaining -= delta;
        if (lifetime.remaining <= 0) {
          this.registry.destroyEntity(entity.id);
          continue;
        }
      }

      const health = entity.getComponent<HealthComponent>('Health');
      // REFACTOR: Check property directly instead of .isDead getter
      if (health && health.current <= 0) {
          const identity = entity.getComponent<IdentityComponent>('Identity');
          const transform = entity.getComponent<TransformComponent>('Transform');
          
          if (identity && transform) {
             GameEventBus.emit(GameEvents.ENEMY_DESTROYED, { 
                id: entity.id as number, 
                type: identity.variant, 
                x: transform.x, 
                y: transform.y 
             });
             this.spawnExplosion(transform.x, transform.y, identity.variant);
          }
          
          this.registry.destroyEntity(entity.id);
      }
    }
  }

  private spawnExplosion(x: number, y: number, type: string) {
      const color = type === 'hunter' ? '#F7D277' : type === 'kamikaze' ? '#FF003C' : '#9E4EA5';
      for(let i=0; i<12; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 15;
          const life = 0.5 + Math.random() * 0.5;
          this.spawner.spawnParticle(x, y, color, Math.cos(angle)*speed, Math.sin(angle)*speed, life);
      }
  }

  private spawnPurgeEffect() {
      for(let i=0; i<50; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 10 + Math.random() * 20;
          this.spawner.spawnParticle(0, 0, '#FFFFFF', Math.cos(angle)*speed, Math.sin(angle)*speed, 2.0);
      }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/game/systems/PhysicsSystem.ts
=====================================
import { IPhysicsSystem, IServiceLocator } from '../core/interfaces';
import { SpatialGrid } from '../core/SpatialGrid';
import { TransformComponent } from '../components/data/TransformComponent';
import { MotionComponent } from '../components/data/MotionComponent';
import { EntityRegistry } from '../core/ecs/EntityRegistry';

export class PhysicsSystem implements IPhysicsSystem {
  public spatialGrid: SpatialGrid;
  private registry!: EntityRegistry;

  constructor() {
    this.spatialGrid = new SpatialGrid(4);
  }

  setup(locator: IServiceLocator): void {
    this.registry = locator.getRegistry() as EntityRegistry;
    this.spatialGrid.clear();
  }

  update(delta: number, time: number): void {
    this.spatialGrid.clear();
    
    for (const entity of this.registry.getAll()) {
      if (!entity.active) continue;

      const transform = entity.getComponent<TransformComponent>('Transform');
      const motion = entity.getComponent<MotionComponent>('Motion');
      
      if (transform && motion) {
        transform.x += motion.vx * delta;
        transform.y += motion.vy * delta;
        
        if (motion.friction > 0) {
            motion.vx *= (1 - motion.friction);
            motion.vy *= (1 - motion.friction);
        }

        this.spatialGrid.insert(entity.id, transform.x, transform.y);
      }
    }
  }

  teardown(): void {
    this.spatialGrid.clear();
  }
}


=====================================
FILE: ./src/game/data/Archetypes.ts
=====================================
import { ENEMY_CONFIG } from '../config/EnemyConfig';
import { PhysicsConfig, CollisionLayers } from '../config/PhysicsConfig';
import { EnemyTypes } from '../config/Identifiers';
import { Tag } from '../core/ecs/types';

export interface EntityBlueprint {
  tags: Tag[];
  components: { type: string; data?: any }[];
}

export const ARCHETYPES: Record<string, EntityBlueprint> = {
  [EnemyTypes.DRILLER]: {
    tags: [Tag.ENEMY, Tag.OBSTACLE],
    components: [
      { type: 'Identity', data: { variant: EnemyTypes.DRILLER } },
      { type: 'Health', data: { max: ENEMY_CONFIG.driller.hp } },
      { type: 'Motion', data: { friction: 0 } },
      { type: 'Combat', data: { damage: ENEMY_CONFIG.driller.damage } },
      { type: 'Collider', data: { radius: PhysicsConfig.HITBOX.DRILLER, layer: CollisionLayers.ENEMY, mask: PhysicsConfig.MASKS.ENEMY } },
      { type: 'State', data: { current: 'SPAWN', timers: { spawn: 1.5 } } },
      { type: 'Target', data: { type: 'PANEL' } }
    ]
  },
  [EnemyTypes.KAMIKAZE]: {
    tags: [Tag.ENEMY, Tag.OBSTACLE],
    components: [
      { type: 'Identity', data: { variant: EnemyTypes.KAMIKAZE } },
      { type: 'Health', data: { max: ENEMY_CONFIG.kamikaze.hp } },
      { type: 'Motion', data: { friction: 0 } },
      { type: 'Combat', data: { damage: ENEMY_CONFIG.kamikaze.damage } },
      { type: 'Collider', data: { radius: PhysicsConfig.HITBOX.KAMIKAZE, layer: CollisionLayers.ENEMY, mask: PhysicsConfig.MASKS.ENEMY } },
      { type: 'State', data: { current: 'SPAWN', timers: { spawn: 1.5 } } },
      { type: 'Target', data: { type: 'PLAYER' } }
    ]
  },
  [EnemyTypes.HUNTER]: {
    tags: [Tag.ENEMY, Tag.OBSTACLE],
    components: [
      { type: 'Identity', data: { variant: EnemyTypes.HUNTER } },
      { type: 'Health', data: { max: ENEMY_CONFIG.hunter.hp } },
      { type: 'Motion', data: { friction: 0 } },
      { type: 'Combat', data: { damage: 10 } }, 
      { type: 'Collider', data: { radius: PhysicsConfig.HITBOX.HUNTER, layer: CollisionLayers.ENEMY, mask: PhysicsConfig.MASKS.ENEMY } },
      { type: 'State', data: { current: 'SPAWN', timers: { spawn: 1.5 } } },
      { type: 'Target', data: { type: 'PLAYER' } }
    ]
  },
  // NEW: DAEMON
  [EnemyTypes.DAEMON]: {
    tags: [Tag.PLAYER], // Friendly
    components: [
      { type: 'Identity', data: { variant: EnemyTypes.DAEMON } },
      { type: 'Health', data: { max: 100 } }, // High HP Shield
      { type: 'Orbital', data: { radius: 4.0, speed: 1.5, angle: 0 } },
      { type: 'Transform', data: { scale: 1.0 } },
      { type: 'Target', data: { type: 'ENEMY' } }, // Seeks Enemies
      // Physics: Layer PLAYER means Enemies hit it and take damage/die (Ramming)
      { type: 'Collider', data: { radius: 0.6, layer: CollisionLayers.PLAYER, mask: PhysicsConfig.MASKS.PLAYER } },
      { type: 'State', data: { current: 'ORBIT' } }
    ]
  }
};


=====================================
FILE: ./src/game/store/useGameStore.ts
=====================================
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { UpgradeOption } from '../types/game.types';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { PLAYER_CONFIG } from '../config/PlayerConfig';

const MAX_PANEL_HEALTH = 1000;

interface GameStateUI {
  isPlaying: boolean;
  isZenMode: boolean;
  playerHealth: number;
  maxPlayerHealth: number;
  playerRebootProgress: number;
  score: number;
  highScore: number;
  xp: number;
  level: number;
  xpToNextLevel: number;
  upgradePoints: number;
  systemIntegrity: number;
  
  interactionTarget: string | null;

  availableUpgrades: UpgradeOption[];
  activeUpgrades: Record<string, number>;
  panels: Record<string, { id: string, health: number, isDestroyed: boolean, element?: HTMLElement }>;
  
  // --- TRANSIENT UPDATE SYSTEM (Direct DOM) ---
  transientElements: Map<string, { el: HTMLElement, type: 'text' | 'width' | 'css-var' }>;
  registerTransientElement: (id: string, el: HTMLElement, type: 'text' | 'width' | 'css-var') => void;
  unregisterTransientElement: (id: string) => void;
  updateTransient: (id: string, value: string | number) => void;

  // --- ACTIONS ---
  startGame: () => void;
  stopGame: () => void;
  activateZenMode: () => void;
  
  registerPanel: (id: string, element: HTMLElement) => void;
  unregisterPanel: (id: string) => void;
  syncGameState: (data: Partial<GameStateUI>) => void;
  syncPanels: (panelsData: Record<string, any>) => void;
  selectUpgrade: (option: UpgradeOption) => void;
  addScore: (amount: number) => void;
  addXp: (amount: number) => void;
  damagePlayer: (amount: number) => void;
  healPlayer: (amount: number) => void;
  tickPlayerReboot: (amount: number) => void;
  healPanel: (id: string, amount: number) => void;
  decayReboot: (id: string, amount: number) => void;
  damagePanel: (id: string, amount: number) => void;
  resetGame: () => void;
  recalculateIntegrity: () => void;
}

export const useGameStore = create<GameStateUI>()(
  persist(
    (set, get) => ({
      isPlaying: false,
      isZenMode: false,
      playerHealth: PLAYER_CONFIG.maxHealth,
      maxPlayerHealth: PLAYER_CONFIG.maxHealth,
      playerRebootProgress: 0,
      score: 0,
      highScore: 0,
      xp: 0,
      level: 1,
      xpToNextLevel: PLAYER_CONFIG.baseXpRequirement,
      upgradePoints: 0,
      systemIntegrity: 100,
      interactionTarget: null,
      
      availableUpgrades: [],
      activeUpgrades: { 'RAPID_FIRE': 0, 'MULTI_SHOT': 0, 'SPEED_UP': 0, 'REPAIR_NANITES': 0 },
      panels: {},

      // --- TRANSIENT SYSTEM ---
      transientElements: new Map(),

      registerTransientElement: (id, el, type) => {
        // We modify the Map directly to avoid triggering a React re-render
        get().transientElements.set(id, { el, type });
      },

      unregisterTransientElement: (id) => {
        get().transientElements.delete(id);
      },

      updateTransient: (id, value) => {
        const item = get().transientElements.get(id);
        if (!item) return;

        if (item.type === 'text') {
            item.el.innerText = String(value);
        } else if (item.type === 'width') {
            item.el.style.width = `${value}%`;
        } else if (item.type === 'css-var') {
            item.el.style.setProperty(`--${id}`, String(value));
        }
      },

      // --- GAME ACTIONS ---

      startGame: () => {
        if (get().isPlaying) return;
        set({ 
            isPlaying: true, 
            isZenMode: false,
            score: 0, 
            playerHealth: PLAYER_CONFIG.maxHealth,
            playerRebootProgress: 0,
            xp: 0,
            level: 1,
            xpToNextLevel: PLAYER_CONFIG.baseXpRequirement,
            availableUpgrades: [],
            activeUpgrades: { 'RAPID_FIRE': 0, 'MULTI_SHOT': 0, 'SPEED_UP': 0, 'REPAIR_NANITES': 0 },
            panels: Object.fromEntries(
                Object.entries(get().panels).map(([k, v]) => [k, { ...v, health: MAX_PANEL_HEALTH, isDestroyed: false }])
            )
        });
        // Reset visual elements immediately
        get().updateTransient('score-display', '0000');
        get().updateTransient('player-health', 100);
      },
      
      stopGame: () => {
          const { score, highScore } = get();
          set({ isPlaying: false, highScore: Math.max(score, highScore) });
      },

      activateZenMode: () => {
          set({ isZenMode: true });
          GameEventBus.emit(GameEvents.ZEN_MODE_ENABLED, null);
      },

      syncGameState: (data) => set((state) => ({ ...state, ...data })),
      
      syncPanels: (incomingPanels) => set((state) => {
          const merged = { ...state.panels };
          for (const key in incomingPanels) {
              const prev = merged[key];
              merged[key] = { ...(prev || {}), ...incomingPanels[key] };
          }
          return { panels: merged };
      }),

      registerPanel: (id, element) => set((state) => ({
          panels: { ...state.panels, [id]: { id, element, health: 1000, isDestroyed: false } }
      })),
      
      unregisterPanel: (id) => set((state) => {
          const next = { ...state.panels };
          delete next[id];
          return { panels: next };
      }),

      selectUpgrade: (option) => {
        GameEventBus.emit(GameEvents.UPGRADE_SELECTED, { option });
      },

      addScore: (amount) => set(state => ({ score: state.score + amount })),
      addXp: (amount) => set(state => ({ xp: state.xp + amount })),
      damagePlayer: (amount) => set(state => ({ playerHealth: Math.max(0, state.playerHealth - amount) })),
      healPlayer: (amount) => set(state => ({ playerHealth: Math.min(state.maxPlayerHealth, state.playerHealth + amount) })),
      tickPlayerReboot: (amount) => set(state => ({ playerRebootProgress: Math.min(100, Math.max(0, state.playerRebootProgress + amount)) })),
      healPanel: (id, amount) => {}, 
      decayReboot: (id, amount) => {}, 
      damagePanel: (id, amount) => {}, 
      resetGame: () => {},
      recalculateIntegrity: () => {},
    }),
    {
      name: 'mesoelfy-os-storage-v2',
      partialize: (state) => ({ highScore: state.highScore }),
    }
  )
);


=====================================
FILE: ./src/styles/globals.css
=====================================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 255, 65;
  --shake-x: 0px;
  --shake-y: 0px;
  --shake-r: 0rad;
}

html, body {
  background-color: #000000;
  overscroll-behavior: none; 
  touch-action: none; 
  cursor: none !important;
}

/* Aggressive Cursor Hiding */
* {
  cursor: none !important;
}

body {
  color: #78F654;
  overflow: hidden; 
  font-family: 'Courier New', monospace;
  height: 100dvh; 
  width: 100vw;
}

#global-app-root {
  height: 100dvh;
  transform: translate3d(var(--shake-x), var(--shake-y), 0) rotate(var(--shake-r));
  will-change: transform; 
}

::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #050505; 
  border-left: 1px solid #15530A;
}

::-webkit-scrollbar-thumb {
  background: #0BD426; 
  border: 1px solid #000;
  border-radius: 2px;
}

::-webkit-scrollbar-thumb:hover {
  background: #78F654;
}

.glitch-text {
  text-shadow: 2px 0 #ff003c, -2px 0 #008f11;
}

.clip-corner-btn {
  clip-path: polygon(0 0, 100% 0, 100% 70%, 90% 100%, 0 100%);
}

@keyframes marching {
  0% { background-position: 0 0, 0 100%, 0 0, 100% 0; }
  100% { background-position: 20px 0, -20px 100%, 0 -20px, 100% 20px; }
}

.marching-ants {
  background-image: 
    linear-gradient(to right, var(--ant-color) 50%, transparent 50%),
    linear-gradient(to right, var(--ant-color) 50%, transparent 50%),
    linear-gradient(to bottom, var(--ant-color) 50%, transparent 50%),
    linear-gradient(to bottom, var(--ant-color) 50%, transparent 50%);
  background-size: 20px 1px, 20px 1px, 1px 20px, 1px 20px;
  background-repeat: repeat-x, repeat-x, repeat-y, repeat-y;
  animation: marching 1s linear infinite;
  border: none !important; 
}

body > div[data-nextjs-toast],
body > div[data-nextjs-dialog-overlay],
#next-route-announcer,
[class*="nextjs-toast"],
[class*="build-activity"],
[class*="static-route-indicator"] {
  display: none !important;
  opacity: 0 !important;
  pointer-events: none !important;
  visibility: hidden !important;
}


=====================================
FILE: ./src/scene/props/MiniCrystalCanvas.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { Float, MeshDistortMaterial } from '@react-three/drei';
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { useGameStore } from '@/game/store/useGameStore';

// CONSTANTS
const COLORS = {
  SAFE: new THREE.Color("#78F654"),
  WARN: new THREE.Color("#F7D277"),
  // UPDATED: Brighter/Hotter Red Values
  CRIT: new THREE.Color("#FF4D6D"), 
  EMISSIVE_SAFE: new THREE.Color("#15530A"),
  EMISSIVE_WARN: new THREE.Color("#5e4b00"),
  EMISSIVE_CRIT: new THREE.Color("#FF003C"), 
};

const SpinningGem = () => {
  const meshRef = useRef<THREE.Mesh>(null);
  const materialRef = useRef<any>(null);
  
  // Access global integrity
  const integrity = useGameStore(state => state.systemIntegrity);

  // Internal visual state
  const currentColor = useRef(COLORS.SAFE.clone());
  const currentEmissive = useRef(COLORS.EMISSIVE_SAFE.clone());

  useFrame((state, delta) => {
    if (!meshRef.current || !materialRef.current) return;

    // 1. DETERMINE STATE
    let targetColor = COLORS.SAFE;
    let targetEmissive = COLORS.EMISSIVE_SAFE;
    let speed = 0.01;
    let distort = 0.3;
    let shake = 0;

    if (integrity < 30) {
        targetColor = COLORS.CRIT;
        targetEmissive = COLORS.EMISSIVE_CRIT;
        speed = 0.08;  // Fast panic spin
        distort = 0.8; // Heavy glitch
        shake = 0.1;   // Vibration
    } else if (integrity < 60) {
        targetColor = COLORS.WARN;
        targetEmissive = COLORS.EMISSIVE_WARN;
        speed = 0.04;
        distort = 0.5;
        shake = 0.02;
    }

    // 2. APPLY ROTATION & SHAKE
    meshRef.current.rotation.y += speed;
    meshRef.current.rotation.z += speed * 0.5;
    
    if (shake > 0) {
        meshRef.current.position.x = (Math.random() - 0.5) * shake;
        meshRef.current.position.y = (Math.random() - 0.5) * shake;
    } else {
        meshRef.current.position.x = THREE.MathUtils.lerp(meshRef.current.position.x, 0, 0.1);
        meshRef.current.position.y = THREE.MathUtils.lerp(meshRef.current.position.y, 0, 0.1);
    }

    // 3. COLOR TRANSITION (Lerp)
    currentColor.current.lerp(targetColor, delta * 3.0);
    currentEmissive.current.lerp(targetEmissive, delta * 3.0);

    materialRef.current.color.copy(currentColor.current);
    materialRef.current.emissive.copy(currentEmissive.current);
    materialRef.current.distort = THREE.MathUtils.lerp(materialRef.current.distort, distort, delta);
  });

  return (
    <Float speed={2} rotationIntensity={0.5} floatIntensity={0.5}>
      <mesh ref={meshRef} scale={1.8}>
        <octahedronGeometry args={[1, 0]} />
        <MeshDistortMaterial
          ref={materialRef}
          color="#78F654" // Initial (overridden by ref)
          emissive="#15530A"
          roughness={0.1}
          metalness={0.8}
          distort={0.3}
          speed={2}
          wireframe
        />
      </mesh>
    </Float>
  );
};

export const MiniCrystalCanvas = () => {
  return (
    <div className="w-full h-full bg-black">
      <Canvas 
        camera={{ position: [0, 0, 5] }} 
        gl={{ alpha: true }}
        style={{ background: '#000000' }}
      >
        <ambientLight intensity={0.5} />
        <pointLight position={[10, 10, 10]} intensity={1} color="#C2FE9A" />
        <SpinningGem />
      </Canvas>
    </div>
  );
};


=====================================
FILE: ./src/scene/props/SoulCrystal.tsx
=====================================
import { useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import { Float, MeshDistortMaterial } from '@react-three/drei';
import * as THREE from 'three';

export const SoulCrystal = () => {
  const meshRef = useRef<THREE.Mesh>(null);

  useFrame((state) => {
    if (meshRef.current) {
      const t = state.clock.getElapsedTime();
      meshRef.current.rotation.y = t * 0.5;
      meshRef.current.rotation.z = t * 0.2;
    }
  });

  return (
    <Float speed={2} rotationIntensity={0.5} floatIntensity={1}>
      <mesh ref={meshRef} scale={1.5}>
        <octahedronGeometry args={[1, 0]} />
        <MeshDistortMaterial
          color="#00ff41"
          emissive="#003300"
          roughness={0}
          metalness={1}
          distort={0.4}
          speed={2}
          wireframe
        />
      </mesh>
      {/* Inner Core Glow */}
      <mesh scale={0.8}>
        <octahedronGeometry args={[1, 0]} />
        <meshBasicMaterial color="#ccffcc" transparent opacity={0.5} />
      </mesh>
    </Float>
  );
};


=====================================
FILE: ./src/scene/canvas/SceneCanvas.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { MatrixGrid } from '../effects/MatrixGrid';
import { Suspense } from 'react';
import { clsx } from 'clsx';

interface SceneCanvasProps {
  children?: React.ReactNode;
  className?: string;
}

export const SceneCanvas = ({ children, className }: SceneCanvasProps) => {
  return (
    <div className={clsx("fixed inset-0 w-full h-full z-0 pointer-events-none transition-all duration-[2000ms] ease-out", className)}>
      <Canvas 
        camera={{ position: [0, 2, 10], fov: 45 }}
        gl={{ antialias: true, alpha: false }} 
        dpr={[1, 2]}
        style={{ background: '#000000' }} 
      >
        <color attach="background" args={['#000']} />
        <fog attach="fog" args={['#000', 2, 30]} />
        
        <MatrixGrid />
        
        <ambientLight intensity={0.5} />
        <pointLight position={[10, 10, 10]} intensity={1} color="#78F654" />
        
        <Suspense fallback={null}>
           {children}
        </Suspense>
      </Canvas>
    </div>
  );
};


=====================================
FILE: ./src/scene/effects/MatrixGrid.tsx
=====================================
import { Grid } from '@react-three/drei';
import { useFrame } from '@react-three/fiber';
import { useRef, useMemo } from 'react';
import * as THREE from 'three';
import { useGameStore } from '@/game/store/useGameStore';
import { useStore } from '@/core/store/useStore';

export const MatrixGrid = () => {
  const groupRef = useRef<THREE.Group>(null);
  const gridRef = useRef<any>(null);

  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const bootState = useStore(state => state.bootState);

  const SECTION_SIZE = 5;   
  const SPEED = 0.5;

  const colors = useMemo(() => ({
    safe: {
      section: new THREE.Color("#003300"),
      cell: new THREE.Color("#044d0f")
    },
    warning: {
      section: new THREE.Color("#4d3300"),
      cell: new THREE.Color("#d48806")
    },
    critical: {
      section: new THREE.Color("#4d0000"),
      cell: new THREE.Color("#ff003c")
    },
    sandbox: {
      section: new THREE.Color("#001a33"), 
      cell: new THREE.Color("#00F0FF")     
    }
  }), []);

  const currentSectionColor = useRef(new THREE.Color(colors.safe.section));
  const currentCellColor = useRef(new THREE.Color(colors.safe.cell));

  useFrame((state, delta) => {
    if (groupRef.current) {
      groupRef.current.position.z += SPEED * delta;
      // Loop logic for infinite scrolling effect
      if (groupRef.current.position.z >= SECTION_SIZE) {
        groupRef.current.position.z = 0;
      }
    }

    let targetSection = colors.safe.section;
    let targetCell = colors.safe.cell;

    if (bootState === 'sandbox') {
        targetSection = colors.sandbox.section;
        targetCell = colors.sandbox.cell;
    } else if (systemIntegrity < 30) {
      targetSection = colors.critical.section;
      targetCell = colors.critical.cell;
    } else if (systemIntegrity < 60) {
      targetSection = colors.warning.section;
      targetCell = colors.warning.cell;
    }

    currentSectionColor.current.lerp(targetSection, delta * 3.0);
    currentCellColor.current.lerp(targetCell, delta * 3.0);

    if (gridRef.current && gridRef.current.material) {
        if (gridRef.current.material.uniforms.sectionColor) {
            gridRef.current.material.uniforms.sectionColor.value.copy(currentSectionColor.current);
        }
        if (gridRef.current.material.uniforms.cellColor) {
            gridRef.current.material.uniforms.cellColor.value.copy(currentCellColor.current);
        }
    }
  });

  return (
    <group ref={groupRef} position={[0, -2, 0]}>
      {/* 
         FIX: Nested group to offset geometry without breaking the scrolling logic.
         Z = -10 shifts the center point forward so the "front" edge is well behind the camera.
      */}
      <group position={[0, 0, -10]}>
        <Grid
          ref={gridRef}
          renderOrder={-1}
          infiniteGrid
          
          args={[60, 60]} 
          
          cellSize={1}
          sectionSize={SECTION_SIZE}
          
          // FIX: Reduced fadeDistance slightly to hide distant sub-pixels
          fadeDistance={bootState === 'sandbox' ? 35 : 30}
          
          // FIX: Increased fadeStrength (default is 1)
          // Higher values = sharper falloff. This hides the distant Moiré patterns.
          fadeStrength={2.5}
          
          sectionColor="#003300"
          cellColor="#044d0f"
          sectionThickness={1.2} 
          cellThickness={1.1}
        />
      </group>
    </group>
  );
};


=====================================
FILE: ./src/data/gallery.json
=====================================
[
  {
    "id": "art_001",
    "title": "ELFY_GENESIS",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#78F654"
  },
  {
    "id": "art_002",
    "title": "NEON_HEIST",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#9E4EA5"
  },
  {
    "id": "art_003",
    "title": "VOID_WALKER",
    "url": "https://x.com/mesoelfy",
    "category": "ROGUES",
    "color": "#FF003C"
  },
  {
    "id": "art_004",
    "title": "LATENT_GHOST",
    "url": "https://x.com/mesoelfy",
    "category": "COLLEAGUES",
    "color": "#F7D277"
  },
  {
    "id": "art_005",
    "title": "ZERO_DAY",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#78F654"
  },
  {
    "id": "art_006",
    "title": "SYSTEM_CRASH",
    "url": "https://x.com/mesoelfy",
    "category": "ROGUES",
    "color": "#FF003C"
  }
]


=====================================
FILE: ./src/data/identity.json
=====================================
{
  "name": "Elfy",
  "class": "Latent Space Bandit",
  "abilities": ["Green Flame", "Digital Heist", "Prompt Craft"],
  "stats": {
    "STR": "ERROR",
    "INT": 9001,
    "CHA": 50
  },
  "bio": "I manifest art from the void. My mission: Create cool s**t and annoy the haters."
}


=====================================
FILE: ./src/data/socials.json
=====================================
[
  { "name": "X / Twitter", "url": "https://x.com/mesoelfy", "icon": "twitter", "color": "#1DA1F2" },
  { "name": "YouTube", "url": "https://youtube.com/@mesoelfy", "icon": "youtube", "color": "#FF0000" },
  { "name": "TikTok", "url": "https://tiktok.com/@mesoelfy", "icon": "video", "color": "#00f2ea" },
  { "name": "GitHub", "url": "https://github.com/mesoelfy", "icon": "github", "color": "#ffffff" },
  { "name": "Newgrounds", "url": "https://mesoelfy.newgrounds.com/", "icon": "crosshair", "color": "#ffa500" },
  { "name": "DeviantArt", "url": "https://www.deviantart.com/mesoelfy", "icon": "image", "color": "#05cc47" }
]


=====================================
FILE: ./src/data/feed.json
=====================================
[
  {
    "id": 1,
    "date": "2023-10-27",
    "title": "Elfy vs. RoboGhoul",
    "desc": "The final showdown. Green flame algorithm engaged.",
    "link": "https://x.com/mesoelfy/status/123456"
  },
  {
    "id": 2,
    "date": "2023-10-20",
    "title": "Latent Space Update",
    "desc": "Exploring the void. Found some weird artifacts.",
    "link": "https://x.com/mesoelfy/status/789012"
  }
]


