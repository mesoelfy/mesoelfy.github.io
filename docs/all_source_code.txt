+---------------------------------+
|      M E S O E L F Y _ O S      |
|   Next.js / R3F Source Context  |
+---------------------------------+
Generated on: Sat Dec  6 18:33:38 CST 2025

=====================================
PROJECT DIRECTORY STRUCTURE:
=====================================
.
â”œâ”€â”€ Icon\015
â”œâ”€â”€ README.md
â”œâ”€â”€ _MISC_IGNORE
â”‚Â Â  â”œâ”€â”€ 9776943-KKLCIZVI-7 copy.jpg
â”‚Â Â  â”œâ”€â”€ Generated Image September 28, 2025 - 3_04PM.png
â”‚Â Â  â”œâ”€â”€ Nintendo Game Boy Color.png
â”‚Â Â  â”œâ”€â”€ Nintendo Super Game Boy 2.png
â”‚Â Â  â”œâ”€â”€ Nintendo Super Game Boy.png
â”‚Â Â  â”œâ”€â”€ Screenshot 2023-10-28 at 10.41.26 AM copy.png
â”‚Â Â  â”œâ”€â”€ Sega Genesis.png
â”‚Â Â  â”œâ”€â”€ Sega Mega Drive.png
â”‚Â Â  â”œâ”€â”€ Sega Saturn.png
â”‚Â Â  â”œâ”€â”€ Update 2.0 - Sega Mega CD.png
â”‚Â Â  â”œâ”€â”€ background
â”‚Â Â  â”‚Â Â  â””â”€â”€ 2.jpg
â”‚Â Â  â”œâ”€â”€ cheap_cable copy.png
â”‚Â Â  â”œâ”€â”€ chrome-silver-question-mark copy.png
â”‚Â Â  â”œâ”€â”€ frosted-glass-green-triangle-render copy.png
â”‚Â Â  â””â”€â”€ https ::underkactuscard.carrd.co + three frame animations.png
â”œâ”€â”€ docs
â”‚Â Â  â”œâ”€â”€ MESOELFY_OS_AI_INSTRUCTIONS.md
â”‚Â Â  â”œâ”€â”€ TODO.md
â”‚Â Â  â””â”€â”€ all_source_code.txt
â”œâ”€â”€ next-env.d.ts
â”œâ”€â”€ next.config.js
â”œâ”€â”€ package.json
â”œâ”€â”€ postcss.config.js
â”œâ”€â”€ public
â”‚Â Â  â”œâ”€â”€ assets
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ audio
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ bg_music_placeholder.mp3
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ images
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ social-card.jpg
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ models
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ textures
â”‚Â Â  â”‚Â Â  â””â”€â”€ videos
â”‚Â Â  â””â”€â”€ favicon.ico
â”œâ”€â”€ scripts
â”‚Â Â  â””â”€â”€ create_source_context.command
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ app
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ layout.tsx
â”‚Â Â  â”‚Â Â  â””â”€â”€ page.tsx
â”‚Â Â  â”œâ”€â”€ core
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ audio
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ AudioSystem.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ hooks
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ math
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ store
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ useStore.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ utils
â”‚Â Â  â”œâ”€â”€ data
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ feed.json
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ gallery.json
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ identity.json
â”‚Â Â  â”‚Â Â  â””â”€â”€ socials.json
â”‚Â Â  â”œâ”€â”€ features
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ contact
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ ContactModal.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ effects
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ GlobalShakeManager.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ feed
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ FeedModal.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ gallery
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ GalleryModal.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ identity
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ AboutModal.tsx
â”‚Â Â  â”‚Â Â  â””â”€â”€ intro
â”‚Â Â  â”‚Â Â      â””â”€â”€ MatrixBootSequence.tsx
â”‚Â Â  â”œâ”€â”€ game
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameOverlay.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ BulletRenderer.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EffectsLayer.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EnemyBulletRenderer.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EnemyRenderer.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameDirector.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GlowRenderer.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ HunterChargeRenderer.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ParticleRenderer.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PlayerAvatar.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ProjectileTrails.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ScreenShaker.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ data
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ CombatComponent.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ HealthComponent.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ IdentityComponent.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ LifetimeComponent.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ MotionComponent.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ StateComponent.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ TransformComponent.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ config
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EnemyConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Identifiers.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PlayerConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ WorldConfig.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ core
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EntityFactory.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameBootstrapper.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameEngine.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ObjectPool.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ServiceLocator.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SpatialGrid.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ecs
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Component.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Entity.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EntityRegistry.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ types.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ interfaces.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ events
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameEventBus.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ GameEvents.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ hooks
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ usePanelRegistry.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ logic
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ ai
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ EnemyBehaviors.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ store
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ useGameStore.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ systems
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ BreachSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CameraSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CollisionSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EntitySystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ FXManager.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameStateSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ InputSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ InteractionSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PanelRegistrySystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PlayerSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TimeSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ UISyncSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ WaveSystem.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ theme.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ types
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ game.types.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ utils
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ GeometryUtils.ts
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ Noise.ts
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ TextureGen.ts
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ ViewportHelper.ts
â”‚Â Â  â”‚Â Â      â””â”€â”€ coords.ts
â”‚Â Â  â”œâ”€â”€ scene
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ canvas
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ SceneCanvas.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ effects
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ FireTransition.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ MatrixGrid.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ props
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ MiniCrystalCanvas.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ SoulCrystal.tsx
â”‚Â Â  â”‚Â Â  â””â”€â”€ shaders
â”‚Â Â  â”œâ”€â”€ styles
â”‚Â Â  â”‚Â Â  â””â”€â”€ globals.css
â”‚Â Â  â””â”€â”€ ui
â”‚Â Â      â”œâ”€â”€ atoms
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ CustomCursor.tsx
â”‚Â Â      â”‚Â Â  â””â”€â”€ GlassPanel.tsx
â”‚Â Â      â”œâ”€â”€ molecules
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ HoloCommLog.tsx
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ IdentityHUD.tsx
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ LiveArtGrid.tsx
â”‚Â Â      â”‚Â Â  â””â”€â”€ SocialRow.tsx
â”‚Â Â      â”œâ”€â”€ organisms
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ Footer.tsx
â”‚Â Â      â”‚Â Â  â””â”€â”€ Header.tsx
â”‚Â Â      â””â”€â”€ overlays
â”‚Â Â          â””â”€â”€ ModalContainer.tsx
â”œâ”€â”€ tailwind.config.ts
â””â”€â”€ tsconfig.json

53 directories, 118 files

=====================================
FILE: ./next.config.js
=====================================
/** @type {import('next').NextConfig} */

let commitHash = 'DEV_BUILD';

try {
  const { execSync } = require('child_process');
  commitHash = execSync('git rev-parse --short HEAD').toString().trim();
} catch (error) {
  console.warn('Warning: Could not determine git commit hash.');
}

const nextConfig = {
  output: 'export',
  images: {
    unoptimized: true,
  },
  reactStrictMode: true,
  transpilePackages: ['three'],
  
  // Disable Indicators
  devIndicators: false,


  
  env: {
    NEXT_PUBLIC_COMMIT_HASH: commitHash,
  },
  
  typescript: {
    ignoreBuildErrors: true,
  },
  eslint: {
    ignoreDuringBuilds: true,
  },
}

module.exports = nextConfig


=====================================
FILE: ./docs/TODO.md
=====================================
# MESOELFY_OS // REFACTOR ROADMAP

## ğŸŸ¢ COMPLETED 




## ğŸ”Š AUDIO ENGINEERING
*Goal: Professional mixing and dynamic sound control.*
- [ ] **Audio Bus System:** Create `GainNodes` for Master, Music, and SFX.
- [ ] **Ducking Logic:** Lower Music volume slightly when heavy SFX (Explosions) trigger.
- [ ] **Sound Pooling:** Prevent audio glitches by recycling Audio nodes.

## ğŸ–¥ UI & REACT INTEGRATION
*Goal: Seamless communication between the App and the Game.*
- [ ] **Transient Updates:** Refactor HUD (Health/XP) to bypass React State and update DOM directly for 60fps performance.
- [ ] **Viewport System:** Robust Screen-to-World mapping for resizing/mobile.
- [ ] **Mobile Controls:** Implement Virtual Joystick overlay for touch devices.
- [ ] **Touch Input:** Map touch events to the `InputSystem`.
- [ ] **Asset Loader:** Preload sounds/textures with a progress bar.
- [ ] **Debug Overlay:** FPS, Entity Count, Pool Usage stats toggle.
- [ ] **Settings Modal:** Volume sliders (Music/SFX) and Graphics Quality toggles.

## ğŸ FINAL POLISH & SHIP
- [ ] **Code Freeze & Lint:** Cleanup imports and unused files.
- [ ] **Deployment Check:** Verify GitHub Pages behavior.
- [ ] **Readme Update:** Documentation for future contributors.


## ğŸ› KNOWN BUGS
- [ ] **White Flash on Refresh (FOUC):** The 3D Canvas areas flash white briefly on page reload.
- [ ] **Mobile Controls:** Unplayable on mobile (Need Virtual Joystick).

## MISC THOUGHTS


- instead of just panel munchers (rename from seeker), what if there is also a muncher enemy that targets the elements within a panel such as each of the three video slots or each social media button, or the CONTACT and ABOUT ME buttons? What about an enemy type that enters a modal and does damage inside? Can that be coded for them to be moving around doing stuff even though we haven't instantiated the modal yet? How do we deal with the enemies on the MESOELFY_OS screen if we are inside a modal fighting some enemies? Wouldn't that have weird game logic? I need to brainstorm this with AI.
- need health for player and lives and powerups. (increase bullet size / rate of fire)
- need help seeing not obvious stuff that is missing.

- Kamekazi should be bigger and slow. If it blows up on player and is inside a panel, it does damage to that panel.

- What things does Vampire Survivors do that I should implement? Game design and juice.

- Should I have a high score patron screen where people can enter their name with links to whatever they want?

- Full functionality in the site isn't active immediately. the video slots and social media links could be broken until the first wave of munchers that are already there are dealt with. Maybe a power up that clears and heals the board is dropped?

bullet width upgrade lmited

- OPNE_SOURCE video overlay shouldn't be red, since that is for dangerous bad stuff - update design language -

we can skin the munchers/enemies differently as they get stronger with cool indicators including skins and animations of their pattern, and even glow or particles floating around them.

- We need a dramatic visual animation / indication signifying that a panel has reached 0% health like the system restored animation

- When opening modal, our game mouse cursor needs to be visible

- purple regen bar needs to slowly decay when user is not charging it

sharing https://mesoelfy.github.io/ needs to make an awesome twitter link capsule image.

- each upgrade needs its own bespoke icon that looks like what it does

- there could be "burrow" waves where they burrow into modal - - - and there can be a wave indicator in the header so you can keep track of when you need to go back

- hunter spinning animation needs fine tuning - - - hunter bullet needs to start at size 0 and then grow to full size before being launched at player - - - hunter movement logic needs updating, it feels kind of floaty and not menacing. I want it to feel intimidating.

- Game Over left most broken frame looks weird as broken - should retain full shape

- Power UP - Heal panel faster

=====================================
FILE: ./docs/MESOELFY_OS_AI_INSTRUCTIONS.md
=====================================
I am developing "MESOELFY_OS," a 3D interactive portfolio site with a Cyberpunk/Hacker/Demoscene aesthetic. 

I have attached "all_source_code.txt" which contains the full project tree and code. Please ingest this to understand the current architecture.

***CORE IDENTITY & AESTHETIC***
*   **Persona:** You are assisting "Elfy," a Latent Space Bandit. The vibe is Y2K Hacker, Matrix, Geometry Wars, and High-Tech Demoscene.
*   **Palette:** Electric Green (#78F654) is dominant. Deep Purple (#9E4EA5) is secondary. Red/Yellow for alerts. Black backgrounds.
*   **Current Status:** The site is live at `mesoelfy.github.io`. The "Intro Boot Sequence" and "Main Dashboard" are built and polished.

***TECHNICAL STACK***
*   **Framework:** Next.js 14 (App Router) + TypeScript.
*   **Styling:** Tailwind CSS + Framer Motion (for UI animations).
*   **3D:** React Three Fiber (R3F) + Drei.
*   **Deployment:** GitHub Pages (Static Export).

***WORKFLOW RULES (CRITICAL)***
1.  **Terminal Only:** Do not ask me to manually create files. Provide full terminal commands using `cat << 'EOF' > path/to/file` to create or overwrite files.
2.  **No Placeholders:** Unless specified, write complete, functional code.
3.  **Atomic Commits:** After a successful feature implementation, provide the specific `git add .`, `git commit -m "..."`, and `git push` commands.
4.  **Lean Ship:** Keep dependencies low. Prefer procedural generation (shaders/math) over large assets.

Working directory:
stevencasteel@Stevens-Mac-mini mesoelfy-site % 


Please acknowledge you have analyzed the codebase.

=====================================
FILE: ./next-env.d.ts
=====================================
/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


=====================================
FILE: ./README.md
=====================================
<div align="center">

```text
 â–ˆâ–ˆâ–ˆâ–„ â–„â–ˆâ–ˆâ–ˆâ–“â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–“      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–“â–ˆâ–ˆ   â–ˆâ–ˆâ–“
â–“â–ˆâ–ˆâ–’â–€â–ˆâ–€ â–ˆâ–ˆâ–’â–“â–ˆ   â–€â–’â–ˆâ–ˆ    â–’ â–’â–ˆâ–ˆâ–’  â–ˆâ–ˆâ–’â–“â–ˆ   â–€ â–“â–ˆâ–ˆâ–’    â–’â–“â–ˆ   â–’  â–’â–ˆâ–ˆ  â–ˆâ–ˆâ–’
â–“â–ˆâ–ˆ    â–“â–ˆâ–ˆâ–‘â–’â–ˆâ–ˆâ–ˆ  â–‘ â–“â–ˆâ–ˆâ–„   â–’â–ˆâ–ˆâ–‘  â–ˆâ–ˆâ–’â–’â–ˆâ–ˆâ–ˆ   â–’â–ˆâ–ˆâ–‘    â–’â–“â–ˆâ–ˆâ–ˆ â–‘   â–’â–ˆâ–ˆ â–ˆâ–ˆâ–‘
â–’â–ˆâ–ˆ    â–’â–ˆâ–ˆ â–’â–“â–ˆ  â–„  â–’   â–ˆâ–ˆâ–’â–’â–ˆâ–ˆ   â–ˆâ–ˆâ–‘â–’â–“â–ˆ  â–„ â–’â–ˆâ–ˆâ–‘    â–‘â–“â–ˆâ–’  â–‘   â–‘ â–â–ˆâ–ˆâ–‘â–‘
â–’â–ˆâ–ˆâ–’   â–‘â–ˆâ–ˆâ–’â–‘â–’â–ˆâ–ˆâ–ˆâ–ˆâ–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–‘ â–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–ˆâ–ˆâ–ˆâ–ˆâ–’â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–‘â–’â–ˆâ–‘      â–‘ â–ˆâ–ˆâ–’â–‘â–‘
â–‘ â–’â–‘   â–‘  â–‘â–‘â–‘ â–’â–‘ â–‘ â–’â–‘â–’  â–‘ â–‘ â–’â–‘â–’â–‘â–’â–‘ â–‘â–‘ â–’â–‘ â–‘â–‘ â–’â–‘â–’  â–‘ â–’ â–‘       â–ˆâ–ˆâ–’â–’â–’
â–‘  â–‘      â–‘ â–‘ â–‘  â–‘ â–‘ â–’  â–‘   â–‘ â–’ â–’â–‘  â–‘ â–‘  â–‘â–‘ â–‘ â–’  â–‘ â–‘       â–“â–ˆâ–ˆ â–‘â–’â–‘ 
â–‘      â–‘      â–‘    â–‘ â–‘    â–‘ â–‘ â–‘ â–’     â–‘     â–‘ â–‘    â–‘ â–‘     â–’ â–’ â–‘â–‘  
       â–‘      â–‘  â–‘   â–‘  â–‘     â–‘ â–‘     â–‘  â–‘    â–‘  â–‘         â–‘ â–‘     
```

### **LATENT SPACE BANDIT // DIGITAL HQ**

![System Status](https://img.shields.io/badge/SYSTEM-UNSECURE-ff003c?style=for-the-badge&logo=linux)
![Encryption](https://img.shields.io/badge/ENCRYPTION-BYPASSED-78F654?style=for-the-badge)
![Core](https://img.shields.io/badge/CORE-REACT_THREE_FIBER-9E4EA5?style=for-the-badge&logo=react)

</div>

---

### **// TRANSMISSION_LOG**

**MESOELFY_OS** is a generative 3D operating system disguised as a portfolio site. It serves as the central node for **Elfy**, a rogue entity manifesting art from the void.

The system features a custom "Latent Defense" protocol, audio-reactive interfaces, and a direct uplink to the neural network.

### **// SYSTEM_SPECS (Tech Stack)**

| MODULE | PAYLOAD |
| :--- | :--- |
| **Framework** | Next.js 14 (App Router) + TypeScript |
| **Graphics Core** | React Three Fiber (R3F) + Drei + Shaders |
| **Styling** | Tailwind CSS + Framer Motion |
| **Audio Engine** | Web Audio API (Generative Synthesis) |
| **Deployment** | GitHub Pages (Static Export) |

### **// BOOT_PROTOCOL (Installation)**

```bash
# 1. Clone the Repository
git clone https://github.com/mesoelfy/mesoelfy.github.io.git

# 2. Inject Dependencies
npm install

# 3. Initialize System (Dev Mode)
npm run dev
```

### **// IDENTITY_CORE**

*   **Class:** Latent Space Bandit
*   **Abilities:** Green Flame, Digital Heist, Prompt Craft
*   **Mission:** Create cool s**t. Annoy the haters.

---

<div align="center">
  <p><strong>âš  WARNING: TRANSMISSIONS ARE MONITORED BY THE AI OVERLORD. âš </strong></p>
  <a href="https://x.com/mesoelfy">[ TWITTER_UPLINK ]</a> â€¢ <a href="https://mesoelfy.github.io">[ LAUNCH_OS ]</a>
</div>

=====================================
FILE: ./tailwind.config.ts
=====================================
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './src/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        // --- BRAND CORE (Existing UI) ---
        elfy: {
          green: {
            light: '#7FF65F',
            DEFAULT: 'rgba(96, 196, 68, 1)',
            dim: '#1bb930ff',
            dark: '#217e10ff',
          },
          purple: {
            light: '#BC86BA',
            DEFAULT: '#9E4EA5',
            dim: '#822B8A',
            deep: '#350E3A',
          },
          yellow: {
            DEFAULT: '#eae747ff',
          },
          red: '#FF003C', 
          gray: '#27282A',
          black: '#050505',
        },
        
        // --- LATENT DEFENSE (Game Layer) ---
        // Bespoke values for fine-tuning without affecting UI
        game: {
          turret: {
            base: '#78F654', // Player color
            glow: '#C2FE9A',
          },
          bullet: {
            plasma: '#FFFFFF', 
            trail: '#78F654',
          },
          enemy: {
            seeker: '#9E4EA5', // Fast unit (Purple)
            eater: '#FF003C',  // Tank unit (Red)
            boss: '#F7D277',   // Boss unit (Yellow)
          },
          hud: {
            text: '#78F654',
            warning: '#FF003C',
          },
          vfx: {
            spark: '#FFFFFF',
            damage: '#FF003C',
          }
        }
      },
      fontFamily: {
        header: ['var(--font-montserrat)', 'sans-serif'],
        mono: ['Courier New', 'Courier', 'monospace'],
        tech: ['var(--font-jetbrains)', 'monospace'],
      },
      animation: {
        'spin-slow': 'spin 3s linear infinite',
        'spin-diamond': 'spin-diamond 3s linear infinite',
        'matrix-green': 'matrix-green 4s ease-in-out infinite',
        'matrix-purple': 'matrix-purple 2s ease-in-out infinite',
        'cursor-blink': 'cursor-blink 1.2s ease-in-out infinite',
      },
      keyframes: {
        'spin-diamond': {
          '0%': { transform: 'rotate(45deg)' },
          '100%': { transform: 'rotate(405deg)' },
        },
        'matrix-green': {
          '0%, 100%': { color: '#14630bff' },
          '50%': { color: '#0aa41cff' },
        },
        'matrix-purple': {
          '0%, 100%': { color: '#9E4EA5' }, 
          '33%': { color: '#BC86BA' },      
          '66%': { color: '#350E3A' },      
        },
        'cursor-blink': {
          '0%, 30%': { opacity: '1' }, 
          '50%': { opacity: '0' },     
          '100%': { opacity: '1' },    
        }
      }
    },
  },
  plugins: [],
}
export default config


=====================================
FILE: ./package.json
=====================================
{
  "name": "mesoelfy-site",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@react-three/drei": "^10.7.7",
    "@react-three/fiber": "^9.4.2",
    "@react-three/postprocessing": "^2.19.1",
    "clsx": "^2.1.0",
    "framer-motion": "^11.0.0",
    "lucide-react": "^0.300.0",
    "maath": "^0.10.0",
    "next": "^16.0.7",
    "react": "^19.2.1",
    "react-dom": "^19.2.1",
    "tailwind-merge": "^2.2.0",
    "three": "^0.181.2",
    "zustand": "^4.5.0"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@types/three": "^0.181.0",
    "autoprefixer": "^10.0.1",
    "eslint": "^9.39.1",
    "eslint-config-next": "^16.0.7",
    "postcss": "^8",
    "tailwindcss": "^3.3.0",
    "typescript": "^5"
  }
}


=====================================
FILE: ./tsconfig.json
=====================================
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./src/*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}


=====================================
FILE: ./postcss.config.js
=====================================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


=====================================
FILE: ./src/ui/molecules/SocialRow.tsx
=====================================
import { Twitter, Youtube, Github, Video, Crosshair, Image as ImageIcon } from 'lucide-react';
import socials from '@/data/socials.json';
import { AudioSystem } from '@/core/audio/AudioSystem';

const IconMap: Record<string, any> = {
  twitter: Twitter,
  youtube: Youtube,
  github: Github,
  video: Video,
  crosshair: Crosshair,
  image: ImageIcon,
};

export const SocialRow = () => {
  return (
    <div className="grid grid-cols-3 gap-2 h-full content-center py-2">
      {socials.map((social) => {
        const Icon = IconMap[social.icon] || Crosshair;
        return (
          <a
            key={social.name}
            href={social.url}
            target="_blank"
            rel="noopener noreferrer"
            onMouseEnter={() => AudioSystem.playHover()} // ADDED SFX
            onClick={() => AudioSystem.playClick()}      // ADDED SFX
            className="group flex flex-col items-center justify-center p-2 border border-elfy-green-dim/30 bg-black/40 hover:bg-elfy-green/10 hover:border-elfy-green transition-all duration-300"
          >
            <Icon 
              className="w-5 h-5 mb-1 text-elfy-green-dim group-hover:text-elfy-green group-hover:scale-110 transition-transform" 
              style={{ filter: 'drop-shadow(0 0 2px rgba(120,246,84,0.3))' }}
            />
            <span className="text-[10px] uppercase text-elfy-green-dim/60 group-hover:text-elfy-green tracking-wider font-mono">
              {social.name.split(' ')[0]}
            </span>
          </a>
        );
      })}
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/HoloCommLog.tsx
=====================================
import { useEffect, useState, useRef, useCallback } from 'react';
import { ExternalLink, Radio, WifiOff } from 'lucide-react';
import { useGameStore } from '@/game/store/useGameStore';

const VIDEO_POOL = [
  "oLALHbB3iXU", "A1dnxXrpN-o", "elyXcwunIYA", 
  "bHUcvHx9zlA", "Eq6EYcpWB_c", "sJyWgks1ZtA", 
  "dFlDRhvM4L0", "Ku5fgOHy1JY", "8-91y7BJ8QA"
];

const OfflineStatic = () => (
  <div className="absolute inset-0 z-[100] bg-black flex flex-col items-center justify-center border border-elfy-red/20 overflow-hidden w-full h-full">
    <div className="absolute inset-0 bg-[url('https://media.giphy.com/media/oEI9uBYSzLpBK/giphy.gif')] opacity-40 bg-cover mix-blend-screen pointer-events-none" />
    <div className="relative z-10 animate-pulse text-elfy-red font-mono text-[10px] bg-black/80 px-2 py-1 flex items-center gap-2">
        <WifiOff size={12} />
        <span>SIGNAL_LOST</span>
    </div>
  </div>
);

const VideoSlot = ({ 
  slotIndex, 
  initialVideo, 
  getNextVideo
}: { 
  slotIndex: number, 
  initialVideo: string, 
  getNextVideo: () => string
}) => {
  const [videoId, setVideoId] = useState(initialVideo);
  const [isMasked, setIsMasked] = useState(true);

  // DIRECT STORE ACCESS
  const panelState = useGameStore((state) => state.panels['video']);
  const isOffline = panelState ? (panelState.isDestroyed || panelState.health <= 0) : false;

  useEffect(() => {
    if (isOffline) {
        // RESET MASK INSTANTLY so it's ready for the reveal when power comes back
        setIsMasked(true);
    } else {
        // If coming online (and masked is true), start the reveal sequence
        const unmaskTimer = setTimeout(() => setIsMasked(false), 2000);
        return () => clearTimeout(unmaskTimer);
    }
  }, [isOffline]); 

  // Auto-rotate videos logic
  useEffect(() => {
    if (isOffline) return;
    const duration = 30000 + (Math.random() * 15000);
    const timer = setTimeout(() => {
      setIsMasked(true);
      setTimeout(() => {
        const next = getNextVideo();
        if (next) setVideoId(next);
        setTimeout(() => setIsMasked(false), 2000);
      }, 1000); 
    }, duration);
    return () => clearTimeout(timer);
  }, [videoId, getNextVideo, isOffline]);

  return (
    <div className="relative w-full aspect-video min-h-[140px] md:min-h-0 border border-elfy-red/30 bg-black overflow-hidden group/video hover:border-elfy-red hover:shadow-[0_0_15px_rgba(255,0,60,0.3)] transition-all">
      
      {isOffline && <OfflineStatic />}

      {!isOffline && (
        <>
          <div className="absolute inset-0 z-10">
            <iframe 
              width="100%" 
              height="100%" 
              src={`https://www.youtube.com/embed/${videoId}?autoplay=1&mute=1&controls=0&showinfo=0&modestbranding=1&loop=1&playlist=${videoId}&vq=small`} 
              title="HOLO_COMM" 
              frameBorder="0" 
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
              className="w-full h-full object-cover grayscale"
            />
          </div>

          <div className="absolute inset-0 z-30 pointer-events-none bg-[linear-gradient(rgba(0,0,0,0)_50%,rgba(0,0,0,0.25)_50%)] bg-[length:100%_4px]" />
          
          <div className={`absolute inset-0 z-40 transition-opacity duration-500 flex items-center justify-center pointer-events-none ${isMasked ? 'opacity-100 bg-black' : 'opacity-0 group-hover/video:opacity-100 bg-black/40'}`}>
             {isMasked ? (
                <div className="flex flex-col items-center">
                    <Radio className="text-elfy-red animate-pulse w-6 h-6 mb-2" />
                    <span className="text-[10px] font-mono text-elfy-red animate-pulse">ESTABLISHING_UPLINK...</span>
                </div>
             ) : (
                 <div className="flex items-center gap-2 text-elfy-red font-mono font-bold bg-black/80 px-3 py-1 border border-elfy-red rounded-sm pointer-events-auto">
                    <span>OPEN_SOURCE</span>
                    <ExternalLink size={12} />
                 </div>
             )}
          </div>
          
          {!isMasked && (
              <a 
                href={`https://www.youtube.com/watch?v=${videoId}`}
                target="_blank"
                rel="noopener noreferrer"
                className="absolute inset-0 z-50 cursor-pointer"
                aria-label="Watch on YouTube"
              />
          )}

          <div className="absolute bottom-1 right-1 z-[60] text-[8px] text-elfy-red font-mono bg-black/80 px-1 pointer-events-none">
             CAM_0{slotIndex + 1}
          </div>
        </>
      )}

      {isOffline && (
          <div className="absolute bottom-1 right-1 z-[110] text-[8px] text-elfy-red font-mono bg-black/80 px-1 pointer-events-none">
             CAM_0{slotIndex + 1} [ERR]
          </div>
      )}
    </div>
  );
};

export const HoloCommLog = () => {
  const deckRef = useRef<string[]>([...VIDEO_POOL]);
  const [initialVideos, setInitialVideos] = useState<string[] | null>(null);

  useEffect(() => {
    deckRef.current = [...VIDEO_POOL];
    const init: string[] = [];
    for(let i=0; i<3; i++) {
      const randomIndex = Math.floor(Math.random() * deckRef.current.length);
      const vid = deckRef.current[randomIndex];
      deckRef.current.splice(randomIndex, 1);
      init.push(vid);
    }
    setInitialVideos(init);
  }, []);

  const getNextVideo = useCallback(() => {
    if (deckRef.current.length === 0) deckRef.current = [...VIDEO_POOL];
    const randomIndex = Math.floor(Math.random() * deckRef.current.length);
    const selected = deckRef.current[randomIndex];
    deckRef.current.splice(randomIndex, 1);
    return selected || VIDEO_POOL[0];
  }, []);

  if (!initialVideos) return <div className="h-full bg-black" />;

  return (
    <div className="flex flex-col h-full gap-2 overflow-hidden p-1 justify-center">
      {initialVideos.map((vid, i) => (
        <VideoSlot 
          key={i} 
          slotIndex={i} 
          initialVideo={vid} 
          getNextVideo={getNextVideo}
        />
      ))}
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/LiveArtGrid.tsx
=====================================
import { useEffect, useState } from 'react';
import { useStore } from '@/core/store/useStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { motion, AnimatePresence } from 'framer-motion';

const randomId = () => Math.floor(Math.random() * 899) + 100;

export const LiveArtGrid = () => {
  const { openModal } = useStore();
  const [slots, setSlots] = useState<number[]>([]);

  useEffect(() => {
    setSlots(Array.from({ length: 12 }, randomId));

    const interval = setInterval(() => {
      setSlots(prev => {
        const newSlots = [...prev];
        const randomIndex = Math.floor(Math.random() * 12);
        newSlots[randomIndex] = randomId();
        return newSlots;
      });
    }, 800);

    return () => clearInterval(interval);
  }, []);

  return (
    <div className="grid grid-cols-3 gap-1 w-full p-2 content-start">
      <AnimatePresence mode='popLayout'>
        {slots.map((id, index) => (
          <motion.button
            key={`${index}-${id}`}
            layout
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.2 }}
            
            onClick={() => openModal('gallery')}
            onMouseEnter={() => AudioSystem.playHover()} // ADDED SFX
            
            className="w-full aspect-square relative bg-black/50 border border-elfy-green-dim/30 hover:border-elfy-yellow hover:shadow-[0_0_10px_rgba(247,210,119,0.2)] group overflow-hidden flex items-center justify-center rounded-[1px]"
          >
            <div className="absolute inset-0 bg-elfy-green/5 group-hover:bg-elfy-green/10 transition-colors" />
            
            <span className="relative z-10 text-[9px] font-mono text-elfy-green-dim group-hover:text-elfy-yellow transition-colors">
              IMG_{id}
            </span>

            <div className="absolute top-0 right-0 w-1.5 h-1.5 border-t border-r border-elfy-green-dim/50 group-hover:border-elfy-yellow" />
          </motion.button>
        ))}
      </AnimatePresence>
    </div>
  );
};


=====================================
FILE: ./src/ui/molecules/IdentityHUD.tsx
=====================================
import { MiniCrystalCanvas } from '@/scene/props/MiniCrystalCanvas';
import { useGameStore, UpgradeOption } from '@/game/store/useGameStore';
import identity from '@/data/identity.json';
import { useStore } from '@/core/store/useStore'; 
import { AudioSystem } from '@/core/audio/AudioSystem';
import { Unplug, Zap, AlertCircle } from 'lucide-react';

export const IdentityHUD = () => {
  const { openModal } = useStore();
  
  const hp = useGameStore(s => s.playerHealth);
  const maxHp = useGameStore(s => s.maxPlayerHealth);
  const xp = useGameStore(s => s.xp);
  const nextXp = useGameStore(s => s.xpToNextLevel);
  const level = useGameStore(s => s.level);
  
  const upgradePoints = useGameStore(s => s.upgradePoints);
  const selectUpgrade = useGameStore(s => s.selectUpgrade);
  const rebootProgress = useGameStore(s => s.playerRebootProgress);
  
  const panel = useGameStore(s => s.panels['identity']);
  const isPanelDead = panel ? panel.isDestroyed : false;
  const isPlayerDead = hp <= 0;

  const hpPercent = Math.max(0, (hp / maxHp) * 100);
  const xpPercent = Math.min(100, (xp / nextXp) * 100);

  const size = 160; 
  const center = size / 2;
  const radiusHp = 60;
  const radiusXp = 70;
  const stroke = 4;
  
  const circHp = 2 * Math.PI * radiusHp;
  const circXp = 2 * Math.PI * radiusXp;

  const displayHpPercent = isPlayerDead ? rebootProgress : hpPercent;
  const displayHpColor = isPlayerDead ? "#eae747" : (hpPercent < 30 ? "#FF003C" : "#78F654"); 

  const offsetHp = circHp - (displayHpPercent / 100 * circHp);
  const offsetXp = circXp - (xpPercent / 100 * circXp);

  const availableOptions: UpgradeOption[] = ['RAPID_FIRE', 'MULTI_SHOT', 'SPEED_UP', 'REPAIR_NANITES'];

  const handleUpgrade = (u: UpgradeOption) => {
      if (isPanelDead || isPlayerDead) return; 
      AudioSystem.playClick();
      selectUpgrade(u);
  };

  return (
    <div className={`flex flex-col items-center h-full w-full relative ${isPanelDead ? 'grayscale opacity-50 pointer-events-none' : ''}`}>
      
      {/* 1. THE AVATAR (Top) */}
      <div className="relative w-32 h-32 md:w-40 md:h-40 shrink-0 mt-2 group mb-6"> {/* Added margin bottom to clear badge */}
        
        {/* AVATAR LAYER */}
        <div className={`absolute inset-0 rounded-full bg-black/50 overflow-hidden transition-opacity duration-500 ${isPlayerDead ? 'opacity-60 grayscale' : 'opacity-100'}`}>
           <MiniCrystalCanvas />
        </div>

        {/* REBOOT INDICATOR (Center Text) */}
        {isPlayerDead && (
            <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                {rebootProgress > 0 ? (
                    <span className="text-2xl font-header font-black text-elfy-yellow drop-shadow-md animate-pulse">
                        {Math.floor(rebootProgress)}%
                    </span>
                ) : (
                    <div className="animate-pulse">
                        <Unplug className="text-white/50 w-8 h-8" />
                    </div>
                )}
            </div>
        )}

        {/* HUD RINGS */}
        <svg className="absolute inset-0 w-full h-full -rotate-90 pointer-events-none" viewBox={`0 0 ${size} ${size}`}>
          <circle cx={center} cy={center} r={radiusHp} stroke="#1a1a1a" strokeWidth={stroke} fill="transparent" />
          <circle cx={center} cy={center} r={radiusXp} stroke="#1a1a1a" strokeWidth={stroke} fill="transparent" strokeDasharray="4 4" />
          
          <circle 
            cx={center} cy={center} r={radiusHp} 
            stroke={displayHpColor} 
            strokeWidth={stroke} fill="transparent"
            strokeDasharray={circHp}
            strokeDashoffset={offsetHp}
            strokeLinecap="round"
            className="transition-all duration-100 ease-linear"
          />
          <circle 
            cx={center} cy={center} r={radiusXp} 
            stroke="#9E4EA5" 
            strokeWidth={stroke} fill="transparent"
            strokeDasharray={circXp}
            strokeDashoffset={offsetXp}
            strokeLinecap="round"
            className="transition-all duration-500 ease-out"
          />
        </svg>

        {/* Level Badge - MOVED LOWER (bottom: -16px) */}
        <div className="absolute -bottom-4 left-1/2 -translate-x-1/2 bg-black border border-elfy-purple text-elfy-purple px-3 py-0.5 text-[10px] font-bold font-mono rounded-full shadow-[0_0_10px_rgba(158,78,165,0.4)] z-20">
          LVL_{level}
        </div>
      </div>

      {/* 2. INFO & UPGRADES (Middle) */}
      <div className="flex-1 flex flex-col justify-center items-center w-full gap-2 py-1 min-h-0">
        
        {isPlayerDead && !isPanelDead ? (
            <div className="bg-black/80 border border-elfy-yellow/50 px-4 py-2 rounded animate-pulse text-center relative z-50">
                <div className="flex items-center justify-center gap-2 text-elfy-yellow font-bold text-xs mb-1">
                    <Zap size={14} />
                    <span>SYSTEM CRITICAL</span>
                </div>
                <p className="text-[9px] text-white font-mono">HOLD TO REBOOT</p>
                <p className="text-[8px] text-elfy-red mt-1 font-bold">TAKING DAMAGE DRAINS POWER</p>
            </div>
        ) : (
            <div className="text-center">
              <h2 className="text-2xl font-header font-black text-elfy-green tracking-wider">{identity.name}</h2>
              <div className="text-[9px] text-elfy-purple-light uppercase tracking-widest opacity-80">{identity.class}</div>
            </div>
        )}

        {/* UPGRADE MODULE (Stacking) */}
        {upgradePoints > 0 && !isPlayerDead && (
          <div className="w-full bg-elfy-purple-deep/40 border border-elfy-purple/50 p-1.5 rounded-sm pointer-events-auto z-50 animate-pulse">
            <div className="flex items-center justify-center gap-2 mb-1">
                <AlertCircle size={10} className="text-elfy-green" />
                <div className="text-[9px] text-white text-center font-bold tracking-widest">
                  UPGRADE AVAILABLE ({upgradePoints})
                </div>
            </div>
            
            <div className="grid grid-cols-2 gap-1">
              {availableOptions.map(u => (
                <button 
                  key={u}
                  className={`text-[8px] bg-elfy-purple/20 border border-elfy-purple/50 text-elfy-green font-mono py-1 transition-colors uppercase ${isPanelDead ? 'cursor-not-allowed text-gray-500' : 'hover:bg-elfy-purple hover:text-white'}`}
                  onMouseEnter={() => !isPanelDead && AudioSystem.playHover()}
                  onClick={() => handleUpgrade(u)}
                >
                  {u.replace('_', ' ')}
                </button>
              ))}
            </div>
          </div>
        )}
      </div>

      {/* 3. NAVIGATION */}
      <div className="w-full grid grid-cols-2 gap-3 mt-auto pt-2 border-t border-elfy-green-dim/10">
        <button 
          onClick={() => !isPanelDead && openModal('about')} 
          onMouseEnter={() => !isPanelDead && AudioSystem.playHover()}
          className="py-2 bg-elfy-purple-deep/20 border border-elfy-purple text-elfy-purple-light hover:bg-elfy-purple hover:text-black transition-all font-bold text-xs font-header uppercase clip-corner-btn"
        >
          About
        </button>
        <button 
          onClick={() => !isPanelDead && openModal('contact')} 
          onMouseEnter={() => !isPanelDead && AudioSystem.playHover()}
          className="py-2 bg-elfy-yellow/5 border border-elfy-yellow text-elfy-yellow hover:bg-elfy-yellow hover:text-black transition-all font-bold text-xs font-header uppercase clip-corner-btn"
        >
          Contact
        </button>
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/atoms/CustomCursor.tsx
=====================================
import { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useStore } from '@/core/store/useStore';
import { clsx } from 'clsx';

export const CustomCursor = () => {
  const [pos, setPos] = useState({ x: 0, y: 0 });
  const [isHovering, setIsHovering] = useState(false);
  const [isClicking, setIsClicking] = useState(false);
  
  const { introDone } = useStore();

  useEffect(() => {
    const move = (e: MouseEvent) => {
      setPos({ x: e.clientX, y: e.clientY });
      
      const target = e.target as HTMLElement;
      // Hover triggers on buttons, inputs, links
      const isInteractive = target.closest('button, a, input, [data-interactive="true"]');
      setIsHovering(!!isInteractive);
    };

    const down = () => setIsClicking(true);
    const up = () => setIsClicking(false);

    window.addEventListener('mousemove', move);
    window.addEventListener('mousedown', down);
    window.addEventListener('mouseup', up);

    return () => {
      window.removeEventListener('mousemove', move);
      window.removeEventListener('mousedown', down);
      window.removeEventListener('mouseup', up);
    };
  }, []);

  return (
    <>
      <style jsx global>{`
        body, a, button, input { cursor: none !important; }
      `}</style>

      <motion.div
        className={clsx(
            "fixed top-0 left-0 pointer-events-none z-[9999]",
            // FIX: Only apply difference blend mode when hovering interactive elements
            isHovering ? "mix-blend-difference" : "" 
        )}
        animate={{ x: pos.x, y: pos.y }}
        transition={{ type: "tween", ease: "linear", duration: 0 }}
      >
        <AnimatePresence mode="wait">
          {!introDone && (
            <motion.div
              key="intro-cursor"
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              transition={{ duration: 0.5 }}
              className="relative"
            >
              <svg 
                width="24" 
                height="24" 
                viewBox="0 0 24 24" 
                className={`transition-transform duration-100 ${isClicking ? 'scale-90' : 'scale-100'}`}
                style={{ 
                    filter: isHovering ? 'drop-shadow(0 0 12px #eae747)' : 'drop-shadow(0 0 8px #78F654)',
                    fill: isHovering ? '#eae747' : '#78F654'
                }}
              >
                <path d="M5.5 3.21l12.32 12.32-4.5 1.12 3.5 3.5-2.12 2.12-3.5-3.5-1.12 4.5z" />
              </svg>
            </motion.div>
          )}
        </AnimatePresence>
      </motion.div>
    </>
  );
};


=====================================
FILE: ./src/ui/atoms/GlassPanel.tsx
=====================================
import { clsx } from 'clsx';
import { motion, AnimatePresence } from 'framer-motion';
import { ReactNode } from 'react';
import { usePanelRegistry } from '@/game/hooks/usePanelRegistry';
import { useGameStore } from '@/game/store/useGameStore';
import { ChevronUp, Skull, Power } from 'lucide-react';
import { useEffect as useReactEffect, useState as useReactState, useRef as useReactRef } from 'react';

// --- CONSTANTS ---
const MAX_HEALTH = 1000;

// --- SUB-COMPONENTS ---

const RebootOverlay = () => (
  <motion.div 
    initial={{ opacity: 0, scale: 0.8 }}
    animate={{ opacity: 1, scale: 1 }}
    exit={{ opacity: 0, scale: 1.1, filter: "blur(10px)" }}
    transition={{ duration: 0.4, ease: "backOut" }}
    className="absolute inset-0 z-[60] flex items-center justify-center bg-black/80 backdrop-blur-[2px]"
  >
    <div className="flex flex-col items-center gap-2 border-y-2 border-elfy-green bg-elfy-green/10 w-full py-4 relative overflow-hidden">
      <motion.div 
        className="absolute top-0 left-0 w-full h-full bg-gradient-to-b from-transparent via-elfy-green/20 to-transparent"
        animate={{ top: ["-100%", "100%"] }}
        transition={{ duration: 1.5, ease: "linear", repeat: Infinity }}
      />
      <div className="relative z-10 flex items-center gap-3">
        <motion.div
          initial={{ rotate: -180, scale: 0 }}
          animate={{ rotate: 0, scale: 1 }}
          transition={{ type: "spring", stiffness: 200, delay: 0.1 }}
        >
            <Power className="text-elfy-green w-8 h-8 md:w-10 md:h-10" />
        </motion.div>
        <div className="flex flex-col">
            <motion.span 
                initial={{ x: 20, opacity: 0 }}
                animate={{ x: 0, opacity: 1 }}
                transition={{ delay: 0.2 }}
                className="text-2xl md:text-3xl font-header font-black text-elfy-green tracking-widest italic"
            >
                SYSTEM
            </motion.span>
            <motion.span 
                initial={{ x: -20, opacity: 0 }}
                animate={{ x: 0, opacity: 1 }}
                transition={{ delay: 0.3 }}
                className="text-xs md:text-sm font-mono font-bold text-elfy-green-dim tracking-[0.3em]"
            >
                RESTORED
            </motion.span>
        </div>
      </div>
    </div>
  </motion.div>
);

const ScrollingRow = ({ direction, text }: { direction: number, text: string }) => {
  return (
    <div className="flex whitespace-nowrap overflow-hidden select-none opacity-60">
      <motion.div 
        className="flex gap-4 font-header font-black text-xl md:text-2xl text-elfy-red tracking-widest uppercase py-1"
        animate={{ x: direction === 1 ? ["-50%", "0%"] : ["0%", "-50%"] }} 
        transition={{ duration: 40, repeat: Infinity, ease: "linear" }}
      >
        {Array.from({ length: 12 }).map((_, i) => (
          <span key={i} className={i % 2 === 0 ? "text-elfy-red" : "text-transparent stroke-elfy-red stroke-1"}>
             {text}
          </span>
        ))}
      </motion.div>
    </div>
  );
};

const BreachOverlay = ({ progress, isVideo }: { progress: number, isVideo: boolean }) => {
  return (
    <div className={clsx(
        "absolute inset-0 z-[70] flex flex-col items-center justify-center overflow-hidden backdrop-blur-sm",
        // FIX: If it's the video panel, make background fully transparent so static is visible.
        isVideo ? "bg-transparent" : "bg-black/90"
    )}>
        <div className="absolute inset-[-50%] flex flex-col justify-center rotate-[-12deg] opacity-30 pointer-events-none">
            <motion.div
               className="flex flex-col gap-8"
               animate={{ y: ["0%", "-50%"] }}
               transition={{ duration: 30, repeat: Infinity, ease: "linear" }}
            >
                {[0, 1].map((set) => (
                    <div key={set} className="flex flex-col gap-8">
                        {Array.from({ length: 6 }).map((_, i) => (
                            <ScrollingRow 
                                key={`${set}-${i}`} 
                                direction={i % 2 === 0 ? 1 : -1} 
                                text="SYSTEM BREACH // CRITICAL FAILURE // REBOOT REQUIRED //" 
                            />
                        ))}
                    </div>
                ))}
            </motion.div>
        </div>

        <div className="relative z-20 flex flex-col items-center justify-center gap-2 cursor-crosshair transition-all duration-100">
            <div className="relative">
                <div className="group-hover:opacity-0 transition-opacity duration-200 absolute inset-0 flex items-center justify-center">
                    <motion.div 
                        animate={{ y: [0, -10, 0] }}
                        transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }}
                        className="text-elfy-red drop-shadow-md"
                    >
                        <ChevronUp size={64} strokeWidth={3} />
                    </motion.div>
                </div>

                <div className="opacity-0 group-hover:opacity-100 transition-opacity duration-200 absolute inset-0 flex items-center justify-center -translate-y-8">
                    <motion.div 
                        animate={{ scale: [1, 1.2, 1], filter: ["brightness(1)", "brightness(1.5)", "brightness(1)"] }}
                        transition={{ duration: 0.2, repeat: Infinity, ease: "easeInOut" }}
                        className="text-elfy-purple drop-shadow-[0_0_15px_#9E4EA5]"
                    >
                        <ChevronUp size={64} strokeWidth={4} />
                    </motion.div>
                </div>
                
                <div className="w-16 h-16 pointer-events-none opacity-0"><ChevronUp size={64} /></div>
            </div>

            <div className="flex flex-col items-center text-center">
                <span className="text-sm font-header font-black tracking-widest text-elfy-red group-hover:text-elfy-purple transition-colors duration-200 drop-shadow-md">
                    HOLD TO REBOOT
                </span>
                
                <div className="w-32 bg-gray-900/80 h-1.5 mt-2 rounded-full overflow-hidden border border-gray-700 shadow-lg">
                    <motion.div 
                        className="h-full bg-elfy-purple shadow-[0_0_10px_#9E4EA5]" 
                        initial={{ width: 0 }}
                        animate={{ width: `${progress}%` }}
                        transition={{ type: "tween", duration: 0.1 }}
                    />
                </div>
                
                <div className="text-[10px] font-mono text-elfy-purple font-bold mt-1 opacity-0 group-hover:opacity-100 transition-opacity bg-black/60 px-2 rounded">
                    INTEGRITY: {Math.floor(progress)}%
                </div>
            </div>
        </div>
    </div>
  );
};

// --- MAIN COMPONENT ---

interface GlassPanelProps {
  children: ReactNode;
  className?: string;
  title?: string;
  gameId?: string; 
  suppressOfflineOverlay?: boolean;
}

const panelVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { 
    opacity: 1, 
    y: 0,
    transition: { duration: 0.5, ease: "easeOut" }
  },
  shattered: (custom: number) => ({
    y: 350 + (custom * 50),
    opacity: 0.8,
    rotate: custom * 15,
    transition: { 
        duration: 1.5, 
        ease: "anticipate",
        delay: Math.abs(custom) * 0.1 
    }
  })
};

export const GlassPanel = ({ children, className, title, gameId }: GlassPanelProps) => {
  const registryRef = gameId ? usePanelRegistry(gameId) : null;
  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const isGameOver = Math.floor(systemIntegrity) <= 0;
  const panelState = useGameStore((state) => gameId ? state.panels[gameId] : null);

  const health = panelState ? panelState.health : MAX_HEALTH;
  const isDestroyed = panelState ? panelState.isDestroyed : false;
  const healthPercent = (health / MAX_HEALTH) * 100; 
  const isDamaged = health < MAX_HEALTH;
  const isCritical = !isDestroyed && health < (MAX_HEALTH * 0.3);

  const [showReboot, setShowReboot] = useReactState(false);
  const prevDestroyed = useReactRef(isDestroyed);

  useReactEffect(() => {
    if (prevDestroyed.current && !isDestroyed) {
        setShowReboot(true);
        const timer = setTimeout(() => setShowReboot(false), 2000); 
        return () => clearTimeout(timer);
    }
    prevDestroyed.current = isDestroyed;
  }, [isDestroyed]);

  let borderColor = "border-elfy-green-dim/30";
  if (isDestroyed) borderColor = "border-elfy-red animate-pulse"; 
  else if (isCritical) borderColor = "border-elfy-red/80 animate-pulse";
  else if (isDamaged) borderColor = "border-elfy-yellow/50";

  let barColor = "bg-elfy-green";
  if (isDestroyed) barColor = "bg-elfy-purple"; 
  else if (healthPercent < 30) barColor = "bg-elfy-red";
  else if (healthPercent < 60) barColor = "bg-elfy-yellow";

  const randSeed = (title?.length || 5) % 2 === 0 ? 1 : -1;
  const greenCircleClass = isDestroyed ? "border border-elfy-green" : "bg-elfy-green";
  const purpleCircleClass = isDestroyed ? "bg-elfy-purple" : "border border-elfy-purple-dim";

  return (
    <motion.div 
      ref={registryRef}
      variants={panelVariants}
      initial="hidden"
      animate={isGameOver ? "shattered" : "visible"}
      custom={randSeed}
      className={clsx(
        "relative overflow-hidden flex flex-col group",
        "bg-black border",
        borderColor, 
        "shadow-[0_0_15px_rgba(11,212,38,0.05)]", 
        "rounded-sm",
        className
      )}
    >
      <div className="absolute inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(10,10,10,0.4)_50%)] z-0 bg-[length:100%_4px]" />
      
      {title && (
        <div className="relative flex flex-col border-b border-elfy-green-dim/30 bg-elfy-green-dark/20 shrink-0 z-10">
          <div className="flex items-center justify-between px-3 py-1">
            <span className="text-sm md:text-base font-header font-bold text-elfy-green uppercase tracking-wider drop-shadow-md">
              {title}
            </span>
            <div className="flex gap-1">
              <div className={`w-2 h-2 rounded-full ${greenCircleClass}`} />
              <div className={`w-2 h-2 rounded-full ${purpleCircleClass}`} />
            </div>
          </div>
          {gameId && (
            <div className="w-full h-1 bg-black/50">
              <motion.div 
                className={clsx("h-full transition-colors duration-200", barColor)}
                initial={{ width: "100%" }}
                animate={{ width: `${healthPercent}%` }}
                transition={{ type: "tween", ease: "easeOut", duration: 0.1 }}
              />
            </div>
          )}
        </div>
      )}

      <div className="relative z-10 p-4 h-full">
        {isDestroyed && !isGameOver && (
            <BreachOverlay progress={healthPercent} isVideo={gameId === 'video'} />
        )}

        <AnimatePresence>
            {showReboot && <RebootOverlay key="reboot" />}
        </AnimatePresence>
        
        {isGameOver && (
            <div className="absolute inset-0 z-[100] bg-black/90 flex flex-col items-center justify-center gap-4">
                <Skull className="text-elfy-red animate-pulse w-20 h-20" />
                <span className="text-elfy-red font-header font-black text-2xl tracking-widest">SYSTEM FAILURE</span>
            </div>
        )}
        
        {children}
      </div>
    </motion.div>
  );
};


=====================================
FILE: ./src/ui/overlays/ModalContainer.tsx
=====================================
import { useStore } from '@/core/store/useStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { motion, AnimatePresence } from 'framer-motion';
import { X } from 'lucide-react';

interface ModalContainerProps {
  children: React.ReactNode;
  title: string;
  type: string;
}

export const ModalContainer = ({ children, title, type }: ModalContainerProps) => {
  const { activeModal, closeModal } = useStore();
  const isOpen = activeModal === type;

  return (
    <AnimatePresence>
      {isOpen && (
        // FIX: Bumped z-index to 100 to stay above GameOverlay (z-60)
        <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 md:p-10">
          
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={closeModal}
            className="absolute inset-0 bg-black/80 backdrop-blur-sm cursor-pointer"
          />

          <motion.div
            initial={{ scale: 0.9, opacity: 0, y: 20 }}
            animate={{ scale: 1, opacity: 1, y: 0 }}
            exit={{ scale: 0.95, opacity: 0, y: 10 }}
            transition={{ type: "spring", bounce: 0, duration: 0.3 }}
            className="relative w-full max-w-5xl h-full max-h-[90vh] bg-black border border-elfy-green/50 shadow-[0_0_50px_rgba(0,255,65,0.1)] flex flex-col overflow-hidden"
          >
            <div className="flex items-center justify-between px-4 py-3 bg-elfy-green/10 border-b border-elfy-green/30">
              <div className="flex items-center gap-2">
                <div className="w-3 h-3 bg-elfy-red rounded-full animate-pulse" />
                <span className="font-header font-black text-elfy-green text-lg md:text-xl tracking-widest">
                  {title}
                </span>
              </div>
              <button 
                onClick={closeModal}
                onMouseEnter={() => AudioSystem.playHover()} 
                className="p-1 hover:bg-elfy-red hover:text-black text-elfy-green transition-colors"
              >
                <X />
              </button>
            </div>

            <div className="flex-1 overflow-auto p-6 relative scrollbar-thin scrollbar-thumb-elfy-green scrollbar-track-black">
              <div className="absolute inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.1)_50%)] bg-[length:100%_4px] opacity-20" />
              <div className="relative z-10">
                {children}
              </div>
            </div>

            <div className="px-4 py-1 bg-black border-t border-elfy-green/30 text-xs text-elfy-green-dim font-mono text-right">
              MODE: SECURE // ENCRYPTION: ENABLED
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/organisms/Footer.tsx
=====================================
export const Footer = () => {
  const commitHash = process.env.NEXT_PUBLIC_COMMIT_HASH || 'UNKNOWN';
  const actionsUrl = "https://github.com/mesoelfy/mesoelfy.github.io/actions";

  return (
    <footer className="w-full h-10 border-t border-elfy-green-dim/30 bg-black flex items-center justify-between px-4 z-40 shrink-0 text-[10px] text-elfy-green-dim font-mono">
      <div className="flex items-center gap-2">
        {/* Static Label */}
        <span>BUILD_VER:</span>
        
        {/* Interactive Link */}
        <a 
          href={actionsUrl}
          target="_blank" 
          rel="noopener noreferrer"
          className="text-elfy-green-dim hover:text-elfy-green transition-colors cursor-pointer group"
        >
          [
          {/* Underline only applies to the internal span on hover */}
          <span className="group-hover:underline decoration-dashed decoration-elfy-green underline-offset-2">
            {commitHash}
          </span>
          ]
        </a>
        
        <span>//</span>
        
        <span className="text-elfy-red font-bold animate-pulse">STATUS: UNSAFE // MONITORING</span>
      </div>

      <div className="flex items-center gap-2">
        <span>LATENT_CORE:</span>
        <div className="w-4 h-4 flex items-center justify-center">
          {/* Yellow border/bg, Green Shadow, Custom Diamond Spin */}
          <div className="w-2.5 h-2.5 border border-elfy-yellow bg-elfy-yellow/20 animate-spin-diamond shadow-[0_0_8px_#78F654]" />
        </div>
      </div>
    </footer>
  );
};


=====================================
FILE: ./src/ui/organisms/Header.tsx
=====================================
import { Volume2, VolumeX, Radio, Trophy, Skull } from 'lucide-react';
import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { useEffect, useState } from 'react';

export const Header = () => {
  const { musicEnabled, toggleMusic } = useStore();
  
  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const score = useGameStore(state => state.score);
  const highScore = useGameStore(state => state.highScore);

  const [mounted, setMounted] = useState(false);
  useEffect(() => setMounted(true), []);

  const handleToggle = () => {
      AudioSystem.playClick();
      toggleMusic();
      AudioSystem.setMute(!musicEnabled ? false : true); 
  };

  let integrityColor = "bg-elfy-green";
  if (systemIntegrity < 40) integrityColor = "bg-elfy-red";
  else if (systemIntegrity < 70) integrityColor = "bg-elfy-yellow";

  return (
    <header className="relative w-full h-12 bg-black/90 backdrop-blur-md flex items-center justify-between px-4 z-40 shrink-0">
      
      {/* LEFT: Identity */}
      <div className="flex items-center gap-4">
        <span className="font-header font-black text-elfy-green text-xl md:text-2xl tracking-wide drop-shadow-[0_0_5px_rgba(120,246,84,0.5)]">
          MESOELFY_OS
        </span>
        
        {mounted && (
          <div className="hidden md:flex items-center gap-6 text-xs font-mono border-l border-elfy-green-dim/20 pl-4">
            
            {/* CURRENT KILLS */}
            <div className="flex items-center gap-2 text-elfy-green" title="Current Session Kills">
              <Skull size={14} />
              <span className="opacity-70">KILLS:</span>
              <span className="font-bold">{score.toString().padStart(4, '0')}</span>
            </div>

            {/* MAX KILLS */}
            <div className="flex items-center gap-2 text-elfy-yellow" title="All-Time Max Kills">
              <Trophy size={14} />
              <span className="opacity-70">MAX:</span>
              <span className="font-bold">{highScore.toString().padStart(4, '0')}</span>
            </div>

          </div>
        )}
      </div>

      {/* RIGHT: Status */}
      <div className="flex items-center gap-6">
        <button 
          onClick={handleToggle}
          onMouseEnter={() => AudioSystem.playHover()}
          className="flex items-center gap-2 text-xs font-mono text-elfy-green-dim hover:text-elfy-green transition-colors pl-4 border-l border-elfy-green-dim/20"
        >
          {musicEnabled ? <Volume2 size={14} /> : <VolumeX size={14} />}
        </button>
      </div>

      {/* BOTTOM BORDER: OS INTEGRITY BAR */}
      <div className="absolute bottom-0 left-0 right-0 h-[2px] bg-gray-900">
        <div 
          className={`h-full transition-all duration-500 ease-out ${integrityColor} shadow-[0_0_10px_currentColor]`} 
          style={{ width: `${systemIntegrity}%` }}
        />
      </div>
      
      <div className="absolute bottom-[-14px] right-2 text-[8px] font-mono text-elfy-green-dim flex items-center gap-1">
        <Radio size={8} className={systemIntegrity < 100 ? "animate-pulse text-elfy-red" : ""} />
        <span>OS_INTEGRITY: {Math.floor(systemIntegrity)}%</span>
      </div>

    </header>
  );
};


=====================================
FILE: ./src/core/audio/AudioSystem.ts
=====================================
import { GameEventBus } from '@/game/events/GameEventBus';
import { GameEvents } from '@/game/events/GameEvents';

class AudioSystemController {
  private ctx: AudioContext | null = null;
  private masterGain: GainNode | null = null;
  private sfxGain: GainNode | null = null;
  private musicGain: GainNode | null = null;
  private compressor: DynamicsCompressorNode | null = null;
  private musicSource: MediaElementAudioSourceNode | null = null;
  private musicElement: HTMLAudioElement | null = null;
  private isInitialized = false;
  private isMuted = false;

  public init() {
    if (this.isInitialized) {
        // Always try to resume if context exists but is suspended
        if (this.ctx && this.ctx.state === 'suspended') {
            this.ctx.resume().catch(() => {});
        }
        return;
    }

    const AudioContextClass = (window as any).AudioContext || (window as any).webkitAudioContext;
    this.ctx = new AudioContextClass();
    if (!this.ctx) return;

    this.masterGain = this.ctx.createGain();
    this.masterGain.gain.value = 0.5;

    this.compressor = this.ctx.createDynamicsCompressor();
    this.compressor.threshold.value = -24;
    
    this.sfxGain = this.ctx.createGain();
    this.sfxGain.gain.value = 0.8; 

    this.musicGain = this.ctx.createGain();
    this.musicGain.gain.value = 0.6; 

    this.sfxGain.connect(this.compressor);
    this.musicGain.connect(this.compressor);
    this.compressor.connect(this.masterGain);
    this.masterGain.connect(this.ctx.destination);

    this.setupEventListeners();
    this.setupMusic();

    this.isInitialized = true;
    
    // Resume immediately (this works if called from a click/key handler)
    if (this.ctx.state === 'suspended') {
        this.ctx.resume().catch(() => {});
    }
  }

  private setupMusic() {
    if (!this.ctx || !this.musicGain) return;
    this.musicElement = new Audio('/assets/audio/bg_music_placeholder.mp3');
    this.musicElement.loop = true;
    this.musicElement.crossOrigin = "anonymous";
    this.musicSource = this.ctx.createMediaElementSource(this.musicElement);
    this.musicSource.connect(this.musicGain);
  }

  public startMusic() {
    // Resume context again to be safe
    if (this.ctx && this.ctx.state === 'suspended') {
        this.ctx.resume().catch(() => {});
    }
    if (this.musicElement) this.musicElement.play().catch(e => console.warn(e));
  }

  private setupEventListeners() {
    GameEventBus.subscribe(GameEvents.PLAYER_FIRED, () => this.playLaser());
    GameEventBus.subscribe(GameEvents.PLAYER_HIT, () => this.playImpact(true));
    GameEventBus.subscribe(GameEvents.ENEMY_DESTROYED, (p) => this.playExplosion(p.type));
    GameEventBus.subscribe(GameEvents.PANEL_DAMAGED, () => this.playDamageAlert());
    GameEventBus.subscribe(GameEvents.PANEL_DESTROYED, () => this.playMassiveExplosion());
    GameEventBus.subscribe(GameEvents.PANEL_HEALED, () => this.playHeal());
    GameEventBus.subscribe(GameEvents.GAME_OVER, () => this.playGameOver());
    GameEventBus.subscribe(GameEvents.THREAT_LEVEL_UP, () => this.playAlarm());
    GameEventBus.subscribe(GameEvents.UPGRADE_SELECTED, () => this.playHeal());
  }

  // --- AUDIO LOGIC ---

  private playLaser() {
    if (this.isMuted || !this.ctx) return;
    const t = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(880, t);
    osc.frequency.exponentialRampToValueAtTime(110, t + 0.15);
    
    gain.gain.setValueAtTime(0.25, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
    
    osc.connect(gain);
    gain.connect(this.sfxGain!);
    osc.start(t);
    osc.stop(t + 0.15);
  }

  private playHeal() {
      if (this.isMuted || !this.ctx) return;
      const t = this.ctx.currentTime;
      const osc = this.ctx.createOscillator();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(440, t);
      osc.frequency.linearRampToValueAtTime(880, t + 0.2);
      const gain = this.ctx.createGain();
      
      gain.gain.setValueAtTime(0.05, t);
      gain.gain.linearRampToValueAtTime(0, t + 0.2);
      
      osc.connect(gain);
      gain.connect(this.sfxGain!);
      osc.start(t);
      osc.stop(t + 0.2);
  }

  private playExplosion(type: string) {
    if (this.isMuted || !this.ctx) return;
    const t = this.ctx.currentTime;
    const isBig = type !== 'driller';
    const bufferSize = this.ctx.sampleRate * (isBig ? 0.8 : 0.4);
    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
    const noise = this.ctx.createBufferSource();
    noise.buffer = buffer;
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(1000, t);
    filter.frequency.exponentialRampToValueAtTime(100, t + (isBig ? 0.6 : 0.3));
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(isBig ? 0.4 : 0.2, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + (isBig ? 0.6 : 0.3));
    noise.connect(filter);
    filter.connect(gain);
    gain.connect(this.sfxGain!);
    noise.start(t);
  }

  private playImpact(isPlayer: boolean) {
    if (this.isMuted || !this.ctx) return;
    const t = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    osc.type = 'square';
    osc.frequency.setValueAtTime(150, t);
    osc.frequency.exponentialRampToValueAtTime(40, t + 0.1);
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0.3, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
    osc.connect(gain);
    gain.connect(this.sfxGain!);
    osc.start(t);
    osc.stop(t + 0.1);
  }

  private playDamageAlert() {
      if (!this.ctx || this.isMuted) return;
      const t = this.ctx.currentTime;
      const osc = this.ctx.createOscillator();
      osc.frequency.setValueAtTime(300, t);
      osc.frequency.linearRampToValueAtTime(200, t+0.05);
      const gain = this.ctx.createGain();
      gain.gain.setValueAtTime(0.03, t); 
      gain.gain.linearRampToValueAtTime(0, t+0.05);
      osc.connect(gain);
      gain.connect(this.sfxGain!);
      osc.start(t);
      osc.stop(t+0.05);
  }

  private playMassiveExplosion() {
     this.playExplosion('kamikaze');
     if (this.ctx) {
         const t = this.ctx.currentTime;
         const osc = this.ctx.createOscillator();
         osc.type = 'sine';
         osc.frequency.setValueAtTime(60, t);
         osc.frequency.exponentialRampToValueAtTime(10, t + 2.0);
         const gain = this.ctx.createGain();
         gain.gain.setValueAtTime(0.5, t);
         gain.gain.exponentialRampToValueAtTime(0.001, t + 2.0);
         osc.connect(gain);
         gain.connect(this.masterGain!);
         osc.start(t);
         osc.stop(t + 2.0);
     }
  }
  
  private playAlarm() {
      if (this.isMuted || !this.ctx) return;
      const t = this.ctx.currentTime;
      const osc = this.ctx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(1200, t);
      const gain = this.ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.2, t + 0.1);
      gain.gain.linearRampToValueAtTime(0, t + 0.2);
      osc.connect(gain);
      gain.connect(this.sfxGain!);
      osc.start(t);
      osc.stop(t + 0.3);
  }

  private playGameOver() {
      this.playMassiveExplosion();
      if (this.musicSource && this.musicSource.playbackRate) {
          this.musicSource.playbackRate.value = 0.5;
      }
  }
  
  public playHover() {
    if (this.isMuted || !this.ctx) return;
    const t = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(800, t);
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0.02, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
    osc.connect(gain);
    gain.connect(this.masterGain!);
    osc.start(t);
    osc.stop(t + 0.05);
  }

  public playClick() {
    if (this.isMuted || !this.ctx) return;
    const t = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    osc.type = 'square';
    osc.frequency.setValueAtTime(200, t);
    osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0.1, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
    osc.connect(gain);
    gain.connect(this.masterGain!);
    osc.start(t);
    osc.stop(t + 0.1);
  }

  public playBootSequence() { this.playAlarm(); }
  public setMute(muted: boolean) {
    this.isMuted = muted;
    if (this.masterGain) this.masterGain.gain.setTargetAtTime(muted ? 0 : 0.5, this.ctx!.currentTime, 0.1);
  }
}

export const AudioSystem = new AudioSystemController();


=====================================
FILE: ./src/core/store/useStore.ts
=====================================
import { create } from 'zustand';
import { AudioSystem } from '@/core/audio/AudioSystem';

type ModalType = 'none' | 'about' | 'gallery' | 'feed' | 'contact';

interface AppState {
  introDone: boolean;
  activeModal: ModalType;
  hoveredItem: string | null;
  musicEnabled: boolean; // Acts as Master Audio Switch
  volume: number;
  setIntroDone: (done: boolean) => void;
  openModal: (modal: ModalType) => void;
  closeModal: () => void;
  setHovered: (item: string | null) => void;
  toggleMusic: () => void;
}

export const useStore = create<AppState>((set, get) => ({
  introDone: false,
  activeModal: 'none',
  hoveredItem: null,
  musicEnabled: true, // Default to true, but engine starts suspended
  volume: 0.5,

  setIntroDone: (done) => set({ introDone: done }),
  openModal: (modal) => {
      AudioSystem.playClick(); // Click sound on modal open
      set({ activeModal: modal });
  },
  closeModal: () => {
      AudioSystem.playClick(); // Click sound on modal close
      set({ activeModal: 'none' });
  },
  setHovered: (item) => set({ hoveredItem: item }),
  
  toggleMusic: () => {
      const newState = !get().musicEnabled;
      set({ musicEnabled: newState });
      // In web audio, we don't necessarily "mute" the context, 
      // we just stop triggering playHover/playClick, 
      // but we can also ramp master gain to 0 if we want to kill background music later.
  },
}));


=====================================
FILE: ./src/app/layout.tsx
=====================================
import type { Metadata, Viewport } from 'next';
import { Montserrat, JetBrains_Mono } from 'next/font/google';
import '@/styles/globals.css';

const montserrat = Montserrat({ 
  subsets: ['latin'],
  weight: ['400', '700', '900'], 
  variable: '--font-montserrat',
  display: 'swap',
});

const jetbrains = JetBrains_Mono({
  subsets: ['latin'],
  weight: ['400', '700'],
  variable: '--font-jetbrains',
  display: 'swap',
});

export const metadata: Metadata = {
  title: 'MESOELFY // LATENT SPACE BANDIT',
  description: 'The official digital HQ of Mesoelfy. Art, Lore, and Neural Network Injections.',
  icons: {
    icon: '/favicon.ico',
  },
  openGraph: {
    title: 'MESOELFY_OS',
    description: 'Access the terminal. View the art. Breach the firewall.',
    url: 'https://mesoelfy.github.io',
    siteName: 'MESOELFY',
    images: [
      {
        url: 'https://mesoelfy.github.io/assets/images/social-card.jpg',
        width: 1200,
        height: 630,
      },
    ],
    locale: 'en_US',
    type: 'website',
  },
  twitter: {
    card: 'summary_large_image',
    title: 'MESOELFY // LATENT SPACE BANDIT',
    description: 'Access the terminal. View the art. Breach the firewall.',
    images: ['https://mesoelfy.github.io/assets/images/social-card.jpg'],
  },
};

export const viewport: Viewport = {
  themeColor: '#000000',
  colorScheme: 'dark',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" className={`${montserrat.variable} ${jetbrains.variable}`}>
      <body 
        className="bg-black text-elfy-green selection:bg-elfy-green selection:text-black font-mono"
        style={{ backgroundColor: '#000000' }} // Hardcode black to prevent FOUC
      >
        <div className="relative w-full h-full">
          {children}
        </div>
      </body>
    </html>
  );
}


=====================================
FILE: ./src/app/page.tsx
=====================================
'use client';

import { useStore } from '@/core/store/useStore';
import { useGameStore } from '@/game/store/useGameStore';
import { SceneCanvas } from '@/scene/canvas/SceneCanvas';
import { GlassPanel } from '@/ui/atoms/GlassPanel';
import { SocialRow } from '@/ui/molecules/SocialRow';
import { LiveArtGrid } from '@/ui/molecules/LiveArtGrid';
import { HoloCommLog } from '@/ui/molecules/HoloCommLog';
import { IdentityHUD } from '@/ui/molecules/IdentityHUD';
import { Header } from '@/ui/organisms/Header';
import { Footer } from '@/ui/organisms/Footer';
import { AboutModal } from '@/features/identity/AboutModal';
import { FeedModal } from '@/features/feed/FeedModal';
import { GalleryModal } from '@/features/gallery/GalleryModal';
import { ContactModal } from '@/features/contact/ContactModal';
import { MatrixBootSequence } from '@/features/intro/MatrixBootSequence';
import { GameOverlay } from '@/game/GameOverlay';
import { AudioSystem } from '@/core/audio/AudioSystem';
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { GlobalShakeManager } from '@/features/effects/GlobalShakeManager';
import { CustomCursor } from '@/ui/atoms/CustomCursor';

export default function Home() {
  const { openModal, setIntroDone } = useStore(); // Added setIntroDone
  const startGame = useGameStore(s => s.startGame);
  const recalcIntegrity = useGameStore(s => s.recalculateIntegrity);
  
  const [bootState, setBootState] = useState<'standby' | 'active'>('standby');

  const handleBootComplete = () => {
    setTimeout(() => {
      setBootState('active');
      setIntroDone(true); // FIX: Signal that intro is over so Cursor fades out
      startGame();
    }, 200);
  };

  useEffect(() => {
    if (bootState !== 'active') return;
    const interval = setInterval(recalcIntegrity, 500);
    return () => clearInterval(interval);
  }, [bootState, recalcIntegrity]);

  const playHover = () => AudioSystem.playHover();

  return (
    <div id="global-app-root" className="relative w-full h-screen overflow-hidden cursor-none">
      
      <CustomCursor />
      <GlobalShakeManager />

      <main className="relative w-full h-full flex flex-col overflow-hidden text-elfy-green selection:bg-elfy-green selection:text-black font-mono">
        
        <SceneCanvas className="opacity-100 blur-0" />

        {bootState === 'active' && <GameOverlay />}

        <AboutModal />
        <FeedModal />
        <GalleryModal />
        <ContactModal />

        {bootState === 'standby' && (
          <MatrixBootSequence onComplete={handleBootComplete} />
        )}

        <div className={`relative z-10 flex-1 flex flex-col h-full transition-all duration-1000 ease-in-out ${bootState === 'active' ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-4'}`}>
          
          <Header />

          <motion.div 
            className="flex-1 p-4 md:p-6 grid grid-cols-1 md:grid-cols-12 gap-4 md:gap-6 overflow-y-auto md:overflow-hidden max-w-[1600px] mx-auto w-full scrollbar-thin scrollbar-thumb-elfy-green scrollbar-track-black"
            initial="hidden"
            animate={bootState === 'active' ? "visible" : "hidden"}
            variants={{
              hidden: { opacity: 0 },
              visible: { 
                opacity: 1, 
                transition: { 
                  staggerChildren: 0.3,
                  delayChildren: 0.2 
                } 
              }
            }}
          >
            <div className="md:col-span-4 flex flex-col gap-4 md:gap-6 h-auto">
              
              <GlassPanel title="IDENTITY_CORE" className="flex-1 min-h-0" gameId="identity">
                <IdentityHUD />
              </GlassPanel>

              <GlassPanel title="SOCIAL_UPLINK" className="h-auto shrink-0" gameId="social">
                 <SocialRow />
              </GlassPanel>
            </div>

            <div className="md:col-span-8 flex flex-col gap-4 md:gap-6 h-auto">
              <GlassPanel title="LATEST_LOGS" className="h-48 md:h-64 shrink-0" gameId="feed">
                <div className="flex flex-col items-center justify-center h-full text-elfy-green-dim font-mono text-sm border border-dashed border-elfy-green-dim/30 m-2 bg-black/20">
                  <p className="animate-pulse mb-4">&gt; ESTABLISHING UPLINK...</p>
                  <button 
                    onClick={() => openModal('feed')} 
                    onMouseEnter={playHover}
                    className="px-6 py-2 border border-elfy-green text-elfy-green hover:bg-elfy-green hover:text-black transition-colors uppercase tracking-wider font-header font-black text-base md:text-lg"
                  >
                    [ ACCESS TERMINAL ]
                  </button>
                </div>
              </GlassPanel>

              <div className="flex flex-col md:flex-row gap-4 md:gap-6 items-start h-auto">
                <GlassPanel title="ART_DB" className="flex-1 h-auto" gameId="art">
                   <LiveArtGrid />
                </GlassPanel>

                <GlassPanel title="HOLO_COMM" className="w-full md:w-[45%] shrink-0 h-auto" gameId="video">
                   <HoloCommLog />
                </GlassPanel>
              </div>
            </div>
          </motion.div>
          
          <Footer />
        </div>
      </main>
    </div>
  );
}


=====================================
FILE: ./src/features/contact/ContactModal.tsx
=====================================
import { ModalContainer } from '@/ui/overlays/ModalContainer';
import { Send } from 'lucide-react';

export const ContactModal = () => {
  return (
    <ModalContainer title="ENCRYPTED_UPLINK // CONTACT" type="contact">
      <div className="max-w-2xl mx-auto h-full flex flex-col justify-center">
        
        {/* Added Triangles and Font-Header for the Warning */}
        <div className="p-2 border border-elfy-yellow/30 bg-elfy-yellow/5 mb-6 text-center flex items-center justify-center gap-3">
          <span className="text-elfy-yellow animate-pulse">âš </span>
          <p className="text-xs text-elfy-yellow font-header font-bold tracking-wider">
            WARNING: TRANSMISSIONS ARE MONITORED BY THE AI OVERLORD.
          </p>
          <span className="text-elfy-yellow animate-pulse">âš </span>
        </div>

        <form 
          action="https://formspree.io/f/xkgdbkpz" 
          method="POST"
          className="space-y-6"
        >
          <div className="space-y-1">
            <label className="text-sm text-elfy-green-dim uppercase tracking-wider font-header font-bold">Codename</label>
            <input 
              type="text" 
              name="name"
              required
              placeholder="Enter your handle..."
              className="w-full bg-black border border-elfy-green-dim/50 p-3 text-elfy-green font-mono focus:border-elfy-green focus:outline-none focus:shadow-[0_0_10px_rgba(120,246,84,0.2)] transition-all"
            />
          </div>

          <div className="space-y-1">
            <label className="text-sm text-elfy-green-dim uppercase tracking-wider font-header font-bold">Frequency (Email)</label>
            <input 
              type="email" 
              name="email"
              required
              placeholder="Enter return frequency..."
              className="w-full bg-black border border-elfy-green-dim/50 p-3 text-elfy-green font-mono focus:border-elfy-green focus:outline-none focus:shadow-[0_0_10px_rgba(120,246,84,0.2)] transition-all"
            />
          </div>

          <div className="space-y-1">
            <label className="text-sm text-elfy-green-dim uppercase tracking-wider font-header font-bold">Payload</label>
            <textarea 
              name="message"
              required
              rows={5}
              placeholder="Type your message..."
              className="w-full bg-black border border-elfy-green-dim/50 p-3 text-elfy-green font-mono focus:border-elfy-green focus:outline-none focus:shadow-[0_0_10px_rgba(120,246,84,0.2)] transition-all resize-none"
            />
          </div>

          <button 
            type="submit"
            className="w-full py-4 bg-elfy-green text-black font-header font-black uppercase tracking-widest hover:bg-white transition-colors flex items-center justify-center gap-2 group"
          >
            <span>Send Transmission</span>
            <Send size={16} className="group-hover:translate-x-1 transition-transform" />
          </button>
        </form>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/features/identity/AboutModal.tsx
=====================================
import { ModalContainer } from '@/ui/overlays/ModalContainer';
import identity from '@/data/identity.json';

export const AboutModal = () => {
  return (
    <ModalContainer title="IDENTITY_DATABASE // ELFY" type="about">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-8 h-full">
        
        {/* LEFT: The Avatar Grid */}
        <div className="space-y-4">
          <div className="aspect-square w-full border border-elfy-purple-light/50 bg-elfy-purple-deep/30 relative overflow-hidden group shadow-[0_0_20px_rgba(188,134,186,0.2)]">
            <div className="absolute inset-0 flex items-center justify-center text-elfy-purple-light/50 font-bold text-2xl group-hover:text-elfy-purple-light transition-colors font-header font-black tracking-widest text-center p-4">
              [ COMPOSITE_IMAGE LOADING ]
            </div>
            <div className="absolute top-0 left-0 w-4 h-4 border-t-2 border-l-2 border-elfy-purple-light" />
            <div className="absolute bottom-0 right-0 w-4 h-4 border-b-2 border-r-2 border-elfy-purple-light" />
          </div>
          
          <div className="grid grid-cols-4 gap-2">
            {[1,2,3,4].map(i => (
              <div key={i} className="aspect-square border border-elfy-purple-dim/30 hover:bg-elfy-purple-light/20 hover:border-elfy-purple-light cursor-pointer transition-colors" />
            ))}
          </div>
        </div>

        {/* RIGHT: The Data */}
        <div className="space-y-6">
          <div>
            {/* Header: Montserrat */}
            <h2 className="text-4xl font-header font-black text-elfy-green mb-2 tracking-wide">HI, I'M ELFY.</h2>
            <div className="h-1 w-20 bg-elfy-purple-light mb-4" />
            
            {/* Body: Courier (font-mono) for ease of reading/typewriter feel */}
            <p className="text-lg text-white/90 leading-relaxed font-mono">
              {identity.bio}
            </p>
          </div>

          <div className="space-y-2">
            <h3 className="text-elfy-purple-light font-header font-bold uppercase tracking-wider text-sm">Capabilities</h3>
            <ul className="space-y-1">
              {identity.abilities.map((ability, i) => (
                 <li key={i} className="flex items-center gap-2 text-elfy-green font-mono">
                   <span className="text-elfy-purple-light">&gt;</span> {ability}
                 </li>
              ))}
            </ul>
          </div>

          <div className="p-4 border border-elfy-purple-dim/30 bg-elfy-purple-deep/20 text-sm text-elfy-purple-light font-mono">
            <p>&gt; SYSTEM NOTE: Generated via Latent Space Injection.</p>
            <p>&gt; STATUS: 100% Hype.</p>
          </div>
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/features/intro/MatrixBootSequence.tsx
=====================================
import { useEffect, useRef, useState, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { AudioSystem } from '@/core/audio/AudioSystem';

interface Props {
  onComplete: () => void;
}

const ASCII_TITLE = `
 â–ˆâ–ˆâ–ˆâ–„ â–„â–ˆâ–ˆâ–ˆâ–“â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–“      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–“â–ˆâ–ˆ   â–ˆâ–ˆâ–“
â–“â–ˆâ–ˆâ–’â–€â–ˆâ–€ â–ˆâ–ˆâ–’â–“â–ˆ   â–€â–’â–ˆâ–ˆ    â–’ â–’â–ˆâ–ˆâ–’  â–ˆâ–ˆâ–’â–“â–ˆ   â–€ â–“â–ˆâ–ˆâ–’    â–’â–“â–ˆ   â–’  â–’â–ˆâ–ˆ  â–ˆâ–ˆâ–’
â–“â–ˆâ–ˆ    â–“â–ˆâ–ˆâ–‘â–’â–ˆâ–ˆâ–ˆ  â–‘ â–“â–ˆâ–ˆâ–„   â–’â–ˆâ–ˆâ–‘  â–ˆâ–ˆâ–’â–’â–ˆâ–ˆâ–ˆ   â–’â–ˆâ–ˆâ–‘    â–’â–“â–ˆâ–ˆâ–ˆ â–‘   â–’â–ˆâ–ˆ â–ˆâ–ˆâ–‘
â–’â–ˆâ–ˆ    â–’â–ˆâ–ˆ â–’â–“â–ˆ  â–„  â–’   â–ˆâ–ˆâ–’â–’â–ˆâ–ˆ   â–ˆâ–ˆâ–‘â–’â–“â–ˆ  â–„ â–’â–ˆâ–ˆâ–‘    â–‘â–“â–ˆâ–’  â–‘   â–‘ â–â–ˆâ–ˆâ–‘â–‘
â–’â–ˆâ–ˆâ–’   â–‘â–ˆâ–ˆâ–’â–‘â–’â–ˆâ–ˆâ–ˆâ–ˆâ–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–‘ â–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–ˆâ–ˆâ–ˆâ–ˆâ–’â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–‘â–’â–ˆâ–‘      â–‘ â–ˆâ–ˆâ–’â–‘â–‘
â–‘ â–’â–‘   â–‘  â–‘â–‘â–‘ â–’â–‘ â–‘ â–’â–‘â–’  â–‘ â–‘ â–’â–‘â–’â–‘â–’â–‘ â–‘â–‘ â–’â–‘ â–‘â–‘ â–’â–‘â–’  â–‘ â–’ â–‘       â–ˆâ–ˆâ–’â–’â–’
â–‘  â–‘      â–‘ â–‘ â–‘  â–‘ â–‘ â–’  â–‘   â–‘ â–’ â–’â–‘  â–‘ â–‘  â–‘â–‘ â–‘ â–’  â–‘ â–‘       â–“â–ˆâ–ˆ â–‘â–’â–‘ 
â–‘      â–‘      â–‘    â–‘ â–‘    â–‘ â–‘ â–‘ â–’     â–‘     â–‘ â–‘    â–‘ â–‘     â–’ â–’ â–‘â–‘  
       â–‘      â–‘  â–‘   â–‘  â–‘     â–‘ â–‘     â–‘  â–‘    â–‘  â–‘         â–‘ â–‘     
                                                                 
`;

const BootHeader = () => (
  <div className="flex shrink-0 items-center justify-between border-b border-elfy-green-dim/30 bg-elfy-green/5 px-3 py-1 mb-2 select-none relative z-20">
    <span className="text-xs text-elfy-green-dim font-mono tracking-widest uppercase">BOOT_LOADER.SYS</span>
    <div className="flex gap-1 items-center">
      {[1, 2, 3].map(i => (
        <div key={i} className="w-1 bg-elfy-green/50 animate-pulse" style={{ height: `${i * 4 + 4}px`, animationDelay: `${i * 0.1}s` }} />
      ))}
    </div>
  </div>
);

const CoreHeader = () => (
  <div className="flex shrink-0 items-center justify-between border-b border-elfy-green/30 bg-elfy-green/10 px-3 py-1 mb-2 select-none">
    <span className="text-sm text-elfy-green font-mono font-bold tracking-widest uppercase">MESOELFY_CORE</span>
    <div className="relative w-3 h-3 flex items-center justify-center">
      <div className="absolute inset-0 border border-elfy-green rounded-full animate-spin-slow border-t-transparent" />
      <div className="w-1 h-1 bg-elfy-green rounded-full animate-pulse" />
    </div>
  </div>
);

const AsciiRenderer = () => {
  const renderedChars = useMemo(() => {
    return ASCII_TITLE.split('').map((char, i) => {
      if (char === '\n') return <br key={i} />;
      if (char === ' ') return <span key={i}> </span>;
      const animClass = ['â–ˆ','â–€','â–„'].includes(char) ? 'animate-matrix-green text-elfy-green-dark' : 'text-elfy-green-dark';
      return <span key={i} className={animClass} style={{ animationDelay: Math.random() + 's' }}>{char}</span>;
    });
  }, []);
  return <div className="font-mono font-bold leading-[1.1] whitespace-pre text-center select-none overflow-hidden text-[9px] md:text-[11px] shrink-0">{renderedChars}</div>;
};

const TypedLog = ({ text, color, speed = 20, showDots = false, isActive = false, isPast = false }: any) => {
  const [displayed, setDisplayed] = useState("");
  const [isDoneTyping, setIsDoneTyping] = useState(false);
  
  useEffect(() => {
    let i = 0;
    setDisplayed("");
    setIsDoneTyping(false);
    const interval = setInterval(() => {
      setDisplayed(text.substring(0, i + 1));
      i++;
      if (i >= text.length) {
        setIsDoneTyping(true);
        clearInterval(interval);
      }
    }, speed);
    return () => clearInterval(interval);
  }, [text, speed]);

  if (isPast && displayed !== text) {
    setDisplayed(text);
    setIsDoneTyping(true);
  }

  return (
    <div className={`whitespace-nowrap font-mono ${color} flex items-center shrink-0`}>
      <span>{displayed}</span>
      {isDoneTyping && showDots && <span>{isPast ? '...' : (Math.floor(Date.now() / 300) % 4 === 0 ? '' : '...')}</span>}
      {isActive && <span className="ml-1 animate-cursor-blink text-elfy-green font-bold">_</span>}
    </div>
  );
};

const LOG_DATA = [
  { text: "> INITIALIZE NEURAL_LACE", color: "text-elfy-green-dim", speed: 40, hasDots: true },
  { text: "> CONNECTED TO LATENT_SPACE.", color: "text-elfy-green", speed: 20, hasDots: false },
  { text: "> MOUNT MESOELFY_CORE", color: "text-elfy-green-dim", speed: 40, hasDots: true },
  { text: "> âš  UNSAFE CONNECTION DETECTED âš ", color: "text-elfy-red", speed: 20, hasDots: false },
  { text: "> BYPASSING SENTINEL_NODES", color: "text-elfy-purple-light", speed: 40, hasDots: true },
  { text: "> DECRYPTED.", color: "text-elfy-green", speed: 20, hasDots: false },
  { text: "> âš  PROCEED WITH CAUTION âš ", color: "text-elfy-yellow", speed: 20, hasDots: false },
];

export const MatrixBootSequence = ({ onComplete }: Props) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [step, setStep] = useState(0); 
  const [isBreaching, setIsBreaching] = useState(false);
  const logsToShow = LOG_DATA.slice(0, step + 1);
  
  const showMatrix = step >= 1;       
  const showPayloadWindow = step >= 2; 
  const showWarningBox = step >= 3;    
  const showButton = step >= 6;        

  useEffect(() => {
    const sequence = [
      { t: 3000, step: 1 }, 
      { t: 4000, step: 2 }, 
      { t: 8000, step: 3 }, 
      { t: 9500, step: 4 }, 
      { t: 12500, step: 5 }, 
      { t: 13500, step: 6 }, 
    ];
    const timeouts = sequence.map(({ t, step: s }) => setTimeout(() => {
      if (!isBreaching) setStep(s);
    }, t));
    return () => timeouts.forEach(clearTimeout);
  }, [isBreaching]);

  useEffect(() => {
    if (!showMatrix && !isBreaching) return;
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const cols = Math.floor(canvas.width / 20);
    const ypos = Array(cols).fill(0).map(() => Math.random() * -1000);

    const matrixEffect = () => {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; 
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#0F0';
      ctx.font = '14px "Courier New"';
      ypos.forEach((y, ind) => {
        const charSet = Math.random() > 0.5 ? 0x16A0 : 0x2200; 
        const text = String.fromCharCode(charSet + Math.random() * 64);
        const x = ind * 20;
        ctx.fillText(text, x, y);
        const speed = isBreaching ? 100 : 20; 
        if (y > canvas.height + Math.random() * 10000) ypos[ind] = 0;
        else ypos[ind] = y + speed;
      });
    };
    const interval = setInterval(matrixEffect, 50);
    return () => clearInterval(interval);
  }, [showMatrix, isBreaching]);

  // Handle ESC via Window Listener (No focus required)
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        handleInitialize();
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isBreaching]); 

  const handleInitialize = () => {
    if (isBreaching) return;
    setIsBreaching(true);
    
    // SYNCHRONOUSLY call Audio Init to capture User Gesture
    AudioSystem.init();
    AudioSystem.playBootSequence();
    AudioSystem.startMusic();
    
    setStep(6);
    setTimeout(onComplete, 800); 
  };

  return (
    <motion.div 
      ref={containerRef}
      animate={{ backgroundColor: isBreaching ? "rgba(0,0,0,0)" : "rgba(0,0,0,1)" }}
      transition={{ duration: 0.5, ease: "easeInOut" }}
      className="fixed inset-0 z-[100] flex flex-col items-center justify-start pt-[20vh] md:pt-[25vh] font-mono overflow-hidden outline-none cursor-none"
    >
      <canvas ref={canvasRef} className={`absolute inset-0 z-0 transition-opacity duration-300 ${showMatrix && !isBreaching ? 'opacity-30' : 'opacity-0'}`} />

      <motion.div 
        className="relative z-10 flex flex-col gap-4 items-center w-full max-w-2xl px-4"
        animate={isBreaching ? { scale: 15, opacity: 0, filter: "blur(10px)" } : { scale: 1, opacity: 1, filter: "blur(0px)" }}
        transition={{ scale: { duration: 0.8, ease: "easeIn" }, opacity: { duration: 0.2, ease: "easeIn" }, filter: { duration: 0.2 } }}
      >
        <motion.div initial={{ y: -20, opacity: 0 }} animate={{ y: 0, opacity: 1 }} className="w-full bg-black/90 border border-elfy-green-dim/50 shadow-[0_0_20px_rgba(0,255,65,0.1)] overflow-hidden shrink-0">
          <BootHeader />
          <div className="p-4 pt-2 h-40 flex flex-col justify-start text-xs md:text-sm font-mono relative z-10 leading-relaxed">
            {logsToShow.map((line, i) => (
              <TypedLog key={i} text={line.text} color={line.color} speed={line.speed} showDots={line.hasDots} isActive={i === step && !isBreaching} isPast={i < step} />
            ))}
          </div>
        </motion.div>

        <AnimatePresence>
          {showPayloadWindow && (
            <motion.div 
              initial={{ y: 50, opacity: 0, height: 0 }}
              animate={{ y: 0, opacity: 1, height: "auto" }}
              transition={{ type: "spring", stiffness: 120, damping: 20 }}
              className="w-full bg-black/90 border border-elfy-green shadow-[0_0_40px_rgba(0,255,65,0.15)] overflow-hidden shrink-0"
            >
              <CoreHeader />
              <div className="p-6 flex flex-col items-center gap-8">
                <AsciiRenderer />
                {showWarningBox && (
                  <motion.div 
                    initial={{ opacity: 0, scale: 0.9 }}
                    animate={{ 
                      opacity: 1, scale: 1,
                      boxShadow: ["0 0 10px rgba(255, 0, 60, 0.2)", "0 0 40px rgba(255, 0, 60, 0.6)", "0 0 10px rgba(255, 0, 60, 0.2)"]
                    }}
                    transition={{ opacity: { duration: 0.3 }, scale: { duration: 0.3 }, boxShadow: { duration: 2.5, repeat: Infinity, ease: "easeInOut" } }}
                    className="relative border border-elfy-red bg-elfy-red/10 w-fit mx-auto flex items-center justify-center gap-4 py-2 px-6 select-none shrink-0"
                  >
                    <motion.span animate={{ opacity: [1, 0.2, 1] }} transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }} className="text-3xl text-elfy-red">âš </motion.span>
                    <span className="text-sm font-header font-black tracking-widest text-center text-elfy-red whitespace-nowrap pb-0.5">UNSAFE CONNECTION DETECTED</span>
                    <motion.span animate={{ opacity: [1, 0.2, 1] }} transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }} className="text-3xl text-elfy-red">âš </motion.span>
                  </motion.div>
                )}
                {showButton && (
                  <motion.div initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5, ease: "easeOut" }} className="shrink-0">
                    <button 
                      onClick={handleInitialize}
                      onMouseEnter={() => AudioSystem.playHover()}
                      className="group relative px-8 py-2 overflow-hidden border border-elfy-green transition-all hover:shadow-[0_0_30px_rgba(0,255,65,0.6)] cursor-none"
                    >
                      <div className="absolute inset-0 bg-elfy-green translate-y-full group-hover:translate-y-0 transition-transform duration-300 ease-out" />
                      <span className="relative z-10 font-mono font-bold text-xl md:text-3xl text-elfy-green group-hover:text-black transition-colors block tracking-widest whitespace-nowrap">
                        [ INITIALIZE_SYSTEM.EXE ]
                      </span>
                    </button>
                  </motion.div>
                )}
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </motion.div>
    </motion.div>
  );
};


=====================================
FILE: ./src/features/gallery/GalleryModal.tsx
=====================================
import { ModalContainer } from '@/ui/overlays/ModalContainer';
import gallery from '@/data/gallery.json';
import { ExternalLink, Image as ImageIcon } from 'lucide-react';
import { useState } from 'react';

export const GalleryModal = () => {
  const [filter, setFilter] = useState('ALL');
  
  // Get unique categories
  const categories = ['ALL', ...Array.from(new Set(gallery.map(item => item.category)))];

  const filteredGallery = filter === 'ALL' 
    ? gallery 
    : gallery.filter(item => item.category === filter);

  return (
    <ModalContainer title="ART_DATABASE // VISUALS" type="gallery">
      <div className="flex flex-col h-full gap-6">
        
        {/* Category Tabs */}
        <div className="flex gap-2 overflow-x-auto pb-2 border-b border-elfy-green-dim/30">
          {categories.map(cat => (
            <button
              key={cat}
              onClick={() => setFilter(cat)}
              className={`px-4 py-1 font-mono text-sm border transition-all ${
                filter === cat 
                  ? 'bg-elfy-green text-black border-elfy-green' 
                  : 'text-elfy-green-dim border-elfy-green-dim/30 hover:text-elfy-green hover:border-elfy-green'
              }`}
            >
              [{cat}]
            </button>
          ))}
        </div>

        {/* The Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {filteredGallery.map((item) => (
            <a
              key={item.id}
              href={item.url}
              target="_blank"
              rel="noopener noreferrer"
              className="group relative aspect-video bg-black border border-elfy-green-dim/30 hover:border-elfy-green transition-all overflow-hidden"
            >
              {/* Placeholder Graphic (Since we have no images yet) */}
              <div className="absolute inset-0 flex flex-col items-center justify-center bg-elfy-green-dark/10 group-hover:bg-elfy-green-dark/20 transition-colors">
                <ImageIcon className="w-12 h-12 text-elfy-green-dim/20 group-hover:text-elfy-green group-hover:scale-110 transition-all duration-500" />
                <span className="mt-2 text-xs text-elfy-green-dim/40 font-mono">ENCRYPTED_IMG</span>
              </div>

              {/* Overlay Info */}
              <div className="absolute inset-x-0 bottom-0 p-3 bg-black/80 backdrop-blur-sm border-t border-elfy-green-dim/30 translate-y-full group-hover:translate-y-0 transition-transform duration-300">
                <h4 className="text-elfy-green font-bold text-sm">{item.title}</h4>
                <div className="flex items-center gap-1 text-[10px] text-elfy-purple-light mt-1">
                  <span>OPEN_ON_X</span>
                  <ExternalLink size={10} />
                </div>
              </div>
              
              {/* Corner accent */}
              <div className="absolute top-0 right-0 w-0 h-0 border-t-[20px] border-t-elfy-green/20 border-l-[20px] border-l-transparent" />
            </a>
          ))}
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/features/feed/FeedModal.tsx
=====================================
import { ModalContainer } from '@/ui/overlays/ModalContainer';
import feed from '@/data/feed.json';
import { ExternalLink } from 'lucide-react';

export const FeedModal = () => {
  return (
    <ModalContainer title="SYSTEM_LOGS // FEED" type="feed">
      <div className="space-y-6 font-mono">
        {feed.map((post) => (
          <div key={post.id} className="border-l-2 border-elfy-green-dim pl-4 py-2 hover:bg-elfy-green/5 transition-colors group">
            <div className="flex items-center gap-4 mb-2">
              <span className="text-xs text-elfy-green-dim bg-elfy-green-dark/30 px-2 py-1 rounded">
                [{post.date}]
              </span>
              <h3 className="text-xl font-bold text-elfy-green group-hover:text-elfy-yellow transition-colors">
                {post.title}
              </h3>
            </div>
            
            <p className="text-elfy-green-dim/80 mb-3 max-w-2xl">
              {post.desc}
            </p>

            <a 
              href={post.link}
              target="_blank"
              rel="noopener noreferrer"
              className="inline-flex items-center gap-2 text-sm text-elfy-purple-light hover:text-elfy-green underline decoration-elfy-purple-dim decoration-dashed underline-offset-4"
            >
              <span>VIEW_SOURCE</span>
              <ExternalLink size={14} />
            </a>
          </div>
        ))}
        
        {/* End of Log Marker */}
        <div className="text-center py-8 text-elfy-green-dim/30 animate-pulse">
          -- END OF STREAM --
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/features/effects/GlobalShakeManager.tsx
=====================================
import { useEffect, useRef } from 'react';
import { ServiceLocator } from '@/game/core/ServiceLocator';
import { CameraSystem } from '@/game/systems/CameraSystem';

export const GlobalShakeManager = () => {
  const requestRef = useRef<number>();
  
  useEffect(() => {
    const animate = () => {
      // 1. Get Shake from the authoritative Game System
      let x = 0, y = 0, r = 0;
      try {
          const sys = ServiceLocator.getSystem<CameraSystem>('CameraSystem');
          const shake = sys.getShake();
          x = shake.x;
          y = shake.y;
          r = shake.r;
      } catch {
          // System not ready
      }

      // 2. Apply to HTML Root
      const root = document.getElementById('global-app-root');
      if (root) {
        if (Math.abs(x) > 0.01 || Math.abs(y) > 0.01) {
          // Convert rotation radians to degrees for CSS
          const deg = r * (180 / Math.PI);
          // Scale pixels up slightly so HTML moves perceptibly (since World Units are small)
          const pixelScale = 20; 
          root.style.transform = `translate(${x * pixelScale}px, ${y * pixelScale}px) rotate(${deg}deg)`;
        } else {
          root.style.transform = '';
        }
      }

      requestRef.current = requestAnimationFrame(animate);
    };

    requestRef.current = requestAnimationFrame(animate);
    return () => cancelAnimationFrame(requestRef.current!);
  }, []);

  return null;
};


=====================================
FILE: ./src/game/types/game.types.ts
=====================================
export interface RegisteredPanel {
  id: string;
  element: HTMLElement;
  health: number;
  isDestroyed: boolean;
}

export interface GameState {
  isPlaying: boolean;
  score: number;
  threatLevel: number;
  panels: Record<string, RegisteredPanel>;
  
  startGame: () => void;
  stopGame: () => void;
  registerPanel: (id: string, element: HTMLElement) => void;
  unregisterPanel: (id: string) => void;
  damagePanel: (id: string, amount: number) => void;
  healPanel: (id: string, amount: number) => void;
}

// --- ENTITY TYPES ---

export interface Entity {
  id: number;
  x: number;
  y: number;
  radius: number;
  active: boolean;
  spawnTime: number; 
}

export interface Enemy extends Entity {
  vx: number;
  vy: number;
  hp: number;
  type: 'muncher' | 'kamikaze' | 'hunter';
  state?: 'orbit' | 'charge' | 'fire';
  stateTimer?: number;
  targetId?: string; 
  isEating?: boolean;
  orbitAngle?: number; 
}

export interface Bullet extends Entity {
  vx: number;
  vy: number;
  life: number;
  isEnemy?: boolean;
  hp: number; // NEW: Bullet durability
}

export interface Particle extends Entity {
  vx: number;
  vy: number;
  life: number;
  maxLife: number;
  color: string;
}


=====================================
FILE: ./src/game/core/ObjectPool.ts
=====================================
type FactoryFn<T> = () => T;
type ResetFn<T> = (item: T) => void;

export class ObjectPool<T> {
  private available: T[] = [];
  private factory: FactoryFn<T>;
  private resetFn: ResetFn<T>;
  private _totalCreated = 0;

  constructor(factory: FactoryFn<T>, resetFn: ResetFn<T>, initialSize: number = 100) {
    this.factory = factory;
    this.resetFn = resetFn;
    this.expand(initialSize);
  }

  private expand(amount: number) {
    console.log(`[ObjectPool] Expanding by ${amount}. Total: ${this._totalCreated + amount}`);
    for (let i = 0; i < amount; i++) {
      this.available.push(this.factory());
    }
    this._totalCreated += amount;
  }

  public acquire(): T {
    if (this.available.length === 0) {
      // Dynamic Doubling Strategy: If we run out, double the pool size immediately.
      // We cap expansion minimum at 50 to avoid tiny incremental growths.
      const expandAmount = Math.max(50, this._totalCreated); 
      this.expand(expandAmount);
    }

    const item = this.available.pop()!;
    this.resetFn(item); // Ensure it's clean before handing it out
    return item;
  }

  public release(item: T) {
    this.available.push(item);
  }

  public get totalSize() {
    return this._totalCreated;
  }
  
  public get availableSize() {
      return this.available.length;
  }
}


=====================================
FILE: ./src/game/core/GameBootstrapper.ts
=====================================
import { ServiceLocator } from './ServiceLocator';
import { GameEngineCore } from './GameEngine';
import { EntityFactory } from './EntityFactory';

// Systems
import { TimeSystem } from '../systems/TimeSystem';
import { InputSystem } from '../systems/InputSystem';
import { EntitySystem } from '../systems/EntitySystem';
import { CollisionSystem } from '../systems/CollisionSystem';
import { WaveSystem } from '../systems/WaveSystem';
import { PlayerSystem } from '../systems/PlayerSystem';
import { InteractionSystem } from '../systems/InteractionSystem';
import { CameraSystem } from '../systems/CameraSystem';
import { PanelRegistry } from '../systems/PanelRegistrySystem'; // Singleton
import { GameStateSystem } from '../systems/GameStateSystem'; // NEW
import { UISyncSystem } from '../systems/UISyncSystem'; // NEW

export const GameBootstrapper = () => {
  ServiceLocator.reset();

  const engine = new GameEngineCore();
  
  const timeSys = new TimeSystem();
  const inputSys = new InputSystem();
  const entitySys = new EntitySystem();
  const collisionSys = new CollisionSystem();
  const waveSys = new WaveSystem();
  const playerSys = new PlayerSystem();
  const interactionSys = new InteractionSystem();
  const cameraSys = new CameraSystem();
  const gameSys = new GameStateSystem(); // NEW
  const syncSys = new UISyncSystem(); // NEW
  
  const panelSys = PanelRegistry; 

  // Register
  ServiceLocator.registerSystem('TimeSystem', timeSys);
  ServiceLocator.registerSystem('InputSystem', inputSys);
  ServiceLocator.registerSystem('EntitySystem', entitySys);
  ServiceLocator.registerSystem('CollisionSystem', collisionSys);
  ServiceLocator.registerSystem('WaveSystem', waveSys);
  ServiceLocator.registerSystem('PlayerSystem', playerSys);
  ServiceLocator.registerSystem('InteractionSystem', interactionSys);
  ServiceLocator.registerSystem('CameraSystem', cameraSys);
  ServiceLocator.registerSystem('PanelRegistrySystem', panelSys);
  ServiceLocator.registerSystem('GameStateSystem', gameSys); // NEW
  ServiceLocator.registerSystem('UISyncSystem', syncSys); // NEW
  
  // Engine Loop
  engine.registerSystem(timeSys);
  engine.registerSystem(inputSys);
  engine.registerSystem(panelSys);
  engine.registerSystem(gameSys); // NEW (Logic Update)
  engine.registerSystem(interactionSys); 
  engine.registerSystem(waveSys); 
  engine.registerSystem(playerSys); 
  engine.registerSystem(entitySys); 
  engine.registerSystem(collisionSys); 
  engine.registerSystem(cameraSys); 
  engine.registerSystem(syncSys); // NEW (Last in loop to sync final state)
  
  // Setup
  timeSys.setup(ServiceLocator);
  inputSys.setup(ServiceLocator);
  gameSys.setup(ServiceLocator); // NEW
  entitySys.setup(ServiceLocator);
  collisionSys.setup(ServiceLocator);
  waveSys.setup(ServiceLocator);
  playerSys.setup(ServiceLocator);
  interactionSys.setup(ServiceLocator);
  cameraSys.setup(ServiceLocator);
  panelSys.setup(ServiceLocator);
  syncSys.setup(ServiceLocator); // NEW
  
  engine.setup(ServiceLocator);

  EntityFactory.createPlayer();

  return engine;
};


=====================================
FILE: ./src/game/core/ecs/Component.ts
=====================================
export abstract class Component {
  // A unique string key for this component type (e.g., 'Transform', 'Health')
  abstract readonly _type: string;
}


=====================================
FILE: ./src/game/core/ecs/Entity.ts
=====================================
import { EntityID, Tag } from './types';
import { Component } from './Component';

export class Entity {
  // ID is now mutable because pooled entities get new IDs when reused
  public id: EntityID; 
  public readonly tags = new Set<Tag>();
  public active = true;

  // We expose components map for the Registry to clear it efficiently
  public components = new Map<string, Component>();

  constructor(id: EntityID) {
    this.id = id;
  }

  public addComponent(component: Component): this {
    this.components.set(component._type, component);
    return this;
  }

  public getComponent<T extends Component>(type: string): T | undefined {
    return this.components.get(type) as T;
  }
  
  public requireComponent<T extends Component>(type: string): T {
    const c = this.components.get(type);
    if (!c) throw new Error(`Entity ${this.id} missing required component: ${type}`);
    return c as T;
  }

  public hasComponent(type: string): boolean {
    return this.components.has(type);
  }

  public addTag(tag: Tag): this {
    this.tags.add(tag);
    return this;
  }

  public hasTag(tag: Tag): boolean {
    return this.tags.has(tag);
  }

  // NEW: Reset state for pooling
  public reset(newId: EntityID) {
      this.id = newId;
      this.active = true;
      this.tags.clear();
      this.components.clear();
  }
}


=====================================
FILE: ./src/game/core/ecs/types.ts
=====================================
// Nominal typing to prevent mixing up IDs with math numbers
export type EntityID = number & { __brand: 'EntityID' };

export const createEntityID = (id: number): EntityID => id as EntityID;

export enum Tag {
  PLAYER = 'PLAYER',
  ENEMY = 'ENEMY',
  BULLET = 'BULLET',
  PARTICLE = 'PARTICLE',
  OBSTACLE = 'OBSTACLE'
}


=====================================
FILE: ./src/game/core/ecs/EntityRegistry.ts
=====================================
import { EntityID, createEntityID, Tag } from './types';
import { Entity } from './Entity';
import { ObjectPool } from '../ObjectPool';

class EntityRegistryCore {
  // Active entities (The "Live" List)
  private entities = new Map<EntityID, Entity>();
  private nextId = 0;
  
  private tagCache = new Map<Tag, Set<EntityID>>();

  // The Pool (The "Recycle Bin")
  private entityPool: ObjectPool<Entity>;

  constructor() {
      this.entityPool = new ObjectPool<Entity>(
          () => new Entity(createEntityID(0)), // Factory (ID set later)
          (e) => {}, // Reset (Handled manually in createEntity)
          1000 // Initial Capacity
      );
  }

  public createEntity(): Entity {
    const newId = createEntityID(++this.nextId);
    
    // Acquire from pool
    const entity = this.entityPool.acquire();
    
    // Explicitly reset with new ID
    entity.reset(newId);
    
    this.entities.set(newId, entity);
    return entity;
  }

  public destroyEntity(id: EntityID) {
    const entity = this.entities.get(id);
    if (entity) {
        entity.active = false;
        this.removeFromCache(entity);
        this.entities.delete(id);
        
        // Return to pool
        this.entityPool.release(entity);
    }
  }

  public getEntity(id: EntityID): Entity | undefined {
    return this.entities.get(id);
  }

  public getAll(): IterableIterator<Entity> {
    return this.entities.values();
  }

  public getByTag(tag: Tag): Entity[] {
    if (!this.tagCache.has(tag)) {
        this.rebuildTagCache(tag);
    }
    const ids = this.tagCache.get(tag)!;
    const results: Entity[] = [];
    // We iterate the ID set, but we must check if entity still exists in main map
    // (In case cache is stale within a frame, though we try to keep it sync)
    for (const id of ids) {
        const e = this.entities.get(id);
        if (e && e.active) results.push(e);
    }
    return results;
  }
  
  public updateCache(entity: Entity) {
      for (const tag of entity.tags) {
          if (!this.tagCache.has(tag)) this.tagCache.set(tag, new Set());
          this.tagCache.get(tag)!.add(entity.id);
      }
  }

  private removeFromCache(entity: Entity) {
      for (const tag of entity.tags) {
          if (this.tagCache.has(tag)) {
              this.tagCache.get(tag)!.delete(entity.id);
          }
      }
  }
  
  private rebuildTagCache(tag: Tag) {
      const set = new Set<EntityID>();
      for (const entity of this.entities.values()) {
          if (entity.hasTag(tag)) set.add(entity.id);
      }
      this.tagCache.set(tag, set);
  }

  public clear() {
      // When clearing level, move everything to pool
      for (const entity of this.entities.values()) {
          this.entityPool.release(entity);
      }
      this.entities.clear();
      this.tagCache.clear();
      this.nextId = 0;
  }
  
  // Debug method
  public getStats() {
      return {
          active: this.entities.size,
          pooled: this.entityPool.availableSize,
          totalAllocated: this.entityPool.totalSize
      };
  }
}

export const Registry = new EntityRegistryCore();


=====================================
FILE: ./src/game/core/EntityFactory.ts
=====================================
import { Registry } from './ecs/EntityRegistry';
import { Entity } from './ecs/Entity';
import { Tag } from './ecs/types';

// Components
import { TransformComponent } from '../components/data/TransformComponent';
import { MotionComponent } from '../components/data/MotionComponent';
import { HealthComponent } from '../components/data/HealthComponent';
import { IdentityComponent } from '../components/data/IdentityComponent';
import { LifetimeComponent } from '../components/data/LifetimeComponent';
import { CombatComponent } from '../components/data/CombatComponent';
import { StateComponent } from '../components/data/StateComponent'; // NEW

// Configs
import { ENEMY_CONFIG } from '../config/EnemyConfig';
import { PLAYER_CONFIG } from '../config/PlayerConfig';
import { EnemyTypes, EnemyType } from '../config/Identifiers';

export class EntityFactory {
  
  public static createPlayer(): Entity {
    const e = Registry.createEntity();
    e.addTag(Tag.PLAYER);
    
    e.addComponent(new TransformComponent(0, 0, 0, 1));
    e.addComponent(new MotionComponent(0, 0, 0.9)); 
    e.addComponent(new HealthComponent(PLAYER_CONFIG.maxHealth));
    e.addComponent(new StateComponent('IDLE')); // Track status
    
    Registry.updateCache(e);
    return e;
  }

  public static createEnemy(type: EnemyType, x: number, y: number): Entity {
    const config = ENEMY_CONFIG[type];
    const e = Registry.createEntity();
    
    e.addTag(Tag.ENEMY);
    e.addTag(Tag.OBSTACLE);

    e.addComponent(new TransformComponent(x, y, 0, 1));
    e.addComponent(new IdentityComponent(type));
    e.addComponent(new MotionComponent(0, 0, 0, 0)); 
    e.addComponent(new HealthComponent(config.hp));
    
    // Default state for everyone is IDLE or ORBIT depending on logic
    e.addComponent(new StateComponent('SPAWN')); 
    
    if (config.damage) {
        e.addComponent(new CombatComponent(config.damage));
    }

    Registry.updateCache(e);
    return e;
  }

  public static createBullet(
    x: number, y: number, 
    vx: number, vy: number, 
    isEnemy: boolean, 
    life: number
  ): Entity {
    const e = Registry.createEntity();
    e.addTag(Tag.BULLET);
    if (isEnemy) e.addTag(Tag.ENEMY); 
    else e.addTag(Tag.PLAYER); 

    e.addComponent(new TransformComponent(x, y, Math.atan2(vy, vx), 1));
    e.addComponent(new MotionComponent(vx, vy, 0));
    e.addComponent(new LifetimeComponent(life, life));
    e.addComponent(new CombatComponent(1)); 

    Registry.updateCache(e);
    return e;
  }

  public static createParticle(
    x: number, y: number, 
    color: string, 
    vx: number, vy: number, 
    life: number
  ): Entity {
    const e = Registry.createEntity();
    e.addTag(Tag.PARTICLE);

    e.addComponent(new TransformComponent(x, y, 0, 1));
    e.addComponent(new MotionComponent(vx, vy, 0.05));
    e.addComponent(new LifetimeComponent(life, life));
    e.addComponent(new IdentityComponent(color));

    Registry.updateCache(e);
    return e;
  }
}


=====================================
FILE: ./src/game/core/ServiceLocator.ts
=====================================
import { IServiceLocator, IGameSystem, IAudioService, IInputService } from './interfaces';

class ServiceLocatorImpl implements IServiceLocator {
  private systems = new Map<string, IGameSystem>();
  private audioService?: IAudioService;
  private inputService?: IInputService;

  // Generic getter allows accessing any registered system type-safely
  public getSystem<T extends IGameSystem>(id: string): T {
    const sys = this.systems.get(id);
    if (!sys) throw new Error(`System not registered: ${id}`);
    return sys as T;
  }

  public registerSystem(id: string, system: IGameSystem): void {
    this.systems.set(id, system);
    if (id === 'InputSystem') this.inputService = system as unknown as IInputService;
  }

  public getAudioService(): IAudioService {
    if (!this.audioService) throw new Error("AudioService not registered");
    return this.audioService;
  }

  public getInputService(): IInputService {
    if (!this.inputService) throw new Error("InputService not registered");
    return this.inputService;
  }
  
  public reset(): void {
    this.systems.clear();
    this.audioService = undefined;
    this.inputService = undefined;
  }

  // Helper for debug/tools
  public get registeredSystemIds(): string[] {
    return Array.from(this.systems.keys());
  }
}

export const ServiceLocator = new ServiceLocatorImpl();


=====================================
FILE: ./src/game/core/SpatialGrid.ts
=====================================
import { EntityID } from './ecs/types';
import { Registry } from './ecs/EntityRegistry';
import { TransformComponent } from '../components/data/TransformComponent';

export class SpatialGrid {
  private cellSize: number;
  private buckets = new Map<string, Set<EntityID>>();

  constructor(cellSize: number = 4) {
    this.cellSize = cellSize;
  }

  private getKey(x: number, y: number): string {
    const cx = Math.floor(x / this.cellSize);
    const cy = Math.floor(y / this.cellSize);
    return `${cx}:${cy}`;
  }

  public clear() {
    this.buckets.clear();
  }

  public insert(id: EntityID, x: number, y: number) {
    const key = this.getKey(x, y);
    if (!this.buckets.has(key)) {
      this.buckets.set(key, new Set());
    }
    this.buckets.get(key)!.add(id);
  }

  /**
   * Returns a Set of EntityIDs that are in the cells near the query position.
   * This is a "Broad Phase" check. Precise collision must still be checked after.
   */
  public query(x: number, y: number, radius: number): Set<EntityID> {
    const results = new Set<EntityID>();
    
    // Calculate range of cells to check
    const startX = Math.floor((x - radius) / this.cellSize);
    const endX = Math.floor((x + radius) / this.cellSize);
    const startY = Math.floor((y - radius) / this.cellSize);
    const endY = Math.floor((y + radius) / this.cellSize);

    for (let cx = startX; cx <= endX; cx++) {
      for (let cy = startY; cy <= endY; cy++) {
        const key = `${cx}:${cy}`;
        const bucket = this.buckets.get(key);
        if (bucket) {
          for (const id of bucket) {
            results.add(id);
          }
        }
      }
    }

    return results;
  }
}


=====================================
FILE: ./src/game/core/interfaces.ts
=====================================
import { GameEvents, GameEventPayloads } from '../events/GameEvents';

export interface IGameSystem {
  /** Called once when the game engine initializes */
  setup(locator: IServiceLocator): void;
  
  /** Called every frame (tick) */
  update(delta: number, time: number): void;
  
  /** Called when the game stops or resets */
  teardown(): void;
}

export interface IServiceLocator {
  getSystem<T extends IGameSystem>(id: string): T;
  registerSystem(id: string, system: IGameSystem): void;
  
  // Specific Services
  getAudioService(): IAudioService;
  getInputService(): IInputService;
}

export interface IAudioService {
  playSound(key: string, volume?: number): void;
  playMusic(key: string): void;
  setVolume(volume: number): void;
}

export interface IInputService {
  getCursor(): { x: number, y: number };
  isPressed(action: string): boolean;
}

export interface IEventBus {
  emit<T extends GameEvents>(event: T, payload: GameEventPayloads[T]): void;
  subscribe<T extends GameEvents>(event: T, handler: (p: GameEventPayloads[T]) => void): () => void;
}


=====================================
FILE: ./src/game/core/GameEngine.ts
=====================================
import { IGameSystem, IServiceLocator } from './interfaces';
import { useGameStore } from '../store/useGameStore';
import { FXManager } from '../systems/FXManager';
import { ViewportHelper } from '../utils/ViewportHelper';
import { Registry } from './ecs/EntityRegistry';
import { Tag } from './ecs/types';
import { PanelRegistrySystem } from '../systems/PanelRegistrySystem'; 
import { GameStateSystem } from '../systems/GameStateSystem';

export class GameEngineCore implements IGameSystem {
  private systems: IGameSystem[] = [];
  private locator!: IServiceLocator;

  public get enemies() { return Registry.getByTag(Tag.ENEMY); }
  public get bullets() { return Registry.getByTag(Tag.BULLET).filter(b => !b.hasTag(Tag.ENEMY)); }
  public get enemyBullets() { return Registry.getByTag(Tag.BULLET).filter(b => b.hasTag(Tag.ENEMY)); }
  public get particles() { return Registry.getByTag(Tag.PARTICLE); }
  
  public get isRepairing() { 
    try {
      return (this.locator.getSystem('InteractionSystem') as any).repairState !== 'IDLE';
    } catch { return false; }
  }

  setup(locator: IServiceLocator): void {
    this.locator = locator;
    FXManager.init();
  }

  public registerSystem(system: IGameSystem) {
    this.systems.push(system);
  }

  update(delta: number, time: number): void {
    const store = useGameStore.getState();
    const gameSys = this.locator.getSystem<GameStateSystem>('GameStateSystem');
    
    // SYNC GLOBAL GAME OVER STATE
    if (store.isPlaying && store.systemIntegrity <= 0) {
        store.stopGame();
        FXManager.addTrauma(1.0);
        gameSys.isGameOver = true; // FORCE SYNC
        return;
    }

    // Force GameStateSystem to respect store if stopped manually
    if (!store.isPlaying) {
        gameSys.isGameOver = true;
    }

    for (const sys of this.systems) {
      sys.update(delta, time);
    }
  }

  teardown(): void {
    for (const sys of this.systems) {
      sys.teardown();
    }
    this.systems = [];
  }
  
  public updateViewport(vpW: number, vpH: number, screenW: number, screenH: number) {
    ViewportHelper.update(vpW, vpH, screenW, screenH);
    try {
        const panelSys = this.locator.getSystem<PanelRegistrySystem>('PanelRegistrySystem');
        panelSys.refreshAll();
    } catch (e) {
    }
  }
}


=====================================
FILE: ./src/game/GameOverlay.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { PlayerAvatar } from './components/PlayerAvatar';
import { GameDirector } from './components/GameDirector';
import { EnemyRenderer } from './components/EnemyRenderer';
import { BulletRenderer } from './components/BulletRenderer';
import { EnemyBulletRenderer } from './components/EnemyBulletRenderer';
import { HunterChargeRenderer } from './components/HunterChargeRenderer';
import { ParticleRenderer } from './components/ParticleRenderer';
import { ScreenShaker } from './components/ScreenShaker';
import { ProjectileTrails } from './components/ProjectileTrails'; 
// Removed GlowRenderer

export const GameOverlay = () => {
  return (
    <div className="fixed inset-0 z-[60] w-full h-full pointer-events-none overflow-hidden">
      <Canvas
        orthographic
        camera={{ zoom: 40, position: [0, 0, 100] }}
        gl={{ 
          alpha: true, 
          antialias: true,
          stencil: false,
          powerPreference: "high-performance"
        }}
        eventSource={typeof document !== 'undefined' ? document.body : undefined}
        eventPrefix="client"
      >
        <GameDirector />
        <ScreenShaker />

        <ProjectileTrails />

        <PlayerAvatar />
        <BulletRenderer />
        <HunterChargeRenderer /> 
        <EnemyBulletRenderer />
        <EnemyRenderer />
        <ParticleRenderer /> 
      </Canvas>
    </div>
  );
};


=====================================
FILE: ./src/game/config/PlayerConfig.ts
=====================================
export const PLAYER_CONFIG = {
  maxHealth: 100,
  fireRate: 0.15, 
  bulletSpeed: 45,
  bulletRadius: 0.2,
  bulletLife: 1.5,
  
  // Scoring & Progression
  scoreMultiplier: 1,
  baseXpRequirement: 100,
  xpScalingFactor: 1.5, // Next level = base * (scaling ^ level)
};


=====================================
FILE: ./src/game/config/EnemyConfig.ts
=====================================
import { EnemyTypes } from './Identifiers';

export const ENEMY_CONFIG = {
  [EnemyTypes.DRILLER]: { // RENAMED
    hp: 2,
    baseSpeed: 8,
    radius: 0.5,
    damage: 15,
    score: 10
  },
  [EnemyTypes.KAMIKAZE]: {
    hp: 3,
    baseSpeed: 12,
    radius: 0.5,
    damage: 10,
    score: 20
  },
  [EnemyTypes.HUNTER]: {
    hp: 3,
    baseSpeed: 12,
    radius: 0.5,
    score: 50,
    orbitRadius: 12.5,
    orbitDuration: 2.0,
    chargeDuration: 1.0,
    fireRange: 12.0,
    offsetDistance: 1.6 
  }
};

export const WAVE_CONFIG = {
  baseSpawnInterval: 0.8,
  difficultyScaler: 1.0 
};


=====================================
FILE: ./src/game/config/Identifiers.ts
=====================================
import { GameEvents as NewGameEvents } from '../events/GameEvents';

export const EnemyTypes = {
  DRILLER: 'driller', // RENAMED
  KAMIKAZE: 'kamikaze',
  HUNTER: 'hunter',
} as const;

export type EnemyType = typeof EnemyTypes[keyof typeof EnemyTypes];

// Re-export the new Enum as the old Const Object to maintain backward compatibility
export const GameEvents = NewGameEvents;


=====================================
FILE: ./src/game/config/WorldConfig.ts
=====================================
export const WorldConfig = {
  bounds: {
    width: 32, // World Units
    height: 18,
    depth: 5
  },
  physics: {
    friction: 0.95,
    maxVelocity: 20
  },
  time: {
    fixedDelta: 1 / 60, // 60hz Logic Tick
    maxDelta: 0.1 // Prevent spiral of death on lag
  }
};


=====================================
FILE: ./src/game/logic/ai/EnemyBehaviors.ts
=====================================
import { Entity } from '../../core/ecs/Entity';
import { TransformComponent } from '../../components/data/TransformComponent';
import { MotionComponent } from '../../components/data/MotionComponent';
import { StateComponent } from '../../components/data/StateComponent';
import { ENEMY_CONFIG } from '../../config/EnemyConfig';
import { EnemyTypes, GameEvents } from '../../events/GameEvents';
import { EnemyTypes as Types } from '../../config/Identifiers';
import { Registry } from '../../core/ecs/EntityRegistry';

const getPos = (e: Entity) => e.requireComponent<TransformComponent>('Transform');
const getMotion = (e: Entity) => e.requireComponent<MotionComponent>('Motion');
const getState = (e: Entity) => e.requireComponent<StateComponent>('State');

function rotateTowards(current: number, target: number, speed: number): number {
    let diff = target - current;
    while (diff > Math.PI) diff -= Math.PI * 2;
    while (diff < -Math.PI) diff += Math.PI * 2;
    return current + diff * speed;
}

function lerp(start: number, end: number, t: number): number {
    return start * (1 - t) + end * t;
}

export interface AIContext {
  playerPos: { x: number, y: number };
  panels: any[]; 
  delta: number;
  time: number;
  doDamageTick: boolean;
  spawnProjectile: (x: number, y: number, vx: number, vy: number) => void;
  damagePanel: (id: string, amount: number) => void;
  triggerExplosion: (x: number, y: number, color: string) => void;
  spawnDrillSparks: (x, y, color: string) => void; 
  emitEvent: (name: string, payload: any) => void;
}

export interface EnemyBehavior {
  update(entity: Entity, ctx: AIContext): void;
}

export const DrillerBehavior: EnemyBehavior = {
  update: (e, ctx) => {
    const pos = getPos(e);
    const motion = getMotion(e);
    const state = getState(e);
    
    let targetX = 0;
    let targetY = 0;
    let bestPanel: any = null;
    let nearestDist = Infinity;

    for (const p of ctx.panels) {
      const dx = p.x - pos.x;
      const dy = p.y - pos.y;
      const dist = dx*dx + dy*dy;
      if (dist < nearestDist) {
        nearestDist = dist;
        bestPanel = p;
      }
    }

    let isDrilling = false;

    if (bestPanel) {
      targetX = Math.max(bestPanel.left, Math.min(pos.x, bestPanel.right));
      targetY = Math.max(bestPanel.bottom, Math.min(pos.y, bestPanel.top));
      
      const dx = targetX - pos.x;
      const dy = targetY - pos.y;
      const distToEdge = Math.sqrt(dx*dx + dy*dy);

      if (distToEdge < 0.5) { 
        isDrilling = true;
        ctx.spawnDrillSparks(targetX, targetY, '#9E4EA5');
        if (ctx.doDamageTick) {
            ctx.damagePanel(bestPanel.id, ENEMY_CONFIG[Types.DRILLER].damage);
        }
      }
    } else {
      targetX = Math.sin(ctx.time) * 5;
      targetY = Math.cos(ctx.time) * 5;
    }

    state.current = isDrilling ? 'DRILLING' : 'MOVING';

    if (!isDrilling) {
      const dx = targetX - pos.x;
      const dy = targetY - pos.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const speed = ENEMY_CONFIG[Types.DRILLER].baseSpeed;

      if (dist > 0.1) {
        motion.vx = (dx / dist) * speed;
        motion.vy = (dy / dist) * speed;
      } else {
        motion.vx = 0;
        motion.vy = 0;
      }
    } else {
      motion.vx = 0;
      motion.vy = 0;
    }
    
    // ROTATION LOGIC
    if (isDrilling) {
        // FIX: Force rotation to face the contact point on the panel
        // This ensures the drill tip is "locked" visually to the surface.
        const angleToPanel = Math.atan2(targetY - pos.y, targetX - pos.x) - Math.PI/2;
        pos.rotation = rotateTowards(pos.rotation, angleToPanel, 0.2); // Fast snap
    } 
    else if (Math.abs(motion.vx) > 0.1 || Math.abs(motion.vy) > 0.1) {
        const targetAngle = Math.atan2(motion.vy, motion.vx) - Math.PI/2;
        pos.rotation = rotateTowards(pos.rotation, targetAngle, 0.1);
    }
  }
};

// ... Kamikaze and Hunter behaviors remain unchanged below ...
export const KamikazeBehavior: EnemyBehavior = {
  update: (e, ctx) => {
    const pos = getPos(e);
    const motion = getMotion(e);
    const targetX = ctx.playerPos.x;
    const targetY = ctx.playerPos.y;
    const dx = targetX - pos.x;
    const dy = targetY - pos.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    if (dist < 1.0) {
       Registry.destroyEntity(e.id);
       ctx.triggerExplosion(pos.x, pos.y, '#FF003C');
       ctx.emitEvent(GameEvents.PLAYER_HIT, { damage: 10 });
       return; 
    }

    if (dist > 0.1) {
      const speed = ENEMY_CONFIG[Types.KAMIKAZE].baseSpeed;
      motion.vx = (dx / dist) * speed;
      motion.vy = (dy / dist) * speed;
      pos.rotation += 0.1; 
    }
  }
};

export const HunterBehavior: EnemyBehavior = {
  update: (e, ctx) => {
    const state = getState(e);
    const pos = getPos(e);
    const motion = getMotion(e);

    if (state.data.spinVelocity === undefined) {
        state.data.spinVelocity = 2.0;
        state.data.spinAngle = 0;
    }

    if (state.current === 'SPAWN') {
        state.current = 'HUNT';
        state.timers.action = 3.0; 
        state.data.offsetAngle = (e.id.valueOf() % 10) * 0.6; 
    }

    let targetSpinSpeed = 2.0; 

    if (state.current === 'HUNT') {
        const px = ctx.playerPos.x;
        const py = ctx.playerPos.y;
        
        const orbitSpeed = 0.5;
        const currentAngle = (ctx.time * orbitSpeed) + state.data.offsetAngle;
        
        const targetRadius = 16.0;
        const tx = px + Math.cos(currentAngle) * targetRadius;
        const ty = py + Math.sin(currentAngle) * targetRadius;

        const dx = tx - pos.x;
        const dy = ty - pos.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        const speed = ENEMY_CONFIG[Types.HUNTER].baseSpeed; 
        
        if (dist > 1.0) {
            motion.vx += (dx / dist) * speed * ctx.delta * 2.0;
            motion.vy += (dy / dist) * speed * ctx.delta * 2.0;
        }
        
        motion.vx *= 0.92;
        motion.vy *= 0.92;

        const aimDx = px - pos.x;
        const aimDy = py - pos.y;
        const aimAngle = Math.atan2(aimDy, aimDx) - Math.PI/2;
        pos.rotation = rotateTowards(pos.rotation, aimAngle, 0.05);

        state.timers.action -= ctx.delta;
        const inBounds = Math.abs(pos.x) < 22 && Math.abs(pos.y) < 14;
        
        if (state.timers.action <= 0 && inBounds) {
            state.current = 'CHARGE';
            state.timers.action = ENEMY_CONFIG[Types.HUNTER].chargeDuration;
            motion.vx *= 0.1; 
            motion.vy *= 0.1;
        }
    } 
    
    else if (state.current === 'CHARGE') {
        state.timers.action -= ctx.delta;
        motion.vx *= 0.8;
        motion.vy *= 0.8;

        const dx = ctx.playerPos.x - pos.x;
        const dy = ctx.playerPos.y - pos.y;
        const targetAngle = Math.atan2(dy, dx) - Math.PI/2;
        pos.rotation = rotateTowards(pos.rotation, targetAngle, 0.15);

        targetSpinSpeed = -8.0; 

        if (state.timers.action <= 0) {
            state.current = 'FIRE';
        }
    }
    
    else if (state.current === 'FIRE') {
        const dx = ctx.playerPos.x - pos.x;
        const dy = ctx.playerPos.y - pos.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const dirX = dist > 0 ? dx/dist : 0;
        const dirY = dist > 0 ? dy/dist : 1;
        
        const offset = 1.6;
        const spawnX = pos.x + (dirX * offset);
        const spawnY = pos.y + (dirY * offset);
        const SPEED = 25; 

        ctx.spawnProjectile(spawnX, spawnY, dirX * SPEED, dirY * SPEED);

        state.current = 'HUNT';
        state.timers.action = 2.0 + Math.random() * 2.0;
    }

    state.data.spinVelocity = lerp(state.data.spinVelocity, targetSpinSpeed, ctx.delta * 2.0);
    state.data.spinAngle += state.data.spinVelocity * ctx.delta;
  }
};

export const Behaviors: Record<string, EnemyBehavior> = {
  [Types.DRILLER]: DrillerBehavior,
  [Types.KAMIKAZE]: KamikazeBehavior,
  [Types.HUNTER]: HunterBehavior
};


=====================================
FILE: ./src/game/utils/TextureGen.ts
=====================================
import * as THREE from 'three';

// Helper: Exponential Falloff for natural light
// x is 0..1 (distance from center)
const falloff = (x: number, power: number = 2) => {
  return Math.pow(Math.max(0, 1 - x), power);
};

// 1. High Quality Comet Trail
export const createCometTexture = () => {
  const w = 64;
  const h = 256; // Higher resolution vertical
  const canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext('2d')!;
  
  ctx.clearRect(0, 0, w, h);

  // We draw manually pixel-by-pixel or using complex gradients for better control
  // Gradient: Bottom (Head) -> Top (Tail)
  const gradient = ctx.createLinearGradient(0, h, 0, 0);
  
  // Exponential fade:
  // 0.0 (Head): 100% Opacity
  // 0.2 (Body): 60% Opacity
  // 1.0 (Tail): 0% Opacity
  gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)'); 
  gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.4)');
  gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

  ctx.fillStyle = gradient;

  // Shape: Tapered Triangle
  ctx.beginPath();
  ctx.moveTo(w * 0.1, h);       // Bottom Left (pinched slightly)
  ctx.lineTo(w * 0.9, h);       // Bottom Right
  ctx.lineTo(w * 0.5, 0);       // Top Tip
  ctx.closePath();
  ctx.fill();

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
};

// 2. Player Bullet (Glowing Bar)
export const createGlowingBarTexture = () => {
  const w = 64;
  const h = 128;
  const canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext('2d')!;

  // Clear
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, w, h);

  // Glow (Soft Rect)
  const cx = w / 2;
  const cy = h / 2;
  
  // Radial glow around the bar isn't ideal, let's use shadow blur
  ctx.shadowColor = "white";
  ctx.shadowBlur = 20;
  ctx.fillStyle = "white";
  
  // Draw Core (Slim Rectangle)
  // Leave padding for the glow/shadow to bleed
  ctx.fillRect(24, 20, 16, 88); 

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
};

// 3. Hunter Orb (Exponential Glow)
export const createExponentialBallTexture = () => {
  const size = 128;
  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d')!;
  
  const cx = size / 2;
  const cy = size / 2;
  const radius = size / 2;

  const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
  
  // Sharp Core, Soft Bloom
  gradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); 
  gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.9)'); // Solid Core
  gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)'); // Mid Bloom
  gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Fade out

  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, size, size);

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
};

// 4. Soft Glow (Backgrounds - Legacy/Enemies)
export const createGlowTexture = () => {
  const canvas = document.createElement('canvas');
  canvas.width = 64;
  canvas.height = 64;
  const ctx = canvas.getContext('2d')!;
  
  const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
  gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
  gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 64, 64);

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
};


=====================================
FILE: ./src/game/utils/Noise.ts
=====================================
// Simple 1D Gradient Noise
// Returns value between -1 and 1 based on input 'x'
export function noise(x: number): number {
  const i = Math.floor(x);
  const f = x - i;
  const u = f * f * (3.0 - 2.0 * f); // Cubic smoothing
  return mix(hash(i), hash(i + 1), u);
}

function hash(n: number): number {
  return (Math.sin(n) * 43758.5453) % 1.0;
}

function mix(a: number, b: number, t: number): number {
  return a * (1 - t) + b * t;
}


=====================================
FILE: ./src/game/utils/ViewportHelper.ts
=====================================
export interface WorldRect {
  id: string;
  x: number;
  y: number;
  width: number;
  height: number;
  left: number;
  right: number;
  top: number;
  bottom: number;
}

export class ViewportHelperCore {
  public viewport = { width: 1, height: 1 }; // R3F Viewport units
  public screenSize = { width: 1, height: 1 }; // Window Pixels

  public update(vpW: number, vpH: number, screenW: number, screenH: number) {
    this.viewport = { width: vpW, height: vpH };
    this.screenSize = { width: screenW, height: screenH };
  }

  // Pure Math: Converts Pixel Rect -> World Rect
  public domToWorld(id: string, domRect: DOMRect): WorldRect {
    const sw = this.screenSize.width || 1;
    const sh = this.screenSize.height || 1;
    
    const vw = this.viewport.width;
    const vh = this.viewport.height;
    
    const cx = domRect.left + domRect.width / 2;
    const cy = domRect.top + domRect.height / 2;
    
    // Screen (Pixels) -> World (Orthographic Units)
    // 0,0 is center of screen in World
    const wx = (cx / sw) * vw - (vw / 2);
    const wy = -((cy / sh) * vh - (vh / 2));
    
    const wWidth = (domRect.width / sw) * vw;
    const wHeight = (domRect.height / sh) * vh;

    return {
      id: id,
      x: wx, y: wy,
      width: wWidth, height: wHeight,
      left: wx - wWidth / 2, right: wx + wWidth / 2,
      top: wy + wHeight / 2, bottom: wy - wHeight / 2,
    };
  }
}

export const ViewportHelper = new ViewportHelperCore();


=====================================
FILE: ./src/game/utils/GeometryUtils.ts
=====================================
import * as THREE from 'three';

export const addBarycentricCoordinates = (bufferGeometry: THREE.BufferGeometry, removeEdge: boolean = false) => {
  const geometry = bufferGeometry.toNonIndexed();
  const count = geometry.attributes.position.count;
  const centers = new Float32Array(count * 3);

  for (let i = 0; i < count; i += 3) {
    centers[i * 3] = 1;
    centers[i * 3 + 1] = 0;
    centers[i * 3 + 2] = 0;

    centers[i * 3 + 3] = 0;
    centers[i * 3 + 4] = 1;
    centers[i * 3 + 5] = 0;

    centers[i * 3 + 6] = 0;
    centers[i * 3 + 7] = 0;
    centers[i * 3 + 8] = 1;
  }

  geometry.setAttribute('barycentric', new THREE.BufferAttribute(centers, 3));
  return geometry;
};

// NEW: Tri-Wing "Paper Airplane" Spear
export const createHunterSpear = () => {
  const positions: number[] = [];
  
  // We build 3 "Wings" (thin triangles)
  const numWings = 3;
  const length = 1.2;
  const wingWidth = 0.4;
  const wingThickness = 0.05; // Give it slight 3D thickness

  for(let i=0; i<numWings; i++) {
      const angle = (i / numWings) * Math.PI * 2;
      
      // We build a triangle in the Y/X plane, then rotate it around Y
      // Tip at (0, length/2, 0)
      // Base Outer at (width, -length/2, 0)
      // Base Inner at (0, -length/2, 0)
      
      const tipY = length / 2;
      const baseY = -length / 2;
      
      // Define vertices for a "Thick" triangle (Wedge)
      // P1: Tip
      // P2: Base Outer Left
      // P3: Base Outer Right
      // P4: Base Center (Axis)
      
      // Let's manually push triangles for a "Fin"
      // Fin stands on the +X axis
      
      const pTip = [0, tipY, 0];
      const pBaseOut = [wingWidth, baseY, 0];
      const pBaseInBack = [0, baseY, -wingThickness];
      const pBaseInFront = [0, baseY, wingThickness];
      
      // Helper to rotate point around Y axis
      const rotateY = (p: number[], rad: number) => {
          const x = p[0];
          const z = p[2];
          return [
              x * Math.cos(rad) - z * Math.sin(rad),
              p[1], // Y unchanged
              x * Math.sin(rad) + z * Math.cos(rad)
          ];
      };

      // Push Triangles
      // 1. Face Front
      let v1 = rotateY(pTip, angle);
      let v2 = rotateY(pBaseOut, angle);
      let v3 = rotateY(pBaseInFront, angle);
      positions.push(...v1, ...v2, ...v3);
      
      // 2. Face Back
      v1 = rotateY(pTip, angle);
      v2 = rotateY(pBaseInBack, angle);
      v3 = rotateY(pBaseOut, angle);
      positions.push(...v1, ...v2, ...v3);
      
      // 3. Base Cap (optional, but good for solidity)
      // ... skipping for wireframe aesthetic
  }
  
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  geometry.computeVertexNormals();
  
  return addBarycentricCoordinates(geometry);
};


=====================================
FILE: ./src/game/utils/coords.ts
=====================================
// Camera Zoom level defined in GameOverlay
const ZOOM = 40; 

export const screenToWorld = (screenX: number, screenY: number, screenW: number, screenH: number) => {
  // DOM: 0,0 is Top-Left. +Y is Down.
  // THREE: 0,0 is Center. +Y is Up.
  
  const worldX = (screenX - screenW / 2) / ZOOM;
  const worldY = -(screenY - screenH / 2) / ZOOM; // Invert Y
  
  return { x: worldX, y: worldY };
};

export const domRectToWorldRect = (rect: { x: number, y: number, width: number, height: number }, screenW: number, screenH: number) => {
  // Get center of DOM element
  const centerX = rect.x + rect.width / 2;
  const centerY = rect.y + rect.height / 2;
  
  const centerWorld = screenToWorld(centerX, centerY, screenW, screenH);
  
  return {
    x: centerWorld.x,
    y: centerWorld.y,
    width: rect.width / ZOOM,
    height: rect.height / ZOOM,
    left: centerWorld.x - (rect.width / ZOOM / 2),
    right: centerWorld.x + (rect.width / ZOOM / 2),
    top: centerWorld.y + (rect.height / ZOOM / 2),
    bottom: centerWorld.y - (rect.height / ZOOM / 2),
  };
};


=====================================
FILE: ./src/game/components/PlayerAvatar.tsx
=====================================
import { useRef } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import { GAME_THEME } from '../theme';
import { ServiceLocator } from '../core/ServiceLocator';
import { useGameStore } from '../store/useGameStore';
import { useStore } from '@/core/store/useStore';
import { InteractionSystem, RepairState } from '../systems/InteractionSystem'; 
import * as THREE from 'three';

export const PlayerAvatar = () => {
  const groupRef = useRef<THREE.Group>(null);
  const ringRef = useRef<THREE.Mesh>(null);
  const coreRef = useRef<THREE.Mesh>(null);
  const glowRef = useRef<THREE.Sprite>(null);
  const { viewport } = useThree();
  
  const { introDone } = useStore(); // Access Intro State

  const colorTurret = new THREE.Color(GAME_THEME.turret.base); 
  const colorRepair = new THREE.Color(GAME_THEME.turret.repair); 
  const colorReboot = new THREE.Color('#9E4EA5'); 
  const colorDead = new THREE.Color('#78F654'); 

  const isDead = useGameStore(state => state.playerHealth <= 0);
  const aliveGeo = new THREE.CircleGeometry(0.1, 16);
  const deadGeo = new THREE.RingGeometry(0.15, 0.2, 3);
  
  // Animation State for Fade-In
  const animScale = useRef(0);

  useFrame((state, delta) => {
    if (!groupRef.current) return;

    // FADE IN LOGIC
    const targetScale = introDone ? 1 : 0;
    animScale.current = THREE.MathUtils.lerp(animScale.current, targetScale, delta * 2.0);
    
    // Apply Global Scale (Entrance Animation)
    // If intro is not done, we hide it.
    if (animScale.current < 0.01) {
        groupRef.current.visible = false;
        return;
    }
    groupRef.current.visible = true;

    // 1. Position
    const x = (state.pointer.x * viewport.width) / 2;
    const y = (state.pointer.y * viewport.height) / 2;
    groupRef.current.position.x = x;
    groupRef.current.position.y = y;

    try { ServiceLocator.getInputService().updateCursor(x, y); } catch {}

    // 2. State
    let repairState: RepairState = 'IDLE';
    try {
        const sys = ServiceLocator.getSystem<InteractionSystem>('InteractionSystem');
        repairState = sys.repairState;
    } catch {}
    
    const isRepairing = repairState !== 'IDLE';
    let targetColor = colorTurret;
    if (repairState === 'HEALING') targetColor = colorRepair; 
    if (repairState === 'REBOOTING') targetColor = colorReboot; 

    // 3. Visuals
    if (ringRef.current && coreRef.current && glowRef.current) {
        // Base Scale (multiplied by animScale)
        let currentBaseScale = 1.0;

        if (isDead) {
            ringRef.current.visible = false;
            glowRef.current.visible = isRepairing;
            glowRef.current.material.color.set(colorReboot);
            
            coreRef.current.geometry = deadGeo;
            coreRef.current.material.color.set(isRepairing ? colorReboot : colorDead);
            
            if (isRepairing) {
               coreRef.current.rotation.z -= 0.5; 
               currentBaseScale = 1.5 + Math.sin(state.clock.elapsedTime * 30) * 0.2;
            } else {
               coreRef.current.rotation.z = Math.PI; 
            }
        } else {
            ringRef.current.visible = true;
            glowRef.current.visible = true;
            coreRef.current.geometry = aliveGeo;
            
            if (isRepairing) {
                ringRef.current.rotation.z += 0.4; 
                ringRef.current.material.color.lerp(targetColor, 0.4);
                coreRef.current.material.color.lerp(targetColor, 0.4);
                glowRef.current.material.color.lerp(targetColor, 0.4);
                
                const pulse = 1.2 + Math.sin(state.clock.elapsedTime * 20) * 0.2;
                currentBaseScale = pulse;
            } else {
                ringRef.current.rotation.z -= 0.02; 
                ringRef.current.material.color.lerp(colorTurret, 0.1);
                coreRef.current.material.color.lerp(colorTurret, 0.1);
                glowRef.current.material.color.lerp(colorTurret, 0.1);
            }
        }
        
        // Apply Final Scale (Entrance * State)
        const finalScale = animScale.current * currentBaseScale;
        
        // Apply to sub-meshes individually or group? Group is easier for entrance.
        // But we have logic that sets scale on sub-meshes. Let's apply to group.
        groupRef.current.scale.setScalar(animScale.current);
        
        // The sub-logic above set scalar on coreRef, we should respect that relative to group.
        // Actually, previous logic set scale on coreRef/ringRef directly.
        // Let's modify the previous logic to set local scale, while group handles global entrance.
        coreRef.current.scale.setScalar(currentBaseScale);
        ringRef.current.scale.setScalar(currentBaseScale); 
    }
  });

  return (
    <group ref={groupRef}>
      <mesh ref={coreRef}>
        <bufferGeometry />
        <meshBasicMaterial color={GAME_THEME.turret.base} />
      </mesh>

      <mesh ref={ringRef} rotation={[0, 0, Math.PI / 4]}>
        <ringGeometry args={[0.4, 0.45, 4]} /> 
        <meshBasicMaterial color={GAME_THEME.turret.base} transparent opacity={0.8} />
      </mesh>

      <sprite ref={glowRef} scale={[2, 2, 1]}>
        <spriteMaterial 
          color={GAME_THEME.turret.glow} 
          transparent 
          opacity={0.3}
          blending={THREE.AdditiveBlending}
        />
      </sprite>
    </group>
  );
};


=====================================
FILE: ./src/game/components/BulletRenderer.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { Registry } from '../core/ecs/EntityRegistry';
import { Tag } from '../core/ecs/types';
import { TransformComponent } from '../components/data/TransformComponent';
import { GAME_THEME } from '../theme';

const MAX_BULLETS = 500;
const tempObj = new THREE.Object3D();

const vertexShader = `
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
  }
`;

const fragmentShader = `
  varying vec2 vUv;
  uniform vec3 uColor;
  
  float sdBox(in vec2 p, in vec2 b) {
      vec2 d = abs(p)-b;
      return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
  }

  void main() {
    vec2 p = vUv - 0.5;
    
    // FIX: Reduced box size from (0.15, 0.4) to (0.1, 0.3) for a tighter projectile
    vec2 boxSize = vec2(0.1, 0.3); 
    
    float d = sdBox(p, boxSize);
    
    float core = 1.0 - smoothstep(0.0, 0.02, d);
    float glow = exp(-20.0 * max(0.0, d));
    
    vec3 color = mix(uColor, vec3(1.0), core); 
    float alpha = max(core, glow);

    gl_FragColor = vec4(color, alpha);
  }
`;

export const BulletRenderer = () => {
  const meshRef = useRef<THREE.InstancedMesh>(null);
  
  // Reduced geometry plane size slightly to match new visual scale
  const geometry = useMemo(() => new THREE.PlaneGeometry(1.2, 1.2), []); 
  
  const shaderMaterial = useMemo(() => new THREE.ShaderMaterial({
    vertexShader,
    fragmentShader,
    uniforms: {
      uColor: { value: new THREE.Color(GAME_THEME.bullet.plasma) }
    },
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
  }), []);

  useFrame(() => {
    if (!meshRef.current) return;
    
    const allBullets = Registry.getByTag(Tag.BULLET);
    let count = 0;

    for (const b of allBullets) {
      if (b.hasTag(Tag.ENEMY)) continue; 
      
      const transform = b.getComponent<TransformComponent>('Transform');
      if (!transform) continue;

      if (count >= MAX_BULLETS) break;

      tempObj.position.set(transform.x, transform.y, 0);
      tempObj.rotation.z = transform.rotation - (Math.PI / 2);
      
      tempObj.updateMatrix();
      meshRef.current.setMatrixAt(count, tempObj.matrix);
      count++;
    }

    meshRef.current.count = count;
    meshRef.current.instanceMatrix.needsUpdate = true;
  });

  return (
    <instancedMesh ref={meshRef} args={[geometry, undefined, MAX_BULLETS]}>
      <primitive object={shaderMaterial} attach="material" />
    </instancedMesh>
  );
};


=====================================
FILE: ./src/game/components/ParticleRenderer.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { Registry } from '../core/ecs/EntityRegistry';
import { Tag } from '../core/ecs/types';
import { TransformComponent } from '../components/data/TransformComponent';
import { IdentityComponent } from '../components/data/IdentityComponent';
import { LifetimeComponent } from '../components/data/LifetimeComponent';

const MAX_PARTICLES = 1000;

export const ParticleRenderer = () => {
  const meshRef = useRef<THREE.InstancedMesh>(null);
  const geometry = useMemo(() => new THREE.PlaneGeometry(0.3, 0.3), []); // Slightly larger base size

  const shaderMaterial = useMemo(() => new THREE.ShaderMaterial({
    vertexShader: `
      #ifndef USE_INSTANCING_COLOR
      attribute vec3 instanceColor;
      #endif
      
      varying vec2 vUv;
      varying vec3 vColor;
      
      void main() {
        vUv = uv;
        vColor = instanceColor;
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      varying vec2 vUv;
      varying vec3 vColor;
      
      void main() {
        // Circular Particle
        float dist = distance(vUv, vec2(0.5));
        
        // Sharp core, soft edge
        // 1.0 at center, 0.0 at 0.5 radius
        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
        alpha = pow(alpha, 3.0); // Make it "hot" (fast falloff)
        
        if (alpha < 0.01) discard;
        gl_FragColor = vec4(vColor, alpha);
      }
    `,
    uniforms: {},
    vertexColors: true,
    transparent: true,
    blending: THREE.AdditiveBlending, // Sparks should glow
    depthWrite: false,
  }), []);

  useFrame(() => {
    if (!meshRef.current) return;
    const tempObj = new THREE.Object3D();
    const tempColor = new THREE.Color();

    let count = 0;
    const particles = Registry.getByTag(Tag.PARTICLE);

    for (const p of particles) {
      if (count >= MAX_PARTICLES) break;

      const transform = p.getComponent<TransformComponent>('Transform');
      const identity = p.getComponent<IdentityComponent>('Identity');
      const life = p.getComponent<LifetimeComponent>('Lifetime');
      
      if (!transform || !life) continue;

      tempObj.position.set(transform.x, transform.y, 0);
      
      // Scale based on life: Pop in fast, shrink out slow
      const progress = life.remaining / life.total;
      const scale = progress; 
      
      tempObj.scale.set(scale, scale, 1);
      
      // Identity variant is the Hex Color for particles
      tempColor.set(identity ? identity.variant : '#FFF');
      
      tempObj.updateMatrix();
      meshRef.current.setMatrixAt(count, tempObj.matrix);
      meshRef.current.setColorAt(count, tempColor);
      count++;
    }

    meshRef.current.count = count;
    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor) meshRef.current.instanceColor.needsUpdate = true;
  });

  return (
    <instancedMesh ref={meshRef} args={[geometry, shaderMaterial, MAX_PARTICLES]}>
    </instancedMesh>
  );
};


=====================================
FILE: ./src/game/components/EnemyBulletRenderer.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { Registry } from '../core/ecs/EntityRegistry';
import { Tag } from '../core/ecs/types';
import { TransformComponent } from '../components/data/TransformComponent';
import { GAME_THEME } from '../theme';

const MAX_BULLETS = 200;
const tempObj = new THREE.Object3D();
const tempColor = new THREE.Color();

// --- SHADER DEFINITION ---
const vertexShader = `
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
  }
`;

const fragmentShader = `
  varying vec2 vUv;
  uniform vec3 uColor;
  
  void main() {
    // Calculate distance from center (0.5, 0.5)
    float dist = distance(vUv, vec2(0.5));
    
    // 1. Hard Core (Radius 0.25)
    float core = 1.0 - smoothstep(0.2, 0.25, dist);
    
    // 2. Glow Halo (Radius 0.5)
    float glow = 1.0 - smoothstep(0.25, 0.5, dist);
    glow = pow(glow, 3.0); // Exponential falloff
    
    // Combine: White Core + Colored Glow
    vec3 finalColor = mix(uColor, vec3(1.0), core);
    float alpha = max(core, glow);

    if (alpha < 0.01) discard;
    gl_FragColor = vec4(finalColor, alpha);
  }
`;

export const EnemyBulletRenderer = () => {
  const meshRef = useRef<THREE.InstancedMesh>(null);
  
  // Use Plane for Billboard effect
  const geometry = useMemo(() => new THREE.PlaneGeometry(2.0, 2.0), []); 
  
  const shaderMaterial = useMemo(() => new THREE.ShaderMaterial({
    vertexShader,
    fragmentShader,
    uniforms: {
      uColor: { value: new THREE.Color(GAME_THEME.bullet.hunter) }
    },
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
  }), []);

  useFrame(() => {
    if (!meshRef.current) return;

    const allBullets = Registry.getByTag(Tag.BULLET);
    let count = 0;

    for (const b of allBullets) {
      if (!b.hasTag(Tag.ENEMY)) continue; 

      const transform = b.getComponent<TransformComponent>('Transform');
      if (!transform) continue;

      if (count >= MAX_BULLETS) break;

      tempObj.position.set(transform.x, transform.y, 0);
      tempObj.scale.set(1, 1, 1);
      tempObj.rotation.set(0,0,0); 

      tempObj.updateMatrix();
      meshRef.current.setMatrixAt(count, tempObj.matrix);
      count++;
    }

    meshRef.current.count = count;
    meshRef.current.instanceMatrix.needsUpdate = true;
  });

  return (
    <instancedMesh ref={meshRef} args={[geometry, undefined, MAX_BULLETS]}>
      <primitive object={shaderMaterial} attach="material" />
    </instancedMesh>
  );
};


=====================================
FILE: ./src/game/components/HunterChargeRenderer.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { Registry } from '../core/ecs/EntityRegistry';
import { Tag } from '../core/ecs/types';
import { TransformComponent } from '../components/data/TransformComponent';
import { IdentityComponent } from '../components/data/IdentityComponent';
import { StateComponent } from '../components/data/StateComponent';
import { GAME_THEME } from '../theme';
import { EnemyTypes } from '../config/Identifiers';

const MAX_CHARGES = 50;
const tempObj = new THREE.Object3D();
const OFFSET_DISTANCE = 1.6; 

// --- ORB SHADER ---
const vertexShader = `
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
  }
`;

const fragmentShader = `
  varying vec2 vUv;
  uniform vec3 uColor;
  
  void main() {
    float dist = distance(vUv, vec2(0.5));
    float core = 1.0 - smoothstep(0.2, 0.25, dist);
    float glow = 1.0 - smoothstep(0.25, 0.5, dist);
    glow = pow(glow, 3.0); 
    
    vec3 finalColor = mix(uColor, vec3(1.0), core);
    float alpha = max(core, glow);

    if (alpha < 0.01) discard;
    gl_FragColor = vec4(finalColor, alpha);
  }
`;

export const HunterChargeRenderer = () => {
  const meshRef = useRef<THREE.InstancedMesh>(null);
  const geometry = useMemo(() => new THREE.PlaneGeometry(2.0, 2.0), []);
  
  const shaderMaterial = useMemo(() => new THREE.ShaderMaterial({
    vertexShader,
    fragmentShader,
    uniforms: {
      uColor: { value: new THREE.Color(GAME_THEME.bullet.hunter) }
    },
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
  }), []);

  useFrame(() => {
    if (!meshRef.current) return;

    const enemies = Registry.getByTag(Tag.ENEMY);
    let count = 0;

    for (const e of enemies) {
      const identity = e.getComponent<IdentityComponent>('Identity');
      if (!identity || identity.variant !== EnemyTypes.HUNTER) continue;

      const state = e.getComponent<StateComponent>('State');
      
      if (state && state.current === 'CHARGE') {
        const transform = e.getComponent<TransformComponent>('Transform');
        if (!transform) continue;

        if (count >= MAX_CHARGES) break;

        const timer = state.timers.state || 0;
        // Timer goes 1.0 -> 0.0
        const progress = Math.max(0, Math.min(1, 1.0 - timer));
        
        // FIX: Linear growth (0 to 1) feels more "charging up" than the previous fast-pop
        // We cap it at 1.0 just in case
        const scale = Math.min(1.0, progress * 1.1); 

        // Position: In front of Hunter
        // Since Hunter rotates to face player, we can trust its rotation or re-calc direction?
        // Driller uses State for rotation updates. Hunter uses State.
        // Let's assume Transform.rotation is correct (facing player).
        
        // Transform rotation is Z-axis rotation.
        // -PI/2 adjustment because 0 rotation is usually Right, but UP is forward?
        // Let's use standard trig based on rotation.
        const dirX = Math.cos(transform.rotation + Math.PI/2);
        const dirY = Math.sin(transform.rotation + Math.PI/2);

        const spawnX = transform.x + (dirX * OFFSET_DISTANCE);
        const spawnY = transform.y + (dirY * OFFSET_DISTANCE);

        tempObj.position.set(spawnX, spawnY, 0.1); // Slightly above hunter
        tempObj.scale.set(scale, scale, 1);
        tempObj.rotation.set(0, 0, 0); 

        tempObj.updateMatrix();
        meshRef.current.setMatrixAt(count, tempObj.matrix);
        count++;
      }
    }

    meshRef.current.count = count;
    meshRef.current.instanceMatrix.needsUpdate = true;
  });

  return (
    <instancedMesh ref={meshRef} args={[geometry, undefined, MAX_CHARGES]}>
      <primitive object={shaderMaterial} attach="material" />
    </instancedMesh>
  );
};


=====================================
FILE: ./src/game/components/GlowRenderer.tsx
=====================================
// Component Deprecated: Enemies use Wireframe Shader now.
export const GlowRenderer = () => null;


=====================================
FILE: ./src/game/components/EnemyRenderer.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { Registry } from '../core/ecs/EntityRegistry';
import { Tag } from '../core/ecs/types';
import { TransformComponent } from '../components/data/TransformComponent';
import { IdentityComponent } from '../components/data/IdentityComponent';
import { StateComponent } from '../components/data/StateComponent';
import { GAME_THEME } from '../theme';
import { EnemyTypes } from '../config/Identifiers';
import { addBarycentricCoordinates, createHunterSpear } from '../utils/GeometryUtils';

const MAX_ENEMIES = 1000;
const tempObj = new THREE.Object3D();
const tempColor = new THREE.Color();
const chargeColor = new THREE.Color(GAME_THEME.enemy.charge);

const vertexShader = `
  #ifndef USE_INSTANCING_COLOR
  attribute vec3 instanceColor;
  #endif
  
  attribute vec3 barycentric;
  
  varying vec3 vColor;
  varying vec3 vBarycentric;

  void main() {
    vColor = instanceColor;
    vBarycentric = barycentric;
    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
  }
`;

const fragmentShader = `
  varying vec3 vColor;
  varying vec3 vBarycentric;
  
  float edgeFactor(vec3 bary, float width) {
    vec3 d = fwidth(bary);
    vec3 a3 = smoothstep(vec3(0.0), d * width, bary);
    return min(min(a3.x, a3.y), a3.z);
  }

  void main() {
    // FIX: Thicker lines (2.0)
    float width = 2.0; 
    float edge = edgeFactor(vBarycentric, width);
    float glow = 1.0 - edge;
    glow = pow(glow, 0.4); 
    
    vec3 coreColor = vColor;
    vec3 edgeColor = mix(vColor, vec3(1.0), 0.6); // Brighter edges
    vec3 finalColor = mix(coreColor, edgeColor, glow);
    
    gl_FragColor = vec4(finalColor, 1.0);
  }
`;

export const EnemyRenderer = () => {
  const drillerRef = useRef<THREE.InstancedMesh>(null);
  const kamikazeRef = useRef<THREE.InstancedMesh>(null);
  const hunterRef = useRef<THREE.InstancedMesh>(null);
  
  const drillerGeo = useMemo(() => {
      const geo = new THREE.ConeGeometry(0.3, 0.8, 4); 
      return addBarycentricCoordinates(geo);
  }, []);
  
  const kamikazeGeo = useMemo(() => {
      const geo = new THREE.IcosahedronGeometry(0.6, 0); 
      return addBarycentricCoordinates(geo);
  }, []);
  
  const hunterGeo = useMemo(() => {
      return createHunterSpear();
  }, []);

  const shaderMaterial = useMemo(() => new THREE.ShaderMaterial({
    vertexShader,
    fragmentShader,
    uniforms: {},
    vertexColors: true,
    extensions: { derivatives: true },
    side: THREE.DoubleSide, // FIX: Render both sides for visibility
  }), []);

  useFrame((state) => {
    if (!drillerRef.current || !kamikazeRef.current || !hunterRef.current) return;

    const enemies = Registry.getByTag(Tag.ENEMY);
    const currentTime = state.clock.elapsedTime;
    
    let mCount = 0;
    let kCount = 0;
    let hCount = 0;

    for (const e of enemies) {
      const transform = e.getComponent<TransformComponent>('Transform');
      const identity = e.getComponent<IdentityComponent>('Identity');
      
      if (!transform || !identity) continue;

      // FIX: Z=5.0 to ensure they are well above the panel plane
      tempObj.position.set(transform.x, transform.y, 5.0);
      
      tempObj.rotation.set(0, 0, transform.rotation); 
      tempObj.scale.set(transform.scale, transform.scale, 1);
      
      const type = identity.variant;
      
      if (type === EnemyTypes.DRILLER) {
        if (mCount >= MAX_ENEMIES) continue;
        
        // Pure spin on Y
        const stateComp = e.getComponent<StateComponent>('State');
        const speed = (stateComp && stateComp.current === 'DRILLING') ? 20.0 : 5.0;
        tempObj.rotateY(currentTime * speed); 

        tempColor.set(GAME_THEME.enemy.muncher);
        tempObj.updateMatrix();
        drillerRef.current.setMatrixAt(mCount, tempObj.matrix);
        drillerRef.current.setColorAt(mCount, tempColor);
        mCount++;
      }
      else if (type === EnemyTypes.KAMIKAZE) {
        if (kCount >= MAX_ENEMIES) continue;
        
        tempObj.rotateX(currentTime);
        tempObj.rotateY(currentTime * 0.5);
        
        tempColor.set(GAME_THEME.enemy.kamikaze);
        tempObj.updateMatrix();
        kamikazeRef.current.setMatrixAt(kCount, tempObj.matrix);
        kamikazeRef.current.setColorAt(kCount, tempColor);
        kCount++;
      }
      else if (type === EnemyTypes.HUNTER) {
        if (hCount >= MAX_ENEMIES) continue;
        
        const stateComp = e.getComponent<StateComponent>('State');
        const isCharging = stateComp && stateComp.current === 'CHARGE';
        
        tempColor.set(GAME_THEME.enemy.hunter);
        if (isCharging) {
             const alpha = (Math.sin(currentTime * 20) + 1) / 2;
             tempColor.lerp(chargeColor, alpha);
        }
        
        const spin = stateComp?.data?.spinAngle || 0;
        tempObj.rotateY(spin);

        tempObj.updateMatrix();
        hunterRef.current.setMatrixAt(hCount, tempObj.matrix);
        hunterRef.current.setColorAt(hCount, tempColor);
        hCount++;
      }
    }

    drillerRef.current.count = mCount;
    drillerRef.current.instanceMatrix.needsUpdate = true;
    if (drillerRef.current.instanceColor) drillerRef.current.instanceColor.needsUpdate = true;

    kamikazeRef.current.count = kCount;
    kamikazeRef.current.instanceMatrix.needsUpdate = true;
    if (kamikazeRef.current.instanceColor) kamikazeRef.current.instanceColor.needsUpdate = true;

    hunterRef.current.count = hCount;
    hunterRef.current.instanceMatrix.needsUpdate = true;
    if (hunterRef.current.instanceColor) hunterRef.current.instanceColor.needsUpdate = true;
  });

  return (
    <group>
        <instancedMesh ref={drillerRef} args={[drillerGeo, shaderMaterial, MAX_ENEMIES]} />
        <instancedMesh ref={kamikazeRef} args={[kamikazeGeo, shaderMaterial, MAX_ENEMIES]} />
        <instancedMesh ref={hunterRef} args={[hunterGeo, shaderMaterial, MAX_ENEMIES]} />
    </group>
  );
};


=====================================
FILE: ./src/game/components/GameDirector.tsx
=====================================
import { useFrame, useThree } from '@react-three/fiber';
import { useEffect, useRef } from 'react';
import { GameBootstrapper } from '../core/GameBootstrapper';
import { GameEngineCore } from '../core/GameEngine';
import { ServiceLocator } from '../core/ServiceLocator';
import { InputSystem } from '../systems/InputSystem';
import { PanelRegistry } from '../systems/PanelRegistrySystem';

// We export the active engine instance for the Renderer components to access via import
export let ActiveEngine: GameEngineCore | null = null;

export const GameDirector = () => {
  const { viewport, size } = useThree();
  const engineRef = useRef<GameEngineCore | null>(null);

  useEffect(() => {
    // 1. Boot the game
    const engine = GameBootstrapper();
    engineRef.current = engine;
    ActiveEngine = engine;

    // 2. Initial Viewport Sync
    engine.updateViewport(viewport.width, viewport.height, size.width, size.height);
    
    // 3. Force Layout Refresh Loop (The Fix)
    // Run every 500ms to catch animations settling (entrance) or scroll shifts
    // This is cheap (5-10 elements) and fixes the "Stale Rect" issue.
    const refreshInterval = setInterval(() => {
        PanelRegistry.refreshAll();
    }, 500);

    // 4. Force an immediate refresh chain for the first 2 seconds (Entrance Animation)
    // We poll faster during entrance to make it look responsive immediately
    let initialPolls = 0;
    const fastPoll = setInterval(() => {
        PanelRegistry.refreshAll();
        initialPolls++;
        if (initialPolls > 20) clearInterval(fastPoll); // Stop fast polling after 2s
    }, 100);

    return () => {
      clearInterval(refreshInterval);
      clearInterval(fastPoll);
      engine.teardown();
      engineRef.current = null;
      ActiveEngine = null;
    };
  }, []); // Run once on mount

  // Sync Viewport on resize
  useEffect(() => {
    if (engineRef.current) {
      engineRef.current.updateViewport(viewport.width, viewport.height, size.width, size.height);
    }
  }, [viewport, size]);

  useFrame((state, delta) => {
    if (engineRef.current) {
      // Sync Input from R3F
      const input = ServiceLocator.getSystem<InputSystem>('InputSystem');
      const x = (state.pointer.x * viewport.width) / 2;
      const y = (state.pointer.y * viewport.height) / 2;
      input.updateCursor(x, y);

      // Run Loop
      engineRef.current.update(delta, state.clock.elapsedTime);
    }
  });

  return null;
};


=====================================
FILE: ./src/game/components/ScreenShaker.tsx
=====================================
import { useFrame, useThree } from '@react-three/fiber';
import { ServiceLocator } from '../core/ServiceLocator';
import { CameraSystem } from '../systems/CameraSystem';
import * as THREE from 'three';

export const ScreenShaker = () => {
  const { camera } = useThree();
  
  useFrame(() => {
    try {
        const sys = ServiceLocator.getSystem<CameraSystem>('CameraSystem');
        const { x, y, r } = sys.getShake();

        // Apply shake offset
        // Note: We assume camera stays at (0,0,100) base. 
        // If we add camera tracking later, we must add this offset to the target position.
        camera.position.x = x;
        camera.position.y = y;
        camera.rotation.z = r;
        
    } catch {
        // System not ready yet
    }
  });

  return null;
};


=====================================
FILE: ./src/game/components/data/HealthComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class HealthComponent extends Component {
  readonly _type = 'Health';

  public current: number;

  constructor(
    public max: number,
    public invincibilityTime: number = 0
  ) {
    super();
    this.current = max;
  }

  public get isDead(): boolean {
    return this.current <= 0;
  }

  public damage(amount: number) {
    // Invincibility handling will happen in Systems, this is just data
    this.current = Math.max(0, this.current - amount);
  }
  
  public heal(amount: number) {
      this.current = Math.min(this.max, this.current + amount);
  }
}


=====================================
FILE: ./src/game/components/data/MotionComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class MotionComponent extends Component {
  readonly _type = 'Motion';

  constructor(
    public vx: number = 0,
    public vy: number = 0,
    public friction: number = 0, // 0 = no friction, 1 = stop instantly
    public angularVelocity: number = 0
  ) {
    super();
  }
}


=====================================
FILE: ./src/game/components/data/IdentityComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

// This holds specific game logic identifiers (MUNCHER, HUNTER)
export class IdentityComponent extends Component {
  readonly _type = 'Identity';

  constructor(
    public variant: string // e.g. 'muncher', 'hunter', 'boss'
  ) {
    super();
  }
}


=====================================
FILE: ./src/game/components/data/StateComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class StateComponent extends Component {
  readonly _type = 'State';

  constructor(
    public current: string = 'IDLE',
    public timers: Record<string, number> = {},
    public data: Record<string, any> = {}
  ) {
    super();
  }

  public set(state: string) {
    this.current = state;
  }
}


=====================================
FILE: ./src/game/components/data/LifetimeComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

// Used for bullets and particles that die after N seconds
export class LifetimeComponent extends Component {
  readonly _type = 'Lifetime';

  constructor(
    public remaining: number, // Seconds
    public total: number
  ) {
    super();
  }
}


=====================================
FILE: ./src/game/components/data/TransformComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class TransformComponent extends Component {
  readonly _type = 'Transform';

  constructor(
    public x: number = 0,
    public y: number = 0,
    public rotation: number = 0,
    public scale: number = 1
  ) {
    super();
  }
}


=====================================
FILE: ./src/game/components/data/CombatComponent.ts
=====================================
import { Component } from '../../core/ecs/Component';

export class CombatComponent extends Component {
  readonly _type = 'Combat';

  constructor(
    public damage: number,
    public cooldown: number = 0, // Time until next attack
    public range: number = 0
  ) {
    super();
  }
}


=====================================
FILE: ./src/game/components/EffectsLayer.tsx
=====================================
import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';

export const EffectsLayer = () => {
  return (
    <EffectComposer disableNormalPass>
      {/* 
        BLOOM: Adds the "Neon" glow.
        luminanceThreshold: Only bright colors glow.
        intensity: How strong the glow is.
      */}
      <Bloom 
        luminanceThreshold={0.2} 
        mipmapBlur 
        intensity={1.5} 
        radius={0.4} 
      />
      
      {/* VIGNETTE: Darkens corners for focus */}
      <Vignette eskil={false} offset={0.1} darkness={0.5} />
    </EffectComposer>
  );
};


=====================================
FILE: ./src/game/components/ProjectileTrails.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { Registry } from '../core/ecs/EntityRegistry';
import { Tag } from '../core/ecs/types';
import { TransformComponent } from '../components/data/TransformComponent';
import { MotionComponent } from '../components/data/MotionComponent';
import { LifetimeComponent } from '../components/data/LifetimeComponent';
import { GAME_THEME } from '../theme';
import { createCometTexture } from '../utils/TextureGen';

const MAX_TRAILS = 500; 

export const ProjectileTrails = () => {
  const meshRef = useRef<THREE.InstancedMesh>(null);
  
  const geometry = useMemo(() => {
      const geo = new THREE.PlaneGeometry(1, 1);
      geo.translate(0, 0.5, 0); 
      return geo;
  }, []);

  const shaderMaterial = useMemo(() => new THREE.ShaderMaterial({
    vertexShader: `
      // FIX: Robust Guard.
      // If Three.js has injected the logic (USE_INSTANCING_COLOR), we skip.
      // If not (Frame 0), we define it to prevent 'Undeclared Identifier'.
      #ifndef USE_INSTANCING_COLOR
      attribute vec3 instanceColor;
      #endif

      varying vec2 vUv;
      varying vec3 vColor;
      
      void main() {
        vUv = uv;
        vColor = instanceColor; 
        
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      varying vec2 vUv;
      varying vec3 vColor;
      
      void main() {
        // 1. Horizontal Profile (Sharp Beam)
        float distFromCenter = abs(vUv.x - 0.5) * 2.0;
        float beam = 1.0 - pow(distFromCenter, 3.0);
        
        // 2. Tail Decay (Fade out at end)
        float tailDecay = 1.0 - vUv.y;
        tailDecay = pow(tailDecay, 2.0);
        
        // 3. Head Fade (Soft start)
        float headFade = smoothstep(0.0, 0.1, vUv.y);
        
        float alpha = beam * tailDecay * headFade;
        
        vec3 finalColor = mix(vColor, vec3(1.0), beam * 0.8); 
        
        if (alpha < 0.01) discard;
        gl_FragColor = vec4(finalColor, alpha * 0.8);
      }
    `,
    uniforms: {},
    vertexColors: true, 
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
  }), []);

  useFrame(() => {
    if (!meshRef.current) return;
    const tempObj = new THREE.Object3D();
    const tempColor = new THREE.Color();

    let count = 0;
    const bullets = Registry.getByTag(Tag.BULLET);

    for (const b of bullets) {
        if (count >= MAX_TRAILS) break;
        const t = b.getComponent<TransformComponent>('Transform');
        const m = b.getComponent<MotionComponent>('Motion');
        const life = b.getComponent<LifetimeComponent>('Lifetime');
        
        if (!t || !m || !life) continue;

        const isEnemy = b.hasTag(Tag.ENEMY);
        
        // Widths
        const trailWidth = isEnemy ? 1.0 : 0.4;

        const speed = Math.sqrt(m.vx * m.vx + m.vy * m.vy);
        const age = life.total - life.remaining;
        
        const maxLen = isEnemy ? 4.0 : 3.0; 
        const targetLength = Math.min(speed * 0.12, maxLen);
        const currentLength = Math.min(targetLength, age * 10.0); 

        // Position: Behind bullet
        tempObj.position.set(t.x, t.y, -0.2); 
        
        // Rotation
        tempObj.rotation.z = t.rotation + (Math.PI / 2);
        
        // Scale
        tempObj.scale.set(trailWidth, currentLength, 1);

        const colorHex = isEnemy ? GAME_THEME.bullet.hunter : GAME_THEME.bullet.trail;
        tempColor.set(colorHex);

        tempObj.updateMatrix();
        meshRef.current.setMatrixAt(count, tempObj.matrix);
        meshRef.current.setColorAt(count, tempColor);
        count++;
    }

    meshRef.current.count = count;
    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor) meshRef.current.instanceColor.needsUpdate = true;
  });

  return (
    <instancedMesh ref={meshRef} args={[geometry, shaderMaterial, MAX_TRAILS]} renderOrder={-1}>
    </instancedMesh>
  );
};


=====================================
FILE: ./src/game/hooks/usePanelRegistry.ts
=====================================
import { useEffect, useRef } from 'react';
import { useGameStore } from '../store/useGameStore';
import { PanelRegistry } from '../systems/PanelRegistrySystem';

export const usePanelRegistry = (id: string) => {
  const elementRef = useRef<HTMLDivElement>(null);
  
  const registerPanel = useGameStore((state) => state.registerPanel);
  const unregisterPanel = useGameStore((state) => state.unregisterPanel);

  useEffect(() => {
    const el = elementRef.current;
    if (!el) return;

    // 1. Register Logic (Health/Store)
    registerPanel(id, el);

    // 2. Register Spatial (Singleton)
    // This works immediately, even if game hasn't started
    PanelRegistry.register(id, el);

    // 3. Resize Observer
    const observer = new ResizeObserver(() => {
        PanelRegistry.refreshSingle(id);
    });
    observer.observe(el);

    return () => {
      observer.disconnect();
      unregisterPanel(id);
      PanelRegistry.unregister(id);
    };
  }, [id, registerPanel, unregisterPanel]);

  return elementRef;
};


=====================================
FILE: ./src/game/theme.ts
=====================================
export const GAME_THEME = {
  turret: {
    base: '#78F654',
    glow: '#C2FE9A',
    repair: '#00F0FF',
  },
  bullet: {
    plasma: '#FFFFFF',
    trail: '#78F654',
    hunter: '#F7D277', // Specific color for Hunter shots
  },
  enemy: {
    muncher: '#9E4EA5',
    kamikaze: '#FF003C',
    hunter: '#F7D277',
    charge: '#FFFFFF',  // Telegraph flash
  },
  hud: {
    text: '#78F654',
    warning: '#FF003C',
  },
  vfx: {
    spark: '#FFFFFF',
    damage: '#FF003C',
    heal: '#00F0FF',
    clash: '#F7D277',
  }
};


=====================================
FILE: ./src/game/events/GameEvents.ts
=====================================
export enum GameEvents {
  // --- COMBAT ---
  PLAYER_FIRED = 'PLAYER_FIRED',
  PLAYER_HIT = 'PLAYER_HIT',
  ENEMY_SPAWNED = 'ENEMY_SPAWNED',
  ENEMY_DAMAGED = 'ENEMY_DAMAGED',
  ENEMY_DESTROYED = 'ENEMY_DESTROYED',
  PROJECTILE_CLASH = 'PROJECTILE_CLASH',
  
  // --- PANEL ---
  PANEL_DAMAGED = 'PANEL_DAMAGED',
  PANEL_HEALED = 'PANEL_HEALED',
  PANEL_DESTROYED = 'PANEL_DESTROYED',
  
  // --- SYSTEM ---
  GAME_START = 'GAME_START',
  GAME_OVER = 'GAME_OVER',
  THREAT_LEVEL_UP = 'THREAT_LEVEL_UP',
  UPGRADE_SELECTED = 'UPGRADE_SELECTED', // NEW
  
  // --- VISUAL ---
  TRAUMA_ADDED = 'TRAUMA_ADDED',
  SCENE_READY = 'SCENE_READY'
}

export interface GameEventPayloads {
  [GameEvents.PLAYER_FIRED]: { x: number; y: number };
  [GameEvents.PLAYER_HIT]: { damage: number };
  [GameEvents.ENEMY_SPAWNED]: { type: string; id: number };
  [GameEvents.ENEMY_DAMAGED]: { id: number; damage: number; type: string };
  [GameEvents.ENEMY_DESTROYED]: { id: number; type: string; x: number; y: number };
  [GameEvents.PROJECTILE_CLASH]: { x: number; y: number };
  
  [GameEvents.PANEL_DAMAGED]: { id: string; amount: number; currentHealth: number };
  [GameEvents.PANEL_HEALED]: { id: string; amount: number };
  [GameEvents.PANEL_DESTROYED]: { id: string };
  
  [GameEvents.GAME_START]: null;
  [GameEvents.GAME_OVER]: { score: number };
  [GameEvents.THREAT_LEVEL_UP]: { level: number };
  [GameEvents.UPGRADE_SELECTED]: { option: string }; // NEW
  
  [GameEvents.TRAUMA_ADDED]: { amount: number };
  [GameEvents.SCENE_READY]: null;
}


=====================================
FILE: ./src/game/events/GameEventBus.ts
=====================================
import { GameEvents, GameEventPayloads } from './GameEvents';

type Handler<T extends GameEvents> = (payload: GameEventPayloads[T]) => void;

class GameEventBusController {
  private listeners: Partial<Record<GameEvents, Function[]>> = {};
  private history: { event: string; payload: any; timestamp: number }[] = [];
  private readonly MAX_HISTORY = 50;

  public subscribe<T extends GameEvents>(event: T, handler: Handler<T>): () => void {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event]!.push(handler);

    return () => {
      this.listeners[event] = this.listeners[event]!.filter(h => h !== handler);
    };
  }

  public emit<T extends GameEvents>(event: T, payload: GameEventPayloads[T]): void {
    // 1. Log History
    this.history.push({ event, payload, timestamp: Date.now() });
    if (this.history.length > this.MAX_HISTORY) {
      this.history.shift();
    }

    // 2. Dispatch
    if (!this.listeners[event]) return;
    [...this.listeners[event]!].forEach(handler => handler(payload));
  }

  public clear(): void {
    this.listeners = {};
    this.history = [];
  }

  public dumpHistory(): void {
    console.table(this.history);
  }
}

export const GameEventBus = new GameEventBusController();


=====================================
FILE: ./src/game/systems/CollisionSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { EntitySystem } from './EntitySystem';
import { Registry } from '../core/ecs/EntityRegistry';
import { Tag } from '../core/ecs/types';
import { TransformComponent } from '../components/data/TransformComponent';
import { HealthComponent } from '../components/data/HealthComponent';
import { IdentityComponent } from '../components/data/IdentityComponent';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { EnemyTypes } from '../config/Identifiers';
import { GameStateSystem } from './GameStateSystem'; // NEW

export class CollisionSystem implements IGameSystem {
  private entitySystem!: EntitySystem;
  private gameSystem!: GameStateSystem; // NEW
  private locator!: IServiceLocator;

  setup(locator: IServiceLocator): void {
    this.locator = locator;
    this.entitySystem = locator.getSystem<EntitySystem>('EntitySystem');
    this.gameSystem = locator.getSystem<GameStateSystem>('GameStateSystem');
  }

  update(delta: number, time: number): void {
    const spatial = this.entitySystem.spatialGrid;
    const cursor = this.locator.getInputService().getCursor();

    this.handleBulletCollisions(spatial);
    this.handleProjectileClash(spatial);

    // Enemy Bullets vs Player
    const bullets = Registry.getByTag(Tag.BULLET);
    for (const b of bullets) {
        if (!b.hasTag(Tag.ENEMY)) continue;
        const bPos = b.getComponent<TransformComponent>('Transform');
        if (!bPos) continue;
        const dx = bPos.x - cursor.x;
        const dy = bPos.y - cursor.y;
        if (dx*dx + dy*dy < 0.25) { 
            Registry.destroyEntity(b.id);
            this.damagePlayer(10); 
            this.entitySystem.spawnParticle(bPos.x, bPos.y, '#FF003C', 5);
        }
    }

    // Body Collisions
    const players = Registry.getByTag(Tag.PLAYER);
    const player = players[0];
    
    if (player && player.active) {
        const pPos = player.getComponent<TransformComponent>('Transform');
        if (pPos) {
            const nearby = spatial.query(pPos.x, pPos.y, 1.0);
            for (const id of nearby) {
                const enemy = Registry.getEntity(id);
                if (!enemy || !enemy.active || !enemy.hasTag(Tag.ENEMY)) continue;
                if (enemy.hasTag(Tag.BULLET)) continue; 

                const ePos = enemy.getComponent<TransformComponent>('Transform');
                if (!ePos) continue;

                const dx = pPos.x - ePos.x;
                const dy = pPos.y - ePos.y;
                
                if (dx*dx + dy*dy < 0.36) {
                    this.handleBodyCollision(enemy, ePos.x, ePos.y);
                }
            }
        }
    }
  }

  private handleProjectileClash(spatial: any) {
      const playerBullets = Registry.getByTag(Tag.BULLET).filter(b => !b.hasTag(Tag.ENEMY));
      for (const pb of playerBullets) {
          const pPos = pb.getComponent<TransformComponent>('Transform');
          if (!pPos) continue;
          const nearby = spatial.query(pPos.x, pPos.y, 1.0);
          for (const id of nearby) {
              const target = Registry.getEntity(id);
              if (!target || !target.active || !target.hasTag(Tag.BULLET) || !target.hasTag(Tag.ENEMY)) continue;
              const tPos = target.getComponent<TransformComponent>('Transform');
              if (!tPos) continue;
              const dx = pPos.x - tPos.x;
              const dy = pPos.y - tPos.y;
              if (dx*dx + dy*dy < 1.0) {
                  Registry.destroyEntity(pb.id);
                  Registry.destroyEntity(target.id);
                  GameEventBus.emit(GameEvents.PROJECTILE_CLASH, { x: tPos.x, y: tPos.y });
                  this.entitySystem.spawnParticle(tPos.x, tPos.y, '#F7D277', 6);
                  break; 
              }
          }
      }
  }

  private handleBodyCollision(enemy: any, x: number, y: number) {
      const identity = enemy.getComponent<IdentityComponent>('Identity');
      const type = identity ? identity.variant : 'unknown';
      if (type === EnemyTypes.KAMIKAZE) {
          this.damagePlayer(25); 
          this.entitySystem.spawnParticle(x, y, '#FF003C', 15);
      } else {
          this.damagePlayer(10);
          this.entitySystem.spawnParticle(x, y, '#9E4EA5', 8);
      }
      Registry.destroyEntity(enemy.id);
  }

  private damagePlayer(amount: number) {
      // FIX: Use GameStateSystem, not Store
      this.gameSystem.damagePlayer(amount);
      GameEventBus.emit(GameEvents.PLAYER_HIT, { damage: amount });
  }

  private handleBulletCollisions(spatial: any) {
    const bullets = Registry.getByTag(Tag.BULLET);
    for (const b of bullets) {
        if (b.hasTag(Tag.ENEMY)) continue; 
        const bPos = b.getComponent<TransformComponent>('Transform');
        if (!bPos) continue;

        const candidates = spatial.query(bPos.x, bPos.y, 1.0);
        for (const targetId of candidates) {
            const target = Registry.getEntity(targetId);
            if (!target || !target.active || !target.hasTag(Tag.ENEMY) || target.hasTag(Tag.BULLET)) continue;
            
            const dx = bPos.x - target.getComponent<TransformComponent>('Transform')!.x;
            const dy = bPos.y - target.getComponent<TransformComponent>('Transform')!.y;

            if (dx*dx + dy*dy < 0.49) { 
                Registry.destroyEntity(b.id);
                const hp = target.getComponent<HealthComponent>('Health');
                if (hp) {
                    hp.damage(1);
                    GameEventBus.emit(GameEvents.ENEMY_DAMAGED, { 
                        id: target.id as number, damage: 1, type: 'unknown' 
                    });
                }
                this.entitySystem.spawnParticle(bPos.x, bPos.y, '#FFF', 2);
                break;
            }
        }
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/game/systems/UISyncSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { useGameStore } from '../store/useGameStore';
import { GameStateSystem } from './GameStateSystem';
import { PanelRegistry } from './PanelRegistrySystem';

export class UISyncSystem implements IGameSystem {
  private gameSystem!: GameStateSystem;
  
  private readonly SYNC_INTERVAL = 0.1;
  private timeSinceLastSync = 0;

  setup(locator: IServiceLocator): void {
    this.gameSystem = locator.getSystem<GameStateSystem>('GameStateSystem');
  }

  update(delta: number, time: number): void {
    this.timeSinceLastSync += delta;
    if (this.timeSinceLastSync < this.SYNC_INTERVAL) return;
    this.timeSinceLastSync = 0;
    this.sync();
  }

  teardown(): void {}

  private sync() {
    const store = useGameStore.getState();
    
    // Sync Global State
    store.syncGameState({
        playerHealth: this.gameSystem.playerHealth,
        playerRebootProgress: this.gameSystem.playerRebootProgress,
        score: this.gameSystem.score,
        xp: this.gameSystem.xp,
        level: this.gameSystem.level,
        xpToNextLevel: this.gameSystem.xpToNextLevel,
        upgradePoints: this.gameSystem.upgradePoints,
        systemIntegrity: PanelRegistry.systemIntegrity,
        activeUpgrades: { ...this.gameSystem.activeUpgrades } // FIX: Ensure new object reference
    });

    // Sync Panels
    const uiPanels: Record<string, any> = {};
    const panels = PanelRegistry.getAllPanels();
    
    for(const p of panels) {
        uiPanels[p.id] = {
            id: p.id,
            health: p.health,
            isDestroyed: p.isDestroyed
        };
    }
    
    store.syncPanels(uiPanels);
  }
}


=====================================
FILE: ./src/game/systems/InteractionSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { EntitySystem } from './EntitySystem';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { PanelRegistry } from './PanelRegistrySystem'; 
import { GameStateSystem } from './GameStateSystem'; 

export type RepairState = 'IDLE' | 'HEALING' | 'REBOOTING';

export class InteractionSystem implements IGameSystem {
  public repairState: RepairState = 'IDLE';
  
  private lastRepairTime = 0;
  private readonly REPAIR_RATE = 0.05;
  private locator!: IServiceLocator;
  private entitySystem!: EntitySystem;
  private gameSystem!: GameStateSystem; 

  setup(locator: IServiceLocator): void {
    this.locator = locator;
    this.entitySystem = locator.getSystem<EntitySystem>('EntitySystem');
    this.gameSystem = locator.getSystem<GameStateSystem>('GameStateSystem');
  }

  update(delta: number, time: number): void {
    this.repairState = 'IDLE';
    
    // STRICT CHECK: If game is over (Integrity 0), disable ALL interaction
    if (this.gameSystem.isGameOver) {
        return; 
    }
    
    const cursor = this.locator.getInputService().getCursor();
    
    // Player Dead logic (Revive Player)
    if (this.gameSystem.playerHealth <= 0) {
        this.handleRevival(cursor, time);
        return; 
    }

    // Panel Repair Logic
    this.handlePanelRepair(cursor, time);
    
    // Decay Logic for destroyed panels
    if (time > this.lastRepairTime + this.REPAIR_RATE) {
        const panels = PanelRegistry.getAllPanels();
        for (const p of panels) {
            if (p.isDestroyed && p.health > 0) {
                 PanelRegistry.decayPanel(p.id, 5);
            }
        }
    }
  }

  teardown(): void {}

  private handleRevival(cursor: {x: number, y: number}, time: number) {
    const rect = PanelRegistry.getPanelRect('identity');
    if (!rect) return;
    const padding = 2.0; 
    const isHovering = 
        cursor.x >= rect.left - padding && 
        cursor.x <= rect.right + padding && 
        cursor.y >= rect.bottom - padding && 
        cursor.y <= rect.top + padding;

    if (isHovering) {
        this.repairState = 'REBOOTING';
        if (time > this.lastRepairTime + this.REPAIR_RATE) {
            this.gameSystem.tickReboot(2.5);
            this.lastRepairTime = time;
            if (Math.random() > 0.3) this.entitySystem.spawnParticle(cursor.x, cursor.y, '#9E4EA5', 4);
        }
    } else {
        if (this.gameSystem.playerRebootProgress > 0 && time > this.lastRepairTime + this.REPAIR_RATE) {
            this.gameSystem.tickReboot(-2.0);
        }
    }
  }

  private handlePanelRepair(cursor: {x: number, y: number}, time: number) {
    const panels = PanelRegistry.getAllPanels();
    let hoveringPanelId: string | null = null;

    for (const p of panels) {
      if (!p.isDestroyed && p.health >= 1000) continue;
      if (cursor.x >= p.left && cursor.x <= p.right && cursor.y >= p.bottom && cursor.y <= p.top) {
        hoveringPanelId = p.id;
        break; 
      }
    }

    if (hoveringPanelId) {
        const state = PanelRegistry.getPanelState(hoveringPanelId);
        if (!state) return;
        
        this.repairState = state.isDestroyed ? 'REBOOTING' : 'HEALING';

        if (time > this.lastRepairTime + this.REPAIR_RATE) {
            PanelRegistry.healPanel(hoveringPanelId, 10);
            this.lastRepairTime = time;
            if (!state.isDestroyed) GameEventBus.emit(GameEvents.PANEL_HEALED, { id: hoveringPanelId, amount: 10 });
            if (Math.random() > 0.3) {
                const color = state.isDestroyed ? '#9E4EA5' : '#00F0FF'; 
                this.entitySystem.spawnParticle(cursor.x, cursor.y, color, 4);
            }
        }
    }
  }
}


=====================================
FILE: ./src/game/systems/CameraSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { noise } from '../utils/Noise';

export class CameraSystem implements IGameSystem {
  public trauma = 0;
  private time = 0;
  
  // Configuration
  private readonly DECAY_RATE = 0.8; 
  private readonly MAX_OFFSET = 1.5; 
  private readonly MAX_ROTATION = 0.05; 
  private readonly NOISE_SPEED = 15.0; 

  setup(locator: IServiceLocator): void {
    this.setupListeners();
  }

  update(delta: number, time: number): void {
    this.time += delta;
    if (this.trauma > 0) {
      this.trauma = Math.max(0, this.trauma - (delta * this.DECAY_RATE));
    }
  }

  teardown(): void {}

  private setupListeners() {
    // MINOR SHAKE: Standard Player Hit (Collision)
    GameEventBus.subscribe(GameEvents.PLAYER_HIT, (p) => {
        // Hunter bullets/Munchers deal 10 dmg. Kamikazes deal 25 dmg.
        // FIX: Reduced minor hit trauma from 0.35 to 0.2 for tighter, shorter shake.
        const intensity = p.damage > 10 ? 0.6 : 0.2; 
        this.addTrauma(intensity);
    });

    // MAJOR SHAKE: Panel Destruction
    GameEventBus.subscribe(GameEvents.PANEL_DESTROYED, () => this.addTrauma(0.7));
    
    // CATASTROPHIC: Game Over
    GameEventBus.subscribe(GameEvents.GAME_OVER, () => this.addTrauma(1.0));
  }

  public addTrauma(amount: number) {
    this.trauma = Math.min(1.0, this.trauma + amount);
  }

  public getShake() {
    if (this.trauma <= 0) return { x: 0, y: 0, r: 0 };

    const shake = this.trauma * this.trauma;
    
    const x = this.MAX_OFFSET * shake * noise(this.time * this.NOISE_SPEED);
    const y = this.MAX_OFFSET * shake * noise((this.time * this.NOISE_SPEED) + 100);
    const r = this.MAX_ROTATION * shake * noise((this.time * this.NOISE_SPEED) + 200);

    return { x, y, r };
  }
}


=====================================
FILE: ./src/game/systems/PlayerSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { EntitySystem } from './EntitySystem';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { PLAYER_CONFIG } from '../config/PlayerConfig';
import { Registry } from '../core/ecs/EntityRegistry';
import { Tag } from '../core/ecs/types';
import { TransformComponent } from '../components/data/TransformComponent';
import { StateComponent } from '../components/data/StateComponent';
import { InteractionSystem } from './InteractionSystem';
import { GameStateSystem } from './GameStateSystem';

export class PlayerSystem implements IGameSystem {
  private lastFireTime = 0;
  private entitySystem!: EntitySystem;
  private gameSystem!: GameStateSystem;
  private locator!: IServiceLocator;

  setup(locator: IServiceLocator): void {
    this.locator = locator;
    this.entitySystem = locator.getSystem<EntitySystem>('EntitySystem');
    this.gameSystem = locator.getSystem<GameStateSystem>('GameStateSystem');
    this.setupListeners();
  }

  update(delta: number, time: number): void {
    if (this.gameSystem.isGameOver) return;

    // 1. GET PLAYER ENTITY
    const players = Registry.getByTag(Tag.PLAYER);
    const playerEntity = players[0]; 
    if (!playerEntity) return;

    // 2. SYNC POSITION
    const cursor = this.locator.getInputService().getCursor();
    const transform = playerEntity.getComponent<TransformComponent>('Transform');
    if (transform) {
        transform.x = cursor.x;
        transform.y = cursor.y;
    }

    // 3. UPDATE STATE
    const stateComp = playerEntity.getComponent<StateComponent>('State');
    if (stateComp) {
        if (this.gameSystem.playerHealth <= 0) {
            stateComp.current = 'DEAD';
        } else {
            try {
                const interact = this.locator.getSystem<InteractionSystem>('InteractionSystem');
                if (interact && interact.repairState !== 'IDLE') {
                    stateComp.current = 'REBOOTING';
                } else {
                    stateComp.current = 'ACTIVE';
                }
            } catch {
                stateComp.current = 'ACTIVE';
            }
        }
    }

    // 4. COMBAT LOGIC
    if (stateComp && (stateComp.current === 'ACTIVE' || stateComp.current === 'REBOOTING')) {
        const upgrades = this.gameSystem.activeUpgrades;
        const rapidLevel = upgrades['RAPID_FIRE'] || 0;
        const currentFireRate = PLAYER_CONFIG.fireRate * Math.pow(0.85, rapidLevel);

        if (time > this.lastFireTime + currentFireRate) {
            this.attemptAutoFire(time, playerEntity);
        }
    }
  }

  teardown(): void {
  }

  private setupListeners() {
    GameEventBus.subscribe(GameEvents.PLAYER_HIT, (payload) => {
       // Death logic is handled by state/HUD. Game Over is mostly unused until we define a true lose condition (like failing reboot)
    });

    GameEventBus.subscribe(GameEvents.ENEMY_DESTROYED, () => {
      this.gameSystem.addScore(1);
      this.gameSystem.addXp(10);
    });
  }

  private attemptAutoFire(time: number, player: any) {
    const cursor = this.locator.getInputService().getCursor();
    const enemies = Registry.getByTag(Tag.ENEMY);
    let nearestDist = Infinity;
    const RANGE = 12; 
    let targetEnemy: any = null;

    for (const e of enemies) {
      if (!e.active) continue;
      const t = e.getComponent<TransformComponent>('Transform');
      if (!t) continue;
      const dx = t.x - cursor.x;
      const dy = t.y - cursor.y;
      const dist = dx*dx + dy*dy; 
      if (dist < (RANGE * RANGE) && dist < nearestDist) {
          nearestDist = dist;
          targetEnemy = e;
      }
    }

    if (targetEnemy) {
      const upgrades = this.gameSystem.activeUpgrades;
      const multiLevel = upgrades['MULTI_SHOT'] || 0;
      const projectileCount = 1 + (multiLevel * 2);
      const spreadAngle = 0.2; 
      
      const tPos = targetEnemy.getComponent<TransformComponent>('Transform')!;
      const dx = tPos.x - cursor.x;
      const dy = tPos.y - cursor.y;
      const baseAngle = Math.atan2(dy, dx);
      const startAngle = baseAngle - ((projectileCount - 1) * spreadAngle) / 2;

      for (let i = 0; i < projectileCount; i++) {
          const angle = startAngle + (i * spreadAngle);
          const vx = Math.cos(angle) * PLAYER_CONFIG.bulletSpeed;
          const vy = Math.sin(angle) * PLAYER_CONFIG.bulletSpeed;

          this.entitySystem.spawnBullet(
              cursor.x, cursor.y, vx, vy, false, 
              PLAYER_CONFIG.bulletLife, PLAYER_CONFIG.bulletRadius
          );
      }
      
      GameEventBus.emit(GameEvents.PLAYER_FIRED, { x: cursor.x, y: cursor.y });
      this.lastFireTime = time;
    }
  }
}


=====================================
FILE: ./src/game/systems/TimeSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { WorldConfig } from '../config/WorldConfig';

export class TimeSystem implements IGameSystem {
  public timeScale: number = 1.0;
  public elapsedTime: number = 0;
  public delta: number = 0;
  public isPaused: boolean = false;
  
  private freezeTimer: number = 0;

  setup(locator: IServiceLocator): void {
    this.reset();
  }

  update(rawDelta: number, rawTime: number): void {
    // 1. Handle Hit Stop (Freeze)
    if (this.freezeTimer > 0) {
        this.freezeTimer -= rawDelta;
        this.delta = 0; // Game logic pauses
        return;
    }

    if (this.isPaused) {
      this.delta = 0;
      return;
    }

    // 2. Normal Time Processing
    const safeDelta = Math.min(rawDelta, WorldConfig.time.maxDelta);
    this.delta = safeDelta * this.timeScale;
    this.elapsedTime += this.delta;
  }

  teardown(): void {
    this.reset();
  }

  private reset() {
    this.timeScale = 1.0;
    this.elapsedTime = 0;
    this.delta = 0;
    this.isPaused = false;
    this.freezeTimer = 0;
  }
  
  public setScale(scale: number, duration?: number) {
    this.timeScale = scale;
    if (duration) {
      setTimeout(() => {
        this.timeScale = 1.0;
      }, duration * 1000);
    }
  }

  /**
   * Freezes game logic for a specific duration (seconds)
   * Used for "Hit Stop" effects.
   */
  public freeze(duration: number) {
      this.freezeTimer = duration;
  }
}


=====================================
FILE: ./src/game/systems/EntitySystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { Registry } from '../core/ecs/EntityRegistry';
import { EntityFactory } from '../core/EntityFactory';
import { SpatialGrid } from '../core/SpatialGrid';
import { Tag } from '../core/ecs/types';
import { TransformComponent } from '../components/data/TransformComponent';
import { MotionComponent } from '../components/data/MotionComponent';
import { LifetimeComponent } from '../components/data/LifetimeComponent';
import { HealthComponent } from '../components/data/HealthComponent';
import { IdentityComponent } from '../components/data/IdentityComponent';
import { Behaviors, AIContext } from '../logic/ai/EnemyBehaviors';
import { GameEvents } from '../events/GameEvents';
import { EnemyType } from '../config/Identifiers'; 
import { GameEventBus } from '../events/GameEventBus';
import { PanelRegistry } from './PanelRegistrySystem'; // NEW

export class EntitySystem implements IGameSystem {
  public spatialGrid: SpatialGrid;
  private locator!: IServiceLocator;

  constructor() {
    this.spatialGrid = new SpatialGrid(4);
  }

  setup(locator: IServiceLocator): void {
    this.locator = locator;
    Registry.clear();
    this.spatialGrid.clear();
  }

  update(delta: number, time: number): void {
    this.spatialGrid.clear();
    const cursor = this.locator.getInputService().getCursor();
    const doDamageTick = Math.floor(time * 2) > Math.floor((time - delta) * 2);

    // FIX: Get Panel Data from Registry
    const worldPanels = PanelRegistry.getAllPanels().filter(p => !p.isDestroyed);

    const aiContext: AIContext = {
      playerPos: cursor,
      panels: worldPanels,
      delta,
      time,
      doDamageTick,
      spawnProjectile: (x, y, vx, vy) => EntityFactory.createBullet(x, y, vx, vy, true, 3.0),
      triggerExplosion: (x, y, color) => this.spawnParticle(x, y, color, 8, 15, 0.8),
      spawnDrillSparks: (x, y, color) => this.spawnParticle(x, y, color, 1, 3.0, 0.25),
      emitEvent: (name, payload) => GameEventBus.emit(name as any, payload),
      
      // FIX: Damage via Registry
      damagePanel: (id, amount) => PanelRegistry.damagePanel(id, amount)
    };

    for (const entity of Registry.getAll()) {
      if (!entity.active) continue;

      const lifetime = entity.getComponent<LifetimeComponent>('Lifetime');
      if (lifetime) {
        lifetime.remaining -= delta;
        if (lifetime.remaining <= 0) {
          Registry.destroyEntity(entity.id);
          continue;
        }
      }

      const health = entity.getComponent<HealthComponent>('Health');
      if (health && health.isDead) {
          Registry.destroyEntity(entity.id);
          const identity = entity.getComponent<IdentityComponent>('Identity');
          const transform = entity.getComponent<TransformComponent>('Transform');
          if (identity && transform) {
             GameEventBus.emit(GameEvents.ENEMY_DESTROYED, { 
                id: entity.id as number, 
                type: identity.variant, 
                x: transform.x, 
                y: transform.y 
             });
             this.spawnExplosion(transform.x, transform.y, identity.variant);
          }
          continue;
      }

      const transform = entity.getComponent<TransformComponent>('Transform');
      const motion = entity.getComponent<MotionComponent>('Motion');
      
      if (transform && motion) {
        transform.x += motion.vx * delta;
        transform.y += motion.vy * delta;
        this.spatialGrid.insert(entity.id, transform.x, transform.y);
      }

      if (entity.hasTag(Tag.ENEMY)) {
        const identity = entity.getComponent<IdentityComponent>('Identity');
        if (identity && transform && motion) {
             const behavior = Behaviors[identity.variant];
             if (behavior) behavior.update(entity, aiContext);
        }
      }
    }
  }

  teardown(): void {
    Registry.clear();
    this.spatialGrid.clear();
  }

  public spawnEnemy(type: EnemyType) {
      const angle = Math.random() * Math.PI * 2;
      const radius = 25; 
      const x = Math.cos(angle) * radius;
      const y = Math.sin(angle) * radius;
      const e = EntityFactory.createEnemy(type, x, y);
      GameEventBus.emit(GameEvents.ENEMY_SPAWNED, { type, id: e.id as number });
  }

  public spawnBullet(x: number, y: number, vx: number, vy: number, isEnemy: boolean, life: number, radius: number) {
      EntityFactory.createBullet(x, y, vx, vy, isEnemy, life);
  }

  public spawnParticle(x: number, y: number, color: string, count: number, speedScale = 15, lifeScale = 1.0) {
      for(let i=0; i<count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * speedScale; 
          const life = (0.2 + Math.random() * 0.3) * lifeScale;
          EntityFactory.createParticle(x, y, color, Math.cos(angle)*speed, Math.sin(angle)*speed, life);
      }
  }

  private spawnExplosion(x: number, y: number, type: string) {
      const color = type === 'hunter' ? '#F7D277' : type === 'kamikaze' ? '#FF003C' : '#9E4EA5';
      this.spawnParticle(x, y, color, 12, 15, 1.0);
  }
}


=====================================
FILE: ./src/game/systems/FXManager.ts
=====================================
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { ServiceLocator } from '../core/ServiceLocator';
import { TimeSystem } from './TimeSystem';
import { CameraSystem } from './CameraSystem';

class FXManagerController {
  private initialized = false;
  
  public init() {
    if (this.initialized) return;
    
    // --- HIT STOP & TRAUMA EVENTS ---
    
    // 1. PANEL DESTROYED (Major Impact)
    GameEventBus.subscribe(GameEvents.PANEL_DESTROYED, () => {
        this.addTrauma(0.7);
        this.triggerHitStop(0.15); // 150ms Freeze
    });
    
    // 2. PLAYER HIT (Medium Impact)
    GameEventBus.subscribe(GameEvents.PLAYER_HIT, (p) => {
        const isBig = p.damage > 10;
        this.addTrauma(isBig ? 0.6 : 0.3);
        if (isBig) this.triggerHitStop(0.1); // 100ms Freeze on big hits
    });
    
    // 3. GAME OVER (Catastrophic)
    GameEventBus.subscribe(GameEvents.GAME_OVER, () => {
        this.addTrauma(1.0);
        this.triggerHitStop(0.5); // 500ms Freeze
    });

    // 4. BOSS DEATH (Placeholder Comment)
    // GameEventBus.subscribe(GameEvents.BOSS_DEATH, () => {
    //    this.addTrauma(1.0);
    //    this.triggerHitStop(1.0); // 1 Second dramatic pause
    // });
    
    this.initialized = true;
  }

  public addTrauma(amount: number) {
    try {
        const cam = ServiceLocator.getSystem<CameraSystem>('CameraSystem');
        cam.addTrauma(amount);
    } catch {}
  }

  private triggerHitStop(duration: number) {
    try {
        const time = ServiceLocator.getSystem<TimeSystem>('TimeSystem');
        time.freeze(duration);
    } catch {}
  }
}

export const FXManager = new FXManagerController();


=====================================
FILE: ./src/game/systems/InputSystem.ts
=====================================
import { IGameSystem, IServiceLocator, IInputService } from '../core/interfaces';

export class InputSystem implements IGameSystem, IInputService {
  private _cursor = { x: 0, y: 0 };
  private _keys = new Set<string>();

  setup(locator: IServiceLocator): void {
    // In Phase 5, we will add event listeners here.
    // For now, we rely on the React Component passing cursor data, 
    // effectively "mocking" the listeners.
  }

  update(delta: number, time: number): void {
    // No-op for now, cursor is updated externally via public method
  }

  teardown(): void {
    this._keys.clear();
  }

  // --- IInputService Implementation ---
  
  public updateCursor(x: number, y: number) {
    this._cursor.x = x;
    this._cursor.y = y;
  }

  public getCursorPosition() {
    return this._cursor;
  }

  public getCursor() {
    return this._cursor;
  }

  public isPressed(action: string): boolean {
    return this._keys.has(action);
  }
}


=====================================
FILE: ./src/game/systems/PanelRegistrySystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { ViewportHelper, WorldRect } from '../utils/ViewportHelper';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';

const MAX_PANEL_HEALTH = 1000;

interface PanelState {
  health: number;
  isDestroyed: boolean;
}

class PanelRegistrySystemClass implements IGameSystem {
  // Spatial Data
  private panelRects = new Map<string, WorldRect>();
  private observedElements = new Map<string, HTMLElement>();
  
  // Game Logic Data
  private panelStates = new Map<string, PanelState>();

  // Derived Metric
  public systemIntegrity: number = 100;

  setup(locator: IServiceLocator): void {
    // When game starts, we ensure states exist for all registered panels
    this.resetLogic();
    this.refreshAll();
  }

  update(delta: number, time: number): void {
    // Passive
  }

  teardown(): void {
    // We don't clear observedElements (DOM persists), but we can reset game logic?
    // Actually, let's keep logic state until explicit reset.
  }

  public resetLogic() {
    for (const id of this.observedElements.keys()) {
        this.panelStates.set(id, { health: MAX_PANEL_HEALTH, isDestroyed: false });
    }
    this.calculateIntegrity();
  }

  // --- ACTIONS ---

  public damagePanel(id: string, amount: number) {
    const state = this.panelStates.get(id);
    if (!state || state.isDestroyed) return;

    state.health = Math.max(0, state.health - amount);
    
    // Check Destruction
    if (state.health <= 0 && !state.isDestroyed) {
        state.isDestroyed = true;
        GameEventBus.emit(GameEvents.PANEL_DESTROYED, { id });
    } else {
        GameEventBus.emit(GameEvents.PANEL_DAMAGED, { id, amount, currentHealth: state.health });
    }
    
    this.calculateIntegrity();
  }

  public healPanel(id: string, amount: number) {
    const state = this.panelStates.get(id);
    if (!state) return;

    // Logic: If destroyed, healing brings it back to life but starts at low HP?
    // Or does "Rebooting" bring it back?
    // Let's stick to existing logic: Healing increments HP.
    // If destroyed, you must heal it back to full? Or just some?
    // Let's say: Healing works. If destroyed, getting > 0 doesn't undestroy immediately?
    // Existing logic: "If wasDestroyed and newHealth >= MAX, then undestroy".
    // Wait, InteractionSystem handles the "Reboot vs Heal" logic.
    // Let's allow simple healing here.
    
    const wasDestroyed = state.isDestroyed;
    state.health = Math.min(MAX_PANEL_HEALTH, state.health + amount);
    
    if (wasDestroyed && state.health >= MAX_PANEL_HEALTH) {
        state.isDestroyed = false;
        state.health = 500; // Reset to half health upon revival? Or logic from store...
        // Previous store logic: "if wasDestroyed and newHealth >= MAX ... newHealth = 500"
        // That logic was weird. Let's simplify:
        // You have to fill the bar to revive.
    }
    
    this.calculateIntegrity();
  }

  public decayPanel(id: string, amount: number) {
     const state = this.panelStates.get(id);
     if (!state || !state.isDestroyed) return;
     state.health = Math.max(0, state.health - amount);
  }

  private calculateIntegrity() {
    let current = 0;
    let max = 0;
    for (const state of this.panelStates.values()) {
        max += MAX_PANEL_HEALTH;
        if (!state.isDestroyed) current += state.health;
    }
    this.systemIntegrity = max > 0 ? (current / max) * 100 : 100;
  }

  // --- REGISTRY API ---

  public register(id: string, element: HTMLElement) {
    this.observedElements.set(id, element);
    if (!this.panelStates.has(id)) {
        this.panelStates.set(id, { health: MAX_PANEL_HEALTH, isDestroyed: false });
    }
    this.refreshSingle(id);
  }

  public unregister(id: string) {
    this.observedElements.delete(id);
    this.panelRects.delete(id);
    // We keep state in case it remounts? No, delete state too.
    this.panelStates.delete(id);
  }

  public refreshSingle(id: string) {
    const el = this.observedElements.get(id);
    if (!el || !el.isConnected) return;
    const rect = el.getBoundingClientRect();
    if (rect.width === 0 && rect.height === 0) return;
    this.panelRects.set(id, ViewportHelper.domToWorld(id, rect));
  }

  public refreshAll() {
    const ids = Array.from(this.observedElements.keys());
    for (const id of ids) this.refreshSingle(id);
  }

  // --- GETTERS ---

  public getPanelRect(id: string): WorldRect | undefined {
    return this.panelRects.get(id);
  }

  public getPanelState(id: string): PanelState | undefined {
    return this.panelStates.get(id);
  }
  
  public getAllPanels() {
      // Return combined data
      const result = [];
      for(const [id, rect] of this.panelRects) {
          const state = this.panelStates.get(id) || { health: 0, isDestroyed: true };
          result.push({ ...rect, ...state });
      }
      return result;
  }
}

export const PanelRegistry = new PanelRegistrySystemClass();


=====================================
FILE: ./src/game/systems/GameStateSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { PLAYER_CONFIG } from '../config/PlayerConfig';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';

export class GameStateSystem implements IGameSystem {
  public playerHealth: number = PLAYER_CONFIG.maxHealth;
  public maxPlayerHealth: number = PLAYER_CONFIG.maxHealth;
  public playerRebootProgress: number = 0;
  
  public score: number = 0;
  public xp: number = 0;
  public level: number = 1;
  public xpToNextLevel: number = PLAYER_CONFIG.baseXpRequirement;
  public upgradePoints: number = 0;
  public activeUpgrades: Record<string, number> = {
    'RAPID_FIRE': 0, 'MULTI_SHOT': 0, 'SPEED_UP': 0, 'REPAIR_NANITES': 0
  };

  public isGameOver: boolean = false;

  setup(locator: IServiceLocator): void {
    this.reset();
    
    // Listen for Upgrades
    GameEventBus.subscribe(GameEvents.UPGRADE_SELECTED, (p) => {
        this.applyUpgrade(p.option);
    });
    
    // REMOVED: Listener that caused Game Over on Identity Panel destruction.
    // The panel is now just another piece of hardware that can break and be fixed.
  }

  update(delta: number, time: number): void {}
  teardown(): void {}

  public reset() {
    this.playerHealth = this.maxPlayerHealth;
    this.playerRebootProgress = 0;
    this.score = 0;
    this.xp = 0;
    this.level = 1;
    this.xpToNextLevel = PLAYER_CONFIG.baseXpRequirement;
    this.upgradePoints = 0;
    this.isGameOver = false;
    this.activeUpgrades = { 'RAPID_FIRE': 0, 'MULTI_SHOT': 0, 'SPEED_UP': 0, 'REPAIR_NANITES': 0 };
  }

  public applyUpgrade(option: string) {
      if (this.upgradePoints > 0) {
          this.upgradePoints--;
          this.activeUpgrades[option] = (this.activeUpgrades[option] || 0) + 1;
          
          if (option === 'REPAIR_NANITES') {
             this.healPlayer(this.maxPlayerHealth * 0.2);
          }
      }
  }

  public damagePlayer(amount: number) {
    if (this.isGameOver) return;
    if (this.playerHealth > 0) {
        this.playerHealth = Math.max(0, this.playerHealth - amount);
    } else {
        this.playerRebootProgress = Math.max(0, this.playerRebootProgress - (amount * 2));
    }
  }

  public healPlayer(amount: number) {
    this.playerHealth = Math.min(this.maxPlayerHealth, this.playerHealth + amount);
  }

  public addScore(amount: number) {
    this.score += amount;
  }

  public addXp(amount: number) {
    this.xp += amount;
    while (this.xp >= this.xpToNextLevel) {
        this.xp -= this.xpToNextLevel;
        this.level++;
        this.upgradePoints++;
        this.xpToNextLevel = Math.floor(this.xpToNextLevel * PLAYER_CONFIG.xpScalingFactor);
        
        GameEventBus.emit(GameEvents.THREAT_LEVEL_UP, { level: this.level });
    }
  }

  public tickReboot(amount: number) {
    if (this.playerHealth > 0) return;
    this.playerRebootProgress = Math.max(0, Math.min(100, this.playerRebootProgress + amount));
    if (this.playerRebootProgress >= 100) {
        this.playerHealth = this.maxPlayerHealth / 2;
        this.playerRebootProgress = 0;
    }
  }
}


=====================================
FILE: ./src/game/systems/BreachSystem.ts
=====================================
import { ServiceLocator } from '../core/ServiceLocator';
import { useGameStore } from '../store/useGameStore';
import { ViewportHelper } from '../utils/ViewportHelper';
import { EnemyTypes } from '../config/Identifiers';

export class BreachSystem {
  private lastSpawnTime = 0;
  private SPAWN_INTERVAL = 3.0; // Seconds between breach waves

  public update(time: number) {
    if (!useGameStore.getState().isPlaying) return;

    if (time > this.lastSpawnTime + this.SPAWN_INTERVAL) {
      this.spawnBreachEnemies();
      this.lastSpawnTime = time;
    }
  }

  private spawnBreachEnemies() {
    const panels = useGameStore.getState().panels;
    
    // Find dead panels
    const destroyedPanels = Object.values(panels).filter(p => p.isDestroyed);
    
    if (destroyedPanels.length === 0) return;

    for (const p of destroyedPanels) {
      const rect = ViewportHelper.getPanelWorldRect(p);
      if (!rect) continue;

      // Spawn a fast Muncher or Kamikaze from the center of the dead panel
      // We manually inject the spawn via EntitySystem
      const type = Math.random() > 0.5 ? EnemyTypes.MUNCHER : EnemyTypes.KAMIKAZE;
      const sys = ServiceLocator.entitySystem;
      
      // Manually push to array to override the random position logic in spawnEnemy()
      // OR better: Add a spawnAt() method to EntitySystem. 
      // For now, we will use the internal spawn logic but modify the position immediately after.
      
      // Cleaner approach: Just instantiate data here and push to system.
      // But EntitySystem encapsulates ID logic.
      
      // Let's create a specific spawn method in EntitySystem for this or hack it.
      // Since we want to stick to patterns, let's look at EntitySystem.
      // It lacks a "SpawnAt" method. We will access the array directly for now 
      // to avoid modifying EntitySystem again in this step, but ideal refactor adds spawnAt().
      
      // Actually, let's just modify EntitySystem in the next block if needed.
      // For now, we spawn normally and move it.
      
      sys.spawnEnemy(type);
      const enemy = sys.enemies[sys.enemies.length - 1];
      if (enemy) {
        enemy.x = rect.x;
        enemy.y = rect.y;
        // Give them a little outward velocity immediately
        enemy.vx = (Math.random() - 0.5) * 10;
        enemy.vy = (Math.random() - 0.5) * 10;
      }
    }
  }
}


=====================================
FILE: ./src/game/systems/WaveSystem.ts
=====================================
import { IGameSystem, IServiceLocator } from '../core/interfaces';
import { EntitySystem } from './EntitySystem';
import { EnemyTypes } from '../config/Identifiers';

// --- AGGRESSIVE WAVE CONFIG ---
const WAVE_TIMELINE = [
  // TIME (s) |  TYPE     | COUNT | INTERVAL
  { at: 0,     type: 'driller', count: 3, interval: 0.1 }, 
  { at: 2,     type: 'driller', count: 5, interval: 0.5 }, 
  { at: 5,     type: 'kamikaze', count: 2, interval: 1.0 },
  { at: 8,     type: 'driller', count: 8, interval: 0.2 }, 
  { at: 12,    type: 'hunter',  count: 1, interval: 0 },   
  { at: 15,    type: 'driller', count: 10, interval: 0.1 },
  { at: 20,    type: 'kamikaze', count: 5, interval: 0.5 },
  { at: 25,    type: 'hunter',  count: 3, interval: 1.0 }, 
];

export class WaveSystem implements IGameSystem {
  private entitySystem!: EntitySystem;
  private waveTime = 0;
  private currentWaveIndex = 0;
  private spawnQueue: { type: string, time: number }[] = [];
  private loopCount = 0;

  setup(locator: IServiceLocator): void {
    this.entitySystem = locator.getSystem<EntitySystem>('EntitySystem');
    this.reset();
  }

  private reset() {
    this.waveTime = 0;
    this.currentWaveIndex = 0;
    this.spawnQueue = [];
    this.loopCount = 0;
  }

  update(delta: number, time: number): void {
    this.waveTime += delta;
    this.checkTimeline();
    this.processQueue(time);
  }

  private checkTimeline() {
    if (this.currentWaveIndex >= WAVE_TIMELINE.length) {
        this.waveTime = 0;
        this.currentWaveIndex = 0;
        this.loopCount++;
    }

    const nextWave = WAVE_TIMELINE[this.currentWaveIndex];
    if (nextWave && this.waveTime >= nextWave.at) {
        this.queueSpawns(nextWave);
        this.currentWaveIndex++;
    }
  }

  private queueSpawns(wave: any) {
    const count = wave.count + (this.loopCount * 2);
    for (let i = 0; i < count; i++) {
        this.spawnQueue.push({
            type: wave.type,
            time: this.waveTime + (i * wave.interval)
        });
    }
  }

  private processQueue(currentTime: number) {
    for (let i = this.spawnQueue.length - 1; i >= 0; i--) {
        const spawn = this.spawnQueue[i];
        if (this.waveTime >= spawn.time) {
            this.entitySystem.spawnEnemy(spawn.type as any);
            this.spawnQueue.splice(i, 1);
        }
    }
  }

  teardown(): void {
    this.reset();
  }
}


=====================================
FILE: ./src/game/store/useGameStore.ts
=====================================
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { UpgradeOption } from '../types/game.types';
import { GameEventBus } from '../events/GameEventBus';
import { GameEvents } from '../events/GameEvents';
import { PLAYER_CONFIG } from '../config/PlayerConfig';

const MAX_PANEL_HEALTH = 1000;

interface GameStateUI {
  isPlaying: boolean;
  playerHealth: number;
  maxPlayerHealth: number;
  playerRebootProgress: number;
  score: number;
  highScore: number;
  xp: number;
  level: number;
  xpToNextLevel: number;
  upgradePoints: number;
  systemIntegrity: number;
  
  availableUpgrades: UpgradeOption[];
  activeUpgrades: Record<string, number>;
  panels: Record<string, { id: string, health: number, isDestroyed: boolean, element?: HTMLElement }>;
  
  startGame: () => void;
  stopGame: () => void;
  registerPanel: (id: string, element: HTMLElement) => void;
  unregisterPanel: (id: string) => void;
  syncGameState: (data: Partial<GameStateUI>) => void;
  syncPanels: (panelsData: Record<string, any>) => void;
  selectUpgrade: (option: UpgradeOption) => void;
  addScore: (amount: number) => void;
  addXp: (amount: number) => void;
  damagePlayer: (amount: number) => void;
  healPlayer: (amount: number) => void;
  tickPlayerReboot: (amount: number) => void;
  healPanel: (id: string, amount: number) => void;
  decayReboot: (id: string, amount: number) => void;
  damagePanel: (id: string, amount: number) => void;
  resetGame: () => void;
  recalculateIntegrity: () => void;
}

export const useGameStore = create<GameStateUI>()(
  persist(
    (set, get) => ({
      isPlaying: false,
      playerHealth: PLAYER_CONFIG.maxHealth,
      maxPlayerHealth: PLAYER_CONFIG.maxHealth,
      playerRebootProgress: 0,
      score: 0,
      highScore: 0,
      xp: 0,
      level: 1,
      xpToNextLevel: PLAYER_CONFIG.baseXpRequirement,
      upgradePoints: 0,
      systemIntegrity: 100,
      availableUpgrades: [],
      activeUpgrades: { 'RAPID_FIRE': 0, 'MULTI_SHOT': 0, 'SPEED_UP': 0, 'REPAIR_NANITES': 0 },
      panels: {},

      startGame: () => {
        if (get().isPlaying) return;
        set({ 
            isPlaying: true, 
            score: 0, 
            threatLevel: 1,
            playerHealth: PLAYER_CONFIG.maxHealth,
            playerRebootProgress: 0,
            xp: 0,
            level: 1,
            xpToNextLevel: PLAYER_CONFIG.baseXpRequirement,
            availableUpgrades: [],
            activeUpgrades: { 'RAPID_FIRE': 0, 'MULTI_SHOT': 0, 'SPEED_UP': 0, 'REPAIR_NANITES': 0 },
            panels: Object.fromEntries(
                Object.entries(get().panels).map(([k, v]) => [k, { ...v, health: MAX_PANEL_HEALTH, isDestroyed: false }])
            )
        });
      },
      
      stopGame: () => {
          const { score, highScore } = get();
          set({ isPlaying: false, highScore: Math.max(score, highScore) });
      },

      syncGameState: (data) => set((state) => ({ ...state, ...data })),
      
      syncPanels: (incomingPanels) => set((state) => {
          const merged = { ...state.panels };
          for (const key in incomingPanels) {
              if (merged[key]) {
                  merged[key].health = incomingPanels[key].health;
                  merged[key].isDestroyed = incomingPanels[key].isDestroyed;
              } else {
                  merged[key] = incomingPanels[key];
              }
          }
          return { panels: merged };
      }),

      registerPanel: (id, element) => set((state) => ({
          panels: { ...state.panels, [id]: { id, element, health: 1000, isDestroyed: false } }
      })),
      
      unregisterPanel: (id) => set((state) => {
          const next = { ...state.panels };
          delete next[id];
          return { panels: next };
      }),

      selectUpgrade: (option) => {
        GameEventBus.emit(GameEvents.UPGRADE_SELECTED, { option });
      },

      // Fallback getters/setters for legacy consumers (will be overwritten by sync)
      addScore: (amount) => set(state => ({ score: state.score + amount })),
      addXp: (amount) => set(state => ({ xp: state.xp + amount })),
      damagePlayer: (amount) => set(state => ({ playerHealth: Math.max(0, state.playerHealth - amount) })),
      healPlayer: (amount) => set(state => ({ playerHealth: Math.min(state.maxPlayerHealth, state.playerHealth + amount) })),
      tickPlayerReboot: (amount) => set(state => ({ playerRebootProgress: Math.min(100, Math.max(0, state.playerRebootProgress + amount)) })),
      healPanel: (id, amount) => {}, // Handled by ECS event
      decayReboot: (id, amount) => {}, // Handled by ECS
      damagePanel: (id, amount) => {}, // Handled by ECS
      resetGame: () => {},
      recalculateIntegrity: () => {},
    }),
    {
      name: 'mesoelfy-os-storage-v2', // VERSION BUMP
      partialize: (state) => ({ highScore: state.highScore }),
    }
  )
);


=====================================
FILE: ./src/styles/globals.css
=====================================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 255, 65;
}

html {
  background-color: #000000;
}

body {
  color: #78F654;
  background-color: #000000;
  overflow: hidden; 
  font-family: 'Courier New', monospace;
}

/* --- HACKER SCROLLBAR --- */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #050505; 
  border-left: 1px solid #15530A;
}

::-webkit-scrollbar-thumb {
  background: #0BD426; 
  border: 1px solid #000;
  border-radius: 2px;
}

::-webkit-scrollbar-thumb:hover {
  background: #78F654;
}

/* Utilities */
.glitch-text {
  text-shadow: 2px 0 #ff003c, -2px 0 #008f11;
}

.clip-corner-btn {
  clip-path: polygon(
    0 0, 
    100% 0, 
    100% 70%, 
    90% 100%, 
    0 100%
  );
}

/* --- NUCLEAR OPTION: HIDE NEXT.JS INDICATORS --- */
/* Force hides the "N" button, build spinners, and static route indicators */
body > div[data-nextjs-toast],
body > div[data-nextjs-dialog-overlay],
#next-route-announcer,
[class*="nextjs-toast"],
[class*="build-activity"],
[class*="static-route-indicator"] {
  display: none !important;
  opacity: 0 !important;
  pointer-events: none !important;
  visibility: hidden !important;
}


=====================================
FILE: ./src/scene/props/MiniCrystalCanvas.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { Float, MeshDistortMaterial } from '@react-three/drei';
import { useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';

const SpinningGem = () => {
  const meshRef = useRef<THREE.Mesh>(null);

  useFrame((state) => {
    if (meshRef.current) {
      meshRef.current.rotation.y += 0.01;
      meshRef.current.rotation.z += 0.005;
    }
  });

  return (
    <Float speed={2} rotationIntensity={0.5} floatIntensity={0.5}>
      <mesh ref={meshRef} scale={1.8}>
        <octahedronGeometry args={[1, 0]} />
        <MeshDistortMaterial
          color="#78F654"
          emissive="#15530A"
          roughness={0.1}
          metalness={0.8}
          distort={0.3}
          speed={2}
          wireframe
        />
      </mesh>
    </Float>
  );
};

export const MiniCrystalCanvas = () => {
  return (
    <div className="w-full h-full bg-black">
      <Canvas 
        camera={{ position: [0, 0, 5] }} 
        gl={{ alpha: true }}
        style={{ background: '#000000' }} // <--- THE FIX: Force canvas to be black instantly
      >
        <ambientLight intensity={0.5} />
        <pointLight position={[10, 10, 10]} intensity={1} color="#C2FE9A" />
        <SpinningGem />
      </Canvas>
    </div>
  );
};


=====================================
FILE: ./src/scene/props/SoulCrystal.tsx
=====================================
import { useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import { Float, MeshDistortMaterial } from '@react-three/drei';
import * as THREE from 'three';

export const SoulCrystal = () => {
  const meshRef = useRef<THREE.Mesh>(null);

  useFrame((state) => {
    if (meshRef.current) {
      const t = state.clock.getElapsedTime();
      meshRef.current.rotation.y = t * 0.5;
      meshRef.current.rotation.z = t * 0.2;
    }
  });

  return (
    <Float speed={2} rotationIntensity={0.5} floatIntensity={1}>
      <mesh ref={meshRef} scale={1.5}>
        <octahedronGeometry args={[1, 0]} />
        <MeshDistortMaterial
          color="#00ff41"
          emissive="#003300"
          roughness={0}
          metalness={1}
          distort={0.4}
          speed={2}
          wireframe
        />
      </mesh>
      {/* Inner Core Glow */}
      <mesh scale={0.8}>
        <octahedronGeometry args={[1, 0]} />
        <meshBasicMaterial color="#ccffcc" transparent opacity={0.5} />
      </mesh>
    </Float>
  );
};


=====================================
FILE: ./src/scene/canvas/SceneCanvas.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { MatrixGrid } from '../effects/MatrixGrid';
import { Suspense } from 'react';
import { clsx } from 'clsx';

interface SceneCanvasProps {
  children?: React.ReactNode;
  className?: string;
}

export const SceneCanvas = ({ children, className }: SceneCanvasProps) => {
  return (
    <div className={clsx("fixed inset-0 w-full h-full z-0 pointer-events-none transition-all duration-[2000ms] ease-out", className)}>
      <Canvas 
        camera={{ position: [0, 2, 10], fov: 45 }}
        gl={{ antialias: true, alpha: false }} // Alpha false = performance gain + no transparency issues
        dpr={[1, 2]}
        style={{ background: '#000000' }} // <--- THE FIX: Force canvas to be black instantly
      >
        <color attach="background" args={['#000']} />
        <fog attach="fog" args={['#000', 2, 30]} />
        
        <MatrixGrid />
        
        <ambientLight intensity={0.5} />
        <pointLight position={[10, 10, 10]} intensity={1} color="#78F654" />
        
        <Suspense fallback={null}>
           {children}
        </Suspense>
      </Canvas>
    </div>
  );
};


=====================================
FILE: ./src/scene/effects/FireTransition.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import * as THREE from 'three';
import { useStore } from '@/core/store/useStore';

// Vertex Shader: Standard full-screen quad
const vertexShader = `
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = vec4(position, 1.0);
  }
`;

// Fragment Shader: The Burn Logic
const fragmentShader = `
  uniform float uTime;
  uniform float uProgress;
  uniform vec2 uResolution;
  varying vec2 vUv;

  // Simplex Noise 2D
  vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
  float snoise(vec2 v){
    const vec4 C = vec4(0.211324865405187, 0.366025403784439,
             -0.577350269189626, 0.024390243902439);
    vec2 i  = floor(v + dot(v, C.yy) );
    vec2 x0 = v -   i + dot(i, C.xx);
    vec2 i1;
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod(i, 289.0);
    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
    + i.x + vec3(0.0, i1.x, 1.0 ));
    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
    m = m*m ;
    m = m*m ;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
    vec3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
  }

  void main() {
    // Noise Scale
    float noise = snoise(vUv * 3.0 + vec2(0.0, uTime * 0.2));
    
    // Calculate Burn Edge
    // We modify progress to ensure it goes fully from black (-1) to clear (1)
    float prog = (uProgress * 2.5) - 1.0; 
    
    float alpha = smoothstep(prog, prog + 0.2, noise);
    
    // Edge Color (The Green Flame)
    float edge = 1.0 - smoothstep(prog, prog + 0.05, noise);
    vec3 flameColor = vec3(0.47, 0.96, 0.33); // #78F654
    
    vec3 finalColor = mix(vec3(0.0), flameColor, edge);

    if (alpha <= 0.01) discard; // Cut out the transparent parts

    gl_FragColor = vec4(finalColor, alpha);
  }
`;

export const FireTransition = () => {
  const meshRef = useRef<THREE.Mesh>(null);
  const materialRef = useRef<THREE.ShaderMaterial>(null);
  const { introDone } = useStore();
  const { viewport } = useThree();

  // Animation State
  const animState = useRef({ value: 0 }); // 0 = Black, 1 = Clear

  useFrame((state, delta) => {
    if (!materialRef.current) return;

    // Update Time
    materialRef.current.uniforms.uTime.value = state.clock.elapsedTime;

    // Logic: If Intro is DONE, animate progress 0 -> 1
    // If Intro is NOT DONE, keep progress at 0 (Solid Black)
    const target = introDone ? 1 : 0;
    
    // Linear Interpolation (Lerp) for smoothness
    // Adjust 1.5 to make fire faster/slower
    animState.current.value = THREE.MathUtils.lerp(animState.current.value, target, delta * 1.5);
    
    materialRef.current.uniforms.uProgress.value = animState.current.value;

    // Disable rendering if fully cleared to save GPU
    if (meshRef.current) {
        meshRef.current.visible = animState.current.value < 0.99;
    }
  });

  const uniforms = useMemo(
    () => ({
      uTime: { value: 0 },
      uProgress: { value: 0 }, // Starts Black
      uResolution: { value: new THREE.Vector2(viewport.width, viewport.height) },
    }),
    [viewport]
  );

  return (
    <mesh ref={meshRef} position={[0, 0, 1]}> 
      {/* Plane fills the screen */}
      <planeGeometry args={[viewport.width, viewport.height]} />
      <shaderMaterial
        ref={materialRef}
        vertexShader={vertexShader}
        fragmentShader={fragmentShader}
        uniforms={uniforms}
        transparent={true}
        depthTest={false} // Always draw on top
      />
    </mesh>
  );
};


=====================================
FILE: ./src/scene/effects/MatrixGrid.tsx
=====================================
import { Grid } from '@react-three/drei';
import { useFrame } from '@react-three/fiber';
import { useRef } from 'react';
import * as THREE from 'three';

export const MatrixGrid = () => {
  const groupRef = useRef<THREE.Group>(null);

  const SECTION_SIZE = 5;   
  const SPEED = 0.5;

  useFrame((state, delta) => {
    if (groupRef.current) {
      groupRef.current.position.z += SPEED * delta;
      
      if (groupRef.current.position.z >= SECTION_SIZE) {
        groupRef.current.position.z = 0;
      }
    }
  });

  return (
    <group ref={groupRef} position={[0, -2, 0]}>
      <Grid
        renderOrder={-1}
        infiniteGrid
        cellSize={1}
        sectionSize={SECTION_SIZE}
        
        // FIX 1: Fade out sooner (25) to hide far-away aliasing
        fadeDistance={25}      
        
        // FIX 2: Much darker colors to reduce "Shimmer" and visual weight
        sectionColor="#003300" // Very subtle dark green
        cellColor="#044d0f"    // Darker dim green (less contrast = less aliasing)
        
        sectionThickness={1.2} 
        cellThickness={1.1}
      />
    </group>
  );
};


=====================================
FILE: ./src/data/gallery.json
=====================================
[
  {
    "id": "art_001",
    "title": "ELFY_GENESIS",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#78F654"
  },
  {
    "id": "art_002",
    "title": "NEON_HEIST",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#9E4EA5"
  },
  {
    "id": "art_003",
    "title": "VOID_WALKER",
    "url": "https://x.com/mesoelfy",
    "category": "ROGUES",
    "color": "#FF003C"
  },
  {
    "id": "art_004",
    "title": "LATENT_GHOST",
    "url": "https://x.com/mesoelfy",
    "category": "COLLEAGUES",
    "color": "#F7D277"
  },
  {
    "id": "art_005",
    "title": "ZERO_DAY",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#78F654"
  },
  {
    "id": "art_006",
    "title": "SYSTEM_CRASH",
    "url": "https://x.com/mesoelfy",
    "category": "ROGUES",
    "color": "#FF003C"
  }
]


=====================================
FILE: ./src/data/identity.json
=====================================
{
  "name": "Elfy",
  "class": "Latent Space Bandit",
  "abilities": ["Green Flame", "Digital Heist", "Prompt Craft"],
  "stats": {
    "STR": "ERROR",
    "INT": 9001,
    "CHA": 50
  },
  "bio": "I manifest art from the void. My mission: Create cool s**t and annoy the haters."
}


=====================================
FILE: ./src/data/socials.json
=====================================
[
  { "name": "X / Twitter", "url": "https://x.com/mesoelfy", "icon": "twitter", "color": "#1DA1F2" },
  { "name": "YouTube", "url": "https://youtube.com/@mesoelfy", "icon": "youtube", "color": "#FF0000" },
  { "name": "TikTok", "url": "https://tiktok.com/@mesoelfy", "icon": "video", "color": "#00f2ea" },
  { "name": "GitHub", "url": "https://github.com/mesoelfy", "icon": "github", "color": "#ffffff" },
  { "name": "Newgrounds", "url": "https://mesoelfy.newgrounds.com/", "icon": "crosshair", "color": "#ffa500" },
  { "name": "DeviantArt", "url": "https://www.deviantart.com/mesoelfy", "icon": "image", "color": "#05cc47" }
]


=====================================
FILE: ./src/data/feed.json
=====================================
[
  {
    "id": 1,
    "date": "2023-10-27",
    "title": "Elfy vs. RoboGhoul",
    "desc": "The final showdown. Green flame algorithm engaged.",
    "link": "https://x.com/mesoelfy/status/123456"
  },
  {
    "id": 2,
    "date": "2023-10-20",
    "title": "Latent Space Update",
    "desc": "Exploring the void. Found some weird artifacts.",
    "link": "https://x.com/mesoelfy/status/789012"
  }
]


