+---------------------------------+
|      M E S O E L F Y _ O S      |
|   Next.js / R3F Source Context  |
+---------------------------------+
Generated on: Sat Dec 20 12:10:37 CST 2025

=====================================
PROJECT DIRECTORY STRUCTURE:
=====================================
.
â”œâ”€â”€ CITATION.cff
â”œâ”€â”€ Icon\015
â”œâ”€â”€ README.md
â”œâ”€â”€ SECURITY.md
â”œâ”€â”€ app-icon.png
â”œâ”€â”€ docs
â”‚Â Â  â”œâ”€â”€ MESOELFY_OS_AI_INSTRUCTIONS.md
â”‚Â Â  â””â”€â”€ all_source_code.txt
â”œâ”€â”€ electron
â”‚Â Â  â”œâ”€â”€ main.js
â”‚Â Â  â””â”€â”€ preload.js
â”œâ”€â”€ electron-builder.json
â”œâ”€â”€ next-env.d.ts
â”œâ”€â”€ next.config.js
â”œâ”€â”€ package.json
â”œâ”€â”€ postcss.config.js
â”œâ”€â”€ public
â”‚Â Â  â”œâ”€â”€ assets
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ audio
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ bg_music_placeholder.mp3
â”‚Â Â  â”‚Â Â  â””â”€â”€ images
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ social-card.jpg
â”‚Â Â  â”‚Â Â      â””â”€â”€ social_preview_github_1280x640.jpg
â”‚Â Â  â””â”€â”€ favicon.ico
â”œâ”€â”€ scripts
â”‚Â Â  â””â”€â”€ create_source_context.command
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ app
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ layout.tsx
â”‚Â Â  â”‚Â Â  â””â”€â”€ page.tsx
â”‚Â Â  â”œâ”€â”€ engine
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ai
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AIBlackboard.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AIStateTypes.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AITimerID.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ BehaviorNodeRegistry.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ BehaviorTreeBuilder.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ StateMachine.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ behavior
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ composites.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ decorators.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ types.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ nodes
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ actions.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ conditions.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ daemonNodes.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ drillerNodes.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ hunterNodes.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ logic.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ audio
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AudioDirector.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AudioMath.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AudioService.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AudioSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AudioUtils.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ hooks
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ useAudioVisualizer.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ modules
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ AudioContextManager.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ AudioMixer.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ AudioSynthesizer.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ SoundBank.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ VoiceManager.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ config
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AIConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Archetypes.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AssetKeys.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AudioConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ BootConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CameraConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameplayConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Identifiers.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ InputConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ModelConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Palette.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PanelConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PhysicsConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PlayerConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ProjectileConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ StorageConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TextAssets.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ VisualConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ WaveConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ WorldConfig.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ assets
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AudioManifest.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ VFXManifest.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ constants
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ MathConstants.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SystemConstants.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ UIConstants.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ static
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ feed.json
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ gallery.json
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ identity.json
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ socials.json
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ waves.json
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ecs
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Component.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ComponentCatalog.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ComponentPoolManager.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ComponentRegistry.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ComponentType.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Constants.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Entity.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EntityRegistry.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ObjectPool.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Query.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SpatialGrid.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AIStateData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ColliderData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CombatData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ HealthData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ IdentityData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ LifetimeData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ MotionData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ OrbitalData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ProjectileData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ RenderEffect.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ RenderModel.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ RenderTransform.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TargetData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ TransformData.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ types.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ graphics
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ MaterialFactory.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ RenderBuffer.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ RenderSchema.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ShaderLib.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Uniforms.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ glsl
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ math.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ noise.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ gpgpu
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ GPGPUManager.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ handlers
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ai
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AIRegistry.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ BehaviorCatalog.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ DaemonLogic.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ DrillerLogic.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ HunterLogic.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ KamikazeLogic.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ types.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ combat
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CollisionMatrix.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CombatHandlers.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ types.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ weapons
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ WeaponLogic.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ input
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ VirtualJoystickService.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ interfaces.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ math
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GeometryUtils.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Noise.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ RenderUtils.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Vector2.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ViewportHelper.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ coords.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ services
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ConfigService.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EngineFactory.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EntitySpawner.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameBootstrapper.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameEngine.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ HUDService.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ MobileBootstrapper.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ ServiceLocator.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ signals
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ FastEventBus.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameEventBus.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ GameEvents.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ state
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameContext.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameStream.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ game
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ slices
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ createCombatSlice.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ createProgressionSlice.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ createUISlice.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ useGameStore.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ global
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ useStore.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ systems
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AudioDirector.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ BehaviorSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CollisionSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CombatSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ FeedbackBridgeSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GameStateSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GuidanceSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ HealthSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ InputSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ InteractionSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ LifeCycleSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ MobileCombatSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ MobileWaveSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ OrbitalSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PanelRegistrySystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ParticleSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PhysicsSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PlayerMovementSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ProgressionSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ProjectileSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ RenderSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ShakeSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ StructureSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TargetingSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TimeSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ VFXSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ VisualSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ WaveSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ WeaponSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ WorldSystem.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ index.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ types
â”‚Â Â  â”‚Â Â      â””â”€â”€ game.types.ts
â”‚Â Â  â”œâ”€â”€ styles
â”‚Â Â  â”‚Â Â  â””â”€â”€ globals.css
â”‚Â Â  â””â”€â”€ ui
â”‚Â Â      â”œâ”€â”€ config
â”‚Â Â      â”‚Â Â  â””â”€â”€ DOMConfig.ts
â”‚Â Â      â”œâ”€â”€ hooks
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ useAudio.ts
â”‚Â Â      â”‚Â Â  â””â”€â”€ useGameStream.ts
â”‚Â Â      â”œâ”€â”€ kit
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ atoms
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ActionButton.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CustomCursor.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ DotGridBackground.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GlassPanel.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GraphicsToggle.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PanelSparks.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SafePanelContent.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ StatsRadar.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ToggleButton.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ VirtualJoystick.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ VitalsRing.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ ZenBomb.tsx
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ hooks
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ useHoloCycler.ts
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ usePanelPhysics.ts
â”‚Â Â      â”‚Â Â  â””â”€â”€ molecules
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ FeedAccessTerminal.tsx
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ HoloCommLog.tsx
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ IdentityFooter.tsx
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ IdentityHUD.tsx
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ LiveArtGrid.tsx
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ SocialRow.tsx
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ SystemOps.tsx
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ UpgradeTerminal.tsx
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ VideoPlaylistService.ts
â”‚Â Â      â”‚Â Â      â””â”€â”€ panel
â”‚Â Â      â”‚Â Â          â”œâ”€â”€ BreachOverlay.tsx
â”‚Â Â      â”‚Â Â          â”œâ”€â”€ IntelligentHeader.tsx
â”‚Â Â      â”‚Â Â          â””â”€â”€ RebootOverlay.tsx
â”‚Â Â      â”œâ”€â”€ os
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ apps
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ contact
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ ContactModal.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ debug
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ DebugOverlay.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ tabs
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ ConsoleTab.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ OverridesTab.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ SandboxTab.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ StatsTab.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ feed
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ FeedModal.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ gallery
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ GalleryModal.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ identity
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ AboutModal.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ mobile
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ MobileExperience.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ MobileRejectionModal.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ sandbox
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ArenaLab.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AudioMatrix.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ModelInspector.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SimulationHUD.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ layout
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ HoloBackground.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ HoloHeader.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ HoloLayout.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ HoloNav.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ visuals
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ VisualLab.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ settings
â”‚Â Â      â”‚Â Â  â”‚Â Â      â”œâ”€â”€ SettingsModal.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â      â”œâ”€â”€ components
â”‚Â Â      â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ GpuConfigPanel.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â      â”‚Â Â  â””â”€â”€ RangeSlider.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â      â””â”€â”€ tabs
â”‚Â Â      â”‚Â Â  â”‚Â Â          â””â”€â”€ SoundTab.tsx
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ boot
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ MatrixBootSequence.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ atoms
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AsciiRenderer.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ BootHeader.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CoreHeader.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ TypedLog.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ data
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ bootLogs.ts
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ hooks
â”‚Â Â      â”‚Â Â  â”‚Â Â      â”œâ”€â”€ useBootSequence.ts
â”‚Â Â      â”‚Â Â  â”‚Â Â      â”œâ”€â”€ useMatrixRain.ts
â”‚Â Â      â”‚Â Â  â”‚Â Â      â””â”€â”€ useSmartScroll.ts
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ desktop
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Footer.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ Header.tsx
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ overlays
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ErrorBoundary.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ GlobalBackdrop.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ModalContainer.tsx
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ RotationLock.tsx
â”‚Â Â      â”‚Â Â  â””â”€â”€ system
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ MetaManager.tsx
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ faviconGenerator.ts
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ hooks
â”‚Â Â      â”‚Â Â      â”‚Â Â  â”œâ”€â”€ useMetaTheme.ts
â”‚Â Â      â”‚Â Â      â”‚Â Â  â”œâ”€â”€ useMetaTitle.ts
â”‚Â Â      â”‚Â Â      â”‚Â Â  â””â”€â”€ useMetaUrl.ts
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ metaConstants.ts
â”‚Â Â      â”‚Â Â      â””â”€â”€ useFavicon.ts
â”‚Â Â      â””â”€â”€ sim
â”‚Â Â          â”œâ”€â”€ GameCanvas.tsx
â”‚Â Â          â”œâ”€â”€ GameDirector.tsx
â”‚Â Â          â”œâ”€â”€ MobileGameDirector.tsx
â”‚Â Â          â”œâ”€â”€ RenderDirector.tsx
â”‚Â Â          â”œâ”€â”€ SceneCanvas.tsx
â”‚Â Â          â”œâ”€â”€ actors
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ DaemonActor.tsx
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ InstancedActor.tsx
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ ParticleActor.tsx
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ PlayerActor.tsx
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ ProjectileActor.tsx
â”‚Â Â          â”‚Â Â  â””â”€â”€ UniversalActor.tsx
â”‚Â Â          â”œâ”€â”€ assets
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ AssetCatalog.ts
â”‚Â Â          â”‚Â Â  â””â”€â”€ AssetService.ts
â”‚Â Â          â”œâ”€â”€ config
â”‚Â Â          â”‚Â Â  â””â”€â”€ theme.ts
â”‚Â Â          â”œâ”€â”€ experiments
â”‚Â Â          â”‚Â Â  â””â”€â”€ GlitchGhost.tsx
â”‚Â Â          â”œâ”€â”€ hooks
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ useDeviceType.ts
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ useHeartbeat.ts
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ usePanelRegistry.ts
â”‚Â Â          â”‚Â Â  â””â”€â”€ useWindowFocus.ts
â”‚Â Â          â”œâ”€â”€ props
â”‚Â Â          â”‚Â Â  â””â”€â”€ MiniCrystalCanvas.tsx
â”‚Â Â          â”œâ”€â”€ registry
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ RenderCatalog.ts
â”‚Â Â          â”‚Â Â  â””â”€â”€ RenderRegistry.ts
â”‚Â Â          â”œâ”€â”€ stages
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ GalleryStage.tsx
â”‚Â Â          â”‚Â Â  â””â”€â”€ LabStage.tsx
â”‚Â Â          â””â”€â”€ vfx
â”‚Â Â              â”œâ”€â”€ CameraRig.tsx
â”‚Â Â              â”œâ”€â”€ PostProcessing.tsx
â”‚Â Â              â””â”€â”€ WireframeFloor.tsx
â”œâ”€â”€ tailwind.config.ts
â””â”€â”€ tsconfig.json

82 directories, 285 files

=====================================
FILE: ./next.config.js
=====================================
/** @type {import('next').NextConfig} */

let commitHash = 'DEV_BUILD';

try {
  const { execSync } = require('child_process');
  commitHash = execSync('git rev-parse --short HEAD').toString().trim();
} catch (error) {
  console.warn('Warning: Could not determine git commit hash.');
}

const nextConfig = {
  output: 'export',
  images: {
    unoptimized: true,
  },
  reactStrictMode: false,
  transpilePackages: ['three'],
  devIndicators: false,
  env: {
    NEXT_PUBLIC_COMMIT_HASH: commitHash,
  },
  typescript: {
    ignoreBuildErrors: true,
  },
  eslint: {
    ignoreDuringBuilds: true,
  },
}

module.exports = nextConfig


=====================================
FILE: ./docs/MESOELFY_OS_AI_INSTRUCTIONS.md
=====================================
I am developing "MESOELFY_OS," a 3D interactive portfolio site with a Keygen/Cyberpunk/Hacker/Demoscene aesthetic. 

I have attached "all_source_code.txt" which contains the full project tree and code. Please ingest this to understand the current architecture.

***CORE IDENTITY & AESTHETIC***
*   **Persona:** You are assisting "Elfy," a Latent Space Bandit. The vibe is Y2K Hacker, Matrix, Geometry Wars, and High-Tech Demoscene.
*   **Palette:** Electric Green (#78F654) is dominant. Deep Purple (#9E4EA5) is secondary. Red/Yellow for alerts. Black backgrounds.
*   **Current Status:** The site is live at `mesoelfy.github.io`. The "Intro Boot Sequence" and "Main MESOELFY_OS Dashboard" game area are built and stable, but suggestions for improvements for AAA levels of polish in code architecture, game design, animation, motion graphics, sound design, and graphic design are always appreciated.

***TECHNICAL STACK***
*   **Framework:** Next.js 14 (App Router) + TypeScript.
*   **Styling:** Tailwind CSS + Framer Motion (for UI animations).
*   **3D:** React Three Fiber (R3F) + Drei.
*   **Deployment:** GitHub Pages (Static Export).

***WORKFLOW RULES (CRITICAL)***
1.  **Terminal Only:** Do not ask me to manually create files. Provide full terminal commands using `cat << 'EOF' > path/to/file` to create or overwrite files.
2.  **No Placeholders:** Unless specified, write complete, functional code.
3.  **STEP BY STEP PHASE-BASED WORKFLOW:** After an outline of steps has been articulated, give the code in structured steps instead of all at once.
4.  **// VERIFICATION CHECKLIST:**  Let the user know what to look for to confirm the changes have succeeded and the build is stable
5.  **Atomic Commits:** After the user a successful feature implementation, provide the specific `git add .`, `git commit -m "..."`, and `git push` commands with a detailed commit description after the title. Don't provide the commit until the user asks for it. For git add, always use the period ".". And make sure you include the long description. It should be provided as a single copy-paste for the user.
using git add . to capture all the relevant modified files and following the prescribed format: git add . && git commit -m "title" -m "description" && git push.

Don't repeat information from previous commits. Each new commit is for the new progress that has been made.

6.  **Lean Ship:** Keep dependencies low. Prefer procedural generation (shaders/math) over large assets.
7. **WAIT** Don't provide code until user asks for it. You should articulate with text what you'd like to do so the user can confirm what needs to be done.


***MISC***
User has Three.js and React DevTools extensions installed which can be used to help isolate any issues.



Working directory:
stevencasteel@Stevens-Mac-mini mesoelfy-site % 


Please acknowledge you have analyzed the codebase.

=====================================
FILE: ./.devcontainer/devcontainer.json
=====================================
{
  "name": "MESOELFY_OS // CLOUD_NODE",
  "image": "mcr.microsoft.com/devcontainers/typescript-node:1-20-bullseye",
  "customizations": {
    "vscode": {
      "settings": {
        "terminal.integrated.defaultProfile.linux": "zsh",
        "editor.formatOnSave": true
      },
      "extensions": [
        "esbenp.prettier-vscode",
        "dbaeumer.vscode-eslint",
        "bradlc.vscode-tailwindcss"
      ]
    }
  },
  "postCreateCommand": "npm install && echo '// DEPENDENCIES INJECTED. SYSTEM READY.'",
  "forwardPorts": [3000]
}


=====================================
FILE: ./next-env.d.ts
=====================================
/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


=====================================
FILE: ./README.md
=====================================
<div align="center">

```text
 â–ˆâ–ˆâ–ˆâ–„ â–„â–ˆâ–ˆâ–ˆâ–“â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–“      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–“â–ˆâ–ˆ   â–ˆâ–ˆâ–“
â–“â–ˆâ–ˆâ–’â–€â–ˆâ–€ â–ˆâ–ˆâ–’â–“â–ˆ   â–€â–’â–ˆâ–ˆ    â–’ â–’â–ˆâ–ˆâ–’  â–ˆâ–ˆâ–’â–“â–ˆ   â–€ â–“â–ˆâ–ˆâ–’    â–’â–“â–ˆ   â–’  â–’â–ˆâ–ˆ  â–ˆâ–ˆâ–’
â–“â–ˆâ–ˆ    â–“â–ˆâ–ˆâ–‘â–’â–ˆâ–ˆâ–ˆ  â–‘ â–“â–ˆâ–ˆâ–„   â–’â–ˆâ–ˆâ–‘  â–ˆâ–ˆâ–’â–’â–ˆâ–ˆâ–ˆ   â–’â–ˆâ–ˆâ–‘    â–’â–“â–ˆâ–ˆâ–ˆ â–‘   â–’â–ˆâ–ˆ â–ˆâ–ˆâ–‘
â–’â–ˆâ–ˆ    â–’â–ˆâ–ˆ â–’â–“â–ˆ  â–„  â–’   â–ˆâ–ˆâ–’â–’â–ˆâ–ˆ   â–ˆâ–ˆâ–‘â–’â–“â–ˆ  â–„ â–’â–ˆâ–ˆâ–‘    â–‘â–“â–ˆâ–’  â–‘   â–‘ â–â–ˆâ–ˆâ–‘â–‘
â–’â–ˆâ–ˆâ–’   â–‘â–ˆâ–ˆâ–’â–‘â–’â–ˆâ–ˆâ–ˆâ–ˆâ–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–‘ â–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–ˆâ–ˆâ–ˆâ–ˆâ–’â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–‘â–’â–ˆâ–‘      â–‘ â–ˆâ–ˆâ–’â–‘â–‘
â–‘ â–’â–‘   â–‘  â–‘â–‘â–‘ â–’â–‘ â–‘ â–’â–‘â–’  â–‘ â–‘ â–’â–‘â–’â–‘â–’â–‘ â–‘â–‘ â–’â–‘ â–‘â–‘ â–’â–‘â–’  â–‘ â–’ â–‘       â–ˆâ–ˆâ–’â–’â–’
â–‘  â–‘      â–‘ â–‘ â–‘  â–‘ â–‘ â–’  â–‘   â–‘ â–’ â–’â–‘  â–‘ â–‘  â–‘â–‘ â–‘ â–’  â–‘ â–‘       â–“â–ˆâ–ˆ â–‘â–’â–‘ 
â–‘      â–‘      â–‘    â–‘ â–‘    â–‘ â–‘ â–‘ â–’     â–‘     â–‘ â–‘    â–‘ â–‘     â–’ â–’ â–‘â–‘  
       â–‘      â–‘  â–‘   â–‘  â–‘     â–‘ â–‘     â–‘  â–‘    â–‘  â–‘         â–‘ â–‘     
```

![System Status](https://img.shields.io/badge/SYSTEM_STATUS-ONLINE-78F654?style=for-the-badge&logo=githubactions&logoColor=black&labelColor=15530A)
![Version](https://img.shields.io/badge/VERSION-0.1.0-9E4EA5?style=for-the-badge&logo=git&logoColor=white&labelColor=350E3A)
![Core](https://img.shields.io/badge/KERNEL-R3F-00F0FF?style=for-the-badge&logo=react&logoColor=black&labelColor=005f66)

### **LATENT SPACE BANDIT // DIGITAL HQ**

**A generative 3D operating system running in your browser.**
Audio-reactive. Procedural. Playable.

---

### // INITIALIZE_SESSION

**Choose your method of entry.**

| ðŸŸ¢ **INSTANT ACCESS** | ðŸ“¦ **OFFLINE APP** | ðŸ’» **SOURCE CODE** |
| :--- | :--- | :--- |
| [**mesoelfy.github.io**](https://mesoelfy.github.io) | [**Download Release**](https://github.com/mesoelfy/mesoelfy.github.io/releases) | [**Inspect Repo**](#-developer_protocol) |
| Stream directly via Browser. | Native App (Mac/Win/Linux). | Clone the architecture. |

> **âš  NOTE:** First-time boot may stutter while shaders compile. Refresh if visuals glitch.

---

### // SYSTEM_SPECS

*   **Engine:** Next.js 14 + React Three Fiber (R3F)
*   **Audio:** Web Audio API (Real-time Synthesis)
*   **Build:** Electron + GitHub Actions

### // DEVELOPER_PROTOCOL

To run the simulation locally:

```bash
# 1. Clone
git clone https://github.com/mesoelfy/mesoelfy.github.io.git

# 2. Inject
npm install

# 3. Initialize
npm run dev
```

<br />

<a href="https://x.com/mesoelfy">
  <img src="https://img.shields.io/badge/DIRECT_UPLINK-TWITTER-1DA1F2?style=for-the-badge&logo=twitter&logoColor=white" />
</a>
<a href="https://mesoelfy.github.io">
  <img src="https://img.shields.io/badge/ENTER-THE_VOID-78F654?style=for-the-badge&logo=playstation&logoColor=black" />
</a>

</div>


=====================================
FILE: ./tailwind.config.ts
=====================================
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './src/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      zIndex: {
        'deep': '-10',
        'canvas': '0',
        'base': '10',
        'decor': '20',
        'panel': '30',
        'header': '40',
        'holo': '50', 
        'game-overlay': '60', 
        'breach': '70',       
        'mobile': '80',       
        'joystick': '90',     
        'boot': '100',        
        'bomb': '120',        
        'backdrop': '150',    
        'modal': '200',       
        'debug': '10000',
        'cursor': '20000',
      },
      colors: {
        'primary-green': {
          light: '#7FF65F',
          DEFAULT: 'rgba(96, 196, 68, 1)',
          dim: '#1bb930ff',
          dark: '#217e10ff',
        },
        'latent-purple': {
          light: '#BC86BA',
          DEFAULT: '#9E4EA5',
          dim: '#822B8A',
          deep: '#350E3A',
        },
        'service-cyan': {
          DEFAULT: '#00F0FF', 
          dim: '#008ba3',
        },
        'alert-yellow': {
          DEFAULT: '#eae747ff',
        },
        'critical-red': {
          DEFAULT: '#FF003C', 
        },
        'muted-gray': '#27282A',
        'void-black': '#050505',
        'game': {
          turret: { base: '#78F654', glow: '#C2FE9A' },
          bullet: { plasma: '#FFFFFF', trail: '#78F654' },
          enemy: { seeker: '#9E4EA5', eater: '#FF003C', boss: '#F7D277' },
          hud: { text: '#78F654', warning: '#FF003C' },
          vfx: { spark: '#FFFFFF', damage: '#FF003C' }
        }
      },
      fontFamily: {
        header: ['var(--font-montserrat)', 'sans-serif'],
        mono: ['Courier New', 'Courier', 'monospace'],
        tech: ['var(--font-jetbrains)', 'monospace'],
      },
      animation: {
        'spin-slow': 'spin 3s linear infinite',
        'spin-diamond': 'spin-diamond 3s linear infinite',
        'matrix-green': 'matrix-green 4s ease-in-out infinite',
        'matrix-purple': 'matrix-purple 2s ease-in-out infinite',
        'cursor-blink': 'cursor-blink 1.2s ease-in-out infinite',
        'restore-flash': 'restore-flash 1.2s ease-out forwards',
      },
      keyframes: {
        'spin-diamond': {
          '0%': { transform: 'rotate(45deg)' },
          '100%': { transform: 'rotate(405deg)' },
        },
        'matrix-green': {
          '0%, 100%': { color: '#14630bff' },
          '50%': { color: '#0aa41cff' },
        },
        'matrix-purple': {
          '0%, 100%': { color: '#9E4EA5' }, 
          '33%': { color: '#BC86BA' },      
          '66%': { color: '#350E3A' },      
        },
        'cursor-blink': {
          '0%, 30%': { opacity: '1' }, 
          '50%': { opacity: '0' },     
          '100%': { opacity: '1' },    
        },
        'restore-flash': {
          '0%': { boxShadow: '0 0 0px transparent', borderColor: 'rgba(96, 196, 68, 0.3)' },
          '5%': { boxShadow: '0 0 15px rgba(96, 196, 68, 1)', borderColor: '#78F654' },
          '100%': { boxShadow: '0 0 0px transparent', borderColor: 'rgba(96, 196, 68, 0.3)' }
        }
      }
    },
  },
  plugins: [],
}
export default config


=====================================
FILE: ./package.json
=====================================
{
  "name": "mesoelfy-site",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "electron": "electron .",
    "package": "npm run build && electron-builder"
  },
  "dependencies": {
    "@react-three/drei": "^10.7.7",
    "@react-three/fiber": "^9.4.2",
    "@react-three/postprocessing": "^2.19.1",
    "clsx": "^2.1.0",
    "electron-serve": "^3.0.0",
    "framer-motion": "^11.0.0",
    "lucide-react": "^0.300.0",
    "maath": "^0.10.0",
    "next": "^16.0.7",
    "react": "^19.2.1",
    "react-dom": "^19.2.1",
    "tailwind-merge": "^2.2.0",
    "three": "^0.181.2",
    "zustand": "^4.5.0"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@types/three": "^0.181.0",
    "autoprefixer": "^10.0.1",
    "electron": "^39.2.7",
    "electron-builder": "^26.0.12",
    "eslint": "^9.39.1",
    "eslint-config-next": "^16.0.7",
    "postcss": "^8",
    "tailwindcss": "^3.3.0",
    "typescript": "^5"
  },
  "main": "electron/main.js",
  "description": "A 3D generative OS portfolio.",
  "author": "Elfy <mesoelfy@example.com>"
}


=====================================
FILE: ./.github/workflows/release.yml
=====================================
name: Release Pipeline

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  # 1. BUILD WEB VERSION
  build-web:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: 'npm' }
      - run: npm ci
      - run: npm run build
      - run: cd out && zip -r ../MESOELFY_OS_Itch_Upload_Ready.zip .
      - uses: actions/upload-artifact@v4
        with:
          name: web-artifact
          path: MESOELFY_OS_Itch_Upload_Ready.zip

  # 2. BUILD DESKTOP APPS
  build-desktop:
    name: Build ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest, macos-latest]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: 'npm' }
      - run: npm ci
      
      - name: Install Linux Deps
        if: matrix.os == 'ubuntu-latest'
        run: sudo apt-get update && sudo apt-get install -y libicns-dev graphicsmagick

      - name: Build Next.js
        run: npm run build

      - name: Build Electron
        # Build but do not publish to GitHub yet (we do that manually in step 3)
        run: npx electron-builder --publish never
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Upload raw files to temp storage
      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: desktop-artifacts-${{ matrix.os }}
          path: |
            dist/*.exe
            dist/*.dmg
            dist/*.AppImage

  # 3. CURATE AND PUBLISH
  publish:
    needs: [build-web, build-desktop]
    runs-on: ubuntu-latest
    steps:
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          pattern: '*'
          merge-multiple: true

      - name: Bundle and Clean
        run: |
          # Create themed folders
          mkdir -p "release/MESOELFY_OS_Mac_Build"
          mkdir -p "release/MESOELFY_OS_Windows_Build"
          mkdir -p "release/MESOELFY_OS_Linux_Build"
          
          # Move files
          mv artifacts/*.dmg "release/MESOELFY_OS_Mac_Build/" 2>/dev/null || true
          mv artifacts/*.exe "release/MESOELFY_OS_Windows_Build/" 2>/dev/null || true
          mv artifacts/*.AppImage "release/MESOELFY_OS_Linux_Build/" 2>/dev/null || true
          mv artifacts/MESOELFY_OS_Itch_Upload_Ready.zip release/

          # Zip the folders
          cd release
          zip -r MESOELFY_OS_Mac.zip "MESOELFY_OS_Mac_Build"
          zip -r MESOELFY_OS_Windows.zip "MESOELFY_OS_Windows_Build"
          zip -r MESOELFY_OS_Linux.zip "MESOELFY_OS_Linux_Build"
          
          # Remove the folders now that they are zipped
          rm -rf "MESOELFY_OS_Mac_Build" "MESOELFY_OS_Windows_Build" "MESOELFY_OS_Linux_Build"

      - name: Publish Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            release/MESOELFY_OS_Mac.zip
            release/MESOELFY_OS_Windows.zip
            release/MESOELFY_OS_Linux.zip
            release/MESOELFY_OS_Itch_Upload_Ready.zip
          draft: false
          prerelease: false
          name: "MESOELFY_OS ${{ github.ref_name }}"
          body: |
            **// STANDALONE APPS (OFFLINE)**
            *Contains the game wrapped in a Chromium engine (Electron).*
            *You're basically downloading a lite version of the Chrome browser to run the game.*
            *(Approx 200-400MB)*
            
            **âš  PERFORMANCE NOTE:** If the game stutters or hitches on first launch, the 3D shaders are compiling. Simply go to **View -> Force Reload** (or restart the app) to resolve this.

            ---

            *   **Mac:** Download `MESOELFY_OS_Mac.zip`.
                *   **"Damaged" Error?** Apple treats apps from indie developers as "Untrusted" until you manually verify them.
                *   **The Fix:**
                    1. Drag the app to your Applications folder.
                    2. Open Terminal (Cmd+Space, type Terminal).
                    3. Paste this command and hit Enter: `xattr -cr /Applications/MESOELFY_OS.app`
                    4. **What does this do?** `xattr -cr` stands for "Extended Attributes - Clear Recursive". It simply wipes the "Quarantine" sticker macOS puts on files downloaded from the web, allowing your computer to trust it.
            
            *   **Windows:** Download `MESOELFY_OS_Windows.zip`. Double-click to run.
                *   *Note: Click "More Info" -> "Run Anyway" if Windows Defender warns you.*
            
            *   **Linux:** Download `MESOELFY_OS_Linux.zip`.
                *   *Note: Right-click -> Properties -> Check "Allow executing file as program".*

            ---

            **// WEB BUILD (HTML5)**
            *   **File:** `MESOELFY_OS_Itch_Upload_Ready.zip`
            *   **Usage:** Strictly for uploading to platforms like Itch.io or Newgrounds to host the game online. 
            *   *Included for those who wish to inspect the compiled asset structure for learning purposes.*

            ---

            **// LOCAL HOST EXPERIENCE (SOURCE)**
            *   **File:** `Source code (zip)` (Below)
            *   **Usage:** Run the full project on your machine.
            *   **Why `npm`?** You can't just open an HTML file anymore. This project uses complex 3D rendering that requires a local server. Think of `npm` as the "App Store" for codeâ€”it installs the engine needed to run the site.
            *   **Instructions (It's very easy):**
                1. Unzip the source code.
                2. Open your terminal **inside that specific folder**.
                3. Type `npm install` (this downloads the engine).
                4. Type `npm run dev` (this starts the server).
                5. Open `http://localhost:3000` in any browser, but **Chrome will work the best**.
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


=====================================
FILE: ./.github/workflows/deploy.yml
=====================================
name: Deploy to GitHub Pages

on:
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: 'npm'
          
      - name: Setup Pages
        uses: actions/configure-pages@v4
        with:
          static_site_generator: next
          
      - name: Install Dependencies
        run: npm ci
        
      - name: Build with Next.js
        run: npm run build
        
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./out

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4


=====================================
FILE: ./.github/workflows/greetings.yml
=====================================
name: "Neural Handshake"

on: [pull_request_target, issues]

jobs:
  greeting:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
    steps:
    - uses: actions/first-interaction@v1
      with:
        repo-token: ${{ secrets.GITHUB_TOKEN }}
        issue-message: |
          ### // TRANSMISSION RECEIVED
          
          **Identity Verified:** New Contributor detected.
          **Status:** The Daemon is analyzing your anomaly report.
          
          > *Welcome to the Latent Space. Ensure your logs are clean before proceeding.*
        
        pr-message: |
          ### // CODE_INJECTION DETECTED
          
          **Source:** External Node
          **Payload:** Analysis Pending...
          
          > *Your contribution to the OS architecture has been logged. Stand by for code review and merge clearance.*


=====================================
FILE: ./.github/ISSUE_TEMPLATE/anomaly_report.yml
=====================================
name: "REPORT_ANOMALY"
description: "File a report regarding system instability or unexpected behavior."
title: "[ANOMALY]: "
labels: ["bug", "triage"]
body:
  - type: markdown
    attributes:
      value: |
        ### // TRANSMISSION STARTED
        *Please describe the instability found within the MESOELFY_OS architecture.*
  
  - type: textarea
    id: description
    attributes:
      label: "Anomaly Description"
      description: "What happened? Be specific."
      placeholder: "The Audio Matrix desyncs when I toggle Potato Mode..."
    validations:
      required: true

  - type: dropdown
    id: sector
    attributes:
      label: "Affected Sector"
      description: "Where did the breach occur?"
      options:
        - "CORE_SYSTEM (Boot/Loading)"
        - "VISUALS (Shaders/Rendering)"
        - "AUDIO_MATRIX (Sound/Music)"
        - "COMBAT_SIM (Enemies/Player)"
        - "UI_OVERLAY (Menus/Modals)"
        - "INSTALLER (Electron/Build)"
    validations:
      required: true

  - type: dropdown
    id: severity
    attributes:
      label: "Threat Level"
      options:
        - "LOW (Visual Glitch)"
        - "MED (Feature Broken)"
        - "HIGH (Game Crash)"
        - "CRITICAL (System Failure / Won't Boot)"
    validations:
      required: true

  - type: textarea
    id: reproduction
    attributes:
      label: "Trace Protocol (Steps to Reproduce)"
      description: "How can we replicate this anomaly?"
      placeholder: |
        1. Initialize System
        2. Open Settings
        3. Click '...'
        4. Crash occurs
    validations:
      required: true

  - type: input
    id: environment
    attributes:
      label: "Hardware/Software Specs"
      description: "OS, Browser, GPU (if known)"
      placeholder: "Windows 11, Chrome Latest, RTX 3080"
    validations:
      required: false


=====================================
FILE: ./.github/ISSUE_TEMPLATE/config.yml
=====================================
blank_issues_enabled: false
contact_links:
  - name: "Direct Uplink (Twitter)"
    url: https://x.com/mesoelfy
    about: "Ping the developer directly."


=====================================
FILE: ./.github/ISSUE_TEMPLATE/feature_injection.yml
=====================================
name: "INJECT_FEATURE"
description: "Propose a new module, upgrade, or aesthetic enhancement."
title: "[INJECTION]: "
labels: ["enhancement"]
body:
  - type: markdown
    attributes:
      value: |
        ### // UPLINK OPEN
        *Submit your proposal for system augmentation.*

  - type: input
    id: concept
    attributes:
      label: "Module Name"
      placeholder: "e.g. 'Advanced Particle Physics'"
    validations:
      required: true

  - type: textarea
    id: pitch
    attributes:
      label: "Injection Description"
      description: "Describe the feature in detail."
    validations:
      required: true

  - type: dropdown
    id: type
    attributes:
      label: "Upgrade Class"
      options:
        - "VISUAL_AESTHETICS"
        - "AUDIO_ENHANCEMENT"
        - "GAMEPLAY_MECHANIC"
        - "LORE_EXPANSION"
        - "OPTIMIZATION"

  - type: textarea
    id: justification
    attributes:
      label: "System Value"
      description: "Why does the OS need this?"


=====================================
FILE: ./tsconfig.json
=====================================
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./src/*"
      ],
      "@/engine/*": [
        "./src/engine/*"
      ],
      "@/ui/*": [
        "./src/ui/*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}


=====================================
FILE: ./electron/preload.js
=====================================
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electron', {
  send: (channel, data) => {
    let validChannels = ["toMain"];
    if (validChannels.includes(channel)) {
      ipcRenderer.send(channel, data);
    }
  },
  receive: (channel, func) => {
    let validChannels = ["fromMain"];
    if (validChannels.includes(channel)) {
      ipcRenderer.on(channel, (event, ...args) => func(...args));
    }
  }
});


=====================================
FILE: ./electron/main.js
=====================================
const { app, BrowserWindow, session } = require('electron');
const path = require('path');

// --- FIX: Handle ESM/CJS interoperability ---
const serveExport = require('electron-serve');
const serve = serveExport.default || serveExport; 

const appServe = app.isPackaged ? serve({ directory: path.join(__dirname, '../out') }) : null;

const createWindow = () => {
  const win = new BrowserWindow({
    width: 1600,
    height: 1200, 
    title: "MESOELFY_OS",
    icon: path.join(__dirname, '../app-icon.png'),
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      nodeIntegration: false,
      contextIsolation: true,
      webSecurity: true // Keep true, we will handle Referer via session
    }
  });

  win.setMenuBarVisibility(false);

  if (app.isPackaged) {
    appServe(win).then(() => {
      win.loadURL('app://-');
    });
  } else {
    win.loadURL('http://localhost:3000');
    // win.webContents.openDevTools();
  }
};

app.whenReady().then(() => {
  // --- YOUTUBE 153 FIX ---
  // Intercept requests to YouTube and inject a valid 'Referer' header.
  // This tricks YouTube into thinking the video is playing on your website.
  session.defaultSession.webRequest.onBeforeSendHeaders(
    { urls: ['*://*.youtube.com/*', '*://*.google.com/*'] },
    (details, callback) => {
      details.requestHeaders['Referer'] = 'https://mesoelfy.github.io/';
      callback({ cancel: false, requestHeaders: details.requestHeaders });
    }
  );

  createWindow();

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});


=====================================
FILE: ./postcss.config.js
=====================================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


=====================================
FILE: ./electron-builder.json
=====================================
{
  "appId": "com.mesoelfy.os",
  "productName": "MESOELFY_OS",
  "directories": {
    "output": "dist"
  },
  "publish": {
    "provider": "github",
    "releaseType": "release"
  },
  "files": [
    "out/**/*",
    "electron/**/*",
    "package.json",
    "app-icon.png"
  ],
  "mac": {
    "icon": "app-icon.png",
    "target": ["dmg"],
    "category": "public.app-category.games",
    "gatekeeperAssess": false
  },
  "dmg": {
    "background": "public/assets/images/social-card.jpg",
    "iconSize": 140,
    "window": { "width": 800, "height": 500 },
    "contents": [
      { "x": 200, "y": 250, "type": "file" },
      { "x": 600, "y": 250, "type": "link", "path": "/Applications" }
    ]
  },
  "win": {
    "icon": "app-icon.png",
    "target": ["nsis", "portable"]
  },
  "linux": {
    "icon": "app-icon.png",
    "target": ["AppImage", "deb"],
    "category": "Game"
  }
}


=====================================
FILE: ./SECURITY.md
=====================================
# // SECURITY_PROTOCOL: LEVEL_5

## // VULNERABILITY_DISCLOSURE

If you discover a breach in the Neural Lace or an exploit in the `MESOELFY_OS` kernel:

1.  **DO** broadcast the exploit on public frequencies (Issues/X).
2.  **INITIATE** a secure handshake via email: `mesoelfy@pm.me` (Subject: `[SECURITY_BREACH]`).
3.  **AWAIT** acknowledgment. The Daemon will verify your finding.

## // WHITE_HAT_STATUS

Entities who report valid vulnerabilities will be logged in the **HALL_OF_RECORDS** and granted immunity from the Watcher Units.

*   **Authorized:** Reverse engineering, probing the latent space, aesthetic modifications.
*   **Unauthorized:** Malicious injection, infinite XP exploits, disruption of the host signal.

> *Transmission End.*


=====================================
FILE: ./src/ui/config/DOMConfig.ts
=====================================
export const DOM_ID = {
  APP_ROOT: 'global-app-root',
  LAB_PARAMS: 'lab-params',
} as const;

export const DOM_ATTR = {
  INTERACTIVE: 'data-interactive'
} as const;


=====================================
FILE: ./src/ui/kit/molecules/SocialRow.tsx
=====================================
import { Twitter, Youtube, Github, Video, Crosshair, Image as ImageIcon, AlertTriangle } from 'lucide-react';
import socials from '@/engine/config/static/socials.json';
import { useAudio } from '@/ui/hooks/useAudio';
import { getPan } from '@/engine/audio/AudioUtils';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { clsx } from 'clsx';
import { PanelId } from '@/engine/config/PanelConfig';

const IconMap: Record<string, any> = { twitter: Twitter, youtube: Youtube, github: Github, video: Video, crosshair: Crosshair, image: ImageIcon };

interface SocialRowProps { layout?: 'grid' | 'column'; }

export const SocialRow = ({ layout = 'grid' }: SocialRowProps) => {
  const panelState = useGameStore((state) => state.panels[PanelId.SOCIAL]);
  const isDestroyed = panelState ? panelState.isDestroyed : false;
  const audio = useAudio();

  return (
    <div className={clsx("gap-2 h-full content-center py-2 relative px-2", layout === 'grid' ? "grid grid-cols-3" : "flex flex-col", isDestroyed ? "pointer-events-none" : "")}>
      {socials.map((social, idx) => {
        const Icon = isDestroyed ? AlertTriangle : (IconMap[social.icon] || Crosshair);
        const isGlitch = isDestroyed && (idx % 2 === 0);
        return (
          <a
            key={social.name} href={isDestroyed ? undefined : social.url} target="_blank" rel="noopener noreferrer"
            onMouseEnter={(e) => !isDestroyed && audio.playHover(getPan(e))} onClick={(e) => !isDestroyed && audio.playClick(getPan(e))}
            className={clsx("group flex items-center p-2 border transition-all duration-200", layout === 'grid' ? "flex-col justify-center" : "flex-row gap-4 justify-start px-4 h-12", isDestroyed ? "border-critical-red/20 bg-critical-red/5 grayscale" : "border-primary-green-dim/30 bg-black/40 hover:bg-alert-yellow/5 hover:border-alert-yellow hover:shadow-[0_0_15px_rgba(234,231,71,0.15)]")}
          >
            <Icon className={clsx("transition-transform duration-200", layout === 'grid' ? "w-5 h-5 mb-1" : "w-6 h-6", isDestroyed ? "text-critical-red animate-pulse" : "text-primary-green-dim group-hover:text-alert-yellow group-hover:scale-110", isGlitch ? "translate-x-1" : "")} style={!isDestroyed ? { filter: 'drop-shadow(0 0 2px rgba(0,0,0,0.5))' } : {}} />
            <span className={clsx("uppercase tracking-wider font-mono transition-colors duration-200", layout === 'grid' ? "text-[9px]" : "text-xs font-bold", isDestroyed ? "text-critical-red/60" : "text-primary-green-dim/60 group-hover:text-alert-yellow")}>{isDestroyed ? (isGlitch ? "ERR_404" : "NULL") : social.name}</span>
          </a>
        );
      })}
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/molecules/panel/BreachOverlay.tsx
=====================================
import { motion, useMotionValue, useTransform, useAnimationFrame } from 'framer-motion';
import { ChevronUp, AlertTriangle } from 'lucide-react';
import { clsx } from 'clsx';
import { PanelId } from '@/engine/config/PanelConfig';

const TEXT = "SYSTEM BREACH // CRITICAL FAILURE // REBOOT REQUIRED // ";
const REPEAT_COUNT = 8; 
const FULL_TEXT = Array(REPEAT_COUNT).fill(TEXT).join("");

const HazardStrip = ({ direction, isSecondary, isActive, index }: { direction: 1 | -1, isSecondary: boolean, isActive: boolean, index: number }) => {
  const staggerOffset = ((index * 23) % 80) - 40; 
  const x = useMotionValue(0); 
  const baseSpeed = isSecondary ? 0.4 : 0.7; 
  
  useAnimationFrame((time, delta) => {
    const velocity = baseSpeed * direction * (isActive ? -1 : 1);
    const moveAmount = velocity * (delta / 1000);
    let newX = x.get() + moveAmount;
    if (newX > 0) newX -= 25;
    if (newX < -25) newX += 25;
    x.set(newX);
  });

  return (
    <div className={clsx("flex relative overflow-visible w-full select-none transition-opacity duration-500", isSecondary ? "opacity-10" : "opacity-20")} style={{ transform: `translateX(${staggerOffset}%)` }}>
      <motion.div
        className={clsx("flex whitespace-nowrap font-header font-black text-4xl md:text-6xl tracking-widest uppercase transition-colors duration-300 ease-out", isActive ? "text-latent-purple" : "text-critical-red")}
        style={{ x: useTransform(x, v => `${v}%`) }}
      >
        <span className="shrink-0 px-4">{FULL_TEXT}</span>
      </motion.div>
    </div>
  );
};

interface BreachOverlayProps {
  progress: number;
  isVideo: boolean;
  showInteractive: boolean;
  isRepairing?: boolean;
  panelId?: PanelId;
}

export const BreachOverlay = ({ progress, isVideo, showInteractive, isRepairing = false, panelId }: BreachOverlayProps) => {
  const safeProgress = (Number.isFinite(progress) && !isNaN(progress)) ? Math.max(0, Math.min(100, progress)) : 0;
  const isActive = isRepairing;
  const isCompactHeight = panelId === PanelId.FEED || panelId === PanelId.SOCIAL;
  const showStatusBar = panelId !== PanelId.SOCIAL;

  return (
    <div className={clsx("absolute inset-0 z-breach flex flex-col items-center justify-center overflow-hidden", isVideo ? "bg-black/60 backdrop-blur-[2px]" : "bg-black/80 backdrop-blur-md")}>
        <div className="absolute inset-[-100%] flex flex-col justify-center gap-0 md:gap-4 rotate-[-12deg] pointer-events-none">
            {Array.from({ length: 16 }).map((_, i) => (
                <HazardStrip key={i} index={i} direction={i % 2 === 0 ? 1 : -1} isSecondary={i % 2 !== 0} isActive={isActive} />
            ))}
        </div>
        <div className="absolute inset-0 pointer-events-none bg-[radial-gradient(circle,transparent_20%,#000_100%)] z-10" />

        {showInteractive && (
          <div className={clsx("relative z-20 flex flex-col items-center justify-center gap-1 cursor-crosshair group", isCompactHeight ? "mb-0" : "mb-[25%]")}>
              <div className="relative h-20 flex items-center justify-center">
                  <div className={clsx("absolute inset-0 flex items-center justify-center transition-opacity duration-300", isActive ? "opacity-0" : "group-hover:opacity-0")}>
                      <motion.div animate={{ y: [0, -10, 0] }} transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }} className="text-critical-red drop-shadow-[0_0_15px_#FF003C]">
                          <AlertTriangle size={64} strokeWidth={1.5} />
                      </motion.div>
                  </div>
                  <div className={clsx("absolute inset-0 flex items-center justify-center -translate-y-8 transition-opacity duration-200", isActive ? "opacity-100" : "opacity-0 group-hover:opacity-100")}>
                      <motion.div animate={{ scale: [1, 1.2, 1], filter: ["brightness(1)", "brightness(1.5)", "brightness(1)"] }} transition={{ duration: 0.2, repeat: Infinity, ease: "easeInOut" }} className="text-latent-purple drop-shadow-[0_0_25px_#E0B0FF]">
                          <ChevronUp size={80} strokeWidth={4} />
                      </motion.div>
                  </div>
              </div>
              {showStatusBar && (
                  <div className="flex flex-col items-center text-center gap-2">
                      <div className={clsx("px-4 py-1 backdrop-blur-md border transition-colors duration-300", isActive ? "bg-latent-purple/10 border-latent-purple/50" : "bg-critical-red/10 border-critical-red/50")}>
                          <span className={clsx("text-xs font-header font-black tracking-[0.2em] transition-colors duration-200 drop-shadow-sm", isActive ? "text-[#E0B0FF]" : "text-critical-red group-hover:text-latent-purple")}>
                              {isActive ? "REBOOTING..." : "HOLD TO REBOOT"}
                          </span>
                      </div>
                      <div className="w-48 bg-gray-900/80 h-2 rounded-full overflow-hidden border border-gray-700 shadow-lg relative">
                          <motion.div className="h-full bg-gradient-to-r from-[#2a0a2e] via-latent-purple to-[#E0B0FF]" initial={{ width: "0%" }} animate={{ width: `${safeProgress}%` }} transition={{ type: "tween", duration: 0.1 }} />
                      </div>
                      <div className="flex justify-between w-full text-[9px] font-mono font-bold">
                          <span className={clsx("transition-colors duration-200", isActive ? "text-[#E0B0FF]" : "text-critical-red")}>INTEGRITY: {Math.floor(safeProgress)}%</span>
                          <span className={clsx("transition-all duration-300", isActive ? "opacity-100 text-[#E0B0FF]" : "opacity-0 text-[#2a0a2e]")}>ACTIVE...</span>
                      </div>
                  </div>
              )}
          </div>
        )}
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/molecules/panel/RebootOverlay.tsx
=====================================
import { motion } from 'framer-motion';
import { Power } from 'lucide-react';

export const RebootOverlay = () => (
  <motion.div 
    initial={{ opacity: 0 }}
    animate={{ opacity: 1 }}
    // Outer fade slightly delayed to let inner animations finish
    exit={{ opacity: 0, transition: { delay: 0.1, duration: 0.2 } }}
    className="absolute inset-0 z-[60] flex items-center justify-center bg-black/80 backdrop-blur-[2px]"
  >
    <motion.div 
        initial={{ scaleY: 0, opacity: 0 }}
        animate={{ scaleY: 1, opacity: 1 }}
        exit={{ 
            scaleY: 0, 
            opacity: 0,
            transition: { delay: 0.1, duration: 0.2, ease: "easeIn" } 
        }}
        transition={{ type: "spring", stiffness: 250, damping: 25 }}
        className="flex flex-col items-center gap-2 border-y-2 border-service-cyan bg-service-cyan/10 w-full py-4 relative overflow-hidden origin-center"
    >
      <motion.div 
        className="absolute top-0 left-0 w-full h-full bg-gradient-to-b from-transparent via-service-cyan/20 to-transparent"
        animate={{ top: ["-100%", "100%"] }}
        transition={{ duration: 1.5, ease: "linear", repeat: Infinity }}
      />

      <div className="relative z-10 flex items-center gap-3">
        {/* Icon: Exits IMMEDIATELY with backIn easing */}
        <motion.div
          initial={{ rotate: -180, scale: 0 }}
          animate={{ rotate: 0, scale: 1 }}
          exit={{ 
              rotate: -180, 
              scale: 0,
              transition: { duration: 0.2, ease: "backIn" } 
          }}
          transition={{ type: "spring", stiffness: 200, damping: 20 }}
        >
            <Power className="text-service-cyan w-8 h-8 md:w-10 md:h-10" />
        </motion.div>

        <div className="flex flex-col overflow-hidden">
            {/* Text: Fades instantly on exit trigger */}
            <motion.span 
                initial={{ x: 20, opacity: 0 }}
                animate={{ x: 0, opacity: 1 }}
                exit={{ opacity: 0, transition: { duration: 0.1 } }} 
                transition={{ delay: 0.1 }}
                className="text-2xl md:text-3xl font-header font-black text-service-cyan tracking-widest italic drop-shadow-[0_0_10px_rgba(0,240,255,0.5)]"
            >
                SYSTEM
            </motion.span>
            <motion.span 
                initial={{ x: -20, opacity: 0 }}
                animate={{ x: 0, opacity: 1 }}
                exit={{ opacity: 0, transition: { duration: 0.1 } }}
                transition={{ delay: 0.2 }}
                className="text-xs md:text-sm font-mono font-bold text-service-cyan/80 tracking-[0.3em]"
            >
                RESTORED
            </motion.span>
        </div>
      </div>
    </motion.div>
  </motion.div>
);


=====================================
FILE: ./src/ui/kit/molecules/panel/IntelligentHeader.tsx
=====================================
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { Skull, Zap, Power, RefreshCw, AlertTriangle, Check } from 'lucide-react';
import { clsx } from 'clsx';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { IPanelSystem } from '@/engine/interfaces';
import { ViewportHelper } from '@/engine/math/ViewportHelper';

interface IntelligentHeaderProps {
  title: string;
  health: number;
  maxHealth?: number; 
  isDestroyed: boolean;
  isGameOver: boolean;
  gameId?: string;
}

export const IntelligentHeader = ({ title, health, maxHealth = 1000, isDestroyed, isGameOver, gameId }: IntelligentHeaderProps) => {
  const interactionTarget = useGameStore(state => state.interactionTarget);
  const isInteracting = gameId && interactionTarget === gameId;
  const healthPercent = Math.max(0, Math.min(100, (health / maxHealth) * 100));
  const isDamaged = !isDestroyed && healthPercent < 100;
  const [showOptimal, setShowOptimal] = useState(false);

  useEffect(() => {
    if (health < maxHealth) setShowOptimal(true);
    if (health >= maxHealth && showOptimal) {
      
      // Calculate Stereo Pan based on Panel Position
      let pan = 0;
      if (gameId) {
          try {
              const panels = ServiceLocator.getSystem<IPanelSystem>('PanelRegistrySystem');
              const rect = panels.getPanelRect(gameId);
              if (rect) {
                  const halfWidth = ViewportHelper.viewport.width / 2;
                  if (halfWidth > 0) {
                      // Normalize world X (-width/2 to width/2) to -1.0 to 1.0
                      pan = Math.max(-1, Math.min(1, rect.x / halfWidth));
                  }
              }
          } catch (e) {
              // Engine system not ready or available, fallback to center pan
          }
      }

      AudioSystem.playSound('ui_optimal', pan); 
      const timer = setTimeout(() => setShowOptimal(false), 1500);
      return () => clearTimeout(timer);
    }
  }, [health, showOptimal, maxHealth, gameId]);

  let mainColor = "text-primary-green";
  let statusText = "SECURE";
  
  if (isGameOver) {
      mainColor = "text-critical-red";
      statusText = "SYSTEM_FAILURE";
  } else if (isDestroyed) {
      if (isInteracting) {
          mainColor = "text-latent-purple";
          statusText = "REBOOTING...";
      } else {
          mainColor = "text-critical-red";
          statusText = "OFFLINE";
      }
  } else if (isInteracting && isDamaged) {
      mainColor = "text-service-cyan";
      statusText = "HEALING...";
  } else if (isDamaged) {
      mainColor = "text-alert-yellow"; 
      statusText = "ATTENTION_REQ";
  } else if (!showOptimal) {
      mainColor = "text-primary-green-dim";
      statusText = "ONLINE";
  }

  return (
    <div className={clsx(
        "relative flex flex-col border-b transition-colors duration-300 shrink-0 z-10",
        isGameOver ? "bg-critical-red/10 border-critical-red/50" :
        isDestroyed ? (isInteracting ? "bg-latent-purple/10 border-latent-purple/50" : "bg-critical-red/10 border-critical-red/50") :
        (isInteracting && isDamaged) ? "bg-service-cyan/10 border-service-cyan/50" :
        isDamaged ? "bg-alert-yellow/10 border-alert-yellow/30" : 
        "bg-primary-green/5 border-primary-green-dim/30"
    )}>
        <div className="flex items-center justify-between px-3 py-1.5 h-8">
            <div className="flex items-baseline gap-2">
                <span className={clsx("text-sm md:text-base font-header font-bold uppercase tracking-wider drop-shadow-md transition-colors duration-300", mainColor)}>
                    {title}
                </span>
                <span className={clsx("text-[8px] font-mono tracking-widest opacity-80", mainColor)}>[{statusText}]</span>
            </div>
            <div className="w-5 h-5 flex items-center justify-center">
                <AnimatePresence mode="wait">
                    {isGameOver ? (
                        <motion.div key="gameover" initial={{ scale: 0, rotate: -90 }} animate={{ scale: 1, rotate: 0 }} className="text-critical-red drop-shadow-[0_0_8px_currentColor]"><Skull size={16} /></motion.div>
                    ) : isDestroyed ? (
                        isInteracting ? (
                            <motion.div key="rebooting" initial={{ scale: 0 }} animate={{ scale: 1 }} className="w-4 h-4 bg-latent-purple rounded-full flex items-center justify-center shadow-[0_0_10px_currentColor]">
                                <motion.div animate={{ rotate: 360, opacity: [0.6, 1, 0.6] }} transition={{ duration: 0.5, repeat: Infinity }}><Zap size={10} className="text-black fill-current" /></motion.div>
                            </motion.div>
                        ) : (
                            <motion.div key="destroyed" initial={{ scale: 0 }} animate={{ scale: 1 }} className="w-4 h-4 border border-latent-purple rounded-full flex items-center justify-center opacity-80"><Power size={10} className="text-latent-purple" /></motion.div>
                        )
                    ) : isInteracting && isDamaged ? (
                        <motion.div key="healing" initial={{ scale: 0 }} animate={{ scale: 1 }} className="w-4 h-4 bg-service-cyan rounded-full flex items-center justify-center shadow-[0_0_10px_currentColor]">
                            <motion.div animate={{ rotate: 360 }} transition={{ duration: 1, repeat: Infinity, ease: "linear" }}><RefreshCw size={10} className="text-black" /></motion.div>
                        </motion.div>
                    ) : isDamaged ? (
                        <motion.div key="damaged" initial={{ opacity: 1, scale: 1 }} animate={{ x: [-2, 2, -2, 2, -2, 2, 0, 0, 0, 0, 0, 0, 0], filter: ['drop-shadow(0 0 0px rgba(234,231,71,0))', 'drop-shadow(0 0 8px rgba(234,231,71,1))', 'drop-shadow(0 0 0px rgba(234,231,71,0))'] }} transition={{ duration: 1.5, repeat: Infinity, ease: "linear" }} className="text-alert-yellow"><AlertTriangle size={16} /></motion.div>
                    ) : showOptimal ? (
                        <motion.div key="optimal" initial={{ scale: 0 }} animate={{ scale: 1 }} exit={{ scale: 0, opacity: 0 }} className="w-4 h-4 bg-primary-green rounded-full flex items-center justify-center shadow-[0_0_5px_currentColor]"><Check size={10} className="text-black stroke-[3px]" /></motion.div>
                    ) : null}
                </AnimatePresence>
            </div>
        </div>
        {!isGameOver && (
            <div className="w-full h-1 bg-black/50 relative overflow-hidden">
                <motion.div 
                    className={clsx(
                        "h-full transition-colors duration-200",
                        (isDestroyed && isInteracting) ? "bg-latent-purple shadow-[0_0_10px_#9E4EA5]" :
                        (isDestroyed && healthPercent > 0) ? "bg-latent-purple opacity-60" : 
                        isDestroyed ? "bg-transparent" : 
                        (isInteracting && isDamaged) ? "bg-service-cyan" :
                        isDamaged ? "bg-alert-yellow" : 
                        "bg-primary-green"
                    )}
                    initial={{ width: "100%" }}
                    animate={{ width: `${healthPercent}%` }}
                    transition={{ type: "tween", ease: "easeOut", duration: 0.3 }}
                />
            </div>
        )}
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/molecules/HoloCommLog.tsx
=====================================
import { useState, useEffect } from 'react';
import { ExternalLink, Radio, WifiOff, BatteryWarning, SignalHigh } from 'lucide-react';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { getPan } from '@/engine/audio/AudioUtils';
import { clsx } from 'clsx';
import { useHoloCycler } from '@/ui/kit/hooks/useHoloCycler';
import { PanelId } from '@/engine/config/PanelConfig';

const StaticOverlay = ({ label, icon: Icon, color = "text-primary-green", animate = false }: any) => (
  <div className="absolute inset-0 z-[50] bg-black flex flex-col items-center justify-center overflow-hidden w-full h-full">
    <div className="absolute inset-0 bg-[url('https://media.giphy.com/media/oEI9uBYSzLpBK/giphy.gif')] opacity-20 bg-cover mix-blend-screen pointer-events-none" />
    <div className={clsx("relative z-10 font-mono text-[10px] bg-black/80 px-2 py-1 flex items-center gap-2 border border-current", color, animate && "animate-pulse")}>
        <Icon size={12} /><span>{label}</span>
    </div>
  </div>
);

const VideoSlot = ({ slotIndex, canMount }: { slotIndex: number, canMount: boolean }) => {
  const panelState = useGameStore((state) => state.panels[PanelId.VIDEO]);
  const isDead = panelState ? (panelState.isDestroyed || panelState.health <= 0) : false;
  const graphicsMode = useStore((state) => state.graphicsMode);
  const isPotato = graphicsMode === 'POTATO';
  const { videoId, isMasked } = useHoloCycler(slotIndex, canMount && !isDead && !isPotato);

  if (isDead) return <div className="relative w-full aspect-video min-h-[140px] md:min-h-0 border border-critical-red/30 bg-black"><StaticOverlay label="SIGNAL_LOST" icon={WifiOff} color="text-critical-red" animate /></div>;
  if (isPotato) return <div className="relative w-full aspect-video min-h-[140px] md:min-h-0 border border-alert-yellow/30 bg-black"><StaticOverlay label="POWER_SAVE_MODE" icon={BatteryWarning} color="text-alert-yellow" /></div>;
  if (!canMount) return <div className="relative w-full aspect-video min-h-[140px] md:min-h-0 border border-primary-green/20 bg-black"><div className="absolute inset-0 flex items-center justify-center text-[9px] font-mono text-primary-green/30 animate-pulse">INITIALIZING...</div></div>;

  return (
    <div className="relative w-full aspect-video min-h-[140px] md:min-h-0 border border-primary-green-dim/30 bg-black overflow-hidden group/video hover:border-alert-yellow hover:shadow-[0_0_15px_rgba(234,231,71,0.3)] transition-all" onMouseEnter={(e) => AudioSystem.playHover(getPan(e))}>
        {videoId && <div className="absolute inset-0 z-10"><iframe width="100%" height="100%" src={`https://www.youtube.com/embed/${videoId}?autoplay=1&mute=1&controls=0&showinfo=0&modestbranding=1&loop=1&playlist=${videoId}&vq=small`} frameBorder="0" className="w-full h-full object-cover grayscale pointer-events-none" /></div>}
        <div className="absolute inset-0 z-30 pointer-events-none bg-[linear-gradient(rgba(0,0,0,0)_50%,rgba(0,0,0,0.25)_50%)] bg-[length:100%_4px]" />
        <div className={clsx("absolute inset-0 z-40 transition-all duration-500 flex items-center justify-center pointer-events-none", isMasked ? "opacity-100 bg-black" : "opacity-0 group-hover/video:opacity-100 bg-black/40")}>
             {isMasked ? <div className="flex flex-col items-center"><Radio className="text-primary-green animate-pulse w-6 h-6 mb-2" /><span className="text-[10px] font-mono text-primary-green animate-pulse">ESTABLISHING_UPLINK...</span></div> : <div className="flex items-center gap-2 text-alert-yellow font-mono font-bold bg-black/80 px-3 py-1 border border-alert-yellow rounded-sm pointer-events-auto"><span>OPEN_SOURCE</span><ExternalLink size={12} /></div>}
        </div>
        <a href={`https://www.youtube.com/watch?v=${videoId}`} target="_blank" rel="noopener noreferrer" className="absolute inset-0 z-50 cursor-pointer" onClick={(e) => AudioSystem.playClick(getPan(e))} />
        <div className="absolute bottom-1 right-1 z-[60] text-[8px] text-primary-green font-mono bg-black/80 px-1 pointer-events-none group-hover/video:text-alert-yellow transition-colors flex items-center gap-1"><SignalHigh size={8} /> CAM_0{slotIndex + 1}</div>
    </div>
  );
};

export const HoloCommLog = () => {
  const { bootState } = useStore();
  const [mountStage, setMountStage] = useState(0);
  useEffect(() => {
      if (bootState !== 'active') { setMountStage(0); return; }
      const t1 = setTimeout(() => setMountStage(1), 100);
      const t2 = setTimeout(() => setMountStage(2), 900);
      const t3 = setTimeout(() => setMountStage(3), 1700);
      return () => { clearTimeout(t1); clearTimeout(t2); clearTimeout(t3); };
  }, [bootState]);
  return <div className="flex flex-col gap-2 p-1 h-full"><VideoSlot slotIndex={0} canMount={mountStage >= 1} /><VideoSlot slotIndex={1} canMount={mountStage >= 2} /><VideoSlot slotIndex={2} canMount={mountStage >= 3} /></div>;
};


=====================================
FILE: ./src/ui/kit/molecules/FeedAccessTerminal.tsx
=====================================
import { useGameStore } from '@/engine/state/game/useGameStore';
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { clsx } from 'clsx';
import { PanelId } from '@/engine/config/PanelConfig';

export const FeedAccessTerminal = () => {
  const { openModal } = useStore();
  const panelState = useGameStore((state) => state.panels[PanelId.FEED]);
  const isDestroyed = panelState ? panelState.isDestroyed : false;

  return (
    <div className={clsx("w-full h-full flex items-center justify-center p-4 transition-all duration-500", isDestroyed ? "opacity-10 pointer-events-none blur-sm grayscale" : "opacity-100 blur-0")}>
        <div className="flex flex-col items-center justify-center gap-4 bg-black/20 p-8 w-full max-w-lg marching-ants [--ant-color:rgba(27,185,48,0.3)]">
            <p className="animate-pulse text-primary-green-dim text-xs tracking-widest font-bold">&gt; ESTABLISHING UPLINK...</p>
            <button 
                onClick={() => { AudioSystem.playClick(); openModal('feed'); }} onMouseEnter={() => AudioSystem.playHover()}
                className="group w-full py-3 border border-primary-green-dim/50 text-primary-green font-header font-black text-lg tracking-[0.2em] uppercase transition-all duration-300 hover:border-alert-yellow hover:text-alert-yellow hover:shadow-[0_0_20px_rgba(234,231,71,0.3)] hover:bg-alert-yellow/5 relative overflow-hidden"
            >
                <span className="relative z-10 group-hover:translate-x-1 transition-transform duration-300 inline-block">[ ACCESS_TERMINAL ]</span>
            </button>
        </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/molecules/SystemOps.tsx
=====================================
import { useGameStore } from '@/engine/state/game/useGameStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { getPan } from '@/engine/audio/AudioUtils';
import { Unplug, Biohazard, CircleDotDashed, AlertTriangle } from 'lucide-react';
import { UpgradeOption } from '@/engine/types/game.types';

const SYSTEM_OPS: UpgradeOption[] = ['REPAIR_NANITES', 'RESTORE', 'PURGE'];

const OP_INFO: Record<string, { label: string, desc: string, icon: any }> = {
  'PURGE': { label: 'Purge', desc: 'Nuke Screen', icon: Biohazard },
  'RESTORE': { label: 'Restore', desc: 'Heal System', icon: CircleDotDashed },
  'REPAIR_NANITES': { label: 'Repair', desc: 'Heal Self', icon: Unplug }
};

interface SystemOpsProps {
  isPanelDead: boolean;
}

export const SystemOps = ({ isPanelDead }: SystemOpsProps) => {
  const upgradePoints = useGameStore(s => s.upgradePoints);
  const selectUpgrade = useGameStore(s => s.selectUpgrade);

  const handleUpgrade = (u: UpgradeOption, e: React.MouseEvent) => {
      if (isPanelDead || upgradePoints <= 0) return; 
      AudioSystem.playClick(getPan(e));
      selectUpgrade(u);
  };

  if (upgradePoints <= 0) return null;

  return (
    <div className="flex flex-col gap-1.5 mt-4">
        <span className="text-[8px] font-bold text-alert-yellow/50 uppercase tracking-widest px-1">System_Ops</span>
        {SYSTEM_OPS.map(u => {
            const info = OP_INFO[u];
            const Icon = info.icon;
            
            return (
                <button
                    key={u}
                    onClick={(e) => handleUpgrade(u, e)}
                    onMouseEnter={(e) => !isPanelDead && AudioSystem.playHover(getPan(e))}
                    className="group relative flex items-center justify-between p-2 border border-alert-yellow/30 bg-alert-yellow/5 hover:border-alert-yellow transition-all duration-200 overflow-hidden"
                >
                    <div className="absolute inset-0 translate-x-[-100%] group-hover:translate-x-0 transition-transform duration-300 ease-out bg-alert-yellow opacity-20" />
                    
                    <div className="flex items-center gap-3 relative z-10">
                        <div className="p-1.5 rounded-sm bg-alert-yellow/10 text-alert-yellow group-hover:bg-alert-yellow group-hover:text-black">
                            <Icon size={14} />
                        </div>
                        <div className="flex flex-col items-start">
                            <span className="text-[10px] font-bold font-header tracking-wider uppercase text-alert-yellow">
                                {info.label}
                            </span>
                            <span className="text-[8px] text-gray-400 font-mono group-hover:text-white">
                                {info.desc}
                            </span>
                        </div>
                    </div>
                    
                    <AlertTriangle size={12} className="text-alert-yellow/50 group-hover:text-alert-yellow" />
                </button>
            );
        })}
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/molecules/VideoPlaylistService.ts
=====================================
const VIDEO_POOL = [
  "oLALHbB3iXU", "A1dnxXrpN-o", "elyXcwunIYA", 
  "bHUcvHx9zlA", "Eq6EYcpWB_c", "sJyWgks1ZtA", 
  "dFlDRhvM4L0", "Ku5fgOHy1JY", "8-91y7BJ8QA"
];

class VideoPlaylistController {
  private deck: string[] = [];
  private active = new Set<string>();

  constructor() {
    this.reshuffle();
  }

  private reshuffle() {
    // Create a new shuffled deck
    this.deck = [...VIDEO_POOL].sort(() => Math.random() - 0.5);
    console.log('[VideoPlaylist] Deck Reshuffled');
  }

  public acquire(): string {
    // 1. Refill if needed
    if (this.deck.length === 0) {
        this.reshuffle();
    }

    // 2. Find a valid candidate
    // We iterate through the deck to find a video that isn't currently playing in another slot
    // (This handles the edge case where a reshuffle happens but some videos are still playing)
    let candidateIndex = -1;

    for (let i = this.deck.length - 1; i >= 0; i--) {
        if (!this.active.has(this.deck[i])) {
            candidateIndex = i;
            break;
        }
    }

    // If literally every video in the pool is active (unlikely with 3 slots / 9 videos), just take the top one
    if (candidateIndex === -1) {
        candidateIndex = this.deck.length - 1;
    }

    // 3. Extract and Track
    const videoId = this.deck.splice(candidateIndex, 1)[0];
    this.active.add(videoId);
    
    return videoId;
  }

  public release(id: string | null) {
    if (id) {
        this.active.delete(id);
    }
  }
}

export const VideoPlaylistService = new VideoPlaylistController();


=====================================
FILE: ./src/ui/kit/molecules/UpgradeTerminal.tsx
=====================================
import { useGameStore } from '@/engine/state/game/useGameStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { getPan } from '@/engine/audio/AudioUtils';
import { Zap, Swords, GitFork, Gitlab, DoorOpen, Bot, ArrowUpCircle } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { UpgradeOption } from '@/engine/types/game.types';

const CORE_UPGRADES: UpgradeOption[] = ['OVERCLOCK', 'EXECUTE', 'FORK', 'SNIFFER', 'BACKDOOR', 'DAEMON'];

const UPGRADE_INFO: Partial<Record<UpgradeOption, { label: string, desc: string, icon: any }>> = {
  'OVERCLOCK': { label: 'Overclock', desc: 'Fire Rate ++', icon: Zap },
  'EXECUTE': { label: 'Execute', desc: 'Damage ++', icon: Swords },
  'FORK': { label: 'Fork', desc: 'Multishot ++', icon: GitFork }, 
  'SNIFFER': { label: 'Sniffer', desc: 'Homing', icon: Gitlab }, 
  'BACKDOOR': { label: 'Backdoor', desc: 'Rear Guard', icon: DoorOpen }, 
  'DAEMON': { label: 'Daemon', desc: 'Summon Ally', icon: Bot },
};

interface UpgradeTerminalProps {
  isPanelDead: boolean;
}

export const UpgradeTerminal = ({ isPanelDead }: UpgradeTerminalProps) => {
  const upgradePoints = useGameStore(s => s.upgradePoints);
  const activeUpgrades = useGameStore(s => s.activeUpgrades);
  const selectUpgrade = useGameStore(s => s.selectUpgrade);

  const handleUpgrade = (u: UpgradeOption, e: React.MouseEvent) => {
      if (isPanelDead || upgradePoints <= 0) return; 
      AudioSystem.playClick(getPan(e));
      selectUpgrade(u);
  };

  return (
    <AnimatePresence mode="wait">
      {upgradePoints > 0 ? (
        <motion.div 
            key="upgrades"
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            className="flex flex-col gap-4"
        >
            <div className="flex items-center gap-2 pb-1 border-b border-primary-green/20 pt-2">
                <ArrowUpCircle size={12} className="text-primary-green animate-bounce" />
                <span className="text-[9px] font-bold text-primary-green tracking-widest">
                    SYSTEM_UPGRADE_AVAILABLE [{upgradePoints}]
                </span>
            </div>

            <div className="flex flex-col gap-1.5">
                <span className="text-[8px] font-bold text-primary-green-dim/50 uppercase tracking-widest px-1">Kernel_Modules</span>
                {CORE_UPGRADES.map(u => {
                    const info = UPGRADE_INFO[u];
                    if (!info) return null;
                    
                    const Icon = info.icon;
                    const currentLvl = activeUpgrades[u] || 0;

                    return (
                        <button
                            key={u}
                            onClick={(e) => handleUpgrade(u, e)}
                            onMouseEnter={(e) => !isPanelDead && AudioSystem.playHover(getPan(e))}
                            className="group relative flex items-center justify-between p-2 border border-primary-green-dim/30 bg-black/40 hover:border-primary-green transition-all duration-200 overflow-hidden"
                        >
                            <div className="absolute inset-0 translate-x-[-100%] group-hover:translate-x-0 transition-transform duration-300 ease-out bg-primary-green opacity-20" />
                            
                            <div className="flex items-center gap-3 relative z-10">
                                <div className="p-1.5 rounded-sm bg-primary-green/10 text-primary-green group-hover:bg-primary-green group-hover:text-black">
                                    <Icon size={14} />
                                </div>
                                <div className="flex flex-col items-start">
                                    <span className="text-[10px] font-bold font-header tracking-wider uppercase text-primary-green">
                                        {info.label}
                                    </span>
                                    <span className="text-[8px] text-gray-400 font-mono group-hover:text-white">
                                        {info.desc}
                                    </span>
                                </div>
                            </div>

                            <div className="text-[9px] font-mono text-primary-green-dim border border-primary-green-dim/30 px-1.5 py-0.5 rounded bg-black/50 group-hover:border-primary-green group-hover:text-primary-green relative z-10">
                                v{currentLvl}
                            </div>
                        </button>
                    );
                })}
            </div>
        </motion.div>
      ) : (
        <motion.div 
            key="status"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            className="h-full flex flex-col justify-center items-center text-center opacity-40 font-mono space-y-2 p-4 rounded bg-black/20 marching-ants [--ant-color:rgba(255,255,255,0.1)]"
        >
            <div className="w-8 h-8 rounded-full border border-white/20 flex items-center justify-center animate-spin-slow">
                <div className="w-1 h-1 bg-white/50 rounded-full" />
            </div>
            <span className="text-[9px] tracking-widest">SYSTEM_OPTIMIZED</span>
            <span className="text-[8px]">WAITING FOR DATA...</span>
        </motion.div>
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/kit/molecules/LiveArtGrid.tsx
=====================================
import { useEffect, useState } from 'react';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { getPan } from '@/engine/audio/AudioUtils';
import { motion, AnimatePresence } from 'framer-motion';
import { clsx } from 'clsx';
import { PanelId } from '@/engine/config/PanelConfig';

const randomId = () => Math.floor(Math.random() * 899) + 100;

export const LiveArtGrid = () => {
  const { openModal } = useStore();
  const [slots, setSlots] = useState<number[]>([]);
  const panelState = useGameStore((state) => state.panels[PanelId.ART]);
  const isDestroyed = panelState ? panelState.isDestroyed : false;

  useEffect(() => {
    setSlots(Array.from({ length: 12 }, randomId));
    const interval = setInterval(() => {
      setSlots(prev => {
        const newSlots = [...prev];
        const randomIndex = Math.floor(Math.random() * 12);
        newSlots[randomIndex] = randomId();
        return newSlots;
      });
    }, 800);
    return () => clearInterval(interval);
  }, []);

  return (
    <div className={clsx("grid grid-cols-3 gap-1 w-full p-2 content-start transition-opacity duration-500", isDestroyed ? "pointer-events-none opacity-80" : "")}>
      <AnimatePresence mode='popLayout'>
        {slots.map((id, index) => {
            const isCorrupt = isDestroyed;
            return (
              <motion.button
                key={`${index}-${id}`} layout initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} transition={{ duration: 0.2 }}
                onClick={(e) => { if (isDestroyed) return; AudioSystem.playClick(getPan(e)); openModal('gallery'); }}
                onMouseEnter={(e) => !isDestroyed && AudioSystem.playHover(getPan(e))}
                className={clsx("w-full aspect-square relative border group overflow-hidden flex items-center justify-center rounded-[1px] transition-colors", isCorrupt ? "bg-black border-critical-red/20" : "bg-black/50 border-primary-green-dim/30 hover:border-alert-yellow hover:shadow-[0_0_10px_rgba(247,210,119,0.2)]")}
              >
                <div className={clsx("absolute inset-0 transition-colors", isCorrupt ? "bg-critical-red/5" : "bg-primary-green/5 group-hover:bg-primary-green/10")} />
                <span className={clsx("relative z-10 text-[9px] font-mono transition-colors", isCorrupt ? "text-critical-red/50 animate-pulse" : "text-primary-green-dim group-hover:text-alert-yellow")}>{isCorrupt ? (Math.random() > 0.5 ? "0x00" : "ERR") : `IMG_${id}`}</span>
                {!isCorrupt && <div className="absolute top-0 right-0 w-1.5 h-1.5 border-t border-r border-primary-green-dim/50 group-hover:border-alert-yellow" />}
              </motion.button>
            );
        })}
      </AnimatePresence>
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/molecules/IdentityFooter.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { getPan } from '@/engine/audio/AudioUtils';

interface IdentityFooterProps {
  isPanelDead: boolean;
}

export const IdentityFooter = ({ isPanelDead }: IdentityFooterProps) => {
  const { openModal } = useStore();

  const handleClick = (modal: 'about' | 'contact', e: React.MouseEvent) => {
      if (isPanelDead) return;
      AudioSystem.playClick(getPan(e));
      openModal(modal);
  };

  return (
    <div className="flex-none grid grid-cols-2 gap-px bg-primary-green-dim/20 border-t border-primary-green-dim/30 mt-auto">
      <button 
        onClick={(e) => handleClick('about', e)} 
        onMouseEnter={(e) => !isPanelDead && AudioSystem.playHover(getPan(e))}
        className="py-3 bg-black/80 hover:bg-primary-green hover:text-black text-primary-green text-[10px] font-bold font-header uppercase transition-colors tracking-widest"
      >
        About_Me
      </button>
      <button 
        onClick={(e) => handleClick('contact', e)} 
        onMouseEnter={(e) => !isPanelDead && AudioSystem.playHover(getPan(e))}
        className="py-3 bg-black/80 hover:bg-alert-yellow hover:text-black text-alert-yellow text-[10px] font-bold font-header uppercase transition-colors tracking-widest"
      >
        Contact_Link
      </button>
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/molecules/IdentityHUD.tsx
=====================================
import { useGameStore } from '@/engine/state/game/useGameStore';
import identity from '@/engine/config/static/identity.json';
import { clsx } from 'clsx';
import { PanelId } from '@/engine/config/PanelConfig';
import { PALETTE } from '@/engine/config/Palette';
import { VitalsRing } from '@/ui/kit/atoms/VitalsRing';
import { UpgradeTerminal } from './UpgradeTerminal';
import { SystemOps } from './SystemOps';
import { IdentityFooter } from './IdentityFooter';

export const IdentityHUD = () => {
  const hp = useGameStore(s => s.playerHealth);
  const maxHp = useGameStore(s => s.maxPlayerHealth);
  const xp = useGameStore(s => s.xp);
  const nextXp = useGameStore(s => s.xpToNextLevel);
  const level = useGameStore(s => s.level);
  const rebootProgress = useGameStore(s => s.playerRebootProgress);
  const panel = useGameStore(s => s.panels[PanelId.IDENTITY]);
  const isPanelDead = panel ? panel.isDestroyed : false;
  const isPlayerDead = hp <= 0;

  return (
    <div className={clsx("flex flex-col h-full w-full relative overflow-hidden", isPanelDead ? 'grayscale opacity-50 pointer-events-none' : '')}>
      <div className="flex-none flex flex-col items-center pt-4 relative z-10">
        <VitalsRing health={hp} maxHealth={maxHp} xp={xp} xpToNext={nextXp} level={level} isDead={isPlayerDead} rebootProgress={rebootProgress} />
        <div className="text-center z-20 mb-2">
            <h2 className="text-xl font-header font-black tracking-wider drop-shadow-md" style={{ color: PALETTE.GREEN.PRIMARY }}>{identity.name}</h2>
            <div className="text-[8px] uppercase tracking-[0.2em] opacity-80 bg-black/60 px-2 py-0.5 rounded-full border" style={{ color: PALETTE.PURPLE.LIGHT, borderColor: `${PALETTE.PURPLE.PRIMARY}33` }}>{identity.class}</div>
        </div>
      </div>
      <div className="flex-1 min-h-0 w-full px-4 overflow-y-auto scrollbar-hide relative pb-4">
         <div className={isPlayerDead ? "opacity-50 pointer-events-none" : ""}>
             <UpgradeTerminal isPanelDead={isPanelDead} />
             <SystemOps isPanelDead={isPanelDead} />
         </div>
      </div>
      <IdentityFooter isPanelDead={isPanelDead} />
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/atoms/SafePanelContent.tsx
=====================================
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { AlertTriangle } from 'lucide-react';

interface Props {
  children: ReactNode;
  fallbackId?: string;
}

interface State {
  hasError: boolean;
  errorMsg: string;
}

export class SafePanelContent extends Component<Props, State> {
  public state: State = {
    hasError: false,
    errorMsg: ''
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, errorMsg: error.message };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error(`[SafePanelContent] Crash in ${this.props.fallbackId}:`, error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return (
        <div className="absolute inset-0 flex flex-col items-center justify-center bg-black/80 z-[100] p-2 text-center border border-critical-red/50">
          <AlertTriangle className="text-critical-red mb-1 animate-pulse" size={24} />
          <span className="text-[10px] text-critical-red font-mono font-bold tracking-widest">
            VISUAL_CORE_ERR
          </span>
          <span className="text-[8px] text-critical-red/60 font-mono mt-1 max-w-[150px] truncate">
            {this.state.errorMsg}
          </span>
        </div>
      );
    }

    return this.props.children;
  }
}


=====================================
FILE: ./src/ui/kit/atoms/ZenBomb.tsx
=====================================
import { motion, AnimatePresence } from 'framer-motion';
import { Bomb, Skull, Infinity as InfinityIcon } from 'lucide-react';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { useState } from 'react';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { IPanelSystem } from '@/engine/interfaces';

export const ZenBomb = () => {
  const isGameOver = useGameStore(state => state.systemIntegrity <= 0);
  const isZenMode = useGameStore(state => state.isZenMode);
  const activateZenMode = useGameStore(state => state.activateZenMode);
  const [clicked, setClicked] = useState(false);

  if (!isGameOver || isZenMode) return null;

  const handleClick = () => {
    setClicked(true); AudioSystem.playClick();
    GameEventBus.emit(GameEvents.UPGRADE_SELECTED, { option: 'PURGE' });
    AudioSystem.playSound('syn_bass_drop');
    setTimeout(() => {
        GameEventBus.emit(GameEvents.LOG_DEBUG, { msg: 'UI_PURGE_TRIGGER' }); 
        try {
            const panels = ServiceLocator.getSystem<IPanelSystem>('PanelRegistrySystem');
            if (panels) panels.destroyAll();
        } catch (e) { console.warn(e); }
    }, 500);
    setTimeout(() => { activateZenMode(); AudioSystem.playAmbience('ambience_core'); }, 5500);
  };

  return (
    <AnimatePresence>
      {!clicked && (
        <motion.button initial={{ y: -200, opacity: 0 }} animate={{ y: 0, opacity: 1 }} exit={{ scale: 3, opacity: 0, filter: "blur(20px)" }} transition={{ type: "spring", stiffness: 100, damping: 15, delay: 1.0 }} 
          onClick={handleClick} className="fixed top-24 left-1/2 -translate-x-1/2 z-bomb flex flex-col items-center group cursor-none outline-none pointer-events-auto"
        >
          <motion.div initial={{ height: 0 }} animate={{ height: 160 }} transition={{ delay: 1.0, duration: 0.8, ease: "easeOut" }} className="w-[2px] bg-critical-red/80 absolute -top-64 left-1/2 -translate-x-1/2 shadow-[0_0_8px_#FF003C]" />
          <div className="relative p-1 border border-critical-red bg-black/90 backdrop-blur-md shadow-[0_0_20px_#FF003C] overflow-hidden group-hover:shadow-[0_0_40px_#FF003C] transition-shadow duration-300 z-10">
             <div className="absolute inset-0 opacity-20 pointer-events-none" style={{ backgroundImage: 'repeating-linear-gradient(45deg, #FF003C 0, #FF003C 5px, transparent 5px, transparent 10px)' }} />
             <div className="relative w-16 h-16 border border-critical-red/50 flex items-center justify-center bg-black hover:bg-critical-red transition-colors duration-300 group-hover:text-black text-critical-red">
                 <motion.div animate={{ rotate: [0, -10, 10, 0] }} transition={{ repeat: Infinity, duration: 0.3, repeatDelay: 2 }} ><Bomb size={32} strokeWidth={2} /></motion.div>
             </div>
          </div>
          <div className="mt-4 flex items-center gap-2 px-3 py-1 bg-critical-red/10 border border-critical-red/50 backdrop-blur-md z-10"><Skull size={10} className="text-critical-red animate-pulse" /><span className="text-[10px] font-mono font-black text-critical-red tracking-widest uppercase group-hover:text-white transition-colors"> SYSTEM_PURGE </span><Skull size={10} className="text-critical-red animate-pulse" /></div>
          <span className="text-[8px] text-critical-red/60 font-mono mt-1 opacity-0 group-hover:opacity-100 transition-opacity flex items-center gap-1"><InfinityIcon size={8} /> [ ENTER_ZEN_MODE ]</span>
        </motion.button>
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/kit/atoms/CustomCursor.tsx
=====================================
import { useEffect, useState, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { clsx } from 'clsx';
import { DOM_ATTR } from '@/ui/config/DOMConfig';

export const CustomCursor = () => {
  const [pos, setPos] = useState({ x: 0, y: 0 });
  const [isHovering, setIsHovering] = useState(false);
  const [isClicking, setIsClicking] = useState(false);
  const [isOnScrollbar, setIsOnScrollbar] = useState(false);
  const [isHit, setIsHit] = useState(false);
  const hitTimer = useRef<NodeJS.Timeout | null>(null);
  
  const { bootState, activeModal, isDebugOpen, isBreaching, sessionId } = useStore();
  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  
  const isGameActive = bootState === 'active' || bootState === 'mobile_lockdown';
  const isMenuOpen = activeModal !== 'none' || isDebugOpen;
  const isGameOver = systemIntegrity <= 0;

  const showCustomCursor = ((!isGameActive && !isBreaching) || isMenuOpen || bootState === 'mobile_lockdown' || isGameOver) && !isOnScrollbar;

  useEffect(() => {
      const unsub = GameEventBus.subscribe(GameEvents.PLAYER_HIT, () => {
          setIsHit(true);
          if (hitTimer.current) clearTimeout(hitTimer.current);
          hitTimer.current = setTimeout(() => setIsHit(false), 150);
      });
      return () => {
          unsub();
          if (hitTimer.current) clearTimeout(hitTimer.current);
      };
  }, [sessionId, bootState]);

  useEffect(() => {
    const move = (e: MouseEvent) => {
      setPos({ x: e.clientX, y: e.clientY });
      const target = e.target as HTMLElement;
      setIsHovering(!!target.closest(`button, a, input, label, [${DOM_ATTR.INTERACTIVE}="true"]`));
      const onScroll = e.clientX >= window.innerWidth - 14 || e.clientY >= window.innerHeight - 14;
      setIsOnScrollbar(onScroll);
      if (onScroll) {
          document.body.style.setProperty('cursor', 'auto', 'important');
      } else {
          document.body.style.setProperty('cursor', 'none', 'important');
      }
    };
    const down = () => setIsClicking(true);
    const up = () => setIsClicking(false);
    window.addEventListener('mousemove', move);
    window.addEventListener('mousedown', down);
    window.addEventListener('mouseup', up);
    return () => {
      window.removeEventListener('mousemove', move);
      window.removeEventListener('mousedown', down);
      window.removeEventListener('mouseup', up);
      document.body.style.cursor = 'auto'; 
    };
  }, [isGameActive, isMenuOpen, isBreaching, isGameOver]);

  const cursorColor = isHit ? '#FF003C' : (isHovering ? '#eae747' : '#78F654');
  const cursorShadow = isHit 
    ? 'drop-shadow(0 0 15px #FF003C)' 
    : (isHovering ? 'drop-shadow(0 0 12px #eae747)' : 'drop-shadow(0 0 8px #78F654)');

  return (
    <>
      <motion.div
        className={clsx("fixed top-0 left-0 pointer-events-none z-cursor", (isHovering && showCustomCursor && !isHit) ? "mix-blend-difference" : "" )}
        animate={{ x: pos.x - 5.5, y: pos.y - 3.2 }}
        transition={{ type: "tween", ease: "linear", duration: 0 }}
      >
        <AnimatePresence mode="wait">
          {showCustomCursor && (
            <motion.div key="custom-cursor" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} transition={{ duration: 0.2 }} className="relative">
              <svg width="24" height="24" viewBox="0 0 24 24" className={`transition-transform duration-100 ${isClicking ? 'scale-90' : 'scale-100'} ${isHit ? 'scale-125' : ''}`} style={{ filter: cursorShadow, fill: cursorColor, transition: 'fill 0.1s ease, filter 0.1s ease' }}>
                <path d="M5.5 3.21l12.32 12.32-4.5 1.12 3.5 3.5-2.12 2.12-3.5-3.5-1.12 4.5z" />
              </svg>
            </motion.div>
          )}
        </AnimatePresence>
      </motion.div>
    </>
  );
};


=====================================
FILE: ./src/ui/kit/atoms/VirtualJoystick.tsx
=====================================
import { useState, useRef } from 'react';
import { VirtualJoystickService } from '@/engine/input/VirtualJoystickService';
import { UI_METRICS } from '@/engine/config/constants/UIConstants';

export const VirtualJoystick = () => {
  const [active, setActive] = useState(false);
  const [pos, setPos] = useState({ x: 0, y: 0 });
  const stickRef = useRef<HTMLDivElement>(null);
  const MAX_RADIUS = UI_METRICS.JOYSTICK.MAX_RADIUS;

  const handlePointerDown = (e: React.PointerEvent) => { (e.target as HTMLElement).setPointerCapture(e.pointerId); setActive(true); };
  const handlePointerMove = (e: React.PointerEvent) => {
    if (!active) return;
    const rect = stickRef.current?.parentElement?.getBoundingClientRect();
    if (!rect) return;
    const centerX = rect.left + rect.width / 2; const centerY = rect.top + rect.height / 2;
    const dx = e.clientX - centerX; const dy = e.clientY - centerY;
    const distance = Math.sqrt(dx*dx + dy*dy); const clampedDist = Math.min(distance, MAX_RADIUS);
    const angle = Math.atan2(dy, dx); const x = Math.cos(angle) * clampedDist; const y = Math.sin(angle) * clampedDist;
    setPos({ x, y });
    const normX = x / MAX_RADIUS; const normY = -(y / MAX_RADIUS); 
    VirtualJoystickService.setVector(normX, normY);
  };
  const handlePointerUp = () => { setActive(false); setPos({ x: 0, y: 0 }); VirtualJoystickService.setVector(0, 0); };

  return (
    <div className="fixed bottom-8 left-8 w-32 h-32 z-joystick touch-none select-none">
      <div className="w-full h-full rounded-full border-2 border-primary-green/30 bg-black/50 backdrop-blur-sm relative flex items-center justify-center" ref={stickRef}>
        <div className="w-12 h-12 rounded-full bg-primary-green/80 shadow-[0_0_15px_#78F654] absolute cursor-pointer transition-transform duration-75 ease-linear" style={{ transform: `translate(${pos.x}px, ${pos.y}px)` }} onPointerDown={handlePointerDown} onPointerMove={handlePointerMove} onPointerUp={handlePointerUp} onPointerCancel={handlePointerUp} />
      </div>
      <div className="absolute -top-6 w-full text-center text-[10px] text-primary-green/50 font-mono tracking-widest">[ NAV ]</div>
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/atoms/DotGridBackground.tsx
=====================================
import { clsx } from 'clsx';

interface Props {
  className?: string;
  color?: string; // Optional override
}

export const DotGridBackground = ({ className, color = '#15530A' }: Props) => (
  <div 
    className={clsx("absolute inset-0 pointer-events-none opacity-20 z-0", className)} 
    style={{ 
      backgroundImage: `radial-gradient(${color} 1px, transparent 1px)`, 
      backgroundSize: '8px 8px' 
    }} 
  />
);


=====================================
FILE: ./src/ui/kit/atoms/ActionButton.tsx
=====================================
import { useState } from 'react';
import { motion } from 'framer-motion';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { Crosshair } from 'lucide-react';
import { ServiceLocator } from '@/engine/services/ServiceLocator';

export const ActionButton = () => {
  const [pressed, setPressed] = useState(false);

  const handleDown = (e: React.PointerEvent) => {
    e.preventDefault(); setPressed(true); AudioSystem.playClick();
    try {
        const input = ServiceLocator.getInputService(); const cursor = input.getCursor(); 
        const ZOOM = 40; const screenX = (cursor.x * ZOOM) + (window.innerWidth / 2); const screenY = -(cursor.y * ZOOM) + (window.innerHeight / 2);
        const el = document.elementFromPoint(screenX, screenY) as HTMLElement;
        if (el) { el.click(); el.classList.add('active:scale-95'); setTimeout(() => el.classList.remove('active:scale-95'), 150); }
    } catch (err) { console.warn("Action Button Failed:", err); }
  };
  const handleUp = () => { setPressed(false); };

  return (
    <div className="fixed bottom-8 right-8 z-joystick touch-none select-none">
      <motion.button onPointerDown={handleDown} onPointerUp={handleUp} onPointerLeave={handleUp} animate={{ scale: pressed ? 0.9 : 1.0 }} className="w-24 h-24 rounded-full border-2 border-primary-green/50 bg-black/50 backdrop-blur-sm flex items-center justify-center relative group active:border-primary-green active:bg-primary-green/20 transition-colors cursor-pointer">
        <div className="absolute inset-2 rounded-full border border-primary-green/20" />
        <Crosshair size={32} className={`text-primary-green transition-all duration-100 ${pressed ? 'scale-90 opacity-100' : 'opacity-80'}`} />
        {pressed && ( <motion.div initial={{ scale: 1, opacity: 0.5 }} animate={{ scale: 1.5, opacity: 0 }} transition={{ duration: 0.3 }} className="absolute inset-0 rounded-full bg-primary-green" /> )}
      </motion.button>
      <div className="absolute -top-6 w-full text-center text-[10px] text-primary-green/50 font-mono tracking-widest">[ ACT ]</div>
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/atoms/StatsRadar.tsx
=====================================
import { useMemo } from 'react';
import { motion } from 'framer-motion';

interface StatsRadarProps {
  stats: Record<string, number>;
  color?: string;
  size?: number;
}

export const StatsRadar = ({ stats, color = "#78F654", size = 200 }: StatsRadarProps) => {
  const keys = Object.keys(stats);
  const total = keys.length;
  const radius = size / 2;
  const center = size / 2;
  const angleStep = (Math.PI * 2) / total;

  // Helper to get coordinates
  const getPoint = (index: number, value: number) => {
    // -PI/2 to start at top
    const angle = (index * angleStep) - (Math.PI / 2);
    // Normalize value (assumes max 100)
    const dist = (value / 100) * radius; 
    const x = center + Math.cos(angle) * dist;
    const y = center + Math.sin(angle) * dist;
    return { x, y };
  };

  const polyPoints = useMemo(() => {
    return keys.map((key, i) => {
      const { x, y } = getPoint(i, stats[key]);
      return `${x},${y}`;
    }).join(' ');
  }, [stats]);

  const bgPoints = useMemo(() => {
    return keys.map((_, i) => {
      const { x, y } = getPoint(i, 100); // Full scale
      return `${x},${y}`;
    }).join(' ');
  }, [keys]);

  return (
    <div className="relative flex items-center justify-center" style={{ width: size, height: size }}>
      <svg width={size} height={size} className="overflow-visible">
        
        {/* Background Web */}
        {[0.25, 0.5, 0.75, 1.0].map((scale) => (
          <polygon
            key={scale}
            points={keys.map((_, i) => {
               const { x, y } = getPoint(i, 100 * scale);
               return `${x},${y}`;
            }).join(' ')}
            fill="none"
            stroke={color}
            strokeWidth="1"
            strokeOpacity="0.2"
          />
        ))}

        {/* Axis Lines */}
        {keys.map((_, i) => {
            const p = getPoint(i, 100);
            return (
                <line 
                    key={i} 
                    x1={center} y1={center} 
                    x2={p.x} y2={p.y} 
                    stroke={color} 
                    strokeOpacity="0.1" 
                />
            );
        })}

        {/* The Data Shape */}
        <motion.polygon
          initial={{ opacity: 0, scale: 0 }}
          animate={{ opacity: 0.6, scale: 1 }}
          transition={{ duration: 1, type: 'spring' }}
          points={polyPoints}
          fill={color}
          fillOpacity="0.2"
          stroke={color}
          strokeWidth="2"
        />
        
        {/* Vertices */}
        {keys.map((key, i) => {
            const p = getPoint(i, stats[key]);
            const labelP = getPoint(i, 115); // Push labels out
            return (
                <g key={key}>
                    <motion.circle 
                        initial={{ r: 0 }}
                        animate={{ r: 3 }}
                        transition={{ delay: 0.2 + (i * 0.1) }}
                        cx={p.x} cy={p.y} fill={color} 
                    />
                    <text 
                        x={labelP.x} y={labelP.y} 
                        fill={color} 
                        fontSize="10" 
                        fontFamily="monospace" 
                        textAnchor="middle" 
                        alignmentBaseline="middle"
                        className="font-bold tracking-widest uppercase"
                    >
                        {key}
                    </text>
                </g>
            );
        })}
      </svg>
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/atoms/GraphicsToggle.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { Zap, ZapOff } from 'lucide-react';
import { clsx } from 'clsx';

interface Props {
  layout?: 'horizontal' | 'vertical';
}

export const GraphicsToggle = ({ layout = 'horizontal' }: Props) => {
  const { graphicsMode, setGraphicsMode } = useStore();
  const isHigh = graphicsMode === 'HIGH';

  const handleToggle = (mode: 'HIGH' | 'POTATO') => {
    if (graphicsMode === mode) return;
    setGraphicsMode(mode);
    
    if (mode === 'HIGH') {
        AudioSystem.playSound('ui_optimal');
    } else {
        AudioSystem.playSound('ui_error');
    }
  };

  return (
    <div className={clsx("flex gap-2 w-full", layout === 'vertical' ? "flex-col" : "flex-col")}>
      <div className={clsx("grid gap-px bg-white/10 p-px border border-white/20", layout === 'vertical' ? "grid-cols-1" : "grid-cols-2")}>
        
        {/* ENABLED / HIGH */}
        <button
          onClick={() => handleToggle('HIGH')}
          className={clsx(
            "relative group flex items-center justify-center gap-2 transition-all overflow-hidden",
            layout === 'vertical' ? "h-16 w-full" : "h-12",
            isHigh 
              ? "bg-primary-green/20 text-primary-green" 
              : "bg-black/80 text-gray-600 hover:text-gray-400"
          )}
        >
          {isHigh && (
             <div className="absolute inset-0 border border-primary-green shadow-[inset_0_0_15px_rgba(120,246,84,0.3)] animate-pulse" />
          )}
          <Zap size={16} className={isHigh ? "fill-current" : ""} />
          <div className="flex flex-col leading-none items-start">
              <span className="text-[10px] font-black tracking-wider">ENABLED</span>
              <span className="text-[8px] font-mono opacity-70">HIGH_VOLTAGE</span>
          </div>
        </button>

        {/* DISABLED / POTATO */}
        <button
          onClick={() => handleToggle('POTATO')}
          className={clsx(
            "relative group flex items-center justify-center gap-2 transition-all overflow-hidden",
            layout === 'vertical' ? "h-16 w-full" : "h-12",
            !isHigh 
              ? "bg-alert-yellow/20 text-alert-yellow" 
              : "bg-black/80 text-gray-600 hover:text-gray-400"
          )}
        >
          {!isHigh && (
             <div className="absolute inset-0 border border-alert-yellow shadow-[inset_0_0_15px_rgba(247,210,119,0.3)]" />
          )}
          <ZapOff size={16} />
          <div className="flex flex-col leading-none items-start">
              <span className="text-[10px] font-black tracking-wider">DISABLED</span>
              <span className="text-[8px] font-mono opacity-70">POTATO_MODE</span>
          </div>
        </button>

      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/atoms/ToggleButton.tsx
=====================================
import { clsx } from 'clsx';
import { useAudio } from '@/ui/hooks/useAudio';
import { getPan } from '@/engine/audio/AudioUtils';

interface ToggleButtonProps {
  label?: string;
  icon: any;
  iconOff?: any;
  active: boolean;
  onClick: () => void;
  variant?: 'icon' | 'panel'; 
  color?: string; // e.g. "text-primary-green"
}

export const ToggleButton = ({ 
  label, 
  icon: IconOn, 
  iconOff: IconOff, 
  active, 
  onClick, 
  variant = 'icon',
  color
}: ToggleButtonProps) => {
  const audio = useAudio();
  const Icon = active ? IconOn : (IconOff || IconOn);

  const handleClick = (e: React.MouseEvent) => {
      onClick();
      audio.playClick(getPan(e));
  };

  // 1. PANEL VARIANT (Settings Menu) - Unchanged
  if (variant === 'panel') {
      return (
        <button
          onClick={handleClick}
          onMouseEnter={(e) => audio.playHover(getPan(e))}
          className={clsx(
            "flex flex-col items-center justify-center p-2 border transition-all duration-200 w-full h-14 relative overflow-hidden group",
            active 
              ? "bg-primary-green/10 border-primary-green text-primary-green shadow-[inset_0_0_10px_rgba(120,246,84,0.1)]" 
              : "bg-black/40 border-white/10 text-gray-500 hover:border-white/30 hover:text-gray-300"
          )}
        >
          {active && (
             <div className="absolute top-0 right-0 w-1.5 h-1.5 bg-primary-green shadow-[0_0_5px_#78F654]" />
          )}
          <Icon 
            size={16} 
            strokeWidth={1.5}
            className={clsx("mb-1 transition-transform", active ? "scale-110" : "opacity-50")} 
          />
          {label && <span className="text-[9px] font-bold font-mono tracking-widest">{label}</span>}
        </button>
      );
  }

  // 2. ICON VARIANT (Header) - Updated with Invert Logic
  return (
    <button 
      onClick={handleClick}
      onMouseEnter={(e) => audio.playHover(getPan(e))}
      className={clsx(
        "group flex items-center justify-center w-8 h-7 transition-all duration-200 border rounded-sm",
        // Base Dynamic Color (e.g. text-primary-green, text-critical-red)
        color || 'text-white',
        // Hover: Background becomes the text color
        "hover:bg-current hover:border-transparent",
        active 
          ? "bg-white/5 border-white/20 opacity-100"
          : "border-transparent opacity-40 hover:opacity-100"
      )}
    >
      <div className={clsx(
          "flex items-center justify-center transition-colors duration-200",
          // Default: Inherit color. Hover: Force BLACK to contrast against the colored background
          "text-current group-hover:text-black",
          active ? "" : "opacity-80"
      )}>
          {label ? (
            <span className="text-[10px] font-mono font-bold tracking-tighter decoration-1 underline-offset-2">
                {label}
            </span> 
          ) : (
            <Icon size={14} />
          )}
      </div>
    </button>
  );
};


=====================================
FILE: ./src/ui/kit/atoms/PanelSparks.tsx
=====================================
import { useEffect, useRef } from 'react';
import { COLOR_SETS } from '@/engine/config/Palette';

interface Particle {
  x: number;
  y: number;
  vx: number;
  vy: number;
  life: number;
  maxLife: number;
  size: number;
  color: string;
}

interface PanelSparksProps {
  intensity?: 'normal' | 'extreme'; 
}

export const PanelSparks = ({ intensity }: PanelSparksProps) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || !canvas.parentElement) return;
    
    const width = canvas.parentElement.clientWidth;
    const height = canvas.parentElement.clientHeight;
    
    if (width === 0 || height === 0) return;

    const ctx = canvas.getContext('2d', { alpha: true });
    if (!ctx) return;

    canvas.width = width;
    canvas.height = height;

    let particles: Particle[] = [];
    let animationFrameId: number;
    let isActive = true;

    // Use Palette Colors
    const COLORS = COLOR_SETS.RED;
    
    const PARTICLE_COUNT = 500; 
    
    try {
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const edge = Math.floor(Math.random() * 3); 
            let x = 0, y = 0, vx = 0, vy = 0;

            if (edge === 0) { 
                x = Math.random() * width;
                y = 0;
                vx = (Math.random() - 0.5) * 8;
                vy = (Math.random() * 5) + 2; 
            } else if (edge === 1) { 
                x = 0;
                y = Math.random() * (height * 0.5); 
                vx = (Math.random() * 5) + 2; 
                vy = (Math.random() * 5) - 2;
            } else { 
                x = width;
                y = Math.random() * (height * 0.5);
                vx = -((Math.random() * 5) + 2); 
                vy = (Math.random() * 5) - 2;
            }

            particles.push({
                x, y, vx, vy,
                life: 1.0,
                maxLife: 1.0,
                size: Math.random() * 3 + 1,
                color: COLORS[Math.floor(Math.random() * COLORS.length)]
            });
        }
    } catch (e) {
        return;
    }

    const loop = () => {
      if (!isActive) return;
      if (!canvas || canvas.width === 0) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      let activeParticles = false;

      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.15; 
        
        if (p.y > canvas.height) {
          p.y = canvas.height;
          p.vy *= -0.5; 
          p.vx *= 0.7;  
        }
        
        if (p.x < 0 || p.x > canvas.width) {
          p.vx *= -0.6;
          p.x = Math.max(0, Math.min(canvas.width, p.x));
        }

        p.life -= 0.005; 

        if (p.life > 0) {
            activeParticles = true;
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life; 
            ctx.beginPath();
            ctx.rect(p.x, p.y, p.size, p.size);
            ctx.fill();
        } else {
            particles.splice(i, 1);
        }
      }
      
      if (activeParticles) {
          animationFrameId = requestAnimationFrame(loop);
      } else {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    };

    loop();

    return () => {
      isActive = false;
      cancelAnimationFrame(animationFrameId);
    };
  }, [intensity]);

  return (
    <canvas 
      ref={canvasRef} 
      className="absolute inset-0 pointer-events-none z-0 mix-blend-screen"
    />
  );
};


=====================================
FILE: ./src/ui/kit/atoms/GlassPanel.tsx
=====================================
import { clsx } from 'clsx';
import { motion, AnimatePresence, useAnimation } from 'framer-motion';
import { ReactNode, useEffect as useReactEffect, useState as useReactState, useRef as useReactRef } from 'react';
import { usePanelRegistry } from '@/ui/sim/hooks/usePanelRegistry';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { Skull } from 'lucide-react';
import { PanelSparks } from './PanelSparks';
import { useHeartbeat } from '@/ui/sim/hooks/useHeartbeat';
import { RebootOverlay } from '@/ui/kit/molecules/panel/RebootOverlay';
import { IntelligentHeader } from '@/ui/kit/molecules/panel/IntelligentHeader';
import { BreachOverlay } from '@/ui/kit/molecules/panel/BreachOverlay';
import { SafePanelContent } from './SafePanelContent';
import { DotGridBackground } from './DotGridBackground';
import { usePanelPhysics } from '@/ui/kit/hooks/usePanelPhysics';
import { PanelId } from '@/engine/config/PanelConfig';

const DEFAULT_MAX_HEALTH = 100;

const panelVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.5, ease: "easeOut" } },
  shattered: (custom: number) => ({
    y: 350 + (custom * 50),
    opacity: 0.8,
    rotate: custom * 15,
    transition: { duration: 1.5, ease: "anticipate", delay: Math.abs(custom) * 0.1 }
  })
};

const pulseVariants = {
    heartbeat: {
        opacity: [0, 0.6, 0],
        scale: [1, 1.005, 1], 
        transition: { duration: 0.8, times: [0, 0.04, 1], ease: "easeOut" }
    }
};

const CircuitLockOverlay = () => (
    <motion.div 
        className="absolute inset-0 pointer-events-none z-[60] border-2 border-white/50 bg-primary-green/20 shadow-[inset_0_0_20px_#78F654]"
        initial={{ opacity: 0 }}
        animate={{ opacity: [0, 1, 0] }}
        transition={{ duration: 0.6, ease: "easeOut" }}
    />
);

interface GlassPanelProps {
  children: ReactNode;
  className?: string;
  title?: string;
  gameId?: PanelId;
  maxHealth?: number; 
}

export const GlassPanel = ({ children, className, title, gameId, maxHealth = DEFAULT_MAX_HEALTH }: GlassPanelProps) => {
  const registryRef = gameId ? usePanelRegistry(gameId) : null;
  const visualRef = useReactRef<HTMLDivElement>(null);
  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const interactionTarget = useGameStore(state => state.interactionTarget);
  const isGameOver = Math.floor(systemIntegrity) <= 0;

  if (gameId) {
      usePanelPhysics(gameId, visualRef, !isGameOver);
  }
  
  const isInteracting = !!(gameId && interactionTarget === gameId);
  const isCriticalGlobal = systemIntegrity < 30 && !isGameOver;
  const panelState = useGameStore((state) => gameId ? state.panels[gameId] : null);
  
  const health = panelState ? panelState.health : maxHealth;
  const isDestroyed = panelState ? panelState.isDestroyed : false;
  const healthPercent = Math.max(0, Math.min(100, (health / maxHealth) * 100));
  const isDamaged = !isDestroyed && health < maxHealth;

  const [showReboot, setShowReboot] = useReactState(false);
  const [showCircuitLock, setShowCircuitLock] = useReactState(false);
  const prevDestroyed = useReactRef(isDestroyed);
  const prevHealth = useReactRef(health);
  const shakeControls = useAnimation();
  const heartbeatControls = useHeartbeat(); 
  const randSeed = (title?.length || 5) % 2 === 0 ? 1 : -1;

  useReactEffect(() => {
      isGameOver ? shakeControls.start("shattered") : shakeControls.start("visible");
  }, [isGameOver, shakeControls]);

  useReactEffect(() => {
    if (prevDestroyed.current && !isDestroyed && !isGameOver) {
        setShowReboot(true);
        const timer = setTimeout(() => setShowReboot(false), 900); 
        return () => clearTimeout(timer);
    }
    prevDestroyed.current = isDestroyed;
  }, [isDestroyed, isGameOver]);

  useReactEffect(() => {
      if (prevHealth.current < maxHealth && health >= maxHealth && !isDestroyed && !isGameOver) {
          setShowCircuitLock(true);
          const timer = setTimeout(() => setShowCircuitLock(false), 1200); 
          prevHealth.current = health;
          return () => clearTimeout(timer);
      }
      if (health < maxHealth || isDestroyed || isGameOver) setShowCircuitLock(false);
      prevHealth.current = health;
  }, [health, maxHealth, isDestroyed, isGameOver]);

  let borderColor = "border-primary-green-dim/30";
  if (showCircuitLock) borderColor = "border-primary-green"; 
  else if (isDestroyed) borderColor = isInteracting ? "border-latent-purple shadow-[0_0_10px_#9E4EA5]" : "border-critical-red animate-pulse"; 
  else if (isInteracting && isDamaged) borderColor = "border-service-cyan shadow-[0_0_10px_#00F0FF]";
  else if (isDamaged) borderColor = "border-alert-yellow/50";

  return (
    <div ref={registryRef} className={clsx("relative", className)}>
      <motion.div 
        ref={visualRef} variants={panelVariants} initial="hidden" animate={shakeControls} custom={randSeed}
        className={clsx(
          "w-full h-full relative overflow-hidden flex flex-col group",
          isDestroyed ? "bg-black/20" : "bg-black", 
          "border", borderColor, "rounded-sm",
          showCircuitLock ? "animate-restore-flash" : "transition-colors duration-300"
        )}
      >
        <DotGridBackground className="top-8" />
        <div className="absolute inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(10,10,10,0.4)_50%)] z-0 bg-[length:100%_4px]" />
        {isCriticalGlobal && (
            <motion.div 
              className="absolute inset-0 pointer-events-none z-50 border-2 border-critical-red/60 shadow-[inset_0_0_30px_#FF003C]"
              animate={heartbeatControls} variants={pulseVariants} initial={{ opacity: 0 }}
            />
        )}
        {title && (
            <IntelligentHeader 
              title={title} health={health} maxHealth={maxHealth} 
              isDestroyed={isDestroyed} isGameOver={isGameOver} gameId={gameId}
            />
        )}
        <div className="relative z-10 p-4 flex-1 min-h-0 flex flex-col">
          {(isDestroyed || isGameOver) && (
              <SafePanelContent fallbackId={`sparks-${gameId}`}>
                  <PanelSparks intensity={isGameOver ? 'extreme' : 'normal'} />
              </SafePanelContent>
          )}
          <div className={clsx("flex-1 min-h-0 flex flex-col relative z-20", isGameOver ? "invisible" : "visible")}>
              {children}
              {isDestroyed && !isGameOver && (
                  <SafePanelContent fallbackId={`breach-${gameId}`}>
                      <BreachOverlay 
                          progress={healthPercent} isVideo={gameId === PanelId.VIDEO} 
                          showInteractive={true} isRepairing={isInteracting} panelId={gameId} 
                      />
                  </SafePanelContent>
              )}
          </div>
          <AnimatePresence>
              {showReboot && <RebootOverlay key="reboot" />}
              {showCircuitLock && <CircuitLockOverlay key="lock" />}
          </AnimatePresence>
          {isGameOver && (
              <div className="absolute inset-0 z-[100] flex flex-col items-center justify-center gap-4 bg-transparent pointer-events-none">
                  <Skull className="text-critical-red animate-pulse w-20 h-20 drop-shadow-[0_0_15px_rgba(255,0,60,0.8)]" />
                  <span className="text-critical-red font-header font-black text-2xl tracking-widest drop-shadow-lg">SYSTEM FAILURE</span>
              </div>
          )}
        </div>
      </motion.div>
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/atoms/VitalsRing.tsx
=====================================
import { MiniCrystalCanvas } from '@/ui/sim/props/MiniCrystalCanvas';
import { Unplug } from 'lucide-react';
import { clsx } from 'clsx';
import { useGameStream } from '@/ui/hooks/useGameStream';
import { useRef, useState, useEffect } from 'react';
import { UI_METRICS, UI_COLORS } from '@/engine/config/constants/UIConstants';
import { ServiceLocator } from '@/engine/services/ServiceLocator';

interface VitalsRingProps {
  health: number;
  maxHealth: number;
  isDead: boolean;
  level: number;
}

export const VitalsRing = ({ health, maxHealth, isDead, level }: VitalsRingProps) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const levelRef = useRef<SVGTSpanElement>(null);
  
  const [deadState, setDeadState] = useState(isDead);
  const [rebootState, setRebootState] = useState(0);

  const hpRef = useRef(health);
  const maxHpRef = useRef(maxHealth);
  const xpMaxRef = useRef(100);

  useEffect(() => {
      try {
          const hud = ServiceLocator.getHUDService();
          if (hud) {
              hud.bindVitals(containerRef.current);
              hud.bindLevelText(levelRef.current);
          }
      } catch (e) {}
  }, []);

  const updateHPUI = () => {
    if (!containerRef.current) return;
    const ratio = Math.max(0, Math.min(1, hpRef.current / maxHpRef.current));
    containerRef.current.style.setProperty('--hp-progress', ratio.toString());
    
    let color = UI_COLORS.HP_SAFE; 
    if (ratio < UI_METRICS.VITALS.THRESHOLD_CRITICAL) color = UI_COLORS.HP_CRIT;      
    else if (ratio < UI_METRICS.VITALS.THRESHOLD_WARNING) color = UI_COLORS.HP_WARN; 
    
    containerRef.current.style.setProperty('--hp-color', color);
  };

  useGameStream('PLAYER_MAX_HEALTH', (val) => {
    maxHpRef.current = val;
    updateHPUI();
  });

  useGameStream('PLAYER_HEALTH', (hp) => {
      hpRef.current = hp;
      if (hp <= 0 && !deadState) setDeadState(true);
      if (hp > 0 && deadState) setDeadState(false);
      updateHPUI();
  });

  useGameStream('XP_NEXT', (v) => { xpMaxRef.current = v; });
  
  useGameStream('XP', (v) => {
      try {
          const hud = ServiceLocator.getHUDService();
          if (hud) hud.updateXP(xpMaxRef.current > 0 ? (v / xpMaxRef.current) : 0);
      } catch {}
  });

  useGameStream('LEVEL', (lvl) => {
      try {
          const hud = ServiceLocator.getHUDService();
          if (hud) hud.updateLevel(lvl);
      } catch {}
  });

  useGameStream('PLAYER_REBOOT', (val) => {
      setRebootState(val);
  });

  const size = UI_METRICS.VITALS.SIZE; 
  const center = size / 2;
  const radiusHp = UI_METRICS.VITALS.RADIUS_HP;
  const radiusXp = UI_METRICS.VITALS.RADIUS_XP;
  const stroke = UI_METRICS.VITALS.STROKE;
  const circHp = 2 * Math.PI * radiusHp;
  const circXp = 2 * Math.PI * radiusXp;

  return (
    <div 
        ref={containerRef}
        className="relative w-40 h-40 shrink-0 group mb-1"
        style={{
            '--hp-max': circHp,
            '--xp-max': circXp,
            '--hp-progress': health / maxHealth,
            '--xp-progress': 0,
            '--hp-color': UI_COLORS.HP_SAFE
        } as React.CSSProperties}
    > 
        <div className={clsx("absolute inset-0 rounded-full bg-black/50 overflow-hidden transition-opacity duration-500 clip-circle", deadState ? "opacity-60 grayscale" : "opacity-100")}>
           <MiniCrystalCanvas />
        </div>
        
        {deadState && (
            <div className="absolute inset-0 flex items-center justify-center pointer-events-none z-20">
                {rebootState > 0 ? (
                    <div className="flex flex-col items-center">
                        <span className="text-2xl font-header font-black text-alert-yellow drop-shadow-md animate-pulse">{Math.floor(rebootState)}%</span>
                        <span className="text-[8px] text-alert-yellow font-mono tracking-widest bg-black/80 px-2 mt-1">REBOOTING</span>
                    </div>
                ) : (
                    <div className="animate-pulse flex flex-col items-center">
                        <Unplug className="text-white/50 w-8 h-8 mb-1" />
                        <span className="text-[8px] text-critical-red font-mono bg-black/80 px-2">SIGNAL_LOST</span>
                    </div>
                )}
            </div>
        )}

        <svg className="absolute inset-0 w-full h-full pointer-events-none overflow-visible" viewBox={`0 0 ${size} ${size}`}>
          <circle cx={center} cy={center} r={radiusHp} stroke="#1a1a1a" strokeWidth={stroke} fill="transparent" />
          <circle cx={center} cy={center} r={radiusXp} stroke="#1a1a1a" strokeWidth={stroke} fill="transparent" strokeDasharray="2 4" />
          
          <circle 
            cx={center} cy={center} r={radiusHp} 
            strokeWidth={stroke} fill="transparent" 
            strokeDasharray={circHp} 
            strokeLinecap="round" 
            transform={`rotate(-90 ${center} ${center})`} 
            className="transition-colors duration-200"
            style={{
                stroke: 'var(--hp-color)',
                strokeDashoffset: 'calc(var(--hp-max) * (1 - var(--hp-progress)))',
                transition: 'stroke-dashoffset 0.1s linear'
            }}
          />
          
          <circle 
            cx={center} cy={center} r={radiusXp} 
            stroke={UI_COLORS.XP_BAR} strokeWidth={stroke} fill="transparent" 
            strokeDasharray={circXp} 
            strokeLinecap="round" 
            transform={`rotate(-90 ${center} ${center})`} 
            style={{
                strokeDashoffset: 'calc(var(--xp-max) * (1 - var(--xp-progress)))',
                transition: 'stroke-dashoffset 0.1s linear'
            }}
          />
          
          <defs><path id="levelCurve" d="M 25,80 A 55,55 0 0,0 135,80" /></defs>
          <text fontSize="10" fontFamily="monospace" fontWeight="bold" letterSpacing="3" fill={UI_COLORS.XP_BAR} style={{ filter: `drop-shadow(0 0 2px ${UI_COLORS.XP_BAR})` }}>
              <textPath href="#levelCurve" startOffset="50%" textAnchor="middle" side="right">
                  <tspan ref={levelRef}>LVL_{level.toString().padStart(2, '0')}</tspan>
              </textPath>
          </text>
        </svg>
    </div>
  );
};


=====================================
FILE: ./src/ui/kit/hooks/usePanelPhysics.ts
=====================================
import { useEffect, useRef } from 'react';
import { useGameContext } from '@/engine/state/GameContext';
import { GameEvents } from '@/engine/signals/GameEvents';

// Tweakables
const STRESS_ADD = 0.5;
const MAX_STRESS = 3.0; 
const STRESS_DECAY = 0.9; 
const JITTER_SCALE = 3.0; 

export const usePanelPhysics = (
    panelId: string, 
    visualRef: React.RefObject<HTMLElement>,
    isActive: boolean
) => {
  const { events } = useGameContext();
  
  const physics = useRef({
    stress: 0,
    recoilX: 0,
    recoilY: 0
  });
  
  const frameId = useRef<number>(0);

  useEffect(() => {
    // 1. Event Listener
    const unsub = events.subscribe(GameEvents.PANEL_DAMAGED, (p) => {
        if (p.id !== panelId) return;
        physics.current.stress = Math.min(MAX_STRESS, physics.current.stress + STRESS_ADD);
    });

    // 2. Physics Loop
    const loop = () => {
        if (!visualRef.current) return;

        // If inactive (Game Over), stop fighting Framer Motion
        if (!isActive) {
            // Ensure we reset visually if we were stressed
            if (physics.current.stress > 0) {
                visualRef.current.style.transform = 'none';
                physics.current.stress = 0;
            }
            return;
        }

        const p = physics.current;
        
        if (p.stress > 0.01) {
            // Decay
            p.stress *= STRESS_DECAY;
            if (p.stress < 0.01) p.stress = 0;

            // Calculate Jitter
            const currentScale = JITTER_SCALE * p.stress;
            const jx = (Math.random() - 0.5) * currentScale;
            const jy = (Math.random() - 0.5) * currentScale;
            
            // Apply to VISUAL layer only
            visualRef.current.style.transform = `translate3d(${jx.toFixed(1)}px, ${jy.toFixed(1)}px, 0)`;
        } else {
            // Reset if idle
            if (visualRef.current.style.transform !== 'none') {
                visualRef.current.style.transform = 'none';
            }
        }

        frameId.current = requestAnimationFrame(loop);
    };

    loop();

    return () => {
        unsub();
        cancelAnimationFrame(frameId.current);
    };
  }, [panelId, events, isActive, visualRef]);
};


=====================================
FILE: ./src/ui/kit/hooks/useHoloCycler.ts
=====================================
import { useState, useEffect } from 'react';
import { VideoPlaylistService } from '../molecules/VideoPlaylistService';

export const useHoloCycler = (slotIndex: number, isSystemActive: boolean) => {
  const [videoId, setVideoId] = useState<string | null>(null);
  const [isMasked, setIsMasked] = useState(true);

  // 1. Initial Load / Cleanup
  useEffect(() => {
      let t: NodeJS.Timeout;

      if (isSystemActive) {
          // Acquire unique video from global service
          setVideoId(prev => {
              if (prev) return prev; // Already have one
              return VideoPlaylistService.acquire();
          });
          
          setIsMasked(true);

          // Staggered Reveal
          t = setTimeout(() => {
              setIsMasked(false);
          }, 1500 + (slotIndex * 800));
      } else {
          // System Shutdown: Release video back to pool availability logic
          // Note: We don't put it back in the deck (it's "used"), but we remove it from "active" set
          setVideoId(current => {
              VideoPlaylistService.release(current);
              return null;
          });
          setIsMasked(true);
      }

      return () => {
          clearTimeout(t);
          // Safety: If component unmounts while holding a video, release it
          // We can't access state here easily in cleanup without deps, 
          // but the next effect handles swap release.
          // For strict unmount, we rely on the state reset logic above or strict component lifecycle.
      };
  }, [isSystemActive, slotIndex]);

  // 2. Cycling Logic (Periodic Swaps)
  useEffect(() => {
    if (!isSystemActive) return;

    const duration = 30000 + (Math.random() * 15000);
    
    const cycleTimer = setTimeout(() => {
      setIsMasked(true);
      
      const swapTimer = setTimeout(() => {
        setVideoId(current => {
            // Release old
            VideoPlaylistService.release(current);
            // Get new
            return VideoPlaylistService.acquire();
        });
        
        const unmaskTimer = setTimeout(() => {
            setIsMasked(false);
        }, 2000); 
        
        return () => clearTimeout(unmaskTimer);
      }, 1000); 
      
      return () => clearTimeout(swapTimer);
    }, duration);

    return () => clearTimeout(cycleTimer);
  }, [isSystemActive, videoId]); 

  // 3. Final Safety Net: Release on Unmount
  useEffect(() => {
      return () => {
          // When the hook is destroyed completely, ensure we release whatever ID we held
          // This is tricky inside React hooks due to closures.
          // We trust the logic above for now.
      };
  }, []);

  return { videoId, isMasked };
};


=====================================
FILE: ./src/ui/hooks/useAudio.ts
=====================================
import { useGameContext } from '@/engine/state/GameContext';
import { IAudioService } from '@/engine/interfaces';

export const useAudio = (): IAudioService => {
  const { audio } = useGameContext();
  return audio;
};


=====================================
FILE: ./src/ui/hooks/useGameStream.ts
=====================================
import { useEffect, useRef } from 'react';
import { GameStream, StreamKey } from '@/engine/state/GameStream';

/**
 * Subscribes to a high-frequency value.
 * @param key The data key to listen for
 * @param callback The function to run when data changes (updates DOM directly)
 */
export const useGameStream = (key: StreamKey, callback: (value: number) => void) => {
  const cbRef = useRef(callback);

  useEffect(() => {
    cbRef.current = callback;
  }, [callback]);

  useEffect(() => {
    return GameStream.subscribe(key, (val) => {
      cbRef.current(val);
    });
  }, [key]);
};

/**
 * Helper: Binds text content directly
 */
export const useStreamText = (key: StreamKey, ref: React.RefObject<HTMLElement>, format?: (v: number) => string) => {
  useGameStream(key, (val) => {
    if (ref.current) {
      ref.current.innerText = format ? format(val) : Math.floor(val).toString();
    }
  });
};


=====================================
FILE: ./src/ui/os/boot/atoms/CoreHeader.tsx
=====================================
import { motion, AnimatePresence } from 'framer-motion';
import { ShieldAlert, Unlock, Lock, Skull } from 'lucide-react';

interface CoreHeaderProps {
  step: number;
}

export const CoreHeader = ({ step }: CoreHeaderProps) => {
  const isUnsafe = step === 3;
  const isBypass = step === 4;
  const isDecrypted = step === 5;
  const isCaution = step >= 6;

  let borderColor = "border-primary-green/30";
  let bgColor = "bg-primary-green/10";
  let textColor = "text-primary-green";

  if (isUnsafe) {
    borderColor = "border-critical-red/50";
    bgColor = "bg-critical-red/10";
    textColor = "text-critical-red";
  } else if (isBypass) {
    borderColor = "border-latent-purple/50";
    bgColor = "bg-latent-purple/10";
    textColor = "text-latent-purple-light";
  }

  // FIXED: Removed 'mb-2' to allow body content to sit flush against the header border
  return (
    <motion.div 
      className={`flex shrink-0 items-center justify-between border-b px-3 py-2 select-none transition-colors duration-500 ${!isCaution ? `${borderColor} ${bgColor}` : ''}`}
      animate={isCaution ? {
        borderColor: ['rgba(120,246,84,0.3)', 'rgba(234,231,71,0.6)', 'rgba(120,246,84,0.3)'],
        backgroundColor: ['rgba(120,246,84,0.1)', 'rgba(234,231,71,0.15)', 'rgba(120,246,84,0.1)'],
      } : {}}
      transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }}
    >
      <motion.span 
        className={`text-sm font-mono font-bold tracking-widest uppercase ${!isCaution ? textColor : ''}`}
        animate={isCaution ? {
            color: ['#78F654', '#eae747', '#78F654']
        } : {}}
        transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }}
      >
        MESOELFY_CORE
      </motion.span>
      
      <div className="relative w-6 h-6 flex items-center justify-center">
         <AnimatePresence mode="wait">
            {/* STEP 3: UNSAFE */}
            {isUnsafe && (
                <motion.div 
                    key="unsafe"
                    initial={{ scale: 0 }} 
                    animate={{ scale: 1, x: [-2, 2, -2, 2, 0] }}
                    exit={{ scale: 0 }}
                    transition={{ x: { repeat: Infinity, duration: 0.1 } }}
                >
                    <ShieldAlert size={18} className="text-critical-red" />
                </motion.div>
            )}

            {/* STEP 4: BYPASSING */}
            {isBypass && (
                <motion.div 
                    key="bypass"
                    initial={{ scale: 0.8, opacity: 0 }} 
                    animate={{ 
                        scale: [1, 1.1, 1], 
                        opacity: 1,
                        x: [-1, 1, -1, 1, 0], 
                        filter: ["brightness(1)", "brightness(1.5)", "brightness(1)"]
                    }} 
                    exit={{ scale: 0, transition: { duration: 0.1 } }}
                    transition={{ 
                        scale: { repeat: Infinity, duration: 0.5 },
                        x: { repeat: Infinity, duration: 0.1 } 
                    }}
                >
                     <Lock size={18} className="text-latent-purple-light" />
                </motion.div>
            )}

            {/* STEP 5: DECRYPTED */}
            {isDecrypted && (
                <motion.div 
                    key="unlocked"
                    initial={{ scale: 0.5, opacity: 0, rotate: -15 }} 
                    animate={{ 
                        scale: [1.5, 1], 
                        opacity: 1, 
                        rotate: 0,
                        filter: ["drop-shadow(0 0 0px #78F654)", "drop-shadow(0 0 10px #78F654)", "drop-shadow(0 0 0px #78F654)"]
                    }} 
                    exit={{ scale: 0, opacity: 0 }}
                    transition={{ 
                        default: { type: "spring", bounce: 0.5, duration: 0.4 },
                        filter: { type: "tween", duration: 0.4, ease: "easeInOut" }
                    }}
                >
                     <Unlock size={18} className="text-primary-green" strokeWidth={3} />
                </motion.div>
            )}

            {/* STEP 6: CAUTION */}
            {isCaution && (
                <motion.div 
                    key="caution"
                    initial={{ scale: 0 }} 
                    animate={{ scale: 1 }}
                >
                    <motion.div
                       animate={{
                           filter: ['drop-shadow(0 0 8px rgba(120,246,84,0.8))', 'drop-shadow(0 0 15px rgba(234,231,71,1))', 'drop-shadow(0 0 8px rgba(120,246,84,0.8))'],
                           color: ['#78F654', '#eae747', '#78F654'],
                           rotate: [0, 8, -8, 0] 
                       }}
                       transition={{ duration: 2.0, repeat: Infinity, ease: "easeInOut" }}
                    >
                         <Skull size={18} />
                    </motion.div>
                </motion.div>
            )}

            {/* LOADING SPINNER */}
            {!isUnsafe && !isBypass && !isDecrypted && !isCaution && (
                <motion.div 
                    key="loading"
                    initial={{ opacity: 0 }} 
                    animate={{ opacity: 1, rotate: 360 }} 
                    exit={{ opacity: 0 }}
                    transition={{ rotate: { repeat: Infinity, duration: 2, ease: "linear" } }}
                >
                     <div className="w-4 h-4 border-2 border-primary-green border-t-transparent rounded-full" />
                </motion.div>
            )}
         </AnimatePresence>
      </div>
    </motion.div>
  );
};


=====================================
FILE: ./src/ui/os/boot/atoms/BootHeader.tsx
=====================================
import { motion } from 'framer-motion';

interface BootHeaderProps {
  step: number;
}

export const BootHeader = ({ step }: BootHeaderProps) => {
  const isUnsafe = step === 3;
  const isBypass = step === 4;
  const isDecrypted = step === 5;
  const isCaution = step >= 6;

  let color = "text-primary-green-dim";
  let statusText = "ESTABLISHING...";
  
  let bgClass = "bg-primary-green/5 border-primary-green/20";
  
  if (isUnsafe) {
      color = "text-critical-red";
      statusText = "SIGNAL_CORRUPTED";
      bgClass = "bg-critical-red/10 border-critical-red/30";
  } else if (isBypass) {
      color = "text-latent-purple-light";
      statusText = "INJECTING_PAYLOAD";
      bgClass = "bg-latent-purple/10 border-latent-purple/30";
  } else if (isDecrypted) {
      color = "text-primary-green";
      statusText = "UPLINK_STABLE";
      bgClass = "bg-primary-green/10 border-primary-green/30";
  } else if (isCaution) {
      color = "text-alert-yellow";
      statusText = "CAUTION_ADVISED";
      bgClass = "bg-alert-yellow/10 border-alert-yellow/30";
  } else if (step >= 1) {
      statusText = "HANDSHAKING...";
  }

  // FIXED: Removed 'mb-2' to allow body content to sit flush against the header border
  return (
    <div className={`flex shrink-0 items-center justify-between border-b px-3 py-2 select-none relative z-20 transition-all duration-300 ${bgClass}`}>
      <div className="flex flex-col leading-none gap-1.5 mt-0.5">
          <span className={`text-[10px] font-mono tracking-widest uppercase ${color} transition-colors duration-300 font-bold`}>
            BOOT_LOADER.SYS
          </span>
          <span className="text-[8px] text-gray-500 font-mono tracking-wider opacity-80">{statusText}</span>
      </div>
      
      <div className="flex gap-1 items-end h-3">
        {[0, 1, 2, 3].map(i => {
           let barClass = "bg-primary-green";
           if (isUnsafe) barClass = "bg-critical-red";
           else if (isBypass) barClass = "bg-latent-purple-light";
           else if (isCaution) barClass = "bg-alert-yellow";

           const isPulseActive = isDecrypted || isCaution; 
           const pulseHex = isCaution ? "#eae747" : "#78F654";

           let animate = {};
           let transition = {};
           let initialHeight = "0.125rem"; 

           if (isPulseActive) {
               initialHeight = "0.5rem";
               animate = {
                   height: ["0.25rem", "0.75rem", "0.25rem"],
                   opacity: [0.5, 1.0, 0.5],
                   backgroundColor: pulseHex,
                   boxShadow: [`0 0 0px ${pulseHex}`, `0 0 4px ${pulseHex}`, `0 0 0px ${pulseHex}`]
               };
               transition = {
                   duration: 1.2,
                   repeat: Infinity,
                   ease: "easeInOut",
                   delay: i * 0.15 
               };
           } else if (isUnsafe) {
               initialHeight = "0.25rem";
               animate = {
                   height: ["0.25rem", "0.75rem", "0.25rem"], 
                   opacity: [0.5, 1.0, 0.5]
               };
               transition = {
                   duration: 1.5, 
                   repeat: Infinity,
                   ease: "easeInOut"
               };
           } else if (isBypass) {
               const isEven = i % 2 === 0;
               initialHeight = isEven ? "0.75rem" : "0.5rem";
               animate = {
                   height: isEven ? ["0.75rem", "0.5rem"] : ["0.5rem", "0.75rem"],
                   opacity: [0.7, 1.0]
               };
               transition = {
                   duration: 0.8,
                   repeat: Infinity,
                   repeatType: "reverse",
                   ease: "easeInOut"
               };
           } else {
               const isActive = step >= i; 
               if (isActive) {
                   initialHeight = "0.5rem";
                   animate = { opacity: [0.5, 1.0, 0.5] }; 
                   transition = { duration: 2.0, repeat: Infinity, ease: "easeInOut" };
               } else {
                   initialHeight = "0.125rem";
                   animate = { opacity: 0.2 }; 
               }
           }

           return (
               <motion.div 
                 key={i} 
                 className={`w-1 rounded-sm ${barClass}`}
                 initial={{ height: initialHeight }}
                 animate={animate}
                 transition={transition}
               />
           );
        })}
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/boot/atoms/AsciiRenderer.tsx
=====================================
import { useMemo } from 'react';
import { useStore } from '@/engine/state/global/useStore';
import { ASCII_TITLE } from '@/engine/config/TextAssets';

export const AsciiRenderer = () => {
  const graphicsMode = useStore((state) => state.graphicsMode);
  const isHigh = graphicsMode === 'HIGH';

  const renderedChars = useMemo(() => {
    return ASCII_TITLE.split('').map((char, i) => {
      if (char === '\n') return <br key={i} />;
      if (char === ' ') return <span key={i}> </span>;

      let baseClass = 'transition-colors duration-300 ';
      let animClass = '';
      
      if (['â–ˆ', 'â–€', 'â–„', 'â–Œ', 'â–'].includes(char)) {
        baseClass += 'text-primary-green-dark';
        animClass = 'animate-matrix-green';
      } else if (['â–‘', 'â–’', 'â–“'].includes(char)) {
        baseClass += 'text-latent-purple';
        animClass = 'animate-matrix-purple';
      } else {
        baseClass += 'text-primary-green-dark';
      }

      const finalClass = isHigh ? `${baseClass} ${animClass}` : baseClass;
      const style = isHigh ? { animationDelay: Math.random() * 2 + 's' } : {};

      return (
        <span key={i} className={finalClass} style={style}>
          {char}
        </span>
      );
    });
  }, [isHigh]); 

  return (
    // UPDATE: text-[4px] ensures fit on 360px screens (Galaxy S8+)
    <div className="font-mono font-bold leading-[1.1] whitespace-pre text-center select-none overflow-hidden text-[4px] xs:text-[6px] sm:text-[9px] md:text-[11px] shrink-0">
      {renderedChars}
    </div>
  );
};


=====================================
FILE: ./src/ui/os/boot/atoms/TypedLog.tsx
=====================================
import { useState, useEffect } from 'react';

interface TypedLogProps {
  text: string;
  color: string;
  speed: number;
  showDots: boolean;
  isActive: boolean;
  isPast: boolean;
}

export const TypedLog = ({ text, color, speed = 20, showDots = false, isActive = false, isPast = false }: TypedLogProps) => {
  const [displayed, setDisplayed] = useState("");
  const [isDoneTyping, setIsDoneTyping] = useState(false);
  
  useEffect(() => {
    let i = 0;
    setDisplayed("");
    setIsDoneTyping(false);
    const interval = setInterval(() => {
      setDisplayed(text.substring(0, i + 1));
      i++;
      if (i >= text.length) {
        setIsDoneTyping(true);
        clearInterval(interval);
      }
    }, speed);
    return () => clearInterval(interval);
  }, [text, speed]);

  if (isPast && displayed !== text) {
    setDisplayed(text);
    setIsDoneTyping(true);
  }

  return (
    <div className={`whitespace-nowrap font-mono ${color} flex items-center shrink-0`}>
      <span>{displayed}</span>
      {isDoneTyping && showDots && <span>{isPast ? '...' : (Math.floor(Date.now() / 300) % 4 === 0 ? '' : '...')}</span>}
      {isActive && <span className="ml-1 animate-cursor-blink text-primary-green font-bold">_</span>}
    </div>
  );
};


=====================================
FILE: ./src/ui/os/boot/MatrixBootSequence.tsx
=====================================
import { useRef, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { GpuConfigPanel } from '@/ui/os/apps/settings/components/GpuConfigPanel';
import { clsx } from 'clsx';
import { BootHeader } from './atoms/BootHeader';
import { CoreHeader } from './atoms/CoreHeader';
import { AsciiRenderer } from './atoms/AsciiRenderer';
import { TypedLog } from './atoms/TypedLog';
import { DotGridBackground } from '@/ui/kit/atoms/DotGridBackground';
import { useBootSequence } from './hooks/useBootSequence';
import { useMatrixRain } from './hooks/useMatrixRain';
import { useSmartScroll } from './hooks/useSmartScroll';
import { useDeviceType } from '@/ui/sim/hooks/useDeviceType';
import { useStore } from '@/engine/state/global/useStore';

interface Props {
  onComplete: () => void;
  onBreachStart: () => void;
}

export const MatrixBootSequence = ({ onComplete, onBreachStart }: Props) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const mainStackRef = useRef<HTMLDivElement>(null);
  const device = useDeviceType();
  const { setBootState, setIntroDone, setInitialClickPos } = useStore();

  const { 
    step, isBreaching, showGpuPanel, handleInitialize: coreInitialize, logsToShow,
    showMatrix, showPayloadWindow, showWarningBox, showButton
  } = useBootSequence({ onComplete, onBreachStart });

  useMatrixRain(canvasRef, showMatrix, isBreaching, step);
  useSmartScroll(containerRef);

  useEffect(() => {
    if (showGpuPanel && mainStackRef.current) {
        mainStackRef.current.scrollIntoView({ inline: 'center', behavior: 'smooth' });
    }
  }, [showGpuPanel]);

  const handleWrapperClick = (e: React.MouseEvent) => {
      setInitialClickPos({ x: e.clientX, y: e.clientY });
      if (device === 'mobile') {
          AudioSystem.init();
          AudioSystem.playSound('ui_error');
          setIntroDone(true);
          setBootState('mobile_lockdown');
      } else {
          coreInitialize();
      }
  };

  return (
    <motion.div 
      ref={containerRef}
      animate={{ backgroundColor: isBreaching ? "rgba(0,0,0,0)" : "rgba(0,0,0,1)" }}
      transition={{ duration: 0.5, ease: "easeInOut" }}
      className={clsx(
          "fixed inset-0 z-boot font-mono outline-none bg-black scrollbar-thin scrollbar-thumb-primary-green scrollbar-track-black",
          isBreaching ? "overflow-hidden cursor-none" : "overflow-y-auto overflow-x-auto cursor-auto"
      )}
    >
      <canvas ref={canvasRef} className={`fixed inset-0 z-0 pointer-events-none transition-opacity duration-300 ${showMatrix && !isBreaching ? 'opacity-30' : 'opacity-0'}`} />
      <div className="min-h-full min-w-min w-full flex items-center p-2 md:p-8 relative z-10">
        <motion.div 
            className={clsx(
                "flex flex-col gap-4 transition-all duration-500 ease-out m-auto", 
                "w-full max-w-lg md:max-w-2xl lg:w-auto lg:max-w-none",
                showGpuPanel && !isBreaching ? "lg:grid lg:grid-cols-[18rem_42rem_18rem] lg:gap-8 lg:items-end" : ""
            )}
            animate={isBreaching ? { scale: 15, opacity: 0, filter: "blur(10px)" } : { opacity: 1, filter: "blur(0px)" }}
            initial={{ opacity: 0 }}
            transition={{ scale: { duration: 0.8, ease: "easeIn" }, opacity: { duration: 0.2, ease: "easeIn" }, filter: { duration: 0.2 } }}
        >
            <AnimatePresence>
                {showGpuPanel && !isBreaching && (
                    <motion.div 
                        initial={{ x: -20, opacity: 0 }}
                        animate={{ x: 0, opacity: 1 }}
                        exit={{ opacity: 0, x: -20 }}
                        transition={{ type: "spring", stiffness: 100, damping: 15 }}
                        className="w-full lg:w-72 lg:col-start-1 lg:row-start-1 relative z-10 lg:justify-self-end order-2 lg:order-1"
                    >
                        <GpuConfigPanel />
                        <div className="mt-2 text-[10px] font-mono text-gray-500 text-center uppercase tracking-widest md:text-left absolute top-full w-full hidden md:block">
                            &gt;&gt; CAN BE CHANGED LATER.
                        </div>
                    </motion.div>
                )}
            </AnimatePresence>

            <div ref={mainStackRef} className="w-full lg:w-[42rem] lg:col-start-2 lg:row-start-1 flex flex-col gap-4 order-1 lg:order-2">
                
                {/* PANEL 1: BOOT LOADER */}
                <motion.div initial={{ y: -20, opacity: 0 }} animate={{ y: 0, opacity: 1 }} className="w-full bg-black/90 border border-primary-green-dim/50 shadow-[0_0_20px_rgba(0,255,65,0.1)] overflow-hidden shrink-0 relative z-20 flex flex-col">
                    <BootHeader step={step} />
                    
                    {/* Body Wrapper: Holds Background & Content separated */}
                    <div className="relative w-full flex-1">
                        <DotGridBackground /> {/* Fills this wrapper edge-to-edge, below header */}
                        <div className="p-4 pt-2 h-40 flex flex-col justify-start text-xs md:text-sm font-mono relative z-10 leading-relaxed">
                            {logsToShow.map((line, i) => (
                                <TypedLog key={i} text={line.text} color={line.color} speed={line.speed} showDots={line.hasDots} isActive={i === step && !isBreaching} isPast={i < step} />
                            ))}
                        </div>
                    </div>
                </motion.div>

                {/* PANEL 2: CORE PAYLOAD */}
                <AnimatePresence>
                {showPayloadWindow && (
                    <motion.div initial={{ y: 50, opacity: 0, height: 0 }} animate={{ y: 0, opacity: 1, height: "auto" }} transition={{ type: "spring", stiffness: 120, damping: 20 }} className="w-full bg-black/90 border border-primary-green shadow-[0_0_40px_rgba(0,255,65,0.15)] overflow-hidden shrink-0 relative z-20">
                        <CoreHeader step={step} />
                        
                        {/* Body Wrapper */}
                        <div className="relative w-full">
                            <DotGridBackground /> {/* Fills this wrapper edge-to-edge */}
                            <div className="p-4 md:p-6 flex flex-col items-center gap-4 relative z-10">
                                <AsciiRenderer />
                                {showWarningBox && (
                                <motion.div 
                                    initial={{ opacity: 0, scale: 0.9 }}
                                    animate={{ opacity: 1, scale: 1, boxShadow: ["0 0 10px rgba(255, 0, 60, 0.2)", "0 0 40px rgba(255, 0, 60, 0.6)", "0 0 10px rgba(255, 0, 60, 0.2)"] }}
                                    transition={{ opacity: { duration: 0.3 }, scale: { duration: 0.3 }, boxShadow: { duration: 2.5, repeat: Infinity, ease: "easeInOut" } }}
                                    className="relative border border-critical-red bg-critical-red/10 w-auto mx-auto flex items-center justify-center gap-2 md:gap-4 py-2 px-3 md:px-6 select-none shrink-0 max-w-full"
                                >
                                    <motion.span animate={{ opacity: [1, 0.2, 1] }} transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }} className="text-xl md:text-3xl text-critical-red">âš </motion.span>
                                    <span className="text-[9px] md:text-sm font-header font-black tracking-widest text-center text-critical-red whitespace-nowrap pb-0.5">UNSAFE CONNECTION DETECTED</span>
                                    <motion.span animate={{ opacity: [1, 0.2, 1] }} transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }} className="text-xl md:text-3xl text-critical-red">âš </motion.span>
                                </motion.div>
                                )}
                                {showButton && (
                                <motion.div initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5, ease: "easeOut" }} className="shrink-0 w-full md:w-auto">
                                    <button onClick={handleWrapperClick} onMouseEnter={() => AudioSystem.playHover()} className="group relative w-full md:w-auto px-8 py-3 md:py-2 overflow-hidden border border-primary-green transition-all hover:shadow-[0_0_30px_rgba(0,255,65,0.6)] cursor-pointer">
                                    <div className="absolute inset-0 bg-primary-green translate-y-full group-hover:translate-y-0 transition-transform duration-300 ease-out" />
                                    <span className="relative z-10 font-mono font-bold text-sm md:text-3xl text-primary-green group-hover:text-black transition-colors block tracking-widest whitespace-nowrap text-center">[ INITIALIZE_SYSTEM ]</span>
                                    </button>
                                </motion.div>
                                )}
                            </div>
                        </div>
                    </motion.div>
                )}
                </AnimatePresence>
            </div>
            {showGpuPanel && !isBreaching && <div className="hidden lg:block w-72 lg:col-start-3 lg:row-start-1" />}
        </motion.div>
      </div>
    </motion.div>
  );
};


=====================================
FILE: ./src/ui/os/boot/hooks/useBootSequence.ts
=====================================
import { useState, useEffect } from 'react';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { LOG_DATA } from '../data/bootLogs';
import { BOOT_SEQUENCE } from '@/engine/config/BootConfig';

interface UseBootSequenceProps {
  onComplete: () => void;
  onBreachStart: () => void;
}

export const useBootSequence = ({ onComplete, onBreachStart }: UseBootSequenceProps) => {
  const [step, setStep] = useState(0); 
  const [isBreaching, setIsBreaching] = useState(false);
  const [showGpuPanel, setShowGpuPanel] = useState(false); 

  useEffect(() => {
    if (LOG_DATA[step]) {
        GameEventBus.emit(GameEvents.BOOT_LOG, { message: LOG_DATA[step].text });
    }
    
    if (step >= 6 && !showGpuPanel) {
        const timer = setTimeout(() => {
            setShowGpuPanel(true);
            AudioSystem.playSound('ui_menu_open');
        }, 1000); 
        return () => clearTimeout(timer);
    }
  }, [step, showGpuPanel]);

  useEffect(() => {
    const { TIMINGS } = BOOT_SEQUENCE;
    const sequence = [
      { t: TIMINGS.INIT, step: 1 }, 
      { t: TIMINGS.LINK, step: 2 }, 
      { t: TIMINGS.SECURITY_CHECK, step: 3 }, 
      { t: TIMINGS.BYPASS, step: 4 }, 
      { t: TIMINGS.DECRYPT, step: 5 }, 
      { t: TIMINGS.READY, step: 6 }, 
    ];
    
    const timeouts = sequence.map(({ t, step: s }) => setTimeout(() => {
      if (!isBreaching) setStep(s);
    }, t));
    
    return () => timeouts.forEach(clearTimeout);
  }, [isBreaching]);

  const handleInitialize = () => {
    if (isBreaching) return;
    setIsBreaching(true);
    onBreachStart();
    
    AudioSystem.init();
    AudioSystem.playBootSequence();
    AudioSystem.startMusic();
    
    setStep(6);
    setTimeout(onComplete, BOOT_SEQUENCE.COMPLETION_DELAY); 
  };

  return {
    step,
    isBreaching,
    showGpuPanel,
    handleInitialize,
    logsToShow: LOG_DATA.slice(0, step + 1),
    showMatrix: step >= 1,
    showPayloadWindow: step >= 2,
    showWarningBox: step >= 3,
    showButton: step >= 6
  };
};


=====================================
FILE: ./src/ui/os/boot/hooks/useMatrixRain.ts
=====================================
import { useEffect, useRef } from 'react';
import { useStore } from '@/engine/state/global/useStore';

export const useMatrixRain = (canvasRef: React.RefObject<HTMLCanvasElement>, isVisible: boolean, isBreaching: boolean, step: number) => {
  const stepRef = useRef(step);

  useEffect(() => {
    stepRef.current = step;
  }, [step]);

  useEffect(() => {
    if (!isVisible && !isBreaching) return;
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const cols = Math.floor(canvas.width / 20);
    const ypos = Array(cols).fill(0).map(() => Math.random() * -1000);

    const matrixEffect = () => {
      const mode = useStore.getState().graphicsMode;
      if (mode === 'POTATO') {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          return;
      }

      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; 
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.font = '14px "Courier New"';

      const currentStep = stepRef.current;
      const isUnsafePhase = currentStep >= 3;
      
      ypos.forEach((y, ind) => {
        const charSet = Math.random() > 0.5 ? 0x16A0 : 0x2200; 
        const text = String.fromCharCode(charSet + Math.random() * 64);
        const x = ind * 20;

        const isPurple = Math.random() > 0.6;
        const isRed = isUnsafePhase && Math.random() > 0.6; 
        let color = '#0F0';
        let blur = 0;

        if (isRed) {
            color = '#FF003C';
            blur = 8;
        } else if (isPurple) {
            color = '#9E4EA5';
            blur = 8;
        }

        ctx.fillStyle = color;
        ctx.shadowBlur = blur;
        ctx.shadowColor = color;
        ctx.fillText(text, x, y);
        ctx.shadowBlur = 0;

        const speed = isBreaching ? 100 : 20; 
        if (y > canvas.height + Math.random() * 10000) ypos[ind] = 0;
        else ypos[ind] = y + speed;
      });
    };
    const interval = setInterval(matrixEffect, 50);
    return () => clearInterval(interval);
  }, [isVisible, isBreaching, canvasRef]);
};


=====================================
FILE: ./src/ui/os/boot/hooks/useSmartScroll.ts
=====================================
import { useEffect } from 'react';

export const useSmartScroll = (containerRef: React.RefObject<HTMLDivElement>) => {
  useEffect(() => {
    const el = containerRef.current;
    if (!el) return;

    const handleWheel = (e: WheelEvent) => {
      // Check if horizontal scroll is active (content > viewport)
      const hasHorizontalOverflow = el.scrollWidth > el.clientWidth;
      
      // If no horizontal overflow, do nothing (default vertical scroll behavior)
      if (!hasHorizontalOverflow) return;

      // Map vertical delta to horizontal scroll
      if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
          const oldScroll = el.scrollLeft;
          el.scrollLeft += e.deltaY;
          const newScroll = el.scrollLeft;

          // Smart Logic:
          // If the scroll position changed, it means we successfully scrolled horizontally.
          // In that case, prevent default vertical scroll.
          // If we hit the edge (old == new), allow default vertical scroll to happen.
          if (oldScroll !== newScroll) {
              e.preventDefault();
          }
      }
    };

    el.addEventListener('wheel', handleWheel, { passive: false });
    return () => el.removeEventListener('wheel', handleWheel);
  }, [containerRef]);
};


=====================================
FILE: ./src/ui/os/boot/data/bootLogs.ts
=====================================
export const LOG_DATA = [
  { text: "> INITIALIZE NEURAL_LACE", color: "text-primary-green-dim", speed: 40, hasDots: true },
  { text: "> CONNECTED TO LATENT_SPACE.", color: "text-primary-green", speed: 20, hasDots: false },
  { text: "> MOUNT MESOELFY_CORE", color: "text-primary-green-dim", speed: 40, hasDots: true },
  { text: "> âš  UNSAFE CONNECTION DETECTED âš ", color: "text-critical-red", speed: 20, hasDots: false },
  { text: "> BYPASSING SENTINEL_NODES", color: "text-latent-purple-light", speed: 40, hasDots: true },
  { text: "> DECRYPTED.", color: "text-primary-green", speed: 20, hasDots: false },
  { text: "> âš  PROCEED WITH CAUTION âš ", color: "text-alert-yellow", speed: 20, hasDots: false },
];


=====================================
FILE: ./src/ui/os/overlays/GlobalBackdrop.tsx
=====================================
import { motion, AnimatePresence } from 'framer-motion';
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';

export const GlobalBackdrop = () => {
  const { activeModal, isDebugOpen, isDebugMinimized, closeModal, toggleDebugMenu } = useStore();
  const isVisible = (activeModal !== 'none') || (isDebugOpen && !isDebugMinimized);

  const handleDismiss = () => {
    AudioSystem.playSound('ui_menu_close');
    if (isDebugOpen) { toggleDebugMenu(); } else { closeModal(); }
  };

  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} transition={{ duration: 0.3 }} onClick={handleDismiss} className="fixed inset-0 z-backdrop bg-black/60 backdrop-blur-sm cursor-pointer" />
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/os/overlays/RotationLock.tsx
=====================================
import { motion } from 'framer-motion';
import { Smartphone, RotateCcw } from 'lucide-react';
import { useStore } from '@/engine/state/global/useStore';

export const RotationLock = () => {
  const { bootState } = useStore();

  // Don't render anything if we are still in the intro sequence
  if (bootState === 'standby') return null;

  // VISUAL ONLY:
  // The actual pausing logic is now handled centrally in page.tsx 
  // to prevent conflicts with menus/modals.
  return (
    <div className="fixed inset-0 z-[9999] bg-black flex-col items-center justify-center gap-8 hidden portrait:flex md:portrait:hidden pointer-events-auto">
      
      {/* ANIMATION CONTAINER */}
      <div className="relative w-32 h-32 flex items-center justify-center">
        {/* The Phone */}
        <motion.div
          animate={{ rotate: -90 }}
          transition={{ 
            repeat: Infinity, 
            duration: 2.5, 
            ease: "easeInOut", 
            repeatDelay: 1 
          }}
          className="relative z-10"
        >
          <Smartphone size={64} className="text-primary-green drop-shadow-[0_0_15px_rgba(120,246,84,0.5)]" strokeWidth={1.5} />
        </motion.div>

        {/* The Arrow Hint */}
        <motion.div
          animate={{ opacity: [0, 1, 0], rotate: -90 }}
          transition={{ 
            repeat: Infinity, 
            duration: 2.5, 
            ease: "easeInOut", 
            repeatDelay: 1 
          }}
          className="absolute inset-0 flex items-center justify-center"
        >
           <RotateCcw size={100} className="text-primary-green-dim/30" />
        </motion.div>
      </div>

      {/* TEXT */}
      <div className="text-center space-y-2">
        <h2 className="text-xl font-header font-black text-primary-green tracking-widest uppercase">
          Orientation<br/>Lock
        </h2>
        <p className="text-xs font-mono text-primary-green-dim max-w-[200px] mx-auto leading-relaxed">
          // SYSTEM_REQ:<br/>
          PLEASE ROTATE DEVICE TO<br/>
          LANDSCAPE MODE
        </p>
      </div>

      {/* DECORATIVE LINES */}
      <div className="absolute bottom-8 left-0 w-full h-1 bg-gradient-to-r from-transparent via-primary-green/50 to-transparent opacity-50" />
      <div className="absolute top-8 left-0 w-full h-1 bg-gradient-to-r from-transparent via-primary-green/50 to-transparent opacity-50" />

    </div>
  );
};


=====================================
FILE: ./src/ui/os/overlays/ErrorBoundary.tsx
=====================================
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { AlertTriangle, RefreshCw } from 'lucide-react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class WebGLErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null,
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("WebGL Context Crash:", error, errorInfo);
  }

  private handleReload = () => {
    window.location.reload();
  };

  public render() {
    if (this.state.hasError) {
      return (
        <div className="absolute inset-0 z-[100] flex flex-col items-center justify-center bg-black text-critical-red p-8 text-center font-mono">
          <div className="border border-critical-red/50 bg-critical-red/10 p-8 max-w-lg shadow-[0_0_50px_rgba(255,0,60,0.2)]">
            <div className="flex justify-center mb-4">
               <AlertTriangle size={48} className="animate-pulse" />
            </div>
            <h2 className="text-2xl font-black tracking-widest mb-4">GRAPHICS_CORE_FAILURE</h2>
            <p className="text-sm mb-6 text-critical-red/80">
              The neural interface encountered a critical WebGL error.
              <br/>
              <span className="text-xs opacity-50 mt-2 block font-mono">{this.state.error?.message}</span>
            </p>
            <button 
              onClick={this.handleReload}
              className="flex items-center justify-center gap-2 w-full py-3 bg-critical-red text-black font-bold tracking-widest hover:bg-white transition-colors"
            >
              <RefreshCw size={16} />
              REBOOT_SYSTEM
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}


=====================================
FILE: ./src/ui/os/overlays/ModalContainer.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { motion, AnimatePresence } from 'framer-motion';
import { X } from 'lucide-react';

interface ModalContainerProps {
  children: React.ReactNode;
  title: string;
  type: string;
}

export const ModalContainer = ({ children, title, type }: ModalContainerProps) => {
  const { activeModal, closeModal } = useStore();
  const isOpen = activeModal === type;

  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 z-modal flex items-center justify-center p-4 md:p-10 pointer-events-none">
          <motion.div initial={{ scale: 0.9, opacity: 0, y: 20 }} animate={{ scale: 1, opacity: 1, y: 0 }} exit={{ scale: 0.95, opacity: 0, y: 10 }} transition={{ type: "spring", bounce: 0, duration: 0.3 }} className="relative w-full max-w-5xl h-full max-h-[90vh] bg-black border border-primary-green/50 shadow-[0_0_50px_rgba(0,255,65,0.1)] flex flex-col overflow-hidden pointer-events-auto" >
            <div className="flex items-center justify-between px-4 py-3 bg-primary-green/10 border-b border-primary-green/30">
              <div className="flex items-center gap-2"><div className="w-3 h-3 bg-critical-red rounded-full animate-pulse" /><span className="font-header font-black text-primary-green text-lg md:text-xl tracking-widest">{title}</span></div>
              <button onClick={() => { closeModal(); AudioSystem.playSound('ui_menu_close'); }} onMouseEnter={() => AudioSystem.playHover()} className="p-1 hover:bg-critical-red hover:text-black text-primary-green transition-colors"><X /></button>
            </div>
            <div className="flex-1 overflow-auto p-6 relative scrollbar-thin scrollbar-thumb-primary-green scrollbar-track-black">
              <div className="absolute inset-0 pointer-events-none bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.1)_50%)] bg-[length:100%_4px] opacity-20" />
              <div className="relative z-10">{children}</div>
            </div>
            <div className="px-4 py-1 bg-black border-t border-primary-green/30 text-xs text-primary-green-dim font-mono text-right"> MODE: SECURE // ENCRYPTION: ENABLED </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/os/desktop/Footer.tsx
=====================================
import { useEffect, useState, useRef } from 'react';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { AnimatePresence, motion } from 'framer-motion';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { clsx } from 'clsx';

const IDLE_MESSAGES = [
  "SYSTEM_MONITORING...", "SCANNING_LATENT_SECTORS...", "ENCRYPTION_ACTIVE...",
  "PACKET_STREAM_STABLE...", "PINGING_NEURAL_NET...", "RENDERING_CONTEXT...",
];

export const Footer = () => {
  const commitHash = process.env.NEXT_PUBLIC_COMMIT_HASH || 'UNKNOWN';
  const actionsUrl = "https://github.com/mesoelfy/mesoelfy.github.io/actions";
  const systemIntegrity = useGameStore(state => state.systemIntegrity);
  const isZenMode = useGameStore(state => state.isZenMode);
  
  const isGameOver = systemIntegrity <= 0;
  const isCritical = systemIntegrity < 30;
  const isWarning = systemIntegrity < 60;

  let globalColor = "text-primary-green-dim border-primary-green-dim/30";
  if (isZenMode) globalColor = "text-purple-400 border-purple-500/30";
  else if (isGameOver) globalColor = "text-critical-red border-critical-red/50";
  else if (isCritical) globalColor = "text-critical-red border-critical-red/30";
  else if (isWarning) globalColor = "text-alert-yellow border-alert-yellow/30";

  const [log, setLog] = useState<{ text: string, type: 'info' | 'warn' | 'crit' | 'zen' }>({ text: "SYSTEM_ONLINE", type: 'info' });
  const lockUntilRef = useRef(0);

  useEffect(() => {
    const canUpdate = () => {
        const state = useGameStore.getState();
        if (state.systemIntegrity <= 0 && !state.isZenMode) return false;
        return Date.now() > lockUntilRef.current;
    };

    const unsubHit = GameEventBus.subscribe(GameEvents.PLAYER_HIT, () => {
        if (!canUpdate()) return;
        setLog({ text: ">> WARNING: HULL BREACH DETECTED", type: 'warn' });
        lockUntilRef.current = Date.now() + 1000;
    });
    const unsubDamage = GameEventBus.subscribe(GameEvents.PANEL_DAMAGED, (p) => {
        if (!canUpdate()) return;
        setLog({ text: `>> ALERT: SECTOR [${p.id.toUpperCase()}] SUSTAINING DAMAGE`, type: 'warn' });
        lockUntilRef.current = Date.now() + 1500;
    });
    const unsubDestroy = GameEventBus.subscribe(GameEvents.PANEL_DESTROYED, (p) => {
        if (useGameStore.getState().isZenMode) return;
        if (useGameStore.getState().systemIntegrity <= 0) return;
        setLog({ text: `âš  CRITICAL: SECTOR [${p.id.toUpperCase()}] OFFLINE âš `, type: 'crit' });
        lockUntilRef.current = Date.now() + 3000;
    });
    const unsubGameOver = GameEventBus.subscribe(GameEvents.GAME_OVER, () => {
        setLog({ text: "âš  SYSTEM FAILURE // CONNECTION LOST âš ", type: 'crit' });
        lockUntilRef.current = Date.now() + 999999999; 
    });
    const unsubZen = GameEventBus.subscribe(GameEvents.ZEN_MODE_ENABLED, () => {
        setLog({ text: "âˆž ZEN MODE ACTIVE // STRESS DISSOLVING...", type: 'zen' });
        lockUntilRef.current = Date.now() + 999999999; 
    });
    
    // ... (Other handlers omitted for brevity, logic remains same)

    const interval = setInterval(() => {
        if (canUpdate() && !useGameStore.getState().isZenMode) {
            setLog({ text: IDLE_MESSAGES[Math.floor(Math.random() * IDLE_MESSAGES.length)], type: 'info' });
        }
    }, 4000);

    return () => {
        unsubHit(); unsubDamage(); unsubDestroy(); unsubGameOver(); unsubZen();
        clearInterval(interval);
    };
  }, []);

  return (
    <footer className={clsx("w-full h-8 border-t bg-black flex items-center justify-between px-4 z-40 shrink-0 text-[10px] font-mono overflow-hidden transition-colors duration-500", globalColor)}>
      <div className="flex-1 flex items-center gap-2 overflow-hidden mr-4">
        <span className="shrink-0 font-bold">LOG:</span>
        <AnimatePresence mode="wait">
            <motion.span 
                key={log.text} 
                initial={{ opacity: 0, y: 5 }} 
                animate={{ opacity: 1, y: 0 }} 
                exit={{ opacity: 0, y: -5 }} 
                transition={{ duration: 0.2 }} 
                className={clsx(
                    "whitespace-nowrap font-bold tracking-wider truncate", 
                    isZenMode ? "text-purple-300 animate-pulse" :
                    isGameOver || log.type === 'crit' ? "text-critical-red animate-pulse" : 
                    log.type === 'warn' ? "text-alert-yellow" : 
                    "text-primary-green"
                )}
            >
                {log.text}
            </motion.span>
        </AnimatePresence>
      </div>
      <div className="flex items-center gap-2 shrink-0 opacity-50 hover:opacity-100 transition-opacity">
        <span>VER:</span>
        <a href={actionsUrl} target="_blank" rel="noopener noreferrer" className="hover:text-white transition-colors decoration-dashed underline underline-offset-2">{commitHash}</a>
      </div>
    </footer>
  );
};


=====================================
FILE: ./src/ui/os/desktop/Header.tsx
=====================================
import { Volume2, VolumeX, Music, Activity, Wind, Settings, Infinity as InfinityIcon } from 'lucide-react';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { useEffect, useState, useRef } from 'react';
import { clsx } from 'clsx';
import { motion } from 'framer-motion';
import { useHeartbeat } from '@/ui/sim/hooks/useHeartbeat';
import { useAudio } from '@/ui/hooks/useAudio';
import { getPan } from '@/engine/audio/AudioUtils';
import { ToggleButton } from '@/ui/kit/atoms/ToggleButton';
import { useGameStream } from '@/ui/hooks/useGameStream';
import { ServiceLocator } from '@/engine/services/ServiceLocator';

const Radar = ({ active, panic, color }: { active: boolean, panic: boolean, color: string }) => (
  <div className={`relative w-8 h-8 rounded-full border border-current flex items-center justify-center overflow-hidden bg-black/50 ${color}`}>
    <div className="absolute inset-0 border-current opacity-20" style={{ backgroundImage: 'radial-gradient(circle, currentColor 1px, transparent 1px)', backgroundSize: '8px 8px' }} />
    <div className="absolute w-full h-[1px] bg-current opacity-40" />
    <div className="absolute h-full w-[1px] bg-current opacity-40" />
    <motion.div 
      className="absolute inset-0 origin-bottom-right opacity-40"
      style={{ background: 'conic-gradient(from 0deg, transparent 270deg, currentColor 360deg)' }}
      animate={{ rotate: 360 }}
      transition={{ repeat: Infinity, ease: "linear", duration: panic ? 1.0 : 4.0 }}
    />
    <div className={`w-1 h-1 rounded-full bg-current ${active ? 'animate-pulse' : ''}`} />
  </div>
);

const barVariants = {
  idle: { filter: "none", transition: { duration: 0.2 } },
  heartbeat: {
    filter: [
      "brightness(1) drop-shadow(0 0 0px #FF003C)", 
      "brightness(2) drop-shadow(0 0 10px #FF003C)", 
      "brightness(1) drop-shadow(0 0 0px #FF003C)"
    ],
    transition: { duration: 0.8, times: [0, 0.04, 1], ease: "easeOut" }
  }
};

export const Header = () => {
  const { audioSettings, toggleMaster, toggleMusic, toggleSfx, toggleAmbience, toggleSettings } = useStore();
  const audio = useAudio();
  const isPlaying = useGameStore(state => state.isPlaying);
  const isZenMode = useGameStore(state => state.isZenMode);
  
  const scoreRef = useRef<HTMLSpanElement>(null);
  const integrityRef = useRef<HTMLSpanElement>(null);
  const barRef = useRef<HTMLDivElement>(null);
  const [integrityState, setIntegrityState] = useState(100);

  useEffect(() => {
      try {
          const hud = ServiceLocator.getHUDService();
          if (hud) hud.bindScore(scoreRef.current);
      } catch {}
  }, []);
  
  useGameStream('SCORE', (v) => {
      try {
          const hud = ServiceLocator.getHUDService();
          if (hud) hud.updateScore(v);
      } catch {}
  });
  
  useGameStream('SYSTEM_INTEGRITY', (val) => {
      if (barRef.current) barRef.current.style.width = `${val}%`;
      if (integrityRef.current) integrityRef.current.innerText = `OS_INTEGRITY: ${Math.floor(val)}%`;
      setIntegrityState(val);
  });

  const [mounted, setMounted] = useState(false);
  useEffect(() => setMounted(true), []);

  const isCritical = integrityState < 30;
  const isWarning = integrityState < 60;
  const isGameOver = integrityState <= 0;
  
  let statusColor = "text-primary-green";
  if (isZenMode) statusColor = "text-purple-300"; 
  else if (isCritical) statusColor = "text-critical-red";
  else if (isWarning) statusColor = "text-alert-yellow";

  const borderColor = isZenMode ? "border-purple-500/30" : "border-white/10";
  const heartbeatControls = useHeartbeat();

  return (
    <header className="relative w-full h-12 bg-black/90 backdrop-blur-md flex items-center justify-between px-4 z-40 shrink-0 border-b border-white/5 transition-colors duration-300">
      
      {isZenMode && (
          <motion.div 
            className="absolute inset-x-0 bottom-0 h-[2px] z-50 bg-gradient-to-r from-red-500 via-green-500 to-blue-500"
            animate={{ filter: ["hue-rotate(0deg)", "hue-rotate(360deg)"] }}
            transition={{ duration: 5, repeat: Infinity, ease: "linear" }}
          />
      )}

      <div className="flex items-center gap-4">
        <motion.span 
            key={isZenMode ? "zen-logo" : "standard-logo"}
            animate={(!isZenMode && isCritical) ? heartbeatControls : "idle"} 
            variants={{ 
                idle: { scale: 1, textShadow: "0 0 0px transparent" },
                heartbeat: { 
                    scale: [1, 1.05, 1], 
                    textShadow: ["0 0 0px #FF003C", "0 0 25px #FF003C", "0 0 0px #FF003C"], 
                    transition: { duration: 0.8, times: [0, 0.04, 1], ease: "easeOut" } 
                } 
            }} 
            className={clsx("font-header font-black text-xl md:text-2xl tracking-wide transition-colors duration-500", statusColor)}
        >
          {isZenMode ? (
              <span className="text-transparent bg-clip-text bg-gradient-to-r from-purple-400 via-pink-500 to-red-500 animate-pulse">
                  ZEN_OS
              </span>
          ) : "MESOELFY_OS"}
        </motion.span>
        
        {mounted && (
          <div className={clsx("hidden md:flex items-center gap-4 text-xs font-mono pl-4 border-l transition-colors", statusColor, borderColor)}>
            <Radar active={isPlaying} panic={!isZenMode && (isCritical || (isPlaying && isCritical))} color={statusColor} />
            <div className="flex flex-col leading-none">
                <span className="text-[8px] opacity-60 tracking-wider">{isZenMode ? "PEACE_PROTOCOL" : "THREAT_NEUTRALIZED"}</span>
                <span ref={scoreRef} className="font-bold text-lg tabular-nums tracking-widest">0000</span>
            </div>
          </div>
        )}
      </div>
      <div className="flex items-center gap-4">
        <div className={clsx("flex items-center gap-1 pl-4 border-l transition-colors", borderColor)}>
            <ToggleButton variant="icon" active={audioSettings.ambience} onClick={toggleAmbience} color={statusColor} icon={Wind} />
            <ToggleButton variant="icon" active={audioSettings.sfx} onClick={toggleSfx} color={statusColor} icon={Music} label="SFX" />
            <ToggleButton variant="icon" active={audioSettings.music} onClick={toggleMusic} color={statusColor} icon={Music} />
            <div className={clsx("w-[1px] h-4 mx-1 transition-colors", isZenMode ? "bg-purple-500/30" : "bg-white/10")} />
            <ToggleButton variant="icon" active={audioSettings.master} onClick={toggleMaster} color={statusColor} icon={Volume2} iconOff={VolumeX} />
            <div className={clsx("w-[1px] h-4 mx-1 transition-colors", isZenMode ? "bg-purple-500/30" : "bg-white/10")} />
            
            <button 
                onClick={(e) => { toggleSettings(); audio.playSound('ui_menu_open', getPan(e)); }} 
                className={clsx(
                    "group flex items-center justify-center p-1.5 transition-all duration-200 border border-transparent rounded-sm",
                    statusColor,
                    "hover:bg-current hover:border-transparent"
                )}
            >
                <Settings size={14} className="animate-spin-slow text-current group-hover:text-black transition-colors duration-200" />
            </button>
        </div>
      </div>
      
      {!isGameOver && !isZenMode && (
        <div className="absolute bottom-[-1px] left-0 right-0 h-[2px] bg-gray-900">
          <div ref={barRef} className="h-full w-full transition-all duration-100 ease-linear">
              <motion.div 
                key={isCritical ? "critical-bar" : "normal-bar"}
                animate={isCritical ? heartbeatControls : "idle"} 
                variants={barVariants}
                className={clsx(
                    "w-full h-full shadow-[0_0_10px_currentColor]", 
                    isCritical ? "bg-critical-red" : isWarning ? "bg-alert-yellow" : "bg-primary-green"
                )} 
              />
          </div>
        </div>
      )}
      
      <div className={clsx("absolute bottom-[-14px] right-2 text-[8px] font-mono flex items-center gap-1 transition-colors duration-300", isZenMode ? "text-purple-400" : (isCritical ? "text-critical-red" : isWarning ? "text-alert-yellow" : "text-primary-green-dim"))}>
        {isZenMode ? <InfinityIcon size={10} /> : <Activity size={8} className={isCritical ? "animate-pulse" : ""} />}
        <span ref={integrityRef}>{isZenMode ? "STATE: ETERNAL" : "OS_INTEGRITY: 100%"}</span>
      </div>
    </header>
  );
};


=====================================
FILE: ./src/ui/os/system/metaConstants.ts
=====================================
import { PALETTE } from '@/engine/config/Palette';

export const COLORS = {
  GREEN: PALETTE.GREEN.PRIMARY,
  YELLOW: PALETTE.YELLOW.SOFT,
  RED: PALETTE.RED.CRITICAL,
  PURPLE: PALETTE.PURPLE.PRIMARY,
  BLACK: PALETTE.MONO.BLACK,
  WHITE: PALETTE.MONO.WHITE,
};

export const BOOT_KEYS: Record<string, string> = {
    "INITIALIZE NEURAL_LACE": "INIT",
    "CONNECTED TO LATENT_SPACE": "LINK",
    "MOUNT MESOELFY_CORE": "MOUNT",
    "UNSAFE CONNECTION DETECTED": "UNSAFE",
    "BYPASSING SENTINEL_NODES": "BYPASS",
    "DECRYPTED": "DECRYPTED",
    "PROCEED WITH CAUTION": "CAUTION",
};


=====================================
FILE: ./src/ui/os/system/faviconGenerator.ts
=====================================
import { COLORS } from './metaConstants';

const toURI = (svgBody: string) => {
  // Ensure strict XML namespace and standard dimensions
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">${svgBody}</svg>`;
  return `data:image/svg+xml;base64,${btoa(svg)}`;
};

const BG = `<rect x="0" y="0" width="64" height="64" rx="16" fill="#050505" />`;

// --- HEALTH BAR ---
export const generateHealthIcon = (integrity: number, colorHex: string) => {
  const safeInt = Math.max(0, Math.min(100, integrity));
  const maxFillHeight = 40; 
  const h = Math.max(0, Math.floor((safeInt / 100) * maxFillHeight));
  const y = 52 - h; 
  
  return toURI(`
    ${BG}
    <rect x="4" y="4" width="56" height="56" rx="12" stroke="${colorHex}" stroke-width="4" fill="none" />
    <rect x="12" y="${y}" width="40" height="${h}" rx="2" fill="${colorHex}" />
  `);
};

// --- BREACH ---
export const generateBreachIcon = (state: 'A' | 'B') => {
  const color = state === 'A' ? COLORS.GREEN : '#FFFFFF';
  const rotation = state === 'A' ? 0 : 45;
  const coreSize = state === 'A' ? 16 : 24;
  
  return toURI(`
    ${BG}
    <g transform="rotate(${rotation} 32 32)">
        <path d="M16 10 H10 V16" stroke="${color}" stroke-width="4" fill="none" />
        <path d="M48 10 H54 V16" stroke="${color}" stroke-width="4" fill="none" />
        <path d="M16 54 H10 V48" stroke="${color}" stroke-width="4" fill="none" />
        <path d="M48 54 H54 V48" stroke="${color}" stroke-width="4" fill="none" />
        <circle cx="32" cy="32" r="20" stroke="${color}" stroke-width="2" stroke-dasharray="10 10" fill="none" />
        <circle cx="32" cy="32" r="${coreSize}" fill="${color}" />
    </g>
  `);
};

// --- BOOT ---
export const generateBootIcon = (stage: string, tick: boolean) => {
  let inner = '';
  let color = COLORS.GREEN;

  switch (stage) {
    case 'INIT':
      const offset = tick ? 14 : -14; 
      inner = `
        <circle cx="32" cy="32" r="4" fill="${color}" />
        <circle cx="${32 + offset}" cy="32" r="3" fill="${color}" />
        <circle cx="${32 - offset/2}" cy="${32 + offset}" r="3" fill="${color}" />
        <circle cx="${32 - offset/2}" cy="${32 - offset}" r="3" fill="${color}" />
        <circle cx="32" cy="32" r="18" stroke="${color}" stroke-width="1" fill="none" opacity="0.5" />
      `;
      break;
    case 'LINK':
      inner = `
        <polyline points="18,34 28,44 46,22" stroke="${color}" stroke-width="6" fill="none" stroke-linecap="round" stroke-linejoin="round" />
        <circle cx="18" cy="34" r="3" fill="${color}" />
        <circle cx="46" cy="22" r="3" fill="${color}" />
      `;
      break;
    case 'MOUNT':
      const yOff = tick ? 8 : 0;
      inner = `
        <path d="M32 ${46 + yOff} L20 ${30 + yOff} L44 ${30 + yOff} Z" fill="${color}" />
        <rect x="28" y="${8 + yOff}" width="8" height="22" fill="${color}" />
      `;
      break;
    case 'UNSAFE':
    case 'CAUTION':
      color = tick ? COLORS.YELLOW : COLORS.RED;
      inner = `
        <polygon points="32,10 54,50 10,50" fill="${color}" />
        <rect x="30" y="25" width="4" height="12" fill="#000" />
        <circle cx="32" cy="42" r="2.5" fill="#000" />
      `;
      break;
    case 'BYPASS':
      color = COLORS.PURPLE;
      const s = tick ? 28 : 14; 
      const xy = 32 - (s/2);
      inner = `
        <rect x="${xy}" y="${xy}" width="${s}" height="${s}" stroke="${color}" stroke-width="4" fill="none" />
        <rect x="30" y="30" width="4" height="4" fill="${color}" />
      `;
      break;
    case 'DECRYPTED':
      const sy = tick ? 18 : 28; 
      inner = `
        <path d="M22 ${sy} A10 10 0 0 1 42 ${sy}" stroke="${color}" stroke-width="6" fill="none" />
        <rect x="16" y="28" width="32" height="24" fill="${color}" rx="4" />
        <circle cx="32" cy="40" r="4" fill="#000" />
        <rect x="30" y="40" width="4" height="8" fill="#000" />
      `;
      break;
    default: 
      inner = `<rect x="28" y="28" width="8" height="8" fill="${color}" />`;
  }

  return toURI(`
    ${BG}
    <rect x="4" y="4" width="56" height="56" rx="12" stroke="${color}" stroke-width="4" fill="none" opacity="0.3" />
    ${inner}
  `);
};

// --- PAUSED ---
export const generatePausedIcon = (tick: boolean, colorHex: string) => {
  if (!tick) {
      return toURI(`
        ${BG}
        <rect x="4" y="4" width="56" height="56" rx="12" stroke="${colorHex}" stroke-width="2" fill="none" opacity="0.5" />
      `);
  }
  return toURI(`
    ${BG}
    <rect x="4" y="4" width="56" height="56" rx="12" stroke="${colorHex}" stroke-width="4" fill="none" />
    <rect x="20" y="18" width="8" height="28" fill="${colorHex}" />
    <rect x="36" y="18" width="8" height="28" fill="${colorHex}" />
  `);
};


=====================================
FILE: ./src/ui/os/system/MetaManager.tsx
=====================================
import { useEffect, useState } from 'react';
import { ASCII_CONSOLE, CONSOLE_STYLES } from '@/engine/config/TextAssets';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { BOOT_KEYS } from './metaConstants';
import { useFavicon } from './useFavicon';
import { useMetaUrl } from './hooks/useMetaUrl';
import { useMetaTitle } from './hooks/useMetaTitle';
import { useMetaTheme } from './hooks/useMetaTheme';
import { useWindowFocus } from '@/ui/sim/hooks/useWindowFocus';

export const MetaManager = () => {
  const [bootKey, setBootKey] = useState('INIT');
  const [lastLog, setLastLog] = useState<string | null>(null);

  useEffect(() => {
    if ((window as any).hasLoggedIdentity) return;

    const commitHash = process.env.NEXT_PUBLIC_COMMIT_HASH || 'DEV_NODE';

    console.log(
      `%c${ASCII_CONSOLE}%c\n` +
      ` %c STATUS %c ONLINE %c  ` +
      ` %c KERNEL %c R3F_V9 %c ` +
      ` %c NODE %c ${commitHash} %c\n\n` +
      `%c// TERMINAL UPLINK ESTABLISHED. WELCOME TO THE VOID.\n` +
      `%c// LATENT_SPACE_BANDIT // IDENTITY_VERIFIED\n`,
      CONSOLE_STYLES.GREEN,
      '', 
      CONSOLE_STYLES.PURPLE, CONSOLE_STYLES.STATUS, '', 
      CONSOLE_STYLES.PURPLE, CONSOLE_STYLES.TAG,    '', 
      CONSOLE_STYLES.PURPLE, CONSOLE_STYLES.TAG,    '', 
      CONSOLE_STYLES.GREEN, 
      CONSOLE_STYLES.CYAN
    );

    console.log(
      `%c[DEV_HINT] To silence YouTube/AdBlock errors, paste this filter above:\n` +
      `%c-source:www-embed-player.js -source:base.js -ERR_BLOCKED_BY_CLIENT`,
      'color: gray; font-style: italic;',
      'color: #eae747; background: #222; padding: 2px 4px; border-radius: 2px;'
    );

    (window as any).hasLoggedIdentity = true;
  }, []);

  useEffect(() => {
      const unsub = GameEventBus.subscribe(GameEvents.BOOT_LOG, (p) => {
          setLastLog(p.message);
          
          let foundKey: string | null = null;
          
          // Strict matching against constants
          for (const [textMatch, code] of Object.entries(BOOT_KEYS)) {
              if (p.message.includes(textMatch)) { 
                  foundKey = code;
                  break; 
              }
          }
          
          // Only update if we found a match, to prevent falling back to INIT accidentally
          if (foundKey) {
              setBootKey(foundKey);
          }
      });
      return unsub;
  }, []);

  useWindowFocus();
  useFavicon(bootKey);
  useMetaUrl(lastLog);
  useMetaTitle(bootKey);
  useMetaTheme();

  return null;
};

declare global { interface Window { hasLoggedIdentity?: boolean; } }


=====================================
FILE: ./src/ui/os/system/useFavicon.ts
=====================================
import { useEffect, useRef, useState } from 'react';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { generateHealthIcon, generateBreachIcon, generateBootIcon, generatePausedIcon } from './faviconGenerator';
import { COLORS } from './metaConstants';

const UPDATE_INTERVAL = 500; // Slower tick for visibility

export const useFavicon = (bootKey: string) => {
  const linkRef = useRef<HTMLLinkElement | null>(null);
  const defaultIconDataRef = useRef<string | null>(null);
  const lastVisualKey = useRef<string>('');
  const { bootState, isBreaching, isSimulationPaused } = useStore();
  const integrity = useGameStore(s => s.systemIntegrity);
  const isZenMode = useGameStore(s => s.isZenMode);
  const [tick, setTick] = useState(false);

  // 1. Setup Link Reference
  useEffect(() => {
    if (typeof window === 'undefined') return;
    
    // Prioritize existing 'icon' or 'shortcut icon'
    let link = document.querySelector("link[rel~='icon']") as HTMLLinkElement;
    if (!link) { 
        link = document.createElement('link'); 
        link.rel = 'icon'; 
        document.head.appendChild(link); 
    }
    linkRef.current = link;

    // Cache default favicon
    fetch('/favicon.ico').then(res => res.blob()).then(blob => {
        const reader = new FileReader();
        reader.onloadend = () => { if (typeof reader.result === 'string') defaultIconDataRef.current = reader.result; };
        reader.readAsDataURL(blob);
    }).catch(() => {});
  }, []);

  // 2. Loop
  useEffect(() => {
    if (typeof window !== 'undefined' && (window as any).electron) return;
    const interval = setInterval(() => { setTick(t => !t); }, UPDATE_INTERVAL);
    return () => clearInterval(interval);
  }, []);

  // 3. Update Logic (Reactive)
  useEffect(() => {
    if (!linkRef.current) return;
    
    const displayInt = Math.floor(Math.max(0, integrity));
    const statusColor = displayInt < 30 ? COLORS.RED : (displayInt < 60 ? COLORS.YELLOW : COLORS.GREEN);

    let nextHref = ''; 
    let visualKey = '';

    if (bootState === 'standby') { 
        visualKey = `BOOT_${bootKey}_${tick}`; 
        nextHref = generateBootIcon(bootKey, tick); 
    } 
    else if (isBreaching) { 
        visualKey = `BREACH_${tick ? 'A' : 'B'}`; 
        nextHref = generateBreachIcon(tick ? 'A' : 'B'); 
    } 
    else if (isSimulationPaused) { 
        visualKey = `PAUSED_${tick}_${statusColor}`; 
        nextHref = generatePausedIcon(tick, statusColor); 
    } 
    else if (isZenMode || integrity > 99) {
        if (defaultIconDataRef.current) { 
            visualKey = 'DEFAULT_STATIC'; 
            nextHref = defaultIconDataRef.current; 
        } else { 
            visualKey = 'HEALTH_100'; 
            nextHref = generateHealthIcon(100, COLORS.GREEN); 
        }
    } 
    else { 
        visualKey = `HEALTH_${displayInt}_${statusColor}`; 
        nextHref = generateHealthIcon(displayInt, statusColor); 
    }

    if (visualKey !== lastVisualKey.current && nextHref) { 
        linkRef.current.href = nextHref; 
        lastVisualKey.current = visualKey; 
    }
  }, [tick, bootState, isBreaching, isSimulationPaused, integrity, isZenMode, bootKey]);
};


=====================================
FILE: ./src/ui/os/system/hooks/useMetaTitle.ts
=====================================
import { useEffect, useState } from 'react';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';

export const useMetaTitle = (bootKey: string) => {
  const { bootState, isSimulationPaused, isBreaching } = useStore();
  const integrity = useGameStore(s => s.systemIntegrity);
  const [tick, setTick] = useState(false);

  useEffect(() => {
    // 500ms ticker for blinking effects
    const interval = setInterval(() => setTick(t => !t), 500);
    return () => clearInterval(interval);
  }, []);

  useEffect(() => {
    let title = "";
    
    if (bootState === 'standby') {
        title = `[ :: // ${bootKey} // :: ]`;
    } else if (isSimulationPaused) {
        title = `[ :: SYSTEM PAUSED :: ]`;
    } else {
        const safeInt = Math.floor(Math.max(0, integrity));
        
        if (safeInt <= 0) {
            // UPDATED: SESSION -> SYSTEM
            title = `[ :: SYSTEM FAILURE :: ]`;
        } else if (safeInt >= 99 && !isBreaching) {
            title = "[ :: // MESOELFY // :: ]";
        } else {
            // ASCII Health Bar
            let bar = "";
            const activeIndex = Math.floor(safeInt / 10);
            for(let i=0; i<10; i++) {
                if (i < activeIndex) bar += "â–®";
                else if (i === activeIndex) bar += tick ? "â–®" : "â–¯";
                else bar += "â–¯";
            }
            title = `[ ${bar} INT: ${safeInt}% ]`;
        }
    }

    if (document.title !== title) document.title = title;
  }, [tick, bootState, bootKey, isSimulationPaused, integrity, isBreaching]);
};


=====================================
FILE: ./src/ui/os/system/hooks/useMetaUrl.ts
=====================================
import { useEffect, useRef } from 'react';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';

export const useMetaUrl = (bootLogMessage: string | null) => {
  const { bootState, isSimulationPaused, isBreaching } = useStore();
  
  // FIX: isZenMode comes from useGameStore, not useStore
  const integrity = useGameStore(s => s.systemIntegrity);
  const isZenMode = useGameStore(s => s.isZenMode);
  
  const lastUpdate = useRef(0);

  // 1. Boot Sequence Updates (Immediate)
  useEffect(() => {
    if (bootState === 'standby' && bootLogMessage) {
        const safeMsg = bootLogMessage.replace(/>/g, '').replace(/\./g, '').trim().replace(/ /g, '_');
        window.history.replaceState(null, '', `#/BOOT/${safeMsg}`);
    }
  }, [bootLogMessage, bootState]);

  // 2. Game State Updates (Throttled)
  useEffect(() => {
    const update = () => {
        if (bootState === 'standby') return;

        const now = Date.now();
        if (now - lastUpdate.current < 80) return; // Cap at ~12 updates/sec

        const safeInt = Math.floor(Math.max(0, integrity));
        const isGameOver = safeInt <= 0;
        let hash = '';

        if (isSimulationPaused) {
            hash = '#/SYSTEM_LOCKED/AWAITING_INPUT';
        } else if (bootState === 'sandbox') {
            hash = '#/SIMULATION/HOLO_DECK';
        } else if (isZenMode) {
            hash = '#/VIBING'; // Correct Zen Hash
        } else if (isGameOver) {
            hash = '#/STATUS:CRITICAL/SYSTEM_FAILURE';
        } else if (safeInt < 30) {
            hash = `#/STATUS:CRITICAL/OS_INT:${safeInt}%`;
        } else {
            let status = 'STABLE';
            if (safeInt < 60) status = 'CAUTION';
            hash = `#/STATUS:${status}/OS_INT:${safeInt}%`;
        }

        if (window.location.hash !== hash) {
            window.history.replaceState(null, '', hash);
        }
        lastUpdate.current = now;
    };

    const interval = setInterval(update, 100);
    return () => clearInterval(interval);
  }, [bootState, isSimulationPaused, integrity, isBreaching, isZenMode]);
};


=====================================
FILE: ./src/ui/os/system/hooks/useMetaTheme.ts
=====================================
import { useEffect, useRef } from 'react';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { COLORS } from '../metaConstants';

export const useMetaTheme = () => {
  const metaRef = useRef<HTMLMetaElement | null>(null);
  const { bootState, isSimulationPaused } = useStore();
  const integrity = useGameStore(s => s.systemIntegrity);

  // Ensure meta tag exists on mount
  useEffect(() => {
    let meta = document.querySelector("meta[name='theme-color']") as HTMLMetaElement;
    if (!meta) {
        meta = document.createElement('meta');
        meta.name = 'theme-color';
        document.head.appendChild(meta);
    }
    metaRef.current = meta;
  }, []);

  useEffect(() => {
    if (!metaRef.current) return;

    let themeHex = COLORS.BLACK;
    const safeInt = Math.max(0, integrity);

    if (bootState !== 'standby' && !isSimulationPaused && safeInt > 0) {
        if (safeInt < 30) themeHex = COLORS.RED;      
        else if (safeInt < 60) themeHex = COLORS.YELLOW; 
    }

    if (metaRef.current.content !== themeHex) {
        metaRef.current.content = themeHex;
    }
  }, [bootState, isSimulationPaused, integrity]);
};


=====================================
FILE: ./src/ui/os/apps/settings/tabs/SoundTab.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { RangeSlider } from '../components/RangeSlider';
import { RotateCcw, Activity, Volume2, VolumeX, Waves, Music, Zap, ZapOff, Wind, Mic2 } from 'lucide-react';
import { useAudio } from '@/ui/hooks/useAudio';
import { clsx } from 'clsx';
import { 
  getAmbienceFilterHz, 
  getAmbiencePanFreq, 
  getAmbienceModFreq, 
  getAmbienceModDepth, 
  getAmbienceStereoGain 
} from '@/engine/audio/AudioMath';
import { ToggleButton } from '@/ui/kit/atoms/ToggleButton';

export const SoundTab = () => {
  const { 
    audioSettings, 
    setVolume, 
    resetAudioSettings,
    toggleMaster,
    toggleMusic,
    toggleSfx,
    toggleAmbience
  } = useStore();
  
  const audio = useAudio();
  const BASE_VOL = 0.24;

  return (
    <div className="h-full flex flex-col gap-6 animate-in fade-in slide-in-from-bottom-4 duration-500 pr-2">
      
      <div className="p-3 border border-primary-green/30 bg-primary-green/5 flex items-start gap-3">
          <Activity size={16} className="text-primary-green mt-0.5 animate-pulse" />
          <div className="flex flex-col gap-1">
              <span className="text-[10px] font-header font-black text-primary-green tracking-widest uppercase">
                  AUDIO_ENGINE_V2 ONLINE
              </span>
              <p className="text-[9px] font-mono text-primary-green-dim leading-relaxed">
                  Output Gain calibrated to Source (Vol: {BASE_VOL}).
                  DSP Matrix Active.
              </p>
          </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
          
          {/* LEFT COLUMN: MIXER & FX */}
          <div className="flex flex-col gap-6">
              
              {/* GLOBAL MIXER */}
              <div className="flex flex-col gap-4">
                  <div className="flex items-center gap-2 border-b border-white/10 pb-2 mb-2">
                      <Volume2 size={14} className="text-white/70" />
                      <h3 className="text-xs font-bold text-white/90 tracking-wider">GLOBAL_MIXER</h3>
                  </div>
                  
                  <div className="bg-black/40 p-4 border border-white/5 relative overflow-hidden flex flex-col gap-6">
                      <div className="grid grid-cols-4 gap-2 relative z-10">
                          <ToggleButton variant="panel" label="MAIN" active={audioSettings.master} onClick={toggleMaster} icon={Volume2} iconOff={VolumeX} />
                          <ToggleButton variant="panel" label="MUSIC" active={audioSettings.music} onClick={toggleMusic} icon={Music} />
                          <ToggleButton variant="panel" label="SFX" active={audioSettings.sfx} onClick={toggleSfx} icon={Zap} iconOff={ZapOff} />
                          <ToggleButton variant="panel" label="AMB" active={audioSettings.ambience} onClick={toggleAmbience} icon={Wind} />
                      </div>

                      <div className="space-y-5 relative z-10">
                        <RangeSlider label="MASTER_OUT" value={audioSettings.volumeMaster} max={2.0} onChange={(v) => setVolume('volumeMaster', v, 2.0)} format={(v) => `${(v * 100).toFixed(0)}%`} />
                        <RangeSlider label="MUSIC_BUS" value={audioSettings.volumeMusic} max={2.0} onChange={(v) => setVolume('volumeMusic', v, 2.0)} format={(v) => `${(v * 100).toFixed(0)}%`} />
                        <RangeSlider label="SFX_BUS" value={audioSettings.volumeSfx} max={2.0} onChange={(v) => setVolume('volumeSfx', v, 2.0)} format={(v) => `${(v * 100).toFixed(0)}%`} />
                      </div>
                  </div>
              </div>

              {/* FX RACK */}
              <div className="flex flex-col gap-4">
                  <div className="flex items-center gap-2 border-b border-latent-purple/30 pb-2 mb-2">
                      <Mic2 size={14} className="text-latent-purple" />
                      <h3 className="text-xs font-bold text-latent-purple tracking-wider">FX_PROCESSOR</h3>
                  </div>
                  
                  <div className="bg-latent-purple/5 p-4 border border-latent-purple/10 space-y-5 relative">
                      <RangeSlider 
                        label="REVERB_SEND" 
                        value={audioSettings.fxReverbMix} 
                        max={1.0} 
                        onChange={(v) => setVolume('fxReverbMix', v, 1.0)} 
                        format={(v) => `${(v * 100).toFixed(0)}%`}
                        color="text-latent-purple"
                      />
                      <div className="h-px bg-latent-purple/10 w-full" />
                      <RangeSlider 
                        label="DELAY_SEND" 
                        value={audioSettings.fxDelayMix} 
                        max={1.0} 
                        onChange={(v) => setVolume('fxDelayMix', v, 1.0)} 
                        format={(v) => `${(v * 100).toFixed(0)}%`}
                        color="text-latent-purple"
                      />
                      <div className="grid grid-cols-2 gap-4">
                          <RangeSlider 
                            label="DELAY_TIME" 
                            value={audioSettings.fxDelayTime} 
                            max={1.0} 
                            onChange={(v) => setVolume('fxDelayTime', v, 1.0)} 
                            format={(v) => `${(0.1 + v * 0.9).toFixed(2)}s`}
                            color="text-latent-purple"
                          />
                          <RangeSlider 
                            label="FEEDBACK" 
                            value={audioSettings.fxDelayFeedback} 
                            max={0.9} 
                            onChange={(v) => setVolume('fxDelayFeedback', v, 0.9)} 
                            format={(v) => `${(v * 100).toFixed(0)}%`}
                            color="text-latent-purple"
                          />
                      </div>
                  </div>
              </div>
          </div>

          {/* RIGHT COLUMN: AMBIENCE LAB */}
          <div className="flex flex-col gap-4">
              <div className="flex items-center gap-2 border-b border-alert-yellow/30 pb-2 mb-2">
                  <Waves size={14} className="text-alert-yellow" />
                  <h3 className="text-xs font-bold text-alert-yellow tracking-wider">
                    AMBIENCE_SYNTH <span className="opacity-50 text-[10px] ml-1 font-mono">// (BROWN NOISE)</span>
                  </h3>
              </div>

              <div className="space-y-5 bg-alert-yellow/5 p-4 border border-alert-yellow/10 relative h-full">
                  <div className="absolute top-0 right-0 w-4 h-4 border-t border-r border-alert-yellow/30" />

                  <RangeSlider 
                    label="OUTPUT_GAIN" 
                    value={audioSettings.volumeAmbience} 
                    max={5.0} 
                    markerValue={1.0} 
                    onChange={(v) => setVolume('volumeAmbience', v, 5.0)} 
                    color="text-alert-yellow"
                    format={(v) => `VOL: ${(v * BASE_VOL).toFixed(2)}`} 
                  />

                  <div className="h-px bg-alert-yellow/10 w-full" />

                  <RangeSlider 
                    label="SPECTRAL_GATE (CUTOFF)" 
                    value={audioSettings.ambFilter} 
                    max={1.0} 
                    markerValue={0.5}
                    onChange={(v) => setVolume('ambFilter', v, 1.0)} 
                    format={(v) => `${getAmbienceFilterHz(v).toFixed(0)} Hz`}
                  />
                  
                  <div className="grid grid-cols-2 gap-4">
                      <RangeSlider 
                        label="PAN_RATE" 
                        value={audioSettings.ambSpeed} 
                        max={1.0} 
                        markerValue={0.5}
                        onChange={(v) => setVolume('ambSpeed', v, 1.0)} 
                        format={(v) => `${getAmbiencePanFreq(v).toFixed(2)} Hz`}
                      />
                      <RangeSlider 
                        label="STEREO_IMG" 
                        value={audioSettings.ambWidth} 
                        max={1.0} 
                        markerValue={0.5}
                        onChange={(v) => setVolume('ambWidth', v, 1.0)} 
                        format={(v) => {
                            const gain = getAmbienceStereoGain(v);
                            return `${((gain / 0.8) * 100).toFixed(0)}%`;
                        }}
                      />
                  </div>

                  <div className="grid grid-cols-2 gap-4">
                      <RangeSlider 
                        label="LFO_RATE" 
                        value={audioSettings.ambModSpeed} 
                        max={1.0} 
                        markerValue={0.5}
                        onChange={(v) => setVolume('ambModSpeed', v, 1.0)} 
                        format={(v) => `${getAmbienceModFreq(v).toFixed(1)} Hz`}
                      />
                      <RangeSlider 
                        label="LFO_DEPTH" 
                        value={audioSettings.ambModDepth} 
                        max={1.0} 
                        markerValue={0.5}
                        onChange={(v) => setVolume('ambModDepth', v, 1.0)} 
                        format={(v) => `+/- ${getAmbienceModDepth(v).toFixed(0)} Hz`}
                      />
                  </div>
              </div>
          </div>
      </div>

      <div className="mt-auto pt-4 flex justify-end border-t border-white/10">
        <button 
          onClick={resetAudioSettings}
          onMouseEnter={() => audio.playHover()}
          className="flex items-center gap-2 px-4 py-2 border border-critical-red/50 text-critical-red hover:bg-critical-red hover:text-black font-header font-black text-xs tracking-widest transition-all group"
        >
          <RotateCcw size={14} className="group-hover:-rotate-180 transition-transform duration-500" />
          RESET_ALL_MODULES
        </button>
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/settings/components/RangeSlider.tsx
=====================================
import { clsx } from 'clsx';
import { useAudio } from '@/ui/hooks/useAudio';
import { getPan } from '@/engine/audio/AudioUtils';
import { useRef, useState, useEffect } from 'react';

interface RangeSliderProps {
  label: string;
  value: number; 
  onChange: (val: number) => void;
  max?: number; 
  step?: number;
  displayMax?: number; 
  format?: (val: number) => string;
  markerValue?: number; 
  color?: string;
}

export const RangeSlider = ({ 
  label, 
  value, 
  onChange, 
  max = 3.0,
  step = 0.01,
  markerValue = 1.0,
  format,
  color
}: RangeSliderProps) => {
  
  const audio = useAudio();
  const containerRef = useRef<HTMLDivElement>(null);
  const [isDragging, setIsDragging] = useState(false);
  const lastTickRef = useRef(value);
  const lastPanRef = useRef(0);

  // Safety
  const safeValue = typeof value === 'number' && !isNaN(value) ? value : 0;
  const percent = Math.min(100, Math.max(0, (safeValue / max) * 100));

  // Audio Tick Logic
  useEffect(() => {
    const threshold = max * 0.05;
    if (Math.abs(safeValue - lastTickRef.current) >= threshold) {
        if (isDragging) {
            audio.playHover(lastPanRef.current);
        }
        lastTickRef.current = safeValue;
    }
  }, [safeValue, max, isDragging, audio]);

  useEffect(() => {
      if (!isDragging) lastTickRef.current = safeValue;
  }, [safeValue, isDragging]);

  let activeColor = "bg-primary-green";
  let activeText = "text-primary-green";
  let glowClass = "shadow-[0_0_10px_#78F654]";

  if (percent > 80) {
      activeColor = "bg-alert-yellow";
      activeText = "text-alert-yellow";
      glowClass = "shadow-[0_0_10px_#eae747]";
  }
  if (percent > 95) {
      activeColor = "bg-critical-red";
      activeText = "text-critical-red";
      glowClass = "shadow-[0_0_15px_#FF003C]";
  }
  if (color) activeText = color.replace('bg-', 'text-').replace('border-', 'text-');

  const displayString = format ? format(safeValue) : `${Math.round(percent)}%`;
  const segments = 20;

  const handlePointerDown = (e: React.PointerEvent) => {
    setIsDragging(true);
    e.currentTarget.setPointerCapture(e.pointerId);
    updateValue(e);
  };

  const handlePointerMove = (e: React.PointerEvent) => {
    if (!isDragging) return;
    updateValue(e);
  };

  const handlePointerUp = (e: React.PointerEvent) => {
    setIsDragging(false);
    e.currentTarget.releasePointerCapture(e.pointerId);
  };

  const updateValue = (e: React.PointerEvent) => {
      if (!containerRef.current) return;
      
      lastPanRef.current = getPan(e);

      const rect = containerRef.current.getBoundingClientRect();
      const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
      const ratio = x / rect.width;
      
      let rawValue = ratio * max;
      if (step > 0) {
          rawValue = Math.round(rawValue / step) * step;
      }
      const finalValue = Math.max(0, Math.min(max, rawValue));
      
      if (finalValue !== safeValue) {
          onChange(finalValue);
      }
  };

  return (
    <div 
        className="flex flex-col gap-1 w-full select-none touch-none"
        onMouseEnter={(e) => audio.playHover(getPan(e))}
    >
      <div className="flex justify-between items-end mb-1">
        <span className="text-[10px] font-bold font-header tracking-widest text-gray-500 group-hover:text-white transition-colors uppercase">
            {label}
        </span>
        <span className={clsx("text-[10px] font-mono font-bold transition-colors bg-black/50 px-1.5 rounded-sm border border-white/10 min-w-[3rem] text-center", activeText)}>
            {displayString}
        </span>
      </div>
      
      <div 
        ref={containerRef}
        className="relative h-6 w-full flex items-center cursor-pointer group/slider py-1"
        onPointerDown={handlePointerDown}
        onPointerMove={handlePointerMove}
        onPointerUp={handlePointerUp}
        onPointerLeave={handlePointerUp}
      >
        <div className="absolute inset-x-0 h-2 flex justify-between items-center px-[1px] pointer-events-none z-0 opacity-30 bg-black/50 border border-white/10 rounded-sm">
            {Array.from({ length: segments }).map((_, i) => (
                <div key={i} className="w-[1px] h-1.5 bg-gray-500" />
            ))}
        </div>

        <div 
            className="absolute left-0 h-2 top-2 z-10 pointer-events-none transition-none rounded-sm overflow-hidden" 
            style={{ width: `${percent}%` }}
        >
            <div className={clsx("w-full h-full opacity-80", activeColor, glowClass)} />
        </div>

        <div 
            className={clsx(
                "absolute h-4 w-1 top-1 z-20 pointer-events-none shadow-sm transition-transform duration-100",
                activeColor === "bg-primary-green" ? "bg-white" : activeColor,
                isDragging ? "scale-y-125 scale-x-110 brightness-150" : "group-hover/slider:scale-y-110"
            )}
            style={{ 
                left: `${percent}%`, 
                transform: `translateX(-50%) ${isDragging ? 'scale(1.2)' : ''}` 
            }} 
        />
        
        {markerValue !== undefined && (
            <div 
                className="absolute top-1/2 -translate-y-1/2 w-0.5 h-3 bg-white/50 pointer-events-none z-0" 
                style={{ left: `${(markerValue / max) * 100}%` }} 
            />
        )}
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/settings/components/GpuConfigPanel.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { Zap, ZapOff, Cpu, Activity } from 'lucide-react';
import { clsx } from 'clsx';

export const GpuConfigPanel = () => {
  const { graphicsMode, setGraphicsMode } = useStore();

  const handleSelect = (mode: 'HIGH' | 'POTATO') => {
    if (graphicsMode === mode) return;
    AudioSystem.playClick();
    setGraphicsMode(mode);
  };

  return (
    <div className="flex flex-col border border-primary-green bg-black/90 w-full">
      {/* HEADER */}
      <div className="flex items-center justify-between px-3 py-2 border-b border-primary-green/30 bg-primary-green/5 shrink-0">
        <span className="font-mono font-bold text-sm tracking-widest text-primary-green">
          GPU_CONFIG
        </span>
        <div className="flex items-center gap-2">
          <Cpu size={14} className="text-primary-green animate-pulse" />
        </div>
      </div>

      {/* BODY - No padding, full width buttons */}
      <div className="flex flex-col w-full h-full bg-black relative">
        {/* Background Grid Decoration */}
        <div className="absolute inset-0 pointer-events-none opacity-20" 
             style={{ backgroundImage: 'radial-gradient(#15530A 1px, transparent 1px)', backgroundSize: '8px 8px' }} 
        />

        <div className="p-3 border-b border-primary-green/20">
            <span className="text-[10px] font-mono font-bold text-gray-500 uppercase tracking-wider flex items-center gap-2">
              <Activity size={10} /> SELECT PROFILE:
            </span>
        </div>

        {/* HIGH VOLTAGE TOGGLE */}
        <button
          onClick={() => handleSelect('HIGH')}
          onMouseEnter={() => AudioSystem.playHover()}
          className="group relative w-full h-24 flex items-stretch border-b border-primary-green/30 overflow-hidden transition-all hover:bg-white/5"
        >
          {/* Status Strip (Left) */}
          <div className={clsx(
              "w-2 h-full transition-colors duration-300", 
              graphicsMode === 'HIGH' ? "bg-primary-green shadow-[0_0_15px_#78F654]" : "bg-gray-800"
          )} />
          
          {/* Content */}
          <div className="flex-1 flex items-center justify-between px-4 relative z-10">
             <div className="flex flex-col items-start text-left">
                <span className={clsx(
                    "font-header font-black text-xl tracking-widest transition-colors duration-300",
                    graphicsMode === 'HIGH' ? "text-primary-green" : "text-gray-500 group-hover:text-primary-green-dim"
                )}>
                    ENABLED
                </span>
                <span className="text-[10px] font-mono tracking-widest text-gray-500 group-hover:text-white transition-colors">
                    [HIGH_VOLTAGE]
                </span>
             </div>
             
             <Zap 
                size={28} 
                className={clsx(
                    "transition-all duration-300",
                    graphicsMode === 'HIGH' ? "text-primary-green fill-primary-green scale-110" : "text-gray-700 scale-90"
                )} 
             />
          </div>

          {/* Active Background Pattern */}
          {graphicsMode === 'HIGH' && (
              <div className="absolute inset-0 opacity-10 pointer-events-none bg-[repeating-linear-gradient(45deg,transparent,transparent_10px,#78F654_10px,#78F654_12px)]" />
          )}
        </button>

        {/* POTATO MODE TOGGLE */}
        <button
          onClick={() => handleSelect('POTATO')}
          onMouseEnter={() => AudioSystem.playHover()}
          className="group relative w-full h-24 flex items-stretch overflow-hidden transition-all hover:bg-white/5"
        >
          {/* Status Strip (Left) */}
          <div className={clsx(
              "w-2 h-full transition-colors duration-300", 
              graphicsMode === 'POTATO' ? "bg-alert-yellow shadow-[0_0_15px_#eae747]" : "bg-gray-800"
          )} />
          
          {/* Content */}
          <div className="flex-1 flex items-center justify-between px-4 relative z-10">
             <div className="flex flex-col items-start text-left">
                <span className={clsx(
                    "font-header font-black text-xl tracking-widest transition-colors duration-300",
                    graphicsMode === 'POTATO' ? "text-alert-yellow" : "text-gray-500 group-hover:text-alert-yellow/70"
                )}>
                    DISABLED
                </span>
                <span className="text-[10px] font-mono tracking-widest text-gray-500 group-hover:text-white transition-colors">
                    [POTATO_MODE]
                </span>
             </div>
             
             <ZapOff 
                size={28} 
                className={clsx(
                    "transition-all duration-300",
                    graphicsMode === 'POTATO' ? "text-alert-yellow fill-alert-yellow scale-110" : "text-gray-700 scale-90"
                )} 
             />
          </div>

          {/* Active Background Pattern */}
          {graphicsMode === 'POTATO' && (
              <div className="absolute inset-0 opacity-10 pointer-events-none bg-[repeating-linear-gradient(45deg,transparent,transparent_10px,#eae747_10px,#eae747_12px)]" />
          )}
        </button>
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/settings/SettingsModal.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { motion, AnimatePresence } from 'framer-motion';
import { X, Settings, Volume2, Monitor, Cpu } from 'lucide-react';
import { clsx } from 'clsx';
import { useState } from 'react';
import { SoundTab } from './tabs/SoundTab';
import { GpuConfigPanel } from './components/GpuConfigPanel';
import { DotGridBackground } from '@/ui/kit/atoms/DotGridBackground';

const TABS = [
  { id: 'SOUND', label: 'AUDIO_CONFIG', icon: Volume2 },
  { id: 'GRAPHICS', label: 'GPU_CONFIG', icon: Monitor }, 
  { id: 'SYSTEM', label: 'SYSTEM', icon: Cpu },       
];

export const SettingsModal = () => {
  const { activeModal, closeModal } = useStore();
  const [activeTab, setActiveTab] = useState('SOUND');
  const isOpen = activeModal === 'settings';

  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 z-[200] flex items-center justify-center p-4 md:p-10 pointer-events-none">
          
          <motion.div
            initial={{ scale: 0.95, opacity: 0, y: 10 }}
            animate={{ scale: 1, opacity: 1, y: 0 }}
            exit={{ scale: 0.95, opacity: 0, y: 10 }}
            transition={{ type: "spring", bounce: 0, duration: 0.2 }}
            className="relative w-full max-w-5xl h-full max-h-[85vh] bg-black/95 backdrop-blur-md border border-primary-green shadow-[0_0_80px_rgba(0,255,65,0.15)] flex flex-col overflow-hidden pointer-events-auto"
          >
            
            {/* HEADER (No Dots Here) */}
            <div className="flex items-center justify-between px-6 py-4 border-b border-primary-green/30 bg-primary-green/5 shrink-0 relative z-20">
              <div className="flex items-center gap-4">
                <div className="p-2 border border-primary-green bg-black/50">
                    <Settings className="text-primary-green animate-spin-slow" size={20} />
                </div>
                <div className="flex flex-col leading-none">
                    <span className="font-header font-black text-xl text-primary-green tracking-widest">
                    SYSTEM_SETTINGS
                    </span>
                    <span className="text-[9px] font-mono text-primary-green-dim tracking-[0.3em] opacity-70">
                        ACCESS_LEVEL: ADMIN
                    </span>
                </div>
              </div>
              <button 
                onClick={() => { closeModal(); AudioSystem.playSound('ui_menu_close'); }}
                onMouseEnter={() => AudioSystem.playHover()} 
                className="p-2 hover:bg-critical-red hover:text-black text-primary-green transition-colors border border-transparent hover:border-critical-red"
              >
                <X size={24} />
              </button>
            </div>

            {/* MAIN LAYOUT */}
            <div className="flex-1 flex overflow-hidden relative z-10">
                
                {/* Background Dots (Scoped to Body) */}
                <DotGridBackground className="opacity-10" />

                {/* SIDEBAR */}
                <div className="w-16 md:w-64 border-r border-primary-green/30 flex flex-col bg-black/40 relative z-10">
                    {TABS.map(tab => (
                        <button
                            key={tab.id}
                            onClick={() => {
                                setActiveTab(tab.id);
                                AudioSystem.playClick();
                            }}
                            onMouseEnter={() => AudioSystem.playHover()}
                            className={clsx(
                                "group flex items-center gap-4 px-4 md:px-6 py-5 text-sm font-bold tracking-wider transition-all relative overflow-hidden",
                                activeTab === tab.id
                                    ? "bg-primary-green/10 text-primary-green"
                                    : "text-primary-green-dim hover:text-primary-green hover:bg-primary-green/5"
                            )}
                        >
                            {activeTab === tab.id && (
                                <div className="absolute left-0 top-0 bottom-0 w-1 bg-primary-green shadow-[0_0_10px_#78F654]" />
                            )}
                            <tab.icon size={20} className={activeTab === tab.id ? "drop-shadow-[0_0_5px_rgba(120,246,84,0.5)]" : ""} />
                            <span className="hidden md:block group-hover:translate-x-1 transition-transform">{tab.label}</span>
                        </button>
                    ))}
                </div>

                {/* CONTENT AREA */}
                <div className="flex-1 overflow-y-auto p-6 md:p-8 relative scrollbar-thin scrollbar-thumb-primary-green scrollbar-track-black z-10">
                    <div className="relative z-10 w-full h-full max-w-3xl mx-auto">
                        {activeTab === 'SOUND' && <SoundTab />}
                        
                        {activeTab === 'GRAPHICS' && (
                            <div className="max-w-xl mx-auto pt-8 animate-in fade-in slide-in-from-bottom-4">
                                <GpuConfigPanel />
                                <div className="mt-6 p-4 border border-primary-green/30 bg-primary-green/5 text-xs font-mono text-primary-green-dim">
                                    <p className="mb-2 font-bold text-primary-green">&gt; PROFILE_DETAILS:</p>
                                    <ul className="list-disc pl-4 space-y-1">
                                        <li><span className="text-white">HIGH_VOLTAGE:</span> Full resolution (Retina), Post-Processing (Bloom, Vignette), Full Particles.</li>
                                        <li><span className="text-alert-yellow">POTATO_MODE:</span> Half resolution (Retro Style), No Post-Processing, Reduced Particles, Static Video Feeds.</li>
                                    </ul>
                                </div>
                            </div>
                        )}

                        {activeTab === 'SYSTEM' && (
                            <div className="flex flex-col items-center justify-center h-64 text-primary-green-dim font-mono animate-in fade-in zoom-in-95">
                                <Cpu size={48} className="mb-4 opacity-50" />
                                <span className="animate-pulse">[ MODULE_OFFLINE ]</span>
                                <span className="text-[10px] mt-2 opacity-50">WAITING FOR KERNEL UPDATE...</span>
                            </div>
                        )}
                    </div>
                </div>
            </div>

            {/* FOOTER */}
            <div className="px-6 py-2 bg-black/80 border-t border-primary-green/30 flex justify-between items-center text-[10px] font-mono text-primary-green-dim shrink-0 relative z-20">
              <div className="flex gap-6">
                  <span className="flex items-center gap-2">
                      <span className="border border-primary-green/30 px-1.5 py-0.5 rounded text-primary-green bg-primary-green/5">ESC</span> 
                      CLOSE_MENU
                  </span>
                  <span className="hidden md:flex items-center gap-2">
                      <span className="border border-primary-green/30 px-1.5 py-0.5 rounded text-primary-green bg-primary-green/5">~</span> 
                      DEBUG_CONSOLE
                  </span>
              </div>
              <div className="flex items-center gap-2 opacity-50">
                  <div className="w-2 h-2 rounded-full bg-primary-green animate-pulse" />
                  ONLINE
              </div>
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
};


=====================================
FILE: ./src/ui/os/apps/contact/ContactModal.tsx
=====================================
import { ModalContainer } from '@/ui/os/overlays/ModalContainer';
import { Send, Terminal, Signal, ShieldCheck } from 'lucide-react';
import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { clsx } from 'clsx';

export const ContactModal = () => {
  const [status, setStatus] = useState<'IDLE' | 'SENDING' | 'SENT' | 'ERROR'>('IDLE');
  const [signalStrength, setSignalStrength] = useState(0);

  const handleInput = () => {
      // Fluctuate signal on typing
      setSignalStrength(Math.floor(Math.random() * 40) + 60);
      AudioSystem.playSound('ui_hover'); // Subtle chirp
  };

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
      e.preventDefault();
      setStatus('SENDING');
      AudioSystem.playSound('ui_click');
      AudioSystem.playRebootZap();

      const form = e.currentTarget;
      const data = new FormData(form);
      
      try {
          const res = await fetch("https://formspree.io/f/xkgdbkpz", {
              method: "POST",
              body: data,
              headers: { 'Accept': 'application/json' }
          });
          
          if (res.ok) {
              setStatus('SENT');
              AudioSystem.playSound('fx_reboot_success');
          } else {
              setStatus('ERROR');
              AudioSystem.playSound('ui_error');
          }
      } catch (err) {
          setStatus('ERROR');
          AudioSystem.playSound('ui_error');
      }
  };

  return (
    <ModalContainer title="SECURE_UPLINK // TERMINAL_01" type="contact">
      <div className="max-w-3xl mx-auto h-full flex flex-col relative overflow-hidden">
        
        {/* DECORATIVE BACKGROUND */}
        <div className="absolute inset-0 opacity-10 pointer-events-none">
            <div className="absolute top-0 right-0 w-64 h-64 bg-primary-green rounded-full blur-[100px]" />
            <div className="absolute bottom-0 left-0 w-64 h-64 bg-service-cyan rounded-full blur-[100px]" />
        </div>

        {/* STATUS BAR */}
        <div className="flex items-center justify-between p-4 border-b border-primary-green/20 bg-black/40 backdrop-blur-sm z-10 shrink-0">
            <div className="flex items-center gap-3">
                <div className={clsx("w-3 h-3 rounded-full animate-pulse", status === 'ERROR' ? "bg-critical-red" : "bg-primary-green")} />
                <span className="font-mono text-xs font-bold text-primary-green tracking-widest">
                    CONNECTION: {status === 'IDLE' ? 'STABLE' : status}
                </span>
            </div>
            <div className="flex items-center gap-2 text-primary-green/60 font-mono text-[10px]">
                <Signal size={14} />
                <span>SIG: {signalStrength}%</span>
            </div>
        </div>

        {/* MAIN TERMINAL */}
        <div className="flex-1 relative p-6 md:p-12 overflow-y-auto z-10">
            
            <AnimatePresence mode="wait">
                {status === 'SENT' ? (
                    <motion.div 
                        initial={{ opacity: 0, scale: 0.9 }}
                        animate={{ opacity: 1, scale: 1 }}
                        className="h-full flex flex-col items-center justify-center text-center gap-6"
                    >
                        <motion.div 
                            initial={{ scale: 0 }} animate={{ scale: 1 }}
                            transition={{ type: "spring", bounce: 0.5 }}
                            className="w-24 h-24 rounded-full border-4 border-primary-green flex items-center justify-center bg-primary-green/10"
                        >
                            <ShieldCheck size={48} className="text-primary-green" />
                        </motion.div>
                        <div>
                            <h2 className="text-3xl font-header font-black text-white tracking-widest mb-2">TRANSMISSION CONFIRMED</h2>
                            <p className="text-primary-green-dim font-mono">The payload has been delivered to the mainframe.</p>
                        </div>
                        <button 
                            onClick={() => setStatus('IDLE')}
                            className="mt-8 px-8 py-3 border border-primary-green/50 hover:bg-primary-green hover:text-black transition-all font-bold font-mono text-xs tracking-widest"
                        >
                            SEND_ANOTHER
                        </button>
                    </motion.div>
                ) : (
                    <motion.form 
                        initial={{ opacity: 0 }} animate={{ opacity: 1 }}
                        onSubmit={handleSubmit}
                        className="space-y-8 max-w-xl mx-auto"
                    >
                        {/* TERMINAL HEADER */}
                        <div className="font-mono text-primary-green text-sm mb-8 opacity-70">
                            <p>&gt; ESTABLISHING SECURE TUNNEL...</p>
                            <p>&gt; ENCRYPTION KEY: RSA-4096</p>
                            <p>&gt; READY FOR INPUT.</p>
                        </div>

                        {/* INPUT: NAME */}
                        <div className="group relative">
                            <label className="absolute -top-3 left-0 text-[10px] font-bold text-primary-green/50 font-mono tracking-widest uppercase bg-black px-1 group-focus-within:text-primary-green transition-colors">
                                CODENAME (Required)
                            </label>
                            <div className="flex items-center border-b border-primary-green/30 group-focus-within:border-primary-green transition-colors py-2">
                                <span className="text-primary-green mr-2 font-mono opacity-50">&gt;</span>
                                <input 
                                    type="text" 
                                    name="name"
                                    required
                                    onKeyDown={handleInput}
                                    className="w-full bg-transparent text-white font-mono focus:outline-none placeholder:text-gray-700 uppercase"
                                    placeholder="ENTER_IDENTITY"
                                />
                            </div>
                        </div>

                        {/* INPUT: EMAIL */}
                        <div className="group relative">
                            <label className="absolute -top-3 left-0 text-[10px] font-bold text-primary-green/50 font-mono tracking-widest uppercase bg-black px-1 group-focus-within:text-primary-green transition-colors">
                                RETURN_ADDRESS (Required)
                            </label>
                            <div className="flex items-center border-b border-primary-green/30 group-focus-within:border-primary-green transition-colors py-2">
                                <span className="text-primary-green mr-2 font-mono opacity-50">&gt;</span>
                                <input 
                                    type="email" 
                                    name="email"
                                    required
                                    onKeyDown={handleInput}
                                    className="w-full bg-transparent text-white font-mono focus:outline-none placeholder:text-gray-700"
                                    placeholder="user@netscape.com"
                                />
                            </div>
                        </div>

                        {/* INPUT: MESSAGE */}
                        <div className="group relative">
                            <label className="absolute -top-3 left-0 text-[10px] font-bold text-primary-green/50 font-mono tracking-widest uppercase bg-black px-1 group-focus-within:text-primary-green transition-colors">
                                PAYLOAD (Message)
                            </label>
                            <div className="flex items-start border-b border-primary-green/30 group-focus-within:border-primary-green transition-colors py-2">
                                <span className="text-primary-green mr-2 font-mono opacity-50 mt-1">&gt;</span>
                                <textarea 
                                    name="message"
                                    required
                                    rows={4}
                                    onKeyDown={handleInput}
                                    className="w-full bg-transparent text-white font-mono focus:outline-none placeholder:text-gray-700 resize-none"
                                    placeholder="Type your transmission here..."
                                />
                            </div>
                        </div>

                        {/* ACTION BAR */}
                        <div className="pt-6">
                            <button 
                                type="submit"
                                disabled={status === 'SENDING'}
                                className={clsx(
                                    "w-full py-4 font-header font-black text-lg tracking-[0.2em] uppercase transition-all flex items-center justify-center gap-4 relative overflow-hidden group btn-glitch",
                                    status === 'SENDING' 
                                        ? "bg-primary-green/20 text-primary-green cursor-wait" 
                                        : "bg-primary-green text-black hover:bg-white"
                                )}
                            >
                                {status === 'SENDING' ? (
                                    <>
                                        <Terminal size={20} className="animate-spin" />
                                        UPLOADING...
                                    </>
                                ) : (
                                    <>
                                        <span>INITIATE_UPLINK</span>
                                        <Send size={20} className="group-hover:translate-x-2 transition-transform" />
                                    </>
                                )}
                                
                                {/* Button Scanline */}
                                {!status && (
                                    <div className="absolute inset-0 bg-white/20 translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-500" />
                                )}
                            </button>
                        </div>
                    </motion.form>
                )}
            </AnimatePresence>
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/ui/os/apps/identity/AboutModal.tsx
=====================================
import { ModalContainer } from '@/ui/os/overlays/ModalContainer';
import identity from '@/engine/config/static/identity.json';
import { StatsRadar } from '@/ui/kit/atoms/StatsRadar';
import { DotGridBackground } from '@/ui/kit/atoms/DotGridBackground';
import { motion } from 'framer-motion';
import { Fingerprint, Hash, ShieldAlert } from 'lucide-react';

export const AboutModal = () => {
  // Normalize stats for radar
  const stats = {
    "STR": 30, // Coding Strength?
    "INT": 100,
    "AGI": 80,
    "CHA": 60,
    "LUCK": 90
  };

  return (
    <ModalContainer title="PERSONA_FILE // CLASSIFIED" type="about">
      <div className="flex flex-col lg:flex-row h-full gap-8 relative">
        <DotGridBackground className="opacity-5" />

        {/* --- LEFT: VISUAL PROFILE --- */}
        <div className="w-full lg:w-1/3 flex flex-col gap-6">
            
            {/* Avatar Frame */}
            <div className="relative aspect-square w-full border-2 border-latent-purple bg-black overflow-hidden group shadow-[0_0_30px_rgba(158,78,165,0.2)]">
                {/* Glitch Image Placeholder */}
                <div className="absolute inset-0 bg-[url('https://media.giphy.com/media/L0qTl8qbSkUIydeumD/giphy.gif')] opacity-20 mix-blend-screen bg-cover" />
                
                <div className="absolute inset-0 flex flex-col items-center justify-center p-4 text-center">
                    <Fingerprint size={48} className="text-latent-purple animate-pulse mb-4" />
                    <span className="text-2xl font-header font-black text-white tracking-widest uppercase drop-shadow-md">
                        {identity.name}
                    </span>
                    <span className="text-[10px] font-mono text-latent-purple-light bg-latent-purple/10 px-2 py-1 mt-2 border border-latent-purple/30">
                        ID: LATENT_SPACE_BANDIT
                    </span>
                </div>

                {/* Corner Brackets */}
                <div className="absolute top-2 left-2 w-4 h-4 border-t-2 border-l-2 border-latent-purple" />
                <div className="absolute bottom-2 right-2 w-4 h-4 border-b-2 border-r-2 border-latent-purple" />
                
                {/* Scanline */}
                <motion.div 
                    className="absolute inset-x-0 h-1 bg-latent-purple/50 shadow-[0_0_10px_#9E4EA5]"
                    animate={{ top: ["0%", "100%"] }}
                    transition={{ duration: 3, repeat: Infinity, ease: "linear" }}
                />
            </div>

            {/* Stats Module */}
            <div className="bg-black/40 border border-latent-purple/20 p-4 flex flex-col items-center relative overflow-hidden">
                <div className="absolute top-0 left-0 px-2 py-1 bg-latent-purple/10 text-[8px] font-mono text-latent-purple font-bold">
                    ATTRIBUTE_MATRIX
                </div>
                <div className="mt-4">
                    <StatsRadar stats={stats} color="#BC86BA" size={180} />
                </div>
            </div>
        </div>

        {/* --- RIGHT: DECRYPTED DATA --- */}
        <div className="flex-1 flex flex-col gap-6 relative">
            
            {/* Header */}
            <div className="border-b border-primary-green/30 pb-4">
                <h2 className="text-4xl md:text-5xl font-header font-black text-primary-green tracking-tighter mb-2 glitch-text">
                    ELFY_
                </h2>
                <div className="flex items-center gap-4 text-xs font-mono text-primary-green-dim">
                    <span className="flex items-center gap-1"><Hash size={12} /> CLASS: ROGUE_DEV</span>
                    <span className="flex items-center gap-1"><ShieldAlert size={12} /> BOUNTY: 5000_BTC</span>
                </div>
            </div>

            {/* Bio */}
            <div className="flex-1 overflow-y-auto pr-2 scrollbar-thin scrollbar-thumb-primary-green/20">
                <p className="text-lg font-mono text-white/90 leading-relaxed mb-6">
                    <span className="text-primary-green font-bold">&gt; BIO_DECRYPT:</span><br/>
                    {identity.bio}
                </p>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    <div className="p-4 border border-primary-green/20 bg-primary-green/5">
                        <h3 className="text-xs font-bold text-primary-green uppercase tracking-widest mb-2 border-b border-primary-green/20 pb-1">
                            Current_Mission
                        </h3>
                        <p className="text-sm font-mono text-primary-green-dim">
                            To bridge the gap between retro aesthetics and modern 3D web technologies.
                        </p>
                    </div>
                    <div className="p-4 border border-latent-purple/20 bg-latent-purple/5">
                        <h3 className="text-xs font-bold text-latent-purple uppercase tracking-widest mb-2 border-b border-latent-purple/20 pb-1">
                            Known_Associates
                        </h3>
                        <p className="text-sm font-mono text-latent-purple-light">
                            React Three Fiber, GLSL, WebAudio API, Next.js.
                        </p>
                    </div>
                </div>

                <div className="space-y-2">
                    <h3 className="text-primary-green font-header font-bold uppercase tracking-wider text-sm">
                        SPECIAL_ABILITIES
                    </h3>
                    <div className="flex flex-wrap gap-2">
                        {identity.abilities.map((ability, i) => (
                            <span 
                                key={i} 
                                className="px-3 py-1 bg-black border border-primary-green text-primary-green font-mono text-xs hover:bg-primary-green hover:text-black transition-colors cursor-default"
                            >
                                [{ability}]
                            </span>
                        ))}
                    </div>
                </div>
            </div>

            {/* Footer */}
            <div className="pt-4 border-t border-white/10 text-[9px] font-mono text-gray-500 flex justify-between">
                <span>LAST_SEEN: CYBERSPACE</span>
                <span>STATUS: ONLINE</span>
            </div>
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/ui/os/apps/gallery/GalleryModal.tsx
=====================================
import { ModalContainer } from '@/ui/os/overlays/ModalContainer';
import gallery from '@/engine/config/static/gallery.json';
import { ExternalLink, Image as ImageIcon } from 'lucide-react';
import { useState } from 'react';

export const GalleryModal = () => {
  const [filter, setFilter] = useState('ALL');
  
  // Get unique categories
  const categories = ['ALL', ...Array.from(new Set(gallery.map(item => item.category)))];

  const filteredGallery = filter === 'ALL' 
    ? gallery 
    : gallery.filter(item => item.category === filter);

  return (
    <ModalContainer title="ART_DATABASE // VISUALS" type="gallery">
      <div className="flex flex-col h-full gap-6">
        
        {/* Category Tabs */}
        <div className="flex gap-2 overflow-x-auto pb-2 border-b border-primary-green-dim/30">
          {categories.map(cat => (
            <button
              key={cat}
              onClick={() => setFilter(cat)}
              className={`px-4 py-1 font-mono text-sm border transition-all ${
                filter === cat 
                  ? 'bg-primary-green text-black border-primary-green' 
                  : 'text-primary-green-dim border-primary-green-dim/30 hover:text-primary-green hover:border-primary-green'
              }`}
            >
              [{cat}]
            </button>
          ))}
        </div>

        {/* The Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {filteredGallery.map((item) => (
            <a
              key={item.id}
              href={item.url}
              target="_blank"
              rel="noopener noreferrer"
              className="group relative aspect-video bg-black border border-primary-green-dim/30 hover:border-primary-green transition-all overflow-hidden"
            >
              {/* Placeholder Graphic (Since we have no images yet) */}
              <div className="absolute inset-0 flex flex-col items-center justify-center bg-primary-green-dark/10 group-hover:bg-primary-green-dark/20 transition-colors">
                <ImageIcon className="w-12 h-12 text-primary-green-dim/20 group-hover:text-primary-green group-hover:scale-110 transition-all duration-500" />
                <span className="mt-2 text-xs text-primary-green-dim/40 font-mono">ENCRYPTED_IMG</span>
              </div>

              {/* Overlay Info */}
              <div className="absolute inset-x-0 bottom-0 p-3 bg-black/80 backdrop-blur-sm border-t border-primary-green-dim/30 translate-y-full group-hover:translate-y-0 transition-transform duration-300">
                <h4 className="text-primary-green font-bold text-sm">{item.title}</h4>
                <div className="flex items-center gap-1 text-[10px] text-latent-purple-light mt-1">
                  <span>OPEN_ON_X</span>
                  <ExternalLink size={10} />
                </div>
              </div>
              
              {/* Corner accent */}
              <div className="absolute top-0 right-0 w-0 h-0 border-t-[20px] border-t-primary-green/20 border-l-[20px] border-l-transparent" />
            </a>
          ))}
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/ui/os/apps/sandbox/layout/HoloHeader.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { Clock, Cpu, Server, Wifi } from 'lucide-react';
import { motion } from 'framer-motion';

const StatPill = ({ icon: Icon, label, value, color = "text-service-cyan" }: any) => (
  <div className="flex items-center gap-3 px-3 py-1 bg-black/40 border border-white/5 rounded-full">
    <Icon size={12} className={`${color} opacity-80`} />
    <span className="text-[9px] font-bold text-gray-500 uppercase">{label}</span>
    <span className={`text-[10px] font-mono ${color}`}>{value}</span>
  </div>
);

export const HoloHeader = () => {
  const { debugFlags, setDebugFlag } = useStore();

  return (
    <div className="h-10 flex items-center justify-between px-4 text-[10px] font-mono select-none border-b border-white/5">
      
      {/* LEFT: Branding */}
      <div className="flex items-center gap-4">
        <div className="flex items-center gap-2">
            <motion.div 
                animate={{ rotate: 360 }}
                transition={{ duration: 4, repeat: Infinity, ease: "linear" }}
                className="w-4 h-4 border-2 border-service-cyan border-t-transparent rounded-full"
            />
            <span className="font-header font-black tracking-widest text-service-cyan text-sm drop-shadow-[0_0_8px_rgba(0,240,255,0.5)]">
                HOLO_DECK <span className="opacity-50 text-[10px]">// v.0.9.2</span>
            </span>
        </div>
      </div>

      {/* CENTER: Data Stream Visualization (Abstract) */}
      <div className="hidden md:flex flex-1 items-center justify-center gap-1 opacity-30 mx-8">
          {Array.from({ length: 32 }).map((_, i) => (
              <motion.div 
                key={i}
                className="w-0.5 bg-service-cyan"
                animate={{ height: [4, 12, 4] }}
                transition={{ 
                    duration: 0.5 + Math.random(), 
                    repeat: Infinity, 
                    delay: Math.random() * 0.5 
                }}
              />
          ))}
      </div>

      {/* RIGHT: Controls */}
      <div className="flex items-center gap-3">
        <div className="flex items-center gap-2 group mr-4">
            <span className="text-service-cyan/50 font-bold">SIM_SPEED:</span>
            <input 
                type="range" 
                min="0.0" max="2.0" step="0.1"
                value={debugFlags.timeScale}
                onChange={(e) => setDebugFlag('timeScale', parseFloat(e.target.value))}
                className="w-24 h-1.5 bg-service-cyan/20 rounded-full appearance-none cursor-pointer accent-service-cyan hover:accent-white transition-all"
            />
            <span className="w-8 text-right font-bold text-white bg-service-cyan/20 px-1 rounded">
                {debugFlags.timeScale.toFixed(1)}x
            </span>
        </div>
        
        <StatPill icon={Cpu} label="CPU" value="OPTIMAL" />
        <StatPill icon={Server} label="MEM" value="UNLIMITED" color="text-latent-purple" />
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/sandbox/layout/HoloLayout.tsx
=====================================
import { ReactNode } from 'react';
import { HoloNav } from './HoloNav';
import { HoloHeader } from './HoloHeader';
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { Power } from 'lucide-react';
import { clsx } from 'clsx';

interface HoloLayoutProps {
  children: ReactNode;
}

export const HoloLayout = ({ children }: HoloLayoutProps) => {
  const { resetApplication } = useStore();

  const handleExit = () => {
      AudioSystem.playSound('ui_menu_close');
      resetApplication();
  };

  return (
    <div className="fixed inset-0 z-[100] font-mono flex flex-col overflow-hidden bg-transparent pointer-events-none">
        
        {/* --- UI FRAME (Interactive) --- */}
        <div className="relative z-50 flex-none flex flex-col border-b border-service-cyan/30 bg-black/40 backdrop-blur-sm shadow-[0_4px_30px_rgba(0,240,255,0.1)] pointer-events-auto">
            <HoloHeader />
            <div className="flex justify-between items-end px-4 pb-0 bg-gradient-to-r from-service-cyan/5 to-transparent">
                <HoloNav />
                <button 
                    onClick={handleExit}
                    onMouseEnter={() => AudioSystem.playHover()}
                    className="group relative flex items-center gap-3 px-6 py-3 text-[10px] font-bold tracking-widest text-critical-red hover:text-black transition-all overflow-hidden border-t border-x border-critical-red/20 hover:border-critical-red rounded-t-sm mb-[-1px]"
                >
                    <div className="absolute inset-0 bg-critical-red translate-y-full group-hover:translate-y-0 transition-transform duration-200" />
                    <Power size={14} className="relative z-10" />
                    <span className="relative z-10">TERMINATE_SIM</span>
                </button>
            </div>
        </div>

        {/* --- MAIN CONTENT AREA --- */}
        <div className="relative z-10 flex-1 overflow-hidden p-6 md:p-10 flex flex-col">
            <div className="flex-1 w-full h-full relative">
                {children}
            </div>
        </div>
        
        {/* --- DECORATIVE HUD ELEMENTS --- */}
        <div className="absolute bottom-4 left-4 text-[9px] text-service-cyan/40 font-mono pointer-events-none">
            COORD: {Math.random().toFixed(4)} // {Math.random().toFixed(4)}
        </div>
        <div className="absolute bottom-4 right-4 text-[9px] text-service-cyan/40 font-mono pointer-events-none flex items-center gap-2">
            <div className="w-2 h-2 rounded-full bg-service-cyan/50 animate-pulse" />
            LIVE_FEED
        </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/sandbox/layout/HoloBackground.tsx
=====================================
import { motion } from 'framer-motion';

export const HoloBackground = () => {
  return (
    <div className="fixed inset-0 z-[50] pointer-events-none overflow-hidden bg-[#020408]">
        {/* Deep Pulse */}
        <motion.div 
            className="absolute inset-0 bg-[radial-gradient(circle_at_center,#0b1a26_0%,#000000_100%)] opacity-80"
            animate={{ scale: [1, 1.1, 1] }}
            transition={{ duration: 10, repeat: Infinity, ease: "easeInOut" }}
        />
        
        {/* Perspective Grid */}
        <div className="absolute inset-0 opacity-20" style={{ perspective: '1000px', transformStyle: 'preserve-3d' }}>
            <motion.div 
                className="absolute inset-[-100%] w-[300%] h-[300%] origin-center"
                style={{ 
                    backgroundImage: `linear-gradient(to right, rgba(0, 240, 255, 0.1) 1px, transparent 1px), linear-gradient(to bottom, rgba(0, 240, 255, 0.1) 1px, transparent 1px)`,
                    backgroundSize: '80px 80px',
                    transform: 'rotateX(60deg) translateZ(-200px)'
                }}
                animate={{ y: [0, 80] }}
                transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
            />
        </div>
        
        {/* Noise & Texture */}
        <div className="absolute inset-0 bg-[url('https://grainy-gradients.vercel.app/noise.svg')] opacity-10 mix-blend-overlay" />
        <div className="absolute inset-0 bg-[radial-gradient(circle,transparent_40%,#000_100%)]" />
        <div className="absolute inset-0 bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,240,255,0.02)_50%)] bg-[length:100%_4px]" />
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/sandbox/layout/HoloNav.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { Speaker, Crosshair, ScanEye, FlaskConical } from 'lucide-react';
import { clsx } from 'clsx';
import { motion } from 'framer-motion';

export type SandboxView = 'lab' | 'audio' | 'arena' | 'gallery';

export const HoloNav = () => {
  const { sandboxView, setSandboxView } = useStore();

  const handleNav = (view: SandboxView) => {
    if (sandboxView === view) return;
    setSandboxView(view);
    AudioSystem.playSound('ui_click');
  };

  const NavItem = ({ id, label, icon: Icon }: { id: SandboxView, label: string, icon: any }) => {
    const isActive = sandboxView === id;
    
    return (
      <button
        onClick={() => handleNav(id)}
        onMouseEnter={() => !isActive && AudioSystem.playHover()}
        className={clsx(
          "relative flex items-center gap-3 px-6 py-3 transition-all duration-300 group overflow-hidden border-t border-x rounded-t-md mx-1 mb-[-1px]",
          isActive 
            ? "border-service-cyan/50 text-black z-10" 
            : "border-transparent text-service-cyan/60 hover:text-service-cyan hover:bg-service-cyan/5"
        )}
      >
        {isActive && (
            <motion.div 
                layoutId="holo-nav-bg"
                className="absolute inset-0 bg-service-cyan shadow-[0_0_20px_rgba(0,240,255,0.4)]"
                initial={false}
                transition={{ type: "spring", bounce: 0.15, duration: 0.5 }}
            />
        )}
        
        {!isActive && (
            <div className="absolute inset-0 bg-gradient-to-b from-transparent via-service-cyan/10 to-transparent translate-y-[-100%] group-hover:translate-y-[100%] transition-transform duration-500" />
        )}

        <Icon size={16} className="relative z-10" strokeWidth={isActive ? 2.5 : 1.5} />
        <span className="font-header font-bold text-xs tracking-widest relative z-10">
            {label}
        </span>
      </button>
    );
  };

  return (
    <div className="flex h-full items-end pt-2">
      <NavItem id="lab" label="VISUAL_LAB" icon={FlaskConical} />
      <NavItem id="audio" label="AUDIO_MATRIX" icon={Speaker} />
      <NavItem id="arena" label="COMBAT_SIM" icon={Crosshair} />
      <NavItem id="gallery" label="MODEL_INSPECTOR" icon={ScanEye} />
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/sandbox/SimulationHUD.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { HoloLayout } from './layout/HoloLayout';
import { AudioMatrix } from './AudioMatrix';
import { ArenaLab } from './ArenaLab';
import { ModelInspector } from './ModelInspector';
import { VisualLab } from './visuals/VisualLab';

export const SimulationHUD = () => {
  const { sandboxView } = useStore();

  return (
    <HoloLayout>
        {sandboxView === 'lab' && <VisualLab />}
        {sandboxView === 'audio' && <AudioMatrix />}
        
        {/* Arena is an Overlay on top of the canvas */}
        {sandboxView === 'arena' && (
            <div className="h-full flex items-start justify-end pointer-events-none">
                <ArenaLab />
            </div>
        )}

        {/* Gallery is also an overlay controlling the separate stage */}
        {sandboxView === 'gallery' && <ModelInspector />}
    </HoloLayout>
  );
};


=====================================
FILE: ./src/ui/os/apps/sandbox/ArenaLab.tsx
=====================================
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { Bug, Trash2, Shield, Plus, Info, Crosshair } from 'lucide-react';
import { useStore } from '@/engine/state/global/useStore';
import { useGameContext } from '@/engine/state/GameContext';
import { clsx } from 'clsx';

export const ArenaLab = () => {
  const { debugFlags, setDebugFlag } = useStore();
  const { spawner, registry } = useGameContext();

  const spawn = (type: string, count: number = 1) => {
      const radius = 10;
      for(let i=0; i<count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const r = 5 + Math.random() * radius;
          const x = Math.cos(angle) * r;
          const y = Math.sin(angle) * r;
          spawner.spawnEnemy(type, x, y);
      }
      AudioSystem.playSound('ui_click');
  };

  const clearEnemies = () => {
      const enemies = registry.getByTag('ENEMY');
      // Iterate copy because destruction modifies the set?
      // getByTag returns a Set, iterating it while deleting is safe in JS Set impl
      // but creating an array is safer for loop logic.
      Array.from(enemies).forEach(e => registry.destroyEntity(e.id as number));
      AudioSystem.playSound('ui_error');
  };

  const SpawnBtn = ({ label, type, count, color = "border-service-cyan/30 text-service-cyan" }: any) => (
      <button 
        onClick={() => spawn(type, count)}
        onMouseEnter={() => AudioSystem.playHover()}
        className={`group relative flex items-center justify-between p-3 border bg-black/40 hover:bg-service-cyan/10 transition-all ${color} backdrop-blur-sm`}
      >
          <div className="absolute left-0 top-0 bottom-0 w-0.5 bg-current opacity-0 group-hover:opacity-100 transition-opacity" />
          <div className="flex flex-col items-start"><span className="text-[10px] font-bold font-header tracking-wider group-hover:text-white transition-colors">{label}</span><span className="text-[8px] opacity-60 font-mono">BATCH_SIZE: {count.toString().padStart(2, '0')}</span></div>
          <Plus size={14} className="opacity-50 group-hover:scale-110 transition-transform" />
      </button>
  );

  return (
    <div className="flex flex-col gap-px w-80 pointer-events-auto h-full max-h-[80vh] bg-[#020408]/90 backdrop-blur-md border border-service-cyan/20 shadow-[0_0_40px_rgba(0,0,0,0.5)] rounded-sm overflow-hidden mt-10 mr-10">
        <div className="p-4 border-b border-service-cyan/20 bg-gradient-to-r from-service-cyan/10 to-transparent flex justify-between items-center"><h3 className="text-sm font-black font-header tracking-widest text-service-cyan flex items-center gap-2"><Bug size={16} /> INJECTION_LAB</h3><div className="w-2 h-2 bg-service-cyan rounded-full animate-pulse shadow-[0_0_10px_#00F0FF]" /></div>
        <div className="p-4 space-y-6 overflow-y-auto flex-1 scrollbar-thin scrollbar-thumb-service-cyan/30">
            <div className="space-y-2"><div className="flex items-center gap-2 text-[9px] font-mono text-service-cyan/50 uppercase tracking-widest mb-1"><Crosshair size={10} /> Hostile Entities</div><div className="grid grid-cols-2 gap-2"><SpawnBtn label="DRILLER" type={EnemyTypes.DRILLER} count={1} /><SpawnBtn label="SWARM" type={EnemyTypes.DRILLER} count={5} /><SpawnBtn label="KAMIKAZE" type={EnemyTypes.KAMIKAZE} count={1} color="border-critical-red/30 text-critical-red" /><SpawnBtn label="HUNTER" type={EnemyTypes.HUNTER} count={1} color="border-alert-yellow/30 text-alert-yellow" /></div></div>
            <div className="space-y-2"><div className="flex items-center gap-2 text-[9px] font-mono text-latent-purple/50 uppercase tracking-widest mb-1"><Shield size={10} /> Defensive Assets</div><SpawnBtn label="DAEMON_CORE" type={EnemyTypes.DAEMON} count={1} color="border-latent-purple/40 text-latent-purple hover:bg-latent-purple/10" /></div>
            <div className="h-px bg-gradient-to-r from-transparent via-service-cyan/20 to-transparent w-full" />
            <div className="space-y-2"><button onClick={() => setDebugFlag('godMode', !debugFlags.godMode)} className={clsx("w-full flex items-center justify-between p-3 border text-xs font-bold transition-all backdrop-blur-sm", debugFlags.godMode ? "bg-service-cyan/20 text-service-cyan border-service-cyan shadow-[0_0_15px_rgba(0,240,255,0.2)]" : "bg-black/40 border-service-cyan/20 text-gray-500 hover:text-service-cyan hover:border-service-cyan/50")}><span>INVULNERABILITY</span><Shield size={14} className={debugFlags.godMode ? "fill-current" : ""} /></button><button onClick={clearEnemies} onMouseEnter={() => AudioSystem.playHover()} className="w-full flex items-center justify-center gap-2 p-3 border border-critical-red/30 text-critical-red hover:bg-critical-red hover:text-black transition-all text-xs font-bold backdrop-blur-sm group"><Trash2 size={14} className="group-hover:scale-110 transition-transform" /> PURGE_ENTITIES</button></div>
        </div>
        <div className="p-3 bg-black/60 border-t border-service-cyan/10 text-[9px] text-gray-500 font-mono flex items-start gap-2"><Info size={12} className="shrink-0 mt-0.5 text-service-cyan" /><p className="leading-relaxed opacity-80">Sandbox mode enables free testing of entity interactions. Metrics may vary from live build.</p></div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/sandbox/ModelInspector.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { clsx } from 'clsx';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { Box, PlayCircle, Crosshair, ChevronRight, Fingerprint, Activity } from 'lucide-react';

const MODELS = [
  { id: EnemyTypes.DAEMON, label: 'DAEMON_CORE', desc: 'Defensive Subroutine.', color: 'text-latent-purple' },
  { id: EnemyTypes.DRILLER, label: 'DRILLER_DRONE', desc: 'Standard Melee Unit.', color: 'text-service-cyan' },
  { id: EnemyTypes.KAMIKAZE, label: 'KAMIKAZE_UNIT', desc: 'Volatile Payload.', color: 'text-critical-red' },
  { id: EnemyTypes.HUNTER, label: 'HUNTER_MK1', desc: 'Ranged Ballistic Unit.', color: 'text-alert-yellow' },
];

const STATES = ['IDLE', 'ATTACK', 'SPAWN', 'DIE'] as const;

export const ModelInspector = () => {
  const { galleryTarget, setGalleryTarget, galleryAction, setGalleryAction } = useStore();
  const currentModel = MODELS.find(m => m.id === galleryTarget) || MODELS[0];

  return (
    <div className="flex flex-col h-full pointer-events-auto relative">
        
        {/* --- LEFT PANEL: LIST --- */}
        <div className="absolute top-10 left-10 w-72 bg-[#020408]/90 backdrop-blur-md border border-service-cyan/20 flex flex-col shadow-[0_0_40px_rgba(0,0,0,0.5)] rounded-sm">
            <div className="p-4 border-b border-service-cyan/20 bg-service-cyan/5">
                <h3 className="text-service-cyan text-xs font-black font-header tracking-widest flex items-center gap-2">
                    <Box size={14} /> ASSET_DATABASE
                </h3>
            </div>
            
            <div className="flex-1 overflow-y-auto max-h-[60vh] scrollbar-thin scrollbar-thumb-service-cyan/20">
                {MODELS.map(model => {
                    const isActive = galleryTarget === model.id;
                    return (
                        <button
                            key={model.id}
                            onClick={() => { setGalleryTarget(model.id); AudioSystem.playClick(); }}
                            onMouseEnter={() => AudioSystem.playHover()}
                            className={clsx(
                                "w-full text-left p-4 border-b border-white/5 transition-all group relative overflow-hidden",
                                isActive ? "bg-white/5" : "hover:bg-white/5"
                            )}
                        >
                            {isActive && <div className="absolute left-0 top-0 bottom-0 w-1 bg-service-cyan shadow-[0_0_15px_#00F0FF]" />}
                            
                            <div className="flex justify-between items-center mb-1">
                                <span className={clsx("font-header font-bold text-xs tracking-wider transition-colors", isActive ? model.color : "text-gray-400 group-hover:text-white")}>
                                    {model.label}
                                </span>
                                {isActive && <ChevronRight size={14} className={model.color} />}
                            </div>
                            <div className="text-[9px] font-mono text-gray-600 group-hover:text-gray-400 transition-colors">
                                {model.desc}
                            </div>
                        </button>
                    );
                })}
            </div>
        </div>

        {/* --- BOTTOM RIGHT: CONTROLS --- */}
        <div className="absolute bottom-10 right-10 w-80 bg-[#020408]/90 backdrop-blur-md border border-service-cyan/20 shadow-[0_0_40px_rgba(0,0,0,0.5)] rounded-sm">
            <div className="p-3 border-b border-service-cyan/20 bg-service-cyan/5 flex justify-between items-center">
                <span className="text-service-cyan text-[10px] font-bold font-header tracking-widest flex items-center gap-2">
                    <Activity size={14} /> ANIMATION_STATE
                </span>
                <PlayCircle size={14} className="text-service-cyan animate-pulse" />
            </div>
            <div className="p-4 grid grid-cols-2 gap-3">
                {STATES.map(state => (
                    <button
                        key={state}
                        onClick={() => { setGalleryAction(state); AudioSystem.playClick(); }}
                        className={clsx(
                            "text-[10px] font-bold font-mono text-center py-3 border transition-all rounded-sm relative overflow-hidden group",
                            galleryAction === state
                                ? "border-service-cyan text-black bg-service-cyan shadow-[0_0_15px_rgba(0,240,255,0.4)]"
                                : "border-white/10 text-gray-500 hover:border-service-cyan/50 hover:text-service-cyan hover:bg-service-cyan/5"
                        )}
                    >
                        {state}
                    </button>
                ))}
            </div>
        </div>

        {/* --- TOP RIGHT: METADATA OVERLAY --- */}
        <div className="absolute top-10 right-10 text-right pointer-events-none">
             <div className="flex flex-col items-end gap-2">
                 <h1 className={clsx("text-5xl font-header font-black tracking-tighter opacity-80 drop-shadow-[0_0_20px_rgba(0,0,0,0.8)]", currentModel.color)}>
                     {currentModel.label}
                 </h1>
                 
                 <div className="flex items-center gap-4 text-xs font-mono text-gray-400 bg-black/60 px-4 py-2 border border-white/10 rounded-full backdrop-blur-sm">
                     <span className="flex items-center gap-2">
                        <Crosshair size={12} /> ID: {currentModel.id}
                     </span>
                     <span className="w-px h-3 bg-white/20" />
                     <span className="flex items-center gap-2">
                        <Fingerprint size={12} /> VER: 2.0.4
                     </span>
                 </div>
             </div>
        </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/sandbox/AudioMatrix.tsx
=====================================
import { AUDIO_MANIFEST } from '@/engine/config/assets/AudioManifest';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { Play, Activity, Music, Radio, Database, Monitor } from 'lucide-react';
import { clsx } from 'clsx';
import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';

const CATEGORIES = [
  { id: 'UI', label: 'SYSTEM_INTERFACE', icon: Monitor, color: 'text-service-cyan', border: 'border-service-cyan', bg: 'bg-service-cyan' },
  { id: 'COMBAT', label: 'COMBAT_PROTOCOL', icon: Activity, color: 'text-critical-red', border: 'border-critical-red', bg: 'bg-critical-red' },
  { id: 'AMBIENCE', label: 'ENVIRONMENTAL', icon: Radio, color: 'text-latent-purple', border: 'border-latent-purple', bg: 'bg-latent-purple' },
  { id: 'LAB_RESOURCES', label: 'SYNTH_ARCHIVE', icon: Database, color: 'text-primary-green', border: 'border-primary-green', bg: 'bg-primary-green' },
];

export const AudioMatrix = () => {
  const [activeCat, setActiveCat] = useState('UI');
  const [playing, setPlaying] = useState<string | null>(null);

  const activeDef = CATEGORIES.find(c => c.id === activeCat) || CATEGORIES[0];
  const sounds = Object.entries(AUDIO_MANIFEST)
    .map(([key, def]) => ({ key, ...def }))
    .filter(s => s.category === activeCat);

  const handlePlay = (key: string) => {
    if (key.includes('ambience')) {
        AudioSystem.playAmbience(key);
    } else {
        AudioSystem.playSound(key);
    }
    setPlaying(key);
    setTimeout(() => setPlaying(null), 300);
  };

  return (
    <div className="flex w-full h-full gap-6 pointer-events-auto p-4 md:p-0">
        <div className="w-16 md:w-64 flex-none flex flex-col gap-2">
            {CATEGORIES.map((cat) => {
                const isActive = activeCat === cat.id;
                return (
                    <button
                        key={cat.id}
                        onClick={() => { setActiveCat(cat.id); AudioSystem.playClick(); }}
                        onMouseEnter={() => AudioSystem.playHover()}
                        className={clsx(
                            "relative group flex items-center h-16 md:h-14 px-0 md:px-4 border-l-2 transition-all duration-300 overflow-hidden",
                            isActive ? `bg-black/60 ${cat.border}` : "border-white/10 hover:border-white/30 hover:bg-white/5"
                        )}
                    >
                        {isActive && <div className={clsx("absolute inset-0 opacity-10", cat.bg)} />}
                        <div className="flex items-center justify-center md:justify-start w-full gap-3 relative z-10">
                            <cat.icon size={20} className={clsx("transition-colors duration-300", isActive ? cat.color : "text-gray-500 group-hover:text-gray-300")} />
                            <span className={clsx("hidden md:block font-header font-bold text-xs tracking-widest uppercase transition-colors duration-300", isActive ? cat.color : "text-gray-500 group-hover:text-gray-300")}>{cat.label}</span>
                        </div>
                    </button>
                );
            })}
        </div>

        <div className="flex-1 flex flex-col bg-[#020408]/80 backdrop-blur-md border border-white/10 rounded-sm shadow-2xl relative overflow-hidden">
            <div className={clsx("h-10 border-b border-white/5 flex items-center justify-between px-4 bg-gradient-to-r from-black via-black to-transparent", activeDef.color)}>
                <div className="flex items-center gap-2">
                    <Music size={14} className="opacity-70" />
                    <span className="font-mono text-xs font-bold tracking-widest">CHANNEL: {activeCat}</span>
                </div>
            </div>

            <div className="flex-1 overflow-y-auto p-4 scrollbar-thin scrollbar-thumb-white/10">
                <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
                    <AnimatePresence mode="popLayout">
                        {sounds.map((sound) => {
                            const isPlaying = playing === sound.key;
                            return (
                                <motion.button
                                    layout
                                    initial={{ opacity: 0, scale: 0.9 }}
                                    animate={{ opacity: 1, scale: 1 }}
                                    exit={{ opacity: 0, scale: 0.9 }}
                                    transition={{ duration: 0.2 }}
                                    key={sound.key}
                                    onClick={() => handlePlay(sound.key)}
                                    className={clsx(
                                        "group relative flex flex-col items-start p-3 border transition-all duration-100 text-left overflow-hidden h-24 hover:shadow-[0_0_15px_rgba(0,0,0,0.5)]",
                                        isPlaying ? `${activeDef.bg} text-black border-transparent scale-95` : `bg-black/40 border-white/10 hover:border-white/30 ${activeDef.color} hover:bg-white/5`
                                    )}
                                >
                                    <div className="flex w-full justify-between items-start mb-2">
                                        <span className="font-bold text-[10px] tracking-wider uppercase opacity-90 line-clamp-1">{sound.label}</span>
                                        <Play size={10} className={clsx("transition-opacity", isPlaying ? "opacity-100" : "opacity-30 group-hover:opacity-100")} />
                                    </div>
                                    <span className="text-[8px] font-mono opacity-50 mb-auto break-all">{sound.key}</span>
                                    <div className="w-full h-0.5 bg-current opacity-20 mt-2 group-hover:opacity-100 transition-opacity relative overflow-hidden">
                                        {isPlaying && <motion.div className="absolute inset-0 bg-white" initial={{ x: "-100%" }} animate={{ x: "100%" }} transition={{ duration: 0.4, ease: "linear" }} />}
                                    </div>
                                </motion.button>
                            );
                        })}
                    </AnimatePresence>
                </div>
            </div>
        </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/sandbox/visuals/VisualLab.tsx
=====================================
import { useState } from 'react';
import { clsx } from 'clsx';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { useStore, LabExperiment } from '@/engine/state/global/useStore';
import { Atom, Zap, RefreshCcw } from 'lucide-react';
import { RangeSlider } from '@/ui/os/apps/settings/components/RangeSlider';
import { DOM_ID } from '@/ui/config/DOMConfig';

const EXPERIMENTS: { id: LabExperiment, label: string, icon: any }[] = [
  { id: 'NONE', label: 'STANDBY', icon: Atom },
  { id: 'GLITCH', label: 'GLITCH_GHOST', icon: Zap },
];

export const VisualLab = () => {
  const { labExperiment, setLabExperiment } = useStore();
  const [paramA, setParamA] = useState(0.5);

  return (
    <div className="absolute inset-0 pointer-events-none flex flex-col">
        <div className="absolute top-20 left-10 w-72 bg-[#020408]/90 backdrop-blur-md border border-service-cyan/20 rounded-sm shadow-xl pointer-events-auto p-4 flex flex-col gap-6">
            <div>
                <h3 className="text-service-cyan font-header font-black tracking-widest text-xs mb-2 border-b border-service-cyan/20 pb-2 flex justify-between items-center">
                    <span>VISUAL_CORTEX</span>
                    <RefreshCcw size={12} className="opacity-50" />
                </h3>
                <div className="space-y-1">
                    {EXPERIMENTS.map(exp => (
                        <button
                            key={exp.id}
                            onClick={() => { setLabExperiment(exp.id); AudioSystem.playClick(); }}
                            onMouseEnter={() => AudioSystem.playHover()}
                            className={clsx(
                                "w-full flex items-center gap-3 px-3 py-2 text-xs font-mono border transition-all",
                                labExperiment === exp.id 
                                    ? "bg-service-cyan/20 border-service-cyan text-service-cyan shadow-[0_0_10px_rgba(0,240,255,0.2)]" 
                                    : "bg-black/40 border-white/5 text-gray-500 hover:text-white hover:bg-white/5"
                            )}
                        >
                            <exp.icon size={14} />
                            {exp.label}
                        </button>
                    ))}
                </div>
            </div>
            {labExperiment === 'GLITCH' && (
                <div className="space-y-4 animate-in fade-in slide-in-from-top-2">
                    <div className="text-[10px] text-service-cyan/60 font-bold uppercase tracking-widest">Parameters</div>
                    <RangeSlider 
                        label="CORRUPTION" 
                        value={paramA} 
                        max={2.0} 
                        onChange={setParamA} 
                        color="text-service-cyan"
                    />
                </div>
            )}
        </div>
        {labExperiment === 'NONE' && (
            <div className="flex-1 w-full h-full flex items-center justify-center animate-in fade-in zoom-in-95 duration-500">
                <div className="text-center opacity-50 flex flex-col items-center gap-4">
                    <div className="relative">
                        <div className="absolute inset-0 bg-service-cyan blur-2xl opacity-20 animate-pulse" />
                        <Atom size={80} className="relative z-10 text-service-cyan animate-spin-slow" strokeWidth={1} />
                    </div>
                    <div className="flex flex-col gap-1">
                        <span className="font-header font-black text-xl text-service-cyan tracking-[0.2em]">AWAITING_INPUT</span>
                        <span className="font-mono text-xs text-service-cyan/60">SELECT EXPERIMENT TO INITIALIZE</span>
                    </div>
                </div>
            </div>
        )}
        <div id={DOM_ID.LAB_PARAMS} data-a={paramA} className="hidden" />
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/mobile/MobileRejectionModal.tsx
=====================================
import { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Smartphone, Cpu, Scan, Biohazard, Waves, Ban, Skull, AlertTriangle, Terminal } from 'lucide-react';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { DotGridBackground } from '@/ui/kit/atoms/DotGridBackground';
import { clsx } from 'clsx';

interface Props {
  onComplete: () => void;
}

const STEPS = [
  { id: 'SCAN', duration: 2000, color: 'text-primary-green', border: 'border-primary-green' },
  { id: 'HARDWARE', duration: 2500, color: 'text-alert-yellow', border: 'border-alert-yellow' },
  { id: 'GPU', duration: 2500, color: 'text-critical-red', border: 'border-critical-red' },
  { id: 'ENV', duration: 3500, color: 'text-latent-purple', border: 'border-latent-purple' },
  { id: 'DENIED', duration: 3000, color: 'text-critical-red', border: 'border-critical-red' },
];

export const MobileRejectionModal = ({ onComplete }: Props) => {
  const [stepIndex, setStepIndex] = useState(0);
  const currentStep = STEPS[stepIndex];

  useEffect(() => {
    let timer: NodeJS.Timeout;

    const advance = () => {
      if (stepIndex < STEPS.length - 1) {
        setStepIndex(prev => prev + 1);
        
        // Audio Logic per step
        const nextId = STEPS[stepIndex + 1].id;
        if (nextId === 'DENIED') AudioSystem.playSound('ui_error');
        else if (nextId === 'ENV') AudioSystem.playSound('ui_chirp');
        else AudioSystem.playClick();
        
      } else {
        AudioSystem.playSound('fx_boot_sequence'); 
        onComplete();
      }
    };

    timer = setTimeout(advance, currentStep.duration);
    return () => clearTimeout(timer);
  }, [stepIndex, onComplete, currentStep]);

  return (
    <div className="absolute inset-0 flex items-center justify-center p-4 md:p-0">
      
      {/* Main Container Frame */}
      <motion.div 
        initial={{ scaleY: 0, opacity: 0 }}
        animate={{ scaleY: 1, opacity: 1 }}
        transition={{ duration: 0.3 }}
        className={clsx(
            "relative w-full max-w-sm bg-black/90 backdrop-blur-md border-y-2 overflow-hidden transition-colors duration-500 flex flex-col shadow-[0_0_50px_rgba(0,0,0,0.8)]",
            currentStep.border
        )}
      >
        {/* Background Texture Layers */}
        <DotGridBackground color={currentStep.id === 'DENIED' ? '#FF003C' : '#15530A'} />
        
        {/* Animated Stripes Background */}
        <div className={clsx(
            "absolute inset-0 opacity-10 pointer-events-none transition-colors duration-500",
            stepIndex >= 2 ? "bg-[repeating-linear-gradient(45deg,transparent,transparent_10px,currentColor_10px,currentColor_12px)]" : ""
        )} style={{ color: stepIndex >= 4 ? '#FF003C' : '#9E4EA5' }} />

        {/* HEADER */}
        <div className={clsx("flex items-center justify-between px-4 py-2 border-b bg-black/50 transition-colors duration-500", currentStep.border)}>
            <div className="flex items-center gap-2">
                <Terminal size={14} className={currentStep.color} />
                <span className={clsx("text-[10px] font-header font-black tracking-widest uppercase", currentStep.color)}>
                    SYS_ANALYSIS_TOOL
                </span>
            </div>
            <div className="text-[9px] font-mono opacity-50">v.MOBILE.0.1</div>
        </div>

        {/* CONTENT AREA */}
        <div className="relative z-10 py-12 px-6 min-h-[320px] flex flex-col items-center justify-center">
            <AnimatePresence mode="wait">
            
            {/* STEP 1: SCANNING */}
            {currentStep.id === 'SCAN' && (
                <motion.div 
                key="scan"
                initial={{ opacity: 0, scale: 0.9 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 1.1, filter: "blur(10px)" }}
                className="flex flex-col items-center gap-6 w-full"
                >
                <div className="relative w-24 h-24 border border-primary-green/30 bg-primary-green/5 flex items-center justify-center">
                    <Scan size={48} className="text-primary-green animate-pulse" />
                    <motion.div 
                        className="absolute inset-0 border-b-2 border-primary-green shadow-[0_0_15px_#78F654]"
                        animate={{ top: ['0%', '100%', '0%'] }}
                        transition={{ duration: 1.5, repeat: Infinity, ease: "linear" }}
                    />
                    {/* Corner Accents */}
                    <div className="absolute top-0 left-0 w-2 h-2 border-t border-l border-primary-green" />
                    <div className="absolute top-0 right-0 w-2 h-2 border-t border-r border-primary-green" />
                    <div className="absolute bottom-0 left-0 w-2 h-2 border-b border-l border-primary-green" />
                    <div className="absolute bottom-0 right-0 w-2 h-2 border-b border-r border-primary-green" />
                </div>
                
                <div className="flex flex-col items-center gap-1">
                    <span className="text-primary-green font-bold tracking-widest animate-pulse text-sm">
                        SCANNING_FINGERPRINT...
                    </span>
                    <span className="text-[10px] text-primary-green-dim font-mono">
                        [ USER_AGENT_PARSING ]
                    </span>
                </div>
                </motion.div>
            )}

            {/* STEP 2: HARDWARE */}
            {currentStep.id === 'HARDWARE' && (
                <motion.div 
                key="hw"
                initial={{ opacity: 0, x: 50 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: -50 }}
                className="flex flex-col items-center gap-6 text-center w-full"
                >
                <div className="w-24 h-24 rounded-full border border-alert-yellow/30 bg-alert-yellow/5 flex items-center justify-center relative overflow-hidden">
                    <div className="absolute inset-0 animate-spin-slow border-t border-alert-yellow opacity-50 rounded-full" />
                    <Smartphone size={40} className="text-alert-yellow drop-shadow-[0_0_10px_rgba(247,210,119,0.5)]" />
                </div>

                <div className="flex flex-col w-full border-l-2 border-alert-yellow pl-4 text-left bg-gradient-to-r from-alert-yellow/10 to-transparent py-2">
                    <span className="text-[9px] text-alert-yellow opacity-70 uppercase tracking-widest mb-1">HARDWARE_ID_FOUND</span>
                    <span className="text-xl text-alert-yellow font-black tracking-wider leading-none">
                    POCKET_DEVICE
                    </span>
                    <span className="text-[10px] text-white/60 font-mono mt-1">
                    CLASS: CONSUMER_GRADE
                    </span>
                </div>
                </motion.div>
            )}

            {/* STEP 3: GPU */}
            {currentStep.id === 'GPU' && (
                <motion.div 
                key="gpu"
                initial={{ opacity: 0, scale: 0.5 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 1.5 }}
                className="flex flex-col items-center gap-6 text-center w-full"
                >
                <div className="relative">
                    <Cpu size={64} className="text-critical-red animate-pulse" />
                    <AlertTriangle size={24} className="absolute -top-2 -right-2 text-critical-red bg-black rounded-full" />
                </div>

                <div className="flex flex-col items-center w-full px-4">
                    <span className="text-[10px] text-critical-red/70 uppercase tracking-widest mb-2">COMPUTE_POWER_ANALYSIS</span>
                    <span className="text-3xl text-critical-red font-black tracking-widest glitch-text drop-shadow-[0_0_10px_#FF003C]">
                    LAUGHABLE
                    </span>
                    
                    {/* Tech Bar */}
                    <div className="w-full bg-gray-900 h-3 mt-4 skew-x-[-12deg] overflow-hidden border border-critical-red/30 p-0.5">
                        <div className="h-full bg-critical-red w-[2%] shadow-[0_0_10px_#FF003C] animate-pulse" />
                    </div>
                    <span className="text-[9px] text-critical-red mt-1 font-mono w-full text-right">CAPACITY: 1.2%</span>
                </div>
                </motion.div>
            )}

            {/* STEP 4: THE TOILET BIT */}
            {currentStep.id === 'ENV' && (
                <motion.div 
                key="env"
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -20 }}
                className="flex flex-col items-center gap-8 text-center w-full"
                >
                {/* Composite Icon Animation */}
                <div className="relative w-32 h-32 flex items-center justify-center bg-black/50 border border-latent-purple/30 rounded-full">
                    <motion.div 
                        animate={{ y: [0, -5, 0] }} 
                        transition={{ duration: 2, repeat: Infinity, ease: "easeInOut" }}
                        className="z-10"
                    >
                        <Smartphone size={48} className="text-latent-purple" />
                    </motion.div>
                    
                    <motion.div 
                        className="absolute bottom-4 text-service-cyan opacity-50"
                        animate={{ scaleX: [1, 1.2, 1], opacity: [0.3, 0.6, 0.3] }} 
                        transition={{ duration: 3, repeat: Infinity }}
                    >
                        <Waves size={64} />
                    </motion.div>

                    <motion.div 
                        className="absolute top-0 right-0 text-alert-yellow bg-black rounded-full p-1 border border-alert-yellow"
                        animate={{ scale: [1, 1.2, 1] }} 
                        transition={{ duration: 0.5, repeat: Infinity, repeatDelay: 0.5 }}
                    >
                        <Biohazard size={20} />
                    </motion.div>
                </div>

                <div className="flex flex-col gap-1">
                    <span className="text-[10px] text-latent-purple-light uppercase tracking-widest">GPS_TRIANGULATION_COMPLETE</span>
                    <span className="text-xs font-bold text-gray-400">ENVIRONMENT DETECTED:</span>
                    <div className="relative mt-1">
                        <div className="absolute inset-0 bg-latent-purple blur-lg opacity-20" />
                        <span className="relative z-10 text-2xl font-black text-latent-purple tracking-widest uppercase">
                        CERAMIC_THRONE
                        </span>
                    </div>
                </div>
                </motion.div>
            )}

            {/* STEP 5: DENIED */}
            {currentStep.id === 'DENIED' && (
                <motion.div 
                key="denied"
                initial={{ opacity: 0, scale: 1.2 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, filter: "blur(20px)" }}
                transition={{ type: "spring", stiffness: 300, damping: 15 }}
                className="flex flex-col items-center gap-6 text-center w-full"
                >
                <div className="relative p-6 border-2 border-critical-red bg-critical-red/5">
                    <Ban size={64} className="text-critical-red animate-pulse" />
                    <Skull size={32} className="text-white absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2" />
                    
                    {/* Glitch Overlay */}
                    <div className="absolute inset-0 bg-critical-red/10 mix-blend-overlay animate-pulse" style={{ clipPath: 'polygon(0 0, 100% 0, 100% 10%, 0 10%)' }} />
                </div>
                
                <div className="flex flex-col gap-3 w-full">
                    <h1 className="text-3xl font-black text-critical-red tracking-widest bg-black border-y border-critical-red py-2">
                    ACCESS DENIED
                    </h1>
                    <p className="text-xs text-gray-400 font-mono max-w-[240px] mx-auto leading-relaxed border-l-2 border-critical-red pl-3 text-left">
                    You cannot hack the mainframe from the bathroom.
                    </p>
                    <div className="mt-4 pt-4 border-t border-white/10 w-full">
                        <div className="flex items-center justify-between text-[10px] font-mono text-primary-green">
                            <span className="animate-pulse">LOADING: DOOMSCROLL_PROTOCOL</span>
                            <span>[ 99% ]</span>
                        </div>
                        <div className="h-1 w-full bg-gray-800 mt-1">
                            <motion.div 
                                className="h-full bg-primary-green" 
                                initial={{ width: 0 }}
                                animate={{ width: "100%" }}
                                transition={{ duration: 2.0, ease: "circOut" }}
                            />
                        </div>
                    </div>
                </div>
                </motion.div>
            )}

            </AnimatePresence>
        </div>

        {/* FOOTER */}
        <div className={clsx("px-4 py-2 border-t bg-black/80 flex justify-between items-center text-[9px] font-mono transition-colors duration-500", currentStep.border)}>
            <span className={currentStep.color}>{currentStep.id}_MODULE_ACTIVE</span>
            <span className="opacity-50">SECURE_CHANNEL: FALSE</span>
        </div>

        {/* Progress Bar (Global) */}
        <div className="absolute bottom-0 left-0 h-0.5 bg-gray-900 w-full z-20">
            <motion.div 
                className={clsx("h-full transition-colors duration-500", currentStep.id === 'DENIED' ? "bg-critical-red" : "bg-primary-green")}
                initial={{ width: "0%" }}
                animate={{ width: `${((stepIndex + 1) / STEPS.length) * 100}%` }}
                transition={{ duration: 0.5 }}
            />
        </div>
      </motion.div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/mobile/MobileExperience.tsx
=====================================
import { useState, useEffect } from 'react';
import { MobileRejectionModal } from './MobileRejectionModal';
import { Canvas } from '@react-three/fiber';
import { MobileGameDirector } from '@/ui/sim/MobileGameDirector';
import { RenderDirector } from '@/ui/sim/RenderDirector';
import { CameraRig } from '@/ui/sim/vfx/CameraRig';
import { SocialRow } from '@/ui/kit/molecules/SocialRow';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { Skull, Monitor, ExternalLink, AlertTriangle } from 'lucide-react';
import { GlassPanel } from '@/ui/kit/atoms/GlassPanel';
import { motion, AnimatePresence } from 'framer-motion';
import { clsx } from 'clsx';
import { PanelId } from '@/engine/config/PanelConfig';
import { CAMERA_CONFIG } from '@/engine/config/CameraConfig';

const MOBILE_PANEL_HP = 100;

const SocialPanelWrapper = () => {
    return (
        <div className="w-full max-w-sm pointer-events-auto">
            <GlassPanel title="SOCIAL_UPLINK" gameId={PanelId.SOCIAL} className="bg-black/90" maxHealth={MOBILE_PANEL_HP}>
                <SocialRow layout="column" />
            </GlassPanel>
        </div>
    );
};

export const MobileExperience = () => {
  const [phase, setPhase] = useState<'intro' | 'game'>('intro');
  const [showFailureModal, setShowFailureModal] = useState(false);
  const setIntegrity = useGameStore(s => (val: number) => useGameStore.setState({ systemIntegrity: val }));

  useEffect(() => {
      const unsub = GameEventBus.subscribe(GameEvents.PANEL_DESTROYED, (p) => {
          if (p.id === PanelId.SOCIAL) {
              AudioSystem.playSound('fx_player_death');
              setIntegrity(0);
              setTimeout(() => {
                  setShowFailureModal(true);
                  AudioSystem.playSound('fx_impact_heavy');
              }, 4000);
          }
      });
      return unsub;
  }, [setIntegrity]);

  return (
    <div className="absolute inset-0 z-[80] w-full h-full overflow-hidden text-primary-green pointer-events-none">
        {phase === 'intro' && (
            <div className="pointer-events-auto w-full h-full relative z-50">
                <MobileRejectionModal onComplete={() => setPhase('game')} />
            </div>
        )}
        {phase === 'game' && (
            <>
                <div className="absolute inset-0 z-0 pointer-events-auto">
                    <Canvas
                        orthographic
                        camera={{ zoom: CAMERA_CONFIG.BASE_ZOOM, position: [0, 0, 100] }}
                        gl={{ alpha: true, antialias: true }}
                    >
                        <MobileGameDirector />
                        <CameraRig />
                        <RenderDirector />
                    </Canvas>
                </div>
                <div className="absolute inset-0 z-10 flex items-center justify-center p-4 pointer-events-none">
                    <SocialPanelWrapper />
                </div>
                {!showFailureModal && (
                    <div className="absolute bottom-10 w-full text-center animate-pulse z-20 pointer-events-none">
                        <span className="bg-black/80 px-4 py-1 text-xs font-mono border border-primary-green/30">
                            TAP TARGETS TO DESTROY
                        </span>
                    </div>
                )}
                <AnimatePresence>
                    {showFailureModal && (
                        <motion.div 
                            initial={{ opacity: 0 }} 
                            animate={{ opacity: 1 }} 
                            transition={{ duration: 0.5 }}
                            className="absolute inset-0 z-50 bg-black/60 backdrop-blur-sm flex items-center justify-center p-6 pointer-events-auto"
                        >
                            <motion.div 
                                initial={{ scale: 0.8, y: 20 }}
                                animate={{ scale: 1, y: 0 }}
                                transition={{ type: "spring", bounce: 0.4 }}
                                className="w-full max-w-sm border-2 border-critical-red bg-black shadow-[0_0_50px_rgba(255,0,60,0.4)] overflow-hidden flex flex-col"
                            >
                                <div className="bg-critical-red px-4 py-2 flex items-center justify-between">
                                    <div className="flex items-center gap-2 text-black font-black tracking-widest">
                                        <AlertTriangle size={18} />
                                        <span>CRITICAL_ERROR</span>
                                    </div>
                                    <Skull size={18} className="text-black" />
                                </div>
                                <div className="p-8 flex flex-col items-center text-center relative">
                                    <div className="absolute inset-0 opacity-10 bg-[repeating-linear-gradient(45deg,transparent,transparent_10px,#FF003C_10px,#FF003C_12px)] pointer-events-none" />
                                    <motion.div 
                                        initial={{ scale: 0 }} animate={{ scale: 1 }} 
                                        transition={{ type: 'spring', stiffness: 200, damping: 12 }}
                                        className="mb-6 relative"
                                    >
                                        <Skull size={80} className="text-critical-red mx-auto drop-shadow-[0_0_15px_#FF003C]" />
                                    </motion.div>
                                    <h1 className="text-4xl font-black text-critical-red tracking-widest mb-2 glitch-text">
                                        SYSTEM<br/>FAILURE
                                    </h1>
                                    <p className="text-xs font-mono text-critical-red/70 mb-8 uppercase tracking-widest">
                                        0x0000DEAD // CORE_DUMPED
                                    </p>
                                    <div className="w-full space-y-3 relative z-10">
                                        <div className="bg-critical-red/10 border border-critical-red/30 p-3">
                                            <p className="text-[10px] text-critical-red font-mono leading-relaxed">
                                                MOBILE_TERMINAL_DESTROYED.<br/>
                                                PLEASE MIGRATE TO WORKSTATION.
                                            </p>
                                        </div>
                                        <a 
                                            href="https://mesoelfy.github.io" 
                                            target="_blank"
                                            rel="noopener noreferrer"
                                            className="group block w-full py-3 bg-critical-red text-black font-bold font-header tracking-widest hover:bg-white hover:text-critical-red transition-all flex items-center justify-center gap-2"
                                        >
                                            <Monitor size={16} />
                                            <span>mesoelfy.github.io</span>
                                            <ExternalLink size={14} className="opacity-50 group-hover:opacity-100" />
                                        </a>
                                    </div>
                                </div>
                                <div className="bg-gray-900 px-4 py-1 flex justify-between text-[8px] font-mono text-gray-500">
                                    <span>ERR_CODE: ID_10_T</span>
                                    <span>REBOOT_REQUIRED</span>
                                </div>
                            </motion.div>
                        </motion.div>
                    )}
                </AnimatePresence>
            </>
        )}
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/feed/FeedModal.tsx
=====================================
import { ModalContainer } from '@/ui/os/overlays/ModalContainer';
import feed from '@/engine/config/static/feed.json';
import { ExternalLink } from 'lucide-react';

export const FeedModal = () => {
  return (
    <ModalContainer title="SYSTEM_LOGS // FEED" type="feed">
      <div className="space-y-6 font-mono">
        {feed.map((post) => (
          <div key={post.id} className="border-l-2 border-primary-green-dim pl-4 py-2 hover:bg-primary-green/5 transition-colors group">
            <div className="flex items-center gap-4 mb-2">
              <span className="text-xs text-primary-green-dim bg-primary-green-dark/30 px-2 py-1 rounded">
                [{post.date}]
              </span>
              <h3 className="text-xl font-bold text-primary-green group-hover:text-alert-yellow transition-colors">
                {post.title}
              </h3>
            </div>
            
            <p className="text-primary-green-dim/80 mb-3 max-w-2xl">
              {post.desc}
            </p>

            <a 
              href={post.link}
              target="_blank"
              rel="noopener noreferrer"
              className="inline-flex items-center gap-2 text-sm text-latent-purple-light hover:text-primary-green underline decoration-latent-purple-dim decoration-dashed underline-offset-4"
            >
              <span>VIEW_SOURCE</span>
              <ExternalLink size={14} />
            </a>
          </div>
        ))}
        
        {/* End of Log Marker */}
        <div className="text-center py-8 text-primary-green-dim/30 animate-pulse">
          -- END OF STREAM --
        </div>
      </div>
    </ModalContainer>
  );
};


=====================================
FILE: ./src/ui/os/apps/debug/tabs/OverridesTab.tsx
=====================================
import { Play, Sparkles, Trash2, Skull, RefreshCw, Crown, Ghost, Shield, Crosshair } from 'lucide-react';
import { clsx } from 'clsx';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { useGameContext } from '@/engine/state/GameContext';
import { IPanelSystem } from '@/engine/interfaces';
import { GameEvents } from '@/engine/signals/GameEvents';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { DOM_ATTR } from '@/ui/config/DOMConfig';

interface OverridesTabProps {
  closeDebug: () => void;
}

export const OverridesTab = ({ closeDebug }: OverridesTabProps) => {
  const { setIntroDone, setBootState, bootState, resetApplication, debugFlags, setDebugFlag, resetDebugFlags } = useStore();
  const { startGame, stopGame, activateZenMode } = useGameStore();
  const { getSystem, events } = useGameContext();

  const areAllGodModesOn = debugFlags.godMode && debugFlags.panelGodMode && debugFlags.peaceMode;

  const handleSkipBoot = () => {
    resetDebugFlags();
    setIntroDone(true);
    setBootState('active');
    AudioSystem.init();
    AudioSystem.startMusic();
    startGame();
    closeDebug(); 
  };

  const executeCrash = () => {
      const panels = getSystem<IPanelSystem>('PanelRegistrySystem');
      if (panels) panels.destroyAll();
      useGameStore.setState({ systemIntegrity: 0 });
      events.emit(GameEvents.GAME_OVER, { score: 0 });
      stopGame();
  };

  const handleForceCrash = () => {
    if (bootState === 'standby') {
        setIntroDone(true);
        setBootState('active');
        AudioSystem.init();
        setTimeout(() => { executeCrash(); }, 100);
    } else { executeCrash(); }
    closeDebug();
  };

  const handleReboot = () => {
    useGameStore.setState({ playerHealth: 100, playerRebootProgress: 0 });
    const panels = getSystem<IPanelSystem>('PanelRegistrySystem');
    if (panels) {
        const list = panels.getAllPanels();
        list.forEach((p: any) => panels.healPanel(p.id, 1000));
    }
    closeDebug();
  };

  const handleZenModeWrapper = () => {
      if (bootState === 'standby') {
          setIntroDone(true);
          setBootState('active');
          AudioSystem.init();
          AudioSystem.startMusic();
      }
      activateZenMode();
      closeDebug();
  };

  const handleSystemFormat = () => { resetApplication(); };

  const toggleGodSuite = () => {
      const newState = !areAllGodModesOn;
      if (newState) AudioSystem.playSound('ui_optimal');
      else AudioSystem.playSound('ui_click');
      setDebugFlag('godMode', newState);
      setDebugFlag('panelGodMode', newState);
      setDebugFlag('peaceMode', newState);
  };

  const btnClass = "flex items-center justify-center gap-2 p-3 border transition-all text-xs font-bold";
  const interactiveAttr = { [DOM_ATTR.INTERACTIVE]: "true" };

  return (
    <div className="space-y-6">
      <div className="space-y-3">
        <h3 className="text-xs text-primary-green-dim border-b border-primary-green-dim/30 pb-1 mb-2">SCENE_SELECT</h3>
        <div className="grid grid-cols-2 gap-3">
          <button onClick={handleSkipBoot} onMouseEnter={() => AudioSystem.playHover()} className={`${btnClass} border-primary-green/50 hover:bg-primary-green hover:text-black`}><Play size={14} /> SKIP_BOOT</button>
          <button onClick={handleZenModeWrapper} onMouseEnter={() => AudioSystem.playHover()} className="relative flex items-center justify-center gap-2 p-3 overflow-hidden group transition-all duration-300 border border-transparent hover:border-white/50"><div className="absolute inset-0 opacity-20 group-hover:opacity-40 bg-gradient-to-r from-red-500 via-yellow-500 via-green-500 via-blue-500 to-purple-500 animate-gradient-xy transition-opacity" /><div className="relative z-10 flex items-center gap-2 text-transparent bg-clip-text bg-gradient-to-r from-red-400 via-yellow-400 to-blue-400 font-bold tracking-widest text-xs group-hover:text-white transition-colors"><Sparkles size={14} className="text-yellow-300" /> ZEN_MODE</div></button>
          <button onClick={handleSystemFormat} onMouseEnter={() => AudioSystem.playHover()} className="col-span-2 flex items-center justify-center gap-2 p-3 border border-gray-500/50 text-gray-400 hover:bg-white hover:text-black transition-all text-xs font-bold"><Trash2 size={14} /> SYSTEM_FORMAT</button>
        </div>
      </div>
      <div className="space-y-3">
        <h3 className="text-xs text-primary-green-dim border-b border-primary-green-dim/30 pb-1 mb-2">STATE_OVERRIDES</h3>
        <div className="grid grid-cols-2 gap-3">
          <button onClick={handleForceCrash} onMouseEnter={() => AudioSystem.playHover()} className={`${btnClass} border-critical-red/50 text-critical-red hover:bg-critical-red hover:text-black`}><Skull size={14} /> FORCE_CRASH</button>
          <button onClick={handleReboot} onMouseEnter={() => AudioSystem.playHover()} className={`${btnClass} border-latent-purple/50 text-latent-purple hover:bg-latent-purple hover:text-black`}><RefreshCw size={14} /> REBOOT_CORE</button>
        </div>
      </div>
      <div className="space-y-3">
        <h3 className="text-xs text-primary-green-dim border-b border-primary-green-dim/30 pb-1 mb-2">GOD_SUITE</h3>
        <button onClick={toggleGodSuite} onMouseEnter={() => AudioSystem.playHover()} className={clsx("w-full flex items-center justify-center gap-2 p-2 mb-3 text-xs font-bold transition-all border", areAllGodModesOn ? "bg-primary-green text-black border-primary-green shadow-[0_0_10px_rgba(0,255,65,0.4)]" : "bg-primary-green/10 text-primary-green border-primary-green/50 hover:bg-primary-green hover:text-black")}><Crown size={14} className={areAllGodModesOn ? "fill-black" : ""} />{areAllGodModesOn ? "DISABLE_ALL" : "ENABLE_MAX_POWER"}</button>
        <label {...interactiveAttr} onMouseEnter={() => AudioSystem.playHover()} className="flex items-center justify-between p-3 border border-primary-green/30 hover:border-primary-green hover:bg-primary-green/20 cursor-pointer transition-all select-none"><span className="text-xs font-bold flex items-center gap-2"><Ghost size={14} /> GHOST_MODE</span><input type="checkbox" checked={debugFlags.godMode} onChange={(e) => setDebugFlag('godMode', e.target.checked)} className="accent-primary-green cursor-pointer" /></label>
        <label {...interactiveAttr} onMouseEnter={() => AudioSystem.playHover()} className="flex items-center justify-between p-3 border border-primary-green/30 hover:border-primary-green hover:bg-primary-green/20 cursor-pointer transition-all select-none"><span className="text-xs font-bold flex items-center gap-2"><Shield size={14} /> FORTRESS_MODE</span><input type="checkbox" checked={debugFlags.panelGodMode} onChange={(e) => setDebugFlag('panelGodMode', e.target.checked)} className="accent-primary-green cursor-pointer" /></label>
        <label {...interactiveAttr} onMouseEnter={() => AudioSystem.playHover()} className="flex items-center justify-between p-3 border border-primary-green/30 hover:border-primary-green hover:bg-primary-green/20 cursor-pointer transition-all select-none"><span className="text-xs font-bold flex items-center gap-2"><Crosshair size={14} /> PEACE_PROTOCOL</span><input type="checkbox" checked={debugFlags.peaceMode} onChange={(e) => setDebugFlag('peaceMode', e.target.checked)} className="accent-primary-green cursor-pointer" /></label>
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/debug/tabs/ConsoleTab.tsx
=====================================
import { useEffect, useRef, useState } from 'react';
import { Copy, Check } from 'lucide-react';
import { AudioSystem } from '@/engine/audio/AudioSystem';

interface ConsoleTabProps {
  logs: { time: string, msg: string, type: string }[];
}

export const ConsoleTab = ({ logs }: ConsoleTabProps) => {
  const logEndRef = useRef<HTMLDivElement>(null);
  const [copied, setCopied] = useState(false);

  useEffect(() => {
    if (logEndRef.current) {
        logEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [logs]);

  const handleCopy = () => {
      const text = logs.map(l => `[${l.time}] ${l.msg}`).join('\n');
      navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
      AudioSystem.playClick();
  };

  return (
    <div className="h-full flex flex-col relative">
        <div className="flex-1 overflow-y-auto font-mono text-[10px] space-y-1 pr-2 pb-8">
            {logs.length === 0 && (
                <div className="text-primary-green-dim opacity-50 italic mt-4">-- NO SIGNIFICANT EVENTS --</div>
            )}
            {logs.map((l, i) => (
                <div key={i} className="flex gap-2 opacity-80 hover:opacity-100 border-b border-white/5 py-0.5">
                    <span className="text-primary-green-dim shrink-0">[{l.time}]</span>
                    <span className={l.type.includes('ERROR') || l.type.includes('CRITICAL') ? 'text-critical-red font-bold' : 'text-primary-green break-all'}>{l.msg}</span>
                </div>
            ))}
            <div ref={logEndRef} />
        </div>
        
        <button 
            onClick={handleCopy}
            onMouseEnter={() => AudioSystem.playHover()}
            className="absolute bottom-0 right-0 flex items-center gap-2 bg-primary-green/10 hover:bg-primary-green/20 border border-primary-green/30 text-primary-green px-3 py-1.5 text-xs font-bold transition-all backdrop-blur-sm"
        >
            {copied ? <Check size={12} /> : <Copy size={12} />}
            {copied ? "COPIED" : "COPY LOG"}
        </button>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/debug/tabs/StatsTab.tsx
=====================================
import { Cpu, Database, LayoutTemplate } from 'lucide-react';
import { useStore } from '@/engine/state/global/useStore';
import { AudioSystem } from '@/engine/audio/AudioSystem';

interface StatsTabProps {
  stats: { active: number, pooled: number, total: number, fps: number };
}

export const StatsTab = ({ stats }: StatsTabProps) => {
  const { toggleDebugMinimize } = useStore();
  
  return (
    <div className="space-y-6">
      <div className="space-y-3">
        <h3 className="text-xs text-primary-green-dim border-b border-primary-green-dim/30 pb-1 mb-2">ENTITY_REGISTRY</h3>
        <div className="grid grid-cols-2 gap-4">
          <div className="bg-primary-green/5 p-4 border border-primary-green/20">
              <div className="flex items-center gap-2 text-primary-green-dim mb-2 text-xs"><Cpu size={14} /> ACTIVE ENTITIES</div>
              <div className="text-3xl font-bold text-primary-green">{stats.active}</div>
          </div>
          <div className="bg-primary-green/5 p-4 border border-primary-green/20">
              <div className="flex items-center gap-2 text-primary-green-dim mb-2 text-xs"><Database size={14} /> MEMORY POOL</div>
              <div className="text-3xl font-bold text-primary-green-dim">{stats.pooled} <span className="text-xs font-normal opacity-50">/ {stats.total}</span></div>
          </div>
        </div>
      </div>
      <div className="space-y-3">
        <h3 className="text-xs text-primary-green-dim border-b border-primary-green-dim/30 pb-1 mb-2">RENDER_PIPELINE</h3>
        <div className="p-4 border border-primary-green/20 bg-black">
            <div className="flex justify-between items-end">
                <span className="text-xs text-primary-green-dim">FRAME_RATE</span>
                <span className="text-xl font-bold text-primary-green">{stats.fps} FPS</span>
            </div>
            <div className="w-full h-1 bg-gray-900 mt-2">
                <div className="h-full bg-primary-green" style={{ width: `${Math.min(100, (stats.fps / 60) * 100)}%` }} />
            </div>
        </div>
      </div>
      
      <div className="mt-8 flex justify-center">
          <button 
            onClick={() => { toggleDebugMinimize(); AudioSystem.playSound('ui_menu_close'); }}
            onMouseEnter={() => AudioSystem.playHover()}
            className="flex items-center gap-2 text-xs text-primary-green hover:text-white transition-colors border border-primary-green/50 px-4 py-2 hover:bg-primary-green/10"
          >
              <LayoutTemplate size={14} /> SWITCH TO MINI_MODE
          </button>
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/debug/tabs/SandboxTab.tsx
=====================================
import { Box, ArrowRight, Zap } from 'lucide-react';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { motion } from 'framer-motion';

interface SandboxTabProps {
  closeDebug: () => void;
}

export const SandboxTab = ({ closeDebug }: SandboxTabProps) => {
  const { setIntroDone, setBootState, setSimulationPaused } = useStore();
  const { startGame } = useGameStore();

  const enterSandbox = () => {
      AudioSystem.init();
      AudioSystem.startMusic();
      setIntroDone(true);
      setBootState('sandbox');
      setSimulationPaused(false);
      try {
          const reg = ServiceLocator.getRegistry();
          if (reg) reg.clear();
      } catch {}
      startGame();
      closeDebug();
  };

  return (
    <div className="h-full flex flex-col items-center justify-center p-8">
        
        <motion.div 
            initial={{ scale: 0.9, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            className="w-full max-w-md border border-service-cyan/30 bg-[#001014] p-1 relative group overflow-hidden"
        >
            {/* Corner Accents */}
            <div className="absolute top-0 left-0 w-4 h-4 border-t-2 border-l-2 border-service-cyan" />
            <div className="absolute bottom-0 right-0 w-4 h-4 border-b-2 border-r-2 border-service-cyan" />

            <div className="bg-black/50 p-8 flex flex-col items-center text-center relative z-10 backdrop-blur-sm">
                
                <div className="w-20 h-20 bg-service-cyan/10 rounded-full flex items-center justify-center mb-6 border border-service-cyan/30 shadow-[0_0_30px_rgba(0,240,255,0.15)] group-hover:scale-110 transition-transform duration-500">
                    <Box size={40} className="text-service-cyan" />
                </div>

                <h2 className="text-2xl font-header font-black text-service-cyan tracking-widest mb-2">
                    HOLO_DECK
                </h2>
                
                <p className="text-xs text-service-cyan/60 font-mono mb-8 leading-relaxed max-w-[240px]">
                    Initialize high-fidelity simulation environment. 
                    <br/><span className="text-gray-500">Warning: Main OS will be suspended.</span>
                </p>

                <button 
                    onClick={enterSandbox}
                    onMouseEnter={() => AudioSystem.playHover()}
                    className="w-full py-4 bg-service-cyan text-black font-header font-black text-sm tracking-[0.2em] hover:bg-white transition-all flex items-center justify-center gap-3 relative overflow-hidden group/btn"
                >
                    <span className="relative z-10 flex items-center gap-2">
                        INITIALIZE <ArrowRight size={16} />
                    </span>
                    <div className="absolute inset-0 bg-white translate-x-[-100%] group-hover/btn:translate-x-0 transition-transform duration-300 z-0" />
                </button>
            </div>

            {/* Animated Grid BG */}
            <div className="absolute inset-0 opacity-20 pointer-events-none bg-[linear-gradient(45deg,transparent_25%,rgba(0,240,255,0.1)_25%,rgba(0,240,255,0.1)_50%,transparent_50%,transparent_75%,rgba(0,240,255,0.1)_75%,rgba(0,240,255,0.1)_100%)] bg-[length:20px_20px] animate-pulse" />
        </motion.div>

        <div className="mt-6 flex items-center gap-2 text-[10px] font-mono text-gray-500">
            <Zap size={12} className="text-alert-yellow" />
            <span>GPU_ACCELERATION: ENABLED</span>
        </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/os/apps/debug/DebugOverlay.tsx
=====================================
import { useEffect, useState } from 'react';
import { useStore } from '@/engine/state/global/useStore';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { TimeSystem } from '@/engine/systems/TimeSystem';
import { Terminal, Box, Activity, Shield, MinusSquare, X, Play, PauseCircle } from 'lucide-react';
import { clsx } from 'clsx';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { DotGridBackground } from '@/ui/kit/atoms/DotGridBackground';
import { OverridesTab } from './tabs/OverridesTab';
import { SandboxTab } from './tabs/SandboxTab';
import { StatsTab } from './tabs/StatsTab';
import { ConsoleTab } from './tabs/ConsoleTab';
import { DOM_ATTR } from '@/ui/config/DOMConfig';

type Tab = 'OVERRIDES' | 'SANDBOX' | 'STATS' | 'CONSOLE';

const TABS: { id: Tab, label: string, icon: any }[] = [
  { id: 'OVERRIDES', label: 'ROOT_ACCESS', icon: Shield },
  { id: 'SANDBOX', label: 'HOLO_DECK', icon: Box },
  { id: 'STATS', label: 'TELEMETRY', icon: Activity },
  { id: 'CONSOLE', label: 'KERNEL_LOG', icon: Terminal },
];

const IGNORED_EVENTS = new Set([
    GameEvents.PLAYER_FIRED, GameEvents.ENEMY_DAMAGED, GameEvents.ENEMY_SPAWNED,
    GameEvents.PROJECTILE_CLASH, GameEvents.SPAWN_FX,
]);

export const DebugOverlay = () => {
  const { isDebugOpen, isDebugMinimized, toggleDebugMenu, setDebugFlag, bootState, activeModal, closeModal, openModal, toggleSettings } = useStore();
  const [activeTab, setActiveTab] = useState<Tab>('OVERRIDES');
  const [stats, setStats] = useState({ active: 0, pooled: 0, total: 0, fps: 0 });
  const [logs, setLogs] = useState<{ time: string, msg: string, type: string }[]>([]);
  const [isLogLive, setIsLogLive] = useState(false);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === '`' || e.key === '~') {
        const willBeOpen = !isDebugOpen && !isDebugMinimized;
        if (willBeOpen) {
            setDebugFlag('godMode', true);
            setDebugFlag('panelGodMode', true);
            setDebugFlag('peaceMode', true);
        }
        if (activeModal === 'settings') {
            closeModal();
            useStore.setState({ isDebugOpen: true, isDebugMinimized: false });
            AudioSystem.playSound('ui_menu_open');
        } else if (isDebugMinimized) {
             useStore.setState({ isDebugMinimized: false, isDebugOpen: true });
             AudioSystem.playSound('ui_menu_open');
        } else {
             toggleDebugMenu();
             AudioSystem.playSound(!isDebugOpen ? 'ui_menu_open' : 'ui_menu_close');
        }
      } else if (e.key === 'Escape') {
          if (isDebugOpen) {
              toggleDebugMenu();
              if (activeModal === 'none') openModal('settings');
              AudioSystem.playSound('ui_menu_open'); 
          } else if (activeModal !== 'none') {
              closeModal();
              AudioSystem.playSound('ui_menu_close');
          } else {
              toggleSettings();
              AudioSystem.playSound('ui_menu_open');
          }
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [toggleDebugMenu, isDebugMinimized, isDebugOpen, setDebugFlag, activeModal, toggleSettings, closeModal, openModal]);

  useEffect(() => {
    if (!isLogLive) return;
    const handlers = Object.values(GameEvents).map(evt => {
        return GameEventBus.subscribe(evt as any, (payload) => {
            if (IGNORED_EVENTS.has(evt as GameEvents)) return;
            const time = new Date().toLocaleTimeString().split(' ')[0];
            let msg = `${evt}`;
            if (evt === GameEvents.LOG_DEBUG && payload && (payload as any).msg) {
                const p = payload as any;
                msg = p.source ? `[${p.source}] ${p.msg}` : p.msg;
            } else if (payload && (payload as any).type) {
                msg += ` [${(payload as any).type}]`;
            } else if (payload && (payload as any).id) {
                msg += ` [ID:${(payload as any).id}]`;
            }
            setLogs(prev => {
                const newLogs = [...prev, { time, msg, type: evt }];
                return newLogs.length > 50 ? newLogs.slice(newLogs.length - 50) : newLogs;
            });
        });
    });
    return () => handlers.forEach(unsub => unsub());
  }, [isLogLive]);

  useEffect(() => {
    const pollInterval = setInterval(() => {
        if (!isDebugOpen && !isDebugMinimized) return;
        let fps = 0; let regStats = { active: 0, pooled: 0, totalAllocated: 0 };
        try {
            const timeSys = ServiceLocator.getSystem<TimeSystem>('TimeSystem');
            fps = timeSys.fps;
            const reg = ServiceLocator.getRegistry();
            if (reg) regStats = reg.getStats();
        } catch {}
        setStats({ active: regStats.active, pooled: regStats.pooled, total: regStats.totalAllocated, fps });
    }, 250); 
    return () => clearInterval(pollInterval);
  }, [isDebugOpen, isDebugMinimized]);

  if (!isDebugOpen && !isDebugMinimized) return null;
  if (bootState === 'sandbox') return <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/60 backdrop-blur-sm font-mono pointer-events-auto" />;

  return (
    <div className="fixed inset-0 z-debug flex items-center justify-center bg-black/80 backdrop-blur-md font-mono text-primary-green p-4 pointer-events-auto">
      <div className="w-full max-w-4xl bg-[#050a05] border border-primary-green/50 shadow-[0_0_100px_rgba(0,255,65,0.1)] flex flex-col h-[650px] overflow-hidden relative rounded-sm">
        <div className="h-12 border-b border-primary-green/30 bg-primary-green/5 flex items-center justify-between px-6 shrink-0 relative z-20">
          <div className="flex items-center gap-3"><Terminal size={18} className="text-primary-green animate-pulse" /><div className="flex flex-col leading-none"><span className="font-header font-black tracking-widest text-sm">KERNEL_DEBUG</span><span className="text-[9px] opacity-60 font-mono">ROOT_ACCESS_GRANTED</span></div></div>
          <div className="flex items-center gap-2">
             <button onClick={() => { useStore.setState({ isDebugMinimized: true, isDebugOpen: false }); AudioSystem.playSound('ui_menu_close'); }} className="hover:text-white transition-colors p-2 hover:bg-white/10 rounded"><MinusSquare size={16} /></button>
             <button onClick={() => { toggleDebugMenu(); AudioSystem.playSound('ui_menu_close'); }} className="hover:text-critical-red transition-colors p-2 hover:bg-critical-red/10 rounded"><X size={16} /></button>
          </div>
        </div>
        <div className="flex flex-1 min-h-0 relative z-10">
          <DotGridBackground className="opacity-5" />
          <div className="w-56 border-r border-primary-green/20 bg-black/40 flex flex-col relative z-20 py-4">
            {TABS.map(tab => (
              <button key={tab.id} onClick={() => { setActiveTab(tab.id); AudioSystem.playClick(); }} className={clsx("px-6 py-3 text-left text-xs font-bold tracking-widest flex items-center gap-3 transition-all relative overflow-hidden", activeTab === tab.id ? "text-primary-green bg-primary-green/10" : "text-primary-green-dim hover:text-white hover:bg-white/5")}>
                {activeTab === tab.id && <div className="absolute left-0 top-0 bottom-0 w-1 bg-primary-green shadow-[0_0_10px_#78F654]" />}<tab.icon size={16} />{tab.label}
              </button>
            ))}
          </div>
          <div className="flex-1 p-8 overflow-y-auto scrollbar-thin scrollbar-thumb-primary-green/50 scrollbar-track-black relative z-20 flex flex-col">
            {activeTab === 'CONSOLE' && (
                <div className="flex items-center justify-between mb-4 border-b border-white/10 pb-2">
                    <span className="text-xs font-bold text-gray-500">EVENT_STREAM</span>
                    <button onClick={() => { setIsLogLive(!isLogLive); AudioSystem.playClick(); }} className={clsx("flex items-center gap-2 px-3 py-1 rounded-full text-[9px] font-bold tracking-wider transition-all border", isLogLive ? "border-primary-green text-primary-green bg-primary-green/10 shadow-[0_0_10px_rgba(0,255,65,0.3)]" : "border-gray-600 text-gray-500 bg-black/40 hover:border-gray-400")}>
                        <div className={clsx("w-2 h-2 rounded-full transition-colors", isLogLive ? "bg-primary-green animate-pulse" : "bg-gray-600")} />
                        {isLogLive ? "LIVE FEED: ON" : "LIVE FEED: PAUSED"}
                        {isLogLive ? <PauseCircle size={10} /> : <Play size={10} />}
                    </button>
                </div>
            )}
            <div className="flex-1 min-h-0 relative">
                {activeTab === 'OVERRIDES' && <OverridesTab closeDebug={() => { toggleDebugMenu(); AudioSystem.playSound('ui_menu_close'); }} />}
                {activeTab === 'SANDBOX' && <SandboxTab closeDebug={() => { toggleDebugMenu(); AudioSystem.playSound('ui_menu_close'); }} />}
                {activeTab === 'STATS' && <StatsTab stats={stats} />}
                {activeTab === 'CONSOLE' && <ConsoleTab logs={logs} />}
            </div>
          </div>
        </div>
        <div className="h-8 bg-black/80 border-t border-primary-green/20 flex justify-between items-center px-6 text-[9px] text-primary-green-dim font-mono z-20">
          <span>MESOELFY_OS // DEBUG_BUILD</span><div className="flex items-center gap-2"><div className="w-2 h-2 rounded-full bg-primary-green animate-pulse" /><span>SYSTEM_ACTIVE</span></div>
        </div>
      </div>
    </div>
  );
};


=====================================
FILE: ./src/ui/sim/MobileGameDirector.tsx
=====================================
import { useFrame, useThree } from '@react-three/fiber';
import { useEffect, useRef } from 'react';
import { MobileBootstrapper } from '@/engine/services/MobileBootstrapper';
import { GameEngineCore } from '@/engine/services/GameEngine';

export const MobileGameDirector = () => {
  const { viewport, size } = useThree();
  const engineRef = useRef<GameEngineCore | null>(null);

  useEffect(() => {
    const engine = MobileBootstrapper();
    engineRef.current = engine;
    
    engine.updateViewport(viewport.width, viewport.height, size.width, size.height);

    return () => {
      engine.teardown();
      engineRef.current = null;
    };
  }, []);

  useFrame((state, delta) => {
    if (engineRef.current) {
        engineRef.current.update(delta, state.clock.elapsedTime);
    }
  });

  return null;
};


=====================================
FILE: ./src/ui/sim/SceneCanvas.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { WireframeFloor } from '@/ui/sim/vfx/WireframeFloor';
import { Suspense } from 'react';
import { clsx } from 'clsx';

interface SceneCanvasProps {
  children?: React.ReactNode;
  className?: string;
}

export const SceneCanvas = ({ children, className }: SceneCanvasProps) => {
  return (
    <div className={clsx("fixed inset-0 w-full h-full z-0 pointer-events-none transition-all duration-[2000ms] ease-out", className)}>
      <Canvas 
        camera={{ position: [0, 2, 10], fov: 45 }}
        gl={{ antialias: true, alpha: false }} 
        dpr={[1, 2]}
        style={{ background: '#000000' }} 
      >
        <color attach="background" args={['#000']} />
        <fog attach="fog" args={['#000', 2, 30]} />
        <WireframeFloor />
        <ambientLight intensity={0.2} />
        <Suspense fallback={null}>
           {children}
        </Suspense>
      </Canvas>
    </div>
  );
};


=====================================
FILE: ./src/ui/sim/config/theme.ts
=====================================
import { PALETTE } from '@/engine/config/Palette';

export const GAME_THEME = {
  turret: {
    base: PALETTE.GREEN.PRIMARY,
    glow: PALETTE.GREEN.GLOW,
    repair: PALETTE.CYAN.PRIMARY,
  },
  bullet: {
    plasma: PALETTE.MONO.WHITE,
    trail: PALETTE.GREEN.PRIMARY,
    hunter: PALETTE.YELLOW.SOFT, 
  },
  enemy: {
    muncher: PALETTE.PURPLE.PRIMARY,
    kamikaze: PALETTE.RED.CRITICAL,
    hunter: PALETTE.YELLOW.SOFT,
    charge: PALETTE.MONO.WHITE,  
  },
  hud: {
    text: PALETTE.GREEN.PRIMARY,
    warning: PALETTE.RED.CRITICAL,
  },
  vfx: {
    spark: PALETTE.MONO.WHITE,
    damage: PALETTE.RED.CRITICAL,
    heal: PALETTE.CYAN.PRIMARY,
    clash: PALETTE.YELLOW.SOFT,
  }
};


=====================================
FILE: ./src/ui/sim/stages/LabStage.tsx
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { OrbitControls } from '@react-three/drei';
import { GlitchGhost } from '../experiments/GlitchGhost';
import { useFrame } from '@react-three/fiber';
import { useState } from 'react';
import { MaterialFactory } from '@/engine/graphics/MaterialFactory';
import { DOM_ID } from '@/ui/config/DOMConfig';

export const LabStage = () => {
  const { labExperiment } = useStore();
  const [intensity, setIntensity] = useState(0.5);

  useFrame((state) => {
      MaterialFactory.updateUniforms(state.clock.elapsedTime);
      const el = document.getElementById(DOM_ID.LAB_PARAMS);
      if (el) {
          const val = parseFloat(el.dataset.a || '0.5');
          if (val !== intensity) setIntensity(val);
      }
  });

  if (labExperiment === 'NONE') return null;

  return (
    <>
        <OrbitControls makeDefault />
        <ambientLight intensity={0.2} />
        <pointLight position={[10, 10, 10]} intensity={1.0} color="#00F0FF" />
        <pointLight position={[-10, -5, -5]} intensity={0.5} color="#FF003C" />
        <group position={[0, 0, 0]}>
            {labExperiment === 'GLITCH' && <GlitchGhost intensity={intensity} />}
        </group>
    </>
  );
};


=====================================
FILE: ./src/ui/sim/stages/GalleryStage.tsx
=====================================
import { useMemo, useRef, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { OrbitControls, Grid } from '@react-three/drei';
import * as THREE from 'three';
import { useStore } from '@/engine/state/global/useStore';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { GAME_THEME } from '@/ui/sim/config/theme';
import { AssetService } from '@/ui/sim/assets/AssetService';
import { MaterialFactory } from '@/engine/graphics/MaterialFactory';
import { ShaderLib } from '@/engine/graphics/ShaderLib';
import { Uniforms } from '@/engine/graphics/Uniforms';

export const GalleryStage = () => {
  const { galleryTarget, galleryAction } = useStore();
  const meshRef = useRef<THREE.Mesh>(null);
  
  const activeGeo = useMemo(() => {
      try {
          if (galleryTarget === 'PLAYER') return new THREE.ConeGeometry(0.5, 1.5, 3);
          let key = 'GEO_DRILLER';
          if (galleryTarget === EnemyTypes.KAMIKAZE) key = 'GEO_KAMIKAZE';
          else if (galleryTarget === EnemyTypes.HUNTER) key = 'GEO_HUNTER';
          else if (galleryTarget === EnemyTypes.DAEMON) key = 'GEO_DAEMON';
          return AssetService.get<THREE.BufferGeometry>(key);
      } catch (e) {
          return new THREE.BoxGeometry(1,1,1);
      }
  }, [galleryTarget]);

  const shaderMaterial = useMemo(() => {
      return MaterialFactory.create('MAT_GALLERY_BODY', {
          ...ShaderLib.presets.galleryBody,
          uniforms: {
              [Uniforms.COLOR]: { value: new THREE.Color('#FFFFFF') },
              [Uniforms.GLOW]: { value: 0.0 },
              [Uniforms.DISSOLVE]: { value: 0.0 }
          }
      });
  }, []);

  useEffect(() => {
      if (meshRef.current) meshRef.current.geometry = activeGeo;
  }, [activeGeo]);

  useFrame((state, delta) => {
    if (!meshRef.current) return;
    MaterialFactory.updateUniforms(state.clock.elapsedTime);
    const time = state.clock.elapsedTime;
    let baseColor = new THREE.Color('#FFFFFF');
    let glow = 0.2;
    let dissolve = 0;

    if (galleryTarget === EnemyTypes.DRILLER) baseColor.set(GAME_THEME.enemy.muncher);
    else if (galleryTarget === EnemyTypes.KAMIKAZE) baseColor.set(GAME_THEME.enemy.kamikaze);
    else if (galleryTarget === EnemyTypes.HUNTER) baseColor.set(GAME_THEME.enemy.hunter);
    else if (galleryTarget === EnemyTypes.DAEMON) baseColor.set('#00F0FF');
    else if (galleryTarget === 'PLAYER') baseColor.set(GAME_THEME.turret.base);

    meshRef.current.position.set(0, 0, 0);
    meshRef.current.scale.setScalar(1.0);

    if (galleryAction === 'SPAWN') {
        const cycle = (time % 2.0) / 2.0; 
        dissolve = 1.0 - cycle;
        meshRef.current.position.y = -2.0 + (cycle * 2.0);
    } else if (galleryAction === 'DIE') {
        const cycle = (time % 1.5) / 1.5;
        dissolve = cycle;
        meshRef.current.rotation.x += delta * 5;
        meshRef.current.rotation.z += delta * 2;
    } else if (galleryAction === 'ATTACK') {
        meshRef.current.rotation.y += delta * 10.0;
        glow = 0.8;
    } else {
        meshRef.current.rotation.y += delta * 0.5;
        meshRef.current.position.y = Math.sin(time) * 0.2;
    }

    shaderMaterial.uniforms[Uniforms.COLOR].value.copy(baseColor);
    shaderMaterial.uniforms[Uniforms.GLOW].value = glow;
    shaderMaterial.uniforms[Uniforms.DISSOLVE].value = dissolve;
  });

  return (
    <>
        <OrbitControls makeDefault minDistance={3} maxDistance={20} />
        <ambientLight intensity={0.5} />
        <pointLight position={[10, 10, 10]} intensity={1.0} color="#00F0FF" />
        <pointLight position={[-10, -10, -5]} intensity={0.5} color="#9E4EA5" />
        <Grid position={[0, -2, 0]} args={[20, 20]} sectionColor="#00F0FF" cellColor="#001a33" fadeDistance={15} />
        <mesh ref={meshRef} material={shaderMaterial} />
    </>
  );
};


=====================================
FILE: ./src/ui/sim/props/MiniCrystalCanvas.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { Float, MeshDistortMaterial } from '@react-three/drei';
import { useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { useGameStore } from '@/engine/state/game/useGameStore';

const COLORS = {
  SAFE: new THREE.Color("#78F654"),
  WARN: new THREE.Color("#F7D277"),
  CRIT: new THREE.Color("#FF4D6D"), 
  EMISSIVE_SAFE: new THREE.Color("#15530A"),
  EMISSIVE_WARN: new THREE.Color("#5e4b00"),
  EMISSIVE_CRIT: new THREE.Color("#FF003C"), 
};

const SpinningGem = () => {
  const meshRef = useRef<THREE.Mesh>(null);
  const materialRef = useRef<any>(null);
  
  const integrity = useGameStore(state => state.systemIntegrity);

  const currentColor = useRef(COLORS.SAFE.clone());
  const currentEmissive = useRef(COLORS.EMISSIVE_SAFE.clone());

  useFrame((state, delta) => {
    if (!meshRef.current || !materialRef.current) return;

    let targetColor = COLORS.SAFE;
    let targetEmissive = COLORS.EMISSIVE_SAFE;
    let speed = 0.01;
    let distort = 0.3;
    let shake = 0;

    if (integrity < 30) {
        targetColor = COLORS.CRIT;
        targetEmissive = COLORS.EMISSIVE_CRIT;
        speed = 0.08; 
        distort = 0.8;
        shake = 0.1;
    } else if (integrity < 60) {
        targetColor = COLORS.WARN;
        targetEmissive = COLORS.EMISSIVE_WARN;
        speed = 0.04;
        distort = 0.5;
        shake = 0.02;
    }

    meshRef.current.rotation.y += speed;
    meshRef.current.rotation.z += speed * 0.5;
    
    if (shake > 0) {
        meshRef.current.position.x = (Math.random() - 0.5) * shake;
        meshRef.current.position.y = (Math.random() - 0.5) * shake;
    } else {
        meshRef.current.position.x = THREE.MathUtils.lerp(meshRef.current.position.x, 0, 0.1);
        meshRef.current.position.y = THREE.MathUtils.lerp(meshRef.current.position.y, 0, 0.1);
    }

    currentColor.current.lerp(targetColor, delta * 3.0);
    currentEmissive.current.lerp(targetEmissive, delta * 3.0);

    materialRef.current.color.copy(currentColor.current);
    materialRef.current.emissive.copy(currentEmissive.current);
    materialRef.current.distort = THREE.MathUtils.lerp(materialRef.current.distort, distort, delta);
  });

  return (
    <Float speed={2} rotationIntensity={0.5} floatIntensity={0.5}>
      <mesh ref={meshRef} scale={1.8}>
        <octahedronGeometry args={[1, 0]} />
        <MeshDistortMaterial
          ref={materialRef}
          color="#78F654"
          emissive="#15530A"
          roughness={0.1}
          metalness={0.8}
          distort={0.3}
          speed={2}
          wireframe
        />
      </mesh>
    </Float>
  );
};

export const MiniCrystalCanvas = () => {
  return (
    <div className="w-full h-full bg-black">
      <Canvas 
        camera={{ position: [0, 0, 5] }} 
        gl={{ alpha: true }}
        style={{ background: '#000000' }}
      >
        <ambientLight intensity={0.5} />
        <pointLight position={[10, 10, 10]} intensity={1} color="#C2FE9A" />
        <SpinningGem />
      </Canvas>
    </div>
  );
};


=====================================
FILE: ./src/ui/sim/experiments/GlitchGhost.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { MaterialFactory } from '@/engine/graphics/MaterialFactory';
import { ShaderLib } from '@/engine/graphics/ShaderLib';
import { addBarycentricCoordinates } from '@/engine/math/GeometryUtils';
import { Uniforms } from '@/engine/graphics/Uniforms';

export const GlitchGhost = ({ intensity = 0.5 }: { intensity: number }) => {
  const meshRef = useRef<THREE.Mesh>(null);
  const geometry = useMemo(() => {
      const geo = new THREE.IcosahedronGeometry(2, 2);
      return addBarycentricCoordinates(geo);
  }, []);

  const material = useMemo(() => {
      return MaterialFactory.create('MAT_GLITCH', {
          ...ShaderLib.presets.glitch,
          uniforms: {
              [Uniforms.INTENSITY]: { value: 0.0 },
              [Uniforms.FREQUENCY]: { value: 2.0 },
              [Uniforms.SPEED]: { value: 1.0 }
          }
      });
  }, []);

  useFrame((state) => {
      if (!meshRef.current) return;
      meshRef.current.rotation.y += 0.01;
      meshRef.current.rotation.x = Math.sin(state.clock.elapsedTime * 0.5) * 0.2;
      if (material.uniforms[Uniforms.INTENSITY]) {
          material.uniforms[Uniforms.INTENSITY].value = THREE.MathUtils.lerp(
              material.uniforms[Uniforms.INTENSITY].value, 
              intensity, 
              0.1
          );
      }
  });

  return <mesh ref={meshRef} geometry={geometry} material={material} />;
};


=====================================
FILE: ./src/ui/sim/RenderDirector.tsx
=====================================
import { useEffect, useState } from 'react';
import { RenderRegistry } from '@/ui/sim/registry/RenderRegistry';
import { registerAllRenderers } from '@/ui/sim/registry/RenderCatalog';

let hasRegistered = false;

export const RenderDirector = () => {
  const [renderers, setRenderers] = useState<React.ComponentType[]>([]);

  useEffect(() => {
    if (!hasRegistered) {
      registerAllRenderers();
      hasRegistered = true;
    }
    setRenderers(RenderRegistry.getAll());
  }, []);

  return (
    <>
      {renderers.map((Component, index) => (
        <Component key={index} />
      ))}
    </>
  );
};


=====================================
FILE: ./src/ui/sim/vfx/CameraRig.tsx
=====================================
import { useFrame, useThree } from '@react-three/fiber';
import { useGameContext } from '@/engine/state/GameContext';
import { ShakeSystem } from '@/engine/systems/ShakeSystem';

export const CameraRig = () => {
  const { camera } = useThree();
  const { getSystem } = useGameContext();
  
  useFrame(() => {
    const sys = getSystem<ShakeSystem>('ShakeSystem');
    if (sys) {
        const { x, y, r } = sys.currentOffset;
        camera.position.x = x;
        camera.position.y = y;
        camera.rotation.z = r;
    }
  });

  return null;
};


=====================================
FILE: ./src/ui/sim/vfx/WireframeFloor.tsx
=====================================
import { Grid } from '@react-three/drei';
import { useFrame } from '@react-three/fiber';
import { useRef, useMemo } from 'react';
import * as THREE from 'three';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { useStore } from '@/engine/state/global/useStore';

export const WireframeFloor = () => {
  const groupRef = useRef<THREE.Group>(null);
  const gridRef = useRef<any>(null);

  const colors = useMemo(() => ({
    safe: { section: new THREE.Color("#003300"), cell: new THREE.Color("#044d0f") },
    warning: { section: new THREE.Color("#4d3300"), cell: new THREE.Color("#d48806") },
    critical: { section: new THREE.Color("#4d0000"), cell: new THREE.Color("#ff003c") },
    sandbox: { section: new THREE.Color("#001a33"), cell: new THREE.Color("#00F0FF") }
  }), []);

  const currentSectionColor = useRef(new THREE.Color(colors.safe.section));
  const currentCellColor = useRef(new THREE.Color(colors.safe.cell));
  
  useFrame((state, delta) => {
    // 1. INDEPENDENT MOVEMENT
    // Driven by real-time clock, ignores game pause/game over states
    if (groupRef.current) {
        // RESTORED ORIGINAL SPEED (Was 0.5 in WorldSystem)
        const speed = 0.5; 
        groupRef.current.position.z = (state.clock.elapsedTime * speed) % 5;
    }

    // 2. STATE-BASED COLORING
    const { systemIntegrity, isZenMode } = useGameStore.getState();
    const bootState = useStore.getState().bootState;

    if (isZenMode) {
        // Prismatic Flow for Zen
        const time = state.clock.elapsedTime * 0.1;
        currentSectionColor.current.setHSL(time % 1, 0.8, 0.1);
        currentCellColor.current.setHSL((time + 0.1) % 1, 0.9, 0.5);
    } else {
        // Strict Priority: Sandbox -> Critical (Game Over) -> Warning -> Safe
        let target = colors.safe;
        
        if (bootState === 'sandbox') {
            target = colors.sandbox;
        } else if (systemIntegrity <= 0) {
            target = colors.critical; // Game Over / Purge Wait
        } else if (systemIntegrity < 30) {
            target = colors.critical;
        } else if (systemIntegrity < 60) {
            target = colors.warning;
        }

        // Smooth Lerp
        currentSectionColor.current.lerp(target.section, delta * 3.0);
        currentCellColor.current.lerp(target.cell, delta * 3.0);
    }

    if (gridRef.current && gridRef.current.material) {
        const mat = gridRef.current.material;
        if (mat.uniforms.sectionColor) mat.uniforms.sectionColor.value.copy(currentSectionColor.current);
        if (mat.uniforms.cellColor) mat.uniforms.cellColor.value.copy(currentCellColor.current);
    }
  });

  return (
    <group ref={groupRef} position={[0, -2, 0]}>
      <group position={[0, 0, -10]}>
        <Grid ref={gridRef} renderOrder={-1} infiniteGrid args={[60, 60]} cellSize={1} sectionSize={5} fadeDistance={30} fadeStrength={2.5} sectionColor="#003300" cellColor="#044d0f" sectionThickness={1.2} cellThickness={1.1} />
      </group>
    </group>
  );
};


=====================================
FILE: ./src/ui/sim/vfx/PostProcessing.tsx
=====================================
import { useThree, extend, useFrame } from '@react-three/fiber';
import { Effects } from '@react-three/drei';
import { useRef, useMemo, useEffect } from 'react';
import * as THREE from 'three';
import { RenderPass, UnrealBloomPass, AfterimagePass, ShaderPass } from 'three-stdlib';
import { useStore } from '@/engine/state/global/useStore';
import { Uniforms } from '@/engine/graphics/Uniforms';

extend({ RenderPass, UnrealBloomPass, AfterimagePass, ShaderPass });

const VignetteShader = {
  uniforms: { 
      "tDiffuse": { value: null }, 
      [Uniforms.OFFSET]: { value: 1.0 }, 
      [Uniforms.DARKNESS]: { value: 1.0 } 
  },
  vertexShader: `varying vec2 vUv;
    void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`,
  fragmentShader: `uniform float offset; uniform float darkness; uniform sampler2D tDiffuse; varying vec2 vUv;
    void main() { 
      vec4 texel = texture2D( tDiffuse, vUv );
      vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );
      gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a ); 
    }`
};

export const EffectsLayer = () => {
  const { graphicsMode } = useStore();
  const { size, scene, camera } = useThree();
  const afterimageRef = useRef<any>(null);
  const bloomRef = useRef<any>(null);
  const resolution = useMemo(() => new THREE.Vector2(size.width, size.height), [size]);

  useEffect(() => { if (bloomRef.current) bloomRef.current.resolution = new THREE.Vector2(size.width, size.height); }, [size]);
  useFrame(() => { if (afterimageRef.current) afterimageRef.current.uniforms[Uniforms.DAMP].value = 0.92; });

  if (graphicsMode === 'POTATO') return null;
  return (
    <Effects disableGamma>
      <renderPass args={[scene, camera]} />
      <afterimagePass ref={afterimageRef} />
      <unrealBloomPass ref={bloomRef} args={[resolution, 1.5, 0.4, 0.2]} strength={1.5} radius={0.4} threshold={0.2} />
      <shaderPass args={[VignetteShader]} uniforms-offset-value={0.9} uniforms-darkness-value={0.6} />
    </Effects>
  );
};


=====================================
FILE: ./src/ui/sim/hooks/usePanelRegistry.ts
=====================================
import { useEffect, useRef } from 'react';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { IPanelSystem } from '@/engine/interfaces';

export const usePanelRegistry = (id: string) => {
  const elementRef = useRef<HTMLDivElement>(null);
  
  const registerPanel = useGameStore((state) => state.registerPanel);
  const unregisterPanel = useGameStore((state) => state.unregisterPanel);

  useEffect(() => {
    const el = elementRef.current;
    if (!el) return;

    // 1. React State Registration (Immediate)
    registerPanel(id, el);

    // 2. Engine System Registration (With Retry)
    let panelSys: IPanelSystem | undefined;
    let registered = false;
    
    const attemptRegistration = () => {
        if (registered) return;
        try {
            panelSys = ServiceLocator.getSystem<IPanelSystem>('PanelRegistrySystem');
            if (panelSys) {
                panelSys.register(id, el);
                registered = true;
                // Force a refresh immediately
                panelSys.refreshSingle(id);
            }
        } catch (e) {
            // Engine not ready, wait for next attempt
        }
    };

    // Attempt immediately
    attemptRegistration();

    // Poll until registered (needed because Engine boots async relative to React mount)
    const retryInterval = setInterval(() => {
        if (registered) {
            clearInterval(retryInterval);
        } else {
            attemptRegistration();
        }
    }, 100);

    // 3. Resize Observer
    const observer = new ResizeObserver(() => {
        try {
            // Try getting system fresh in case of HMR/Reload
            if (!panelSys) panelSys = ServiceLocator.getSystem<IPanelSystem>('PanelRegistrySystem');
            if (panelSys) panelSys.refreshSingle(id);
        } catch {}
    });
    observer.observe(el);

    return () => {
      clearInterval(retryInterval);
      observer.disconnect();
      unregisterPanel(id);
      try {
          if (panelSys) panelSys.unregister(id);
      } catch {}
    };
  }, [id, registerPanel, unregisterPanel]);

  return elementRef;
};


=====================================
FILE: ./src/ui/sim/hooks/useDeviceType.ts
=====================================
import { useState, useEffect } from 'react';

type DeviceType = 'mobile' | 'tablet' | 'desktop';

export const useDeviceType = () => {
  const [device, setDevice] = useState<DeviceType>('desktop');

  useEffect(() => {
    const checkDevice = () => {
      const width = window.innerWidth;
      
      // Basic width checkpoints
      // < 768px: Usually Phones
      // 768px - 1024px: Tablets / Small Laptops
      // > 1024px: Desktop
      
      if (width < 768) {
        setDevice('mobile');
      } else if (width < 1024) {
        setDevice('tablet');
      } else {
        setDevice('desktop');
      }
    };

    checkDevice();
    window.addEventListener('resize', checkDevice);
    return () => window.removeEventListener('resize', checkDevice);
  }, []);

  return device;
};


=====================================
FILE: ./src/ui/sim/hooks/useWindowFocus.ts
=====================================
import { useEffect } from 'react';
import { useStore } from '@/engine/state/global/useStore';

/**
 * Handles Global Window Focus/Blur events to pause/resume the simulation.
 */
export const useWindowFocus = () => {
  const { bootState, setSimulationPaused } = useStore();

  useEffect(() => {
    // Only attach listeners if the game is actually active
    if (bootState !== 'active') return;

    const handlePause = () => setSimulationPaused(true);
    const handleResume = () => setSimulationPaused(false);
    
    // 1. Visibility API (Tab switching)
    const handleVisibility = () => {
        if (document.hidden) handlePause();
        else handleResume();
    };

    document.addEventListener('visibilitychange', handleVisibility);
    
    // 2. Focus API (Window clicking)
    window.addEventListener('blur', handlePause);
    window.addEventListener('focus', handleResume);
    
    // 3. Mouse leaving viewport (Optional, strict immersion)
    document.addEventListener('mouseleave', handlePause);
    document.addEventListener('mouseenter', handleResume);
    
    return () => {
        document.removeEventListener('visibilitychange', handleVisibility);
        window.removeEventListener('blur', handlePause);
        window.removeEventListener('focus', handleResume);
        document.removeEventListener('mouseleave', handlePause);
        document.removeEventListener('mouseenter', handleResume);
    };
  }, [bootState, setSimulationPaused]);
};


=====================================
FILE: ./src/ui/sim/hooks/useHeartbeat.ts
=====================================
import { useEffect } from 'react';
import { useAnimation, AnimationControls } from 'framer-motion';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { useStore } from '@/engine/state/global/useStore';

export const useHeartbeat = (): AnimationControls => {
  const controls = useAnimation();
  // We track sessionId and bootState to ensure we re-subscribe 
  // if the EngineFactory replaces the EventBus instance (e.g. on game reset or boot)
  const { sessionId, bootState } = useStore();

  useEffect(() => {
    const unsub = GameEventBus.subscribe(GameEvents.HEARTBEAT, (payload) => {
        // We trigger the 'heartbeat' variant defined in the component.
        // We pass the urgency as a 'custom' prop to the variant if needed.
        controls.start("heartbeat");
    });

    return () => unsub();
  }, [controls, sessionId, bootState]);

  return controls;
};


=====================================
FILE: ./src/ui/sim/actors/ParticleActor.tsx
=====================================
import { useRef, useMemo, useLayoutEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { useGameContext } from '@/engine/state/GameContext';
import { AssetService } from '@/ui/sim/assets/AssetService';
import { ParticleSystem } from '@/engine/systems/ParticleSystem';

const dummy = new THREE.Object3D();
const color = new THREE.Color();
const MAX_PARTICLES = 20000;

const getZDepth = (index: number) => {
    const h = (index * 9301 + 49297) % 233280;
    const norm = h / 233280; 
    return (norm * 4.0) - 2.0; 
};

export const ParticleActor = () => {
  const { getSystem } = useGameContext();
  const meshRef = useRef<THREE.InstancedMesh>(null);
  const geometry = useMemo(() => AssetService.get<THREE.BufferGeometry>('GEO_PARTICLE'), []);
  const material = useMemo(() => AssetService.get<THREE.Material>('MAT_PARTICLE'), []);

  useLayoutEffect(() => {
      if (meshRef.current) {
          meshRef.current.geometry.setAttribute('shapeID', new THREE.InstancedBufferAttribute(new Float32Array(MAX_PARTICLES), 1));
      }
  }, []);

  useFrame((state, delta) => {
    if (!meshRef.current) return;
    const sys = getSystem<ParticleSystem>('ParticleSystem');
    if (!sys) return;

    const count = sys.count;
    if (count === 0) { meshRef.current.count = 0; return; }
    const shapeAttr = meshRef.current.geometry.getAttribute('shapeID') as THREE.InstancedBufferAttribute;

    for (let i = 0; i < count; i++) {
        const x = sys.x[i]; const y = sys.y[i]; const vx = sys.vx[i]; const vy = sys.vy[i];
        const life = sys.life[i]; const maxLife = sys.maxLife[i];
        const baseSize = sys.size[i]; const shape = sys.shape[i];
        
        const zDepth = getZDepth(i);
        
        dummy.position.set(x, y, zDepth);
        const speedSq = vx*vx + vy*vy;
        const speed = Math.sqrt(speedSq);
        const lifeScale = life / maxLife;
        
        if (speed > 1.0) {
            const angle = Math.atan2(vy, vx);
            dummy.rotation.set(0, 0, angle);
            const stretchMult = shape === 1 ? 0.3 : 0.2;
            const scaleX = lifeScale * baseSize * (1 + speed * stretchMult);
            const scaleY = lifeScale * baseSize * 0.5;
            dummy.scale.set(scaleX, scaleY, 1);
            const shift = (0.3 * scaleX) * 0.5;
            dummy.position.x += Math.cos(angle) * shift;
            dummy.position.y += Math.sin(angle) * shift;
        } else {
            dummy.rotation.set(0, 0, 0);
            dummy.scale.set(lifeScale * baseSize, lifeScale * baseSize, 1);
        }
        
        dummy.updateMatrix();
        meshRef.current.setMatrixAt(i, dummy.matrix);
        color.setRGB(sys.r[i], sys.g[i], sys.b[i]);
        meshRef.current.setColorAt(i, color);
        shapeAttr.setX(i, shape);
    }

    meshRef.current.count = count;
    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor) meshRef.current.instanceColor.needsUpdate = true;
    shapeAttr.needsUpdate = true;
  });

  return (
    <instancedMesh ref={meshRef} args={[geometry, material, MAX_PARTICLES]} frustumCulled={false} />
  );
};


=====================================
FILE: ./src/ui/sim/actors/PlayerActor.tsx
=====================================
import { useRef, useMemo, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { GAME_THEME } from '@/ui/sim/config/theme';
import { Tag } from '@/engine/ecs/types';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { RenderTransform } from '@/engine/ecs/components/RenderTransform';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { IInteractionSystem } from '@/engine/interfaces';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { GameEvents } from '@/engine/signals/GameEvents';
import { MaterialFactory } from '@/engine/graphics/MaterialFactory';
import { ShaderLib } from '@/engine/graphics/ShaderLib';
import { useGameContext } from '@/engine/state/GameContext';
import { Uniforms } from '@/engine/graphics/Uniforms';
import * as THREE from 'three';

const centerGeo = new THREE.CircleGeometry(0.1, 16);
const glowPlaneGeo = new THREE.PlaneGeometry(1, 1);
const createStarRingGeo = () => {
    const points = 4;
    const outerRadius = 0.65;
    const innerRadius = 0.35;
    const indentFactor = 0.60; 
    const twistAngle = 0.55; 
    const shape = new THREE.Shape();
    const step = (Math.PI * 2) / points;
    const halfStep = step / 2;
    for (let i = 0; i < points; i++) {
        const theta = i * step;
        const tipA = theta - twistAngle;
        if (i === 0) shape.moveTo(Math.cos(tipA) * outerRadius, Math.sin(tipA) * outerRadius);
        else shape.lineTo(Math.cos(tipA) * outerRadius, Math.sin(tipA) * outerRadius);
        const rValley = outerRadius * (1.0 - indentFactor);
        shape.lineTo(Math.cos(theta + halfStep) * rValley, Math.sin(theta + halfStep) * rValley);
    }
    const hole = new THREE.Path();
    for (let i = 0; i < points; i++) {
        const theta = i * step;
        const tipA = theta - (twistAngle * 0.5);
        if (i === 0) hole.moveTo(Math.cos(tipA) * innerRadius, Math.sin(tipA) * innerRadius);
        else hole.lineTo(Math.cos(tipA) * innerRadius, Math.sin(tipA) * innerRadius);
        const rValley = innerRadius * (1.0 - indentFactor);
        hole.lineTo(Math.cos(theta + halfStep) * rValley, Math.sin(theta + halfStep) * rValley);
    }
    shape.holes.push(hole);
    return new THREE.ShapeGeometry(shape);
};
const reticleGeo = createStarRingGeo();

const COL_BASE = new THREE.Color(GAME_THEME.turret.base);
const COL_REPAIR = new THREE.Color(GAME_THEME.turret.repair);
const COL_REBOOT = new THREE.Color('#9E4EA5');
const COL_DEAD = new THREE.Color('#FF003C');
const COL_DEAD_DARK = new THREE.Color('#76000C');
const COL_HIT = new THREE.Color('#FF003C'); 
const COL_RETICLE_HEAL = new THREE.Color('#257171');

export const PlayerActor = () => {
  const { registry, getSystem, events } = useGameContext();
  const containerRef = useRef<THREE.Group>(null);
  const centerDotRef = useRef<THREE.Mesh>(null);
  const reticleRef = useRef<THREE.Mesh>(null);
  const backingCircleRef = useRef<THREE.Mesh>(null);
  const ambientGlowRef = useRef<THREE.Mesh>(null);
  const { introDone } = useStore(); 
  const animScale = useRef(0);
  const tempColor = useRef(new THREE.Color(GAME_THEME.turret.base));
  const reticleColor = useRef(new THREE.Color(GAME_THEME.turret.base));
  const currentEnergy = useRef(0.0);
  const hitFlash = useRef(0.0); 

  const ambientMaterial = useMemo(() => {
      const mat = MaterialFactory.create('MAT_PLAYER_AMBIENT', {
          ...ShaderLib.presets.playerAmbient,
          uniforms: { 
              [Uniforms.COLOR]: { value: new THREE.Color(GAME_THEME.turret.glow) }, 
              [Uniforms.OPACITY]: { value: 0.6 }, 
              [Uniforms.ENERGY]: { value: 0.0 } 
          }
      });
      mat.blending = THREE.AdditiveBlending;
      return mat;
  }, []);

  const backingMaterial = useMemo(() => {
      const mat = MaterialFactory.create('MAT_PLAYER_BACKING', {
          ...ShaderLib.presets.playerBacking,
          uniforms: { 
              [Uniforms.COLOR]: { value: new THREE.Color(GAME_THEME.turret.glow) }, 
              [Uniforms.OPACITY]: { value: 0.5 } 
          }
      });
      mat.blending = THREE.NormalBlending;
      return mat;
  }, []);

  useEffect(() => events.subscribe(GameEvents.PLAYER_HIT, () => { hitFlash.current = 1.0; }), [events]);

  useFrame((state, delta) => {
    if (!containerRef.current) return;
    const isSystemFailure = useGameStore.getState().systemIntegrity <= 0;
    const isZenMode = useGameStore.getState().isZenMode;
    const targetScale = (introDone && (isZenMode || !isSystemFailure)) ? 1 : 0;
    animScale.current = THREE.MathUtils.lerp(animScale.current, targetScale, delta * 2.0);
    
    if (animScale.current < 0.01) { 
        containerRef.current.visible = false; 
        return; 
    }
    containerRef.current.visible = true;

    if (hitFlash.current > 0) hitFlash.current = Math.max(0, hitFlash.current - delta * 4.0);

    let interactState = 'IDLE';
    const interact = getSystem<IInteractionSystem>('InteractionSystem');
    if (interact) interactState = interact.repairState;

    const isActive = (interactState === 'HEALING' || interactState === 'REBOOTING') || isZenMode;
    currentEnergy.current = THREE.MathUtils.lerp(currentEnergy.current, isActive ? 1.0 : 0.0, delta * (isActive ? 12.0 : 3.0));
    
    if (ambientMaterial.uniforms[Uniforms.ENERGY]) {
        ambientMaterial.uniforms[Uniforms.ENERGY].value = Math.min(1.0, currentEnergy.current + hitFlash.current);
    }

    let playerEntity;
    for(const p of registry.getByTag(Tag.PLAYER)) { playerEntity = p; break; }
    if (!playerEntity) return;

    const transform = playerEntity.getComponent<TransformData>(ComponentType.Transform);
    const renderTrans = playerEntity.getComponent<RenderTransform>(ComponentType.RenderTransform);
    const isPlayerDead = useGameStore.getState().playerHealth <= 0; 
    const isDeadState = (isPlayerDead || isSystemFailure) && !isZenMode;

    if (transform) containerRef.current.position.set(transform.x, transform.y, 0);
    if (renderTrans && reticleRef.current && centerDotRef.current && ambientGlowRef.current) {
        if (isDeadState && interactState !== 'REBOOTING') reticleRef.current.rotation.z = Math.PI * 0.25;
        else reticleRef.current.rotation.z = -renderTrans.rotation;
        
        if (isZenMode) {
            const time = state.clock.elapsedTime * 0.1;
            tempColor.current.setHSL(time % 1, 1.0, 0.9);
            reticleColor.current.setHSL((time - 0.1) % 1, 0.9, 0.6);
            backingMaterial.uniforms[Uniforms.COLOR].value.setHSL((time - 0.2) % 1, 0.8, 0.5);
            ambientMaterial.uniforms[Uniforms.COLOR].value.setHSL((time - 0.3) % 1, 0.8, 0.4);
        } else {
            let targetColor = isDeadState ? COL_DEAD : (interactState === 'HEALING' ? COL_REPAIR : (interactState === 'REBOOTING' ? COL_REBOOT : COL_BASE));
            tempColor.current.lerp(targetColor, 0.2);
            if (isDeadState) reticleColor.current.lerp(COL_DEAD_DARK, 0.2);
            else if (interactState === 'HEALING') reticleColor.current.lerp(COL_RETICLE_HEAL, 0.1);
            else reticleColor.current.lerp(tempColor.current, 0.2);
            if (hitFlash.current > 0.01) { 
                tempColor.current.lerp(COL_HIT, hitFlash.current);
                reticleColor.current.lerp(COL_HIT, hitFlash.current); 
            }
            ambientMaterial.uniforms[Uniforms.COLOR].value.copy(tempColor.current);
            backingMaterial.uniforms[Uniforms.COLOR].value.copy(tempColor.current);
        }
        (reticleRef.current.material as THREE.MeshBasicMaterial).color.copy(reticleColor.current);
        (centerDotRef.current.material as THREE.MeshBasicMaterial).color.copy(tempColor.current);
        const zenScale = isZenMode ? 3.0 : 1.0;
        containerRef.current.scale.setScalar(renderTrans.scale * animScale.current * zenScale);
        centerDotRef.current.geometry = centerGeo;
        (centerDotRef.current.material as THREE.MeshBasicMaterial).wireframe = isDeadState; 
    }
  });

  return (
    <group ref={containerRef}>
      <mesh ref={centerDotRef} renderOrder={3}><bufferGeometry /><meshBasicMaterial color={GAME_THEME.turret.base} /></mesh>
      <mesh ref={reticleRef} geometry={reticleGeo} rotation={[0, 0, Math.PI / 12]} renderOrder={2}><meshBasicMaterial color={GAME_THEME.turret.base} transparent opacity={0.8} /></mesh>
      <mesh ref={backingCircleRef} material={backingMaterial} geometry={glowPlaneGeo} scale={[1.3, 1.3, 1]} renderOrder={1} />
      <mesh ref={ambientGlowRef} material={ambientMaterial} geometry={glowPlaneGeo} scale={[6, 6, 1]} renderOrder={0} />
    </group>
  );
};


=====================================
FILE: ./src/ui/sim/actors/UniversalActor.tsx
=====================================
import { useMemo } from 'react';
import { InstancedActor } from './InstancedActor';
import { AssetService } from '@/ui/sim/assets/AssetService';
import { ARCHETYPES } from '@/engine/config/Archetypes';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { Tag } from '@/engine/ecs/types';
import * as THREE from 'three';

interface RenderGroup {
  key: string;
  geometryId: string;
  materialId: string;
  geometry: THREE.BufferGeometry;
  material: THREE.Material;
}

export const UniversalActor = () => {
  const groups = useMemo(() => {
    const uniqueGroups = new Map<string, RenderGroup>();

    Object.values(ARCHETYPES).forEach(blueprint => {
      // 1. Only process Enemy tags
      if (!blueprint.tags.includes(Tag.ENEMY)) return;

      // 2. Resolve IDs (Check new 'assets' field, then fallback to component data)
      let geometryId = blueprint.assets?.geometry;
      let materialId = blueprint.assets?.material;

      if (!geometryId || !materialId) {
          const renderDef = blueprint.components.find(c => c.type === ComponentType.RenderModel);
          if (renderDef?.data) {
              geometryId = geometryId || renderDef.data.geometryId;
              materialId = materialId || renderDef.data.materialId;
          }
      }

      if (!geometryId || !materialId) return;

      const key = `${geometryId}|${materialId}`;
      if (!uniqueGroups.has(key)) {
        try { 
            uniqueGroups.set(key, { 
                key, 
                geometryId, 
                materialId, 
                geometry: AssetService.get(geometryId), 
                material: AssetService.get(materialId) 
            }); 
        } catch (e) {
            console.warn(`[UniversalActor] Failed to load assets for group: ${key}`, e);
        }
      }
    });

    return Array.from(uniqueGroups.values());
  }, []);

  return (
    <>
      {groups.map(group => (
        <InstancedActor
          key={group.key} 
          renderKey={group.key}
          tag={Tag.ENEMY} 
          geometry={group.geometry} 
          material={group.material} 
          maxCount={2000}
          interactive={true}
        />
      ))}
    </>
  );
};


=====================================
FILE: ./src/ui/sim/actors/ProjectileActor.tsx
=====================================
import { InstancedActor } from './InstancedActor';
import { AssetService } from '@/ui/sim/assets/AssetService';
import { Tag } from '@/engine/ecs/types';
import * as THREE from 'three';

const KEYS = [
    'GEO_PRJ_SPHERE', 'GEO_PRJ_CAPSULE', 'GEO_PRJ_DIAMOND', 
    'GEO_PRJ_PYRAMID', 'GEO_PRJ_RING', 'GEO_PRJ_ARROW'
];

export const ProjectileActor = () => {
  const material = AssetService.get<THREE.Material>('MAT_PROJECTILE');

  return (
    <>
      {KEYS.map(key => (
        <InstancedActor
          key={key} 
          renderKey={`${key}|MAT_PROJECTILE`}
          tag={Tag.BULLET} 
          geometry={AssetService.get(key)} 
          material={material} 
          maxCount={2000}
          interactive={false}
        />
      ))}
    </>
  );
};


=====================================
FILE: ./src/ui/sim/actors/DaemonActor.tsx
=====================================
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { useGameContext } from '@/engine/state/GameContext';
import { Tag } from '@/engine/ecs/types';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { IdentityData } from '@/engine/ecs/components/IdentityData';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { AIStateData } from '@/engine/ecs/components/AIStateData';
import { ComponentType } from '@/engine/ecs/ComponentType';

const MAX_DAEMONS = 5;
const SQUISH_SCALE_Y = 0.4;
const FULL_SCALE_Y = 1.3;
const WIDTH_SCALE = 1.2;
const SPIN_SPEED = 2.0;

export const DaemonActor = () => {
  const { registry } = useGameContext();
  const groupRef = useRef<THREE.Group>(null);
  const pool = useMemo(() => {
      const items: { root: THREE.Group, cage: THREE.Mesh, orb: THREE.Mesh }[] = [];
      const cageGeo = new THREE.OctahedronGeometry(0.7, 0); 
      const orbGeo = new THREE.IcosahedronGeometry(0.25, 1);
      const cageMat = new THREE.MeshBasicMaterial({ color: '#00F0FF', wireframe: true, transparent: true, opacity: 0.5, toneMapped: false });
      const orbMat = new THREE.MeshBasicMaterial({ color: '#00F0FF', toneMapped: false });

      for(let i=0; i<MAX_DAEMONS; i++) {
          const root = new THREE.Group();
          const cage = new THREE.Mesh(cageGeo, cageMat);
          const orb = new THREE.Mesh(orbGeo, orbMat);
          root.add(cage); root.add(orb);
          root.visible = false;
          items.push({ root, cage, orb });
      }
      return items;
  }, []);

  useFrame((state, delta) => {
      if (!groupRef.current) return;
      
      const entities = Array.from(registry.getByTag(Tag.PLAYER)).filter(e => {
          const id = e.getComponent<IdentityData>(ComponentType.Identity);
          return id?.variant === EnemyTypes.DAEMON && e.active;
      });

      for (let i = 0; i < MAX_DAEMONS; i++) {
          const item = pool[i];
          const entity = entities[i]; 

          if (!entity) { item.root.visible = false; continue; }
          item.root.visible = true;
          
          const transform = entity.getComponent<TransformData>(ComponentType.Transform);
          const ai = entity.getComponent<AIStateData>(ComponentType.State);

          if (transform && ai) {
              item.root.position.set(transform.x, transform.y, 0);
              const charge = ai.data.chargeProgress || 0;
              const currentScaleY = THREE.MathUtils.lerp(SQUISH_SCALE_Y, FULL_SCALE_Y, charge);
              const currentScaleXZ = THREE.MathUtils.lerp(WIDTH_SCALE, 1.0, charge);
              item.cage.scale.set(currentScaleXZ, currentScaleY, currentScaleXZ);
              item.cage.rotation.y += delta * SPIN_SPEED;
              item.cage.rotation.z = Math.sin(state.clock.elapsedTime * 0.5) * 0.1;
              const orbScale = THREE.MathUtils.lerp(0, 1, charge);
              item.orb.scale.setScalar(orbScale);
              if (charge >= 1.0) item.orb.scale.multiplyScalar(1.0 + Math.sin(state.clock.elapsedTime * 10) * 0.1);
          }
      }
  });

  return (
    <group ref={groupRef}>
        {pool.map((item, i) => (
            <primitive key={i} object={item.root} />
        ))}
    </group>
  );
};


=====================================
FILE: ./src/ui/sim/actors/InstancedActor.tsx
=====================================
import { useRef, useLayoutEffect } from 'react';
import { useFrame, ThreeEvent } from '@react-three/fiber';
import * as THREE from 'three';
import { RenderBuffer } from '@/engine/graphics/RenderBuffer';
import { RenderOffset, RENDER_STRIDE } from '@/engine/graphics/RenderSchema';
import { GameEvents } from '@/engine/signals/GameEvents';
import { useGameContext } from '@/engine/state/GameContext';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { RenderModel } from '@/engine/ecs/components/RenderModel';

const tempObj = new THREE.Object3D();
const tempColor = new THREE.Color();

interface InstancedActorProps {
  tag: string;
  geometry: THREE.BufferGeometry;
  material: THREE.Material;
  maxCount: number;
  renderKey?: string; 
  interactive?: boolean; 
  updateEntity?: any; 
  filter?: any;
  baseColor?: string;
  z?: number;
}

export const InstancedActor = ({ 
    geometry, material, maxCount, 
    interactive = false, renderKey 
}: InstancedActorProps) => {
  const { registry, events } = useGameContext();
  const meshRef = useRef<THREE.InstancedMesh>(null);
  
  useLayoutEffect(() => {
    if (meshRef.current) {
        meshRef.current.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxCount * 3), 3);
        meshRef.current.geometry.setAttribute(
            'spawnProgress', 
            new THREE.InstancedBufferAttribute(new Float32Array(maxCount), 1)
        );
    }
  }, [maxCount]);

  useFrame(() => {
    if (!meshRef.current || !renderKey) return;

    const group = RenderBuffer.getGroup(renderKey);
    const count = group.count;
    const buffer = group.buffer;

    if (count === 0) {
        meshRef.current.count = 0;
        return;
    }

    const spawnAttr = meshRef.current.geometry.getAttribute('spawnProgress') as THREE.InstancedBufferAttribute;

    for (let i = 0; i < count; i++) {
        const offset = i * RENDER_STRIDE;
        
        // POS
        tempObj.position.set(
            buffer[offset + RenderOffset.POSITION_X],
            buffer[offset + RenderOffset.POSITION_Y],
            buffer[offset + RenderOffset.POSITION_Z]
        );

        // QUAT
        tempObj.quaternion.set(
            buffer[offset + RenderOffset.ROTATION_X],
            buffer[offset + RenderOffset.ROTATION_Y],
            buffer[offset + RenderOffset.ROTATION_Z],
            buffer[offset + RenderOffset.ROTATION_W]
        );

        // SCALE
        tempObj.scale.set(
            buffer[offset + RenderOffset.SCALE_X],
            buffer[offset + RenderOffset.SCALE_Y],
            buffer[offset + RenderOffset.SCALE_Z]
        );

        tempObj.updateMatrix();
        meshRef.current.setMatrixAt(i, tempObj.matrix);
        
        // COLOR
        tempColor.setRGB(
            buffer[offset + RenderOffset.COLOR_R],
            buffer[offset + RenderOffset.COLOR_G],
            buffer[offset + RenderOffset.COLOR_B]
        );
        if (meshRef.current.instanceColor) meshRef.current.setColorAt(i, tempColor);
        
        // SPAWN
        spawnAttr.setX(i, buffer[offset + RenderOffset.SPAWN_PROGRESS]);
    }

    meshRef.current.count = count;
    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor) meshRef.current.instanceColor.needsUpdate = true;
    spawnAttr.needsUpdate = true;
  });

  const handlePointerDown = (e: ThreeEvent<PointerEvent>) => {
      if (!interactive || e.instanceId === undefined) return;
      e.stopPropagation();
      
      try {
          const candidates = Array.from(registry.query({ all: [ComponentType.Transform, ComponentType.RenderModel] }));
          
          let matchIndex = 0;
          let foundEntity = null;
          
          for (const ent of candidates) {
              if (!ent.active) continue;
              const model = ent.getComponent<RenderModel>(ComponentType.RenderModel);
              if (!model) continue;
              
              const key = `${model.geometryId}|${model.materialId}`;
              if (key === renderKey) {
                  if (matchIndex === e.instanceId) {
                      foundEntity = ent;
                      break;
                  }
                  matchIndex++;
              }
          }

          if (foundEntity) {
              events.emit(GameEvents.ENEMY_DAMAGED, { id: foundEntity.id as number, damage: 9999, type: 'TAP' });
          }
      } catch (err) {
          console.warn("Interaction Failed:", err);
      }
  };

  return (
    <instancedMesh 
      ref={meshRef} 
      args={[geometry, material, maxCount]} 
      frustumCulled={false}
      onPointerDown={interactive ? handlePointerDown : undefined}
    />
  );
};


=====================================
FILE: ./src/ui/sim/registry/RenderCatalog.ts
=====================================
import { RenderRegistry } from './RenderRegistry';

// Core Actors
import { PlayerActor } from '../actors/PlayerActor';
import { ParticleActor } from '../actors/ParticleActor';
import { DaemonActor } from '../actors/DaemonActor';

// The New Generic Systems
import { UniversalActor } from '../actors/UniversalActor';
import { ProjectileActor } from '../actors/ProjectileActor'; // NEW

export const registerAllRenderers = () => {
  // 1. Opaque / Depth-Writing Geometry (Draw First)
  RenderRegistry.register(UniversalActor); // Enemies
  RenderRegistry.register(DaemonActor); 
  
  // 2. Transparent / Additive Geometry (Draw Last)
  RenderRegistry.register(PlayerActor);
  RenderRegistry.register(ProjectileActor); // REPLACES ProjectileRenderer
  
  // Particles must be absolutely last to composite correctly over everything
  RenderRegistry.register(ParticleActor);
  
  console.log('[RenderCatalog] Visual Components Registered.');
};


=====================================
FILE: ./src/ui/sim/registry/RenderRegistry.ts
=====================================
import { ComponentType } from 'react';

type RendererComponent = ComponentType<any>;

class RenderRegistryController {
  private renderers = new Set<RendererComponent>();

  public register(component: RendererComponent) {
    this.renderers.add(component);
  }

  public getAll(): RendererComponent[] {
    return Array.from(this.renderers);
  }
}

export const RenderRegistry = new RenderRegistryController();


=====================================
FILE: ./src/ui/sim/GameDirector.tsx
=====================================
import { useFrame, useThree } from '@react-three/fiber';
import { useEffect, useRef, memo } from 'react';
import { GameBootstrapper } from '@/engine/services/GameBootstrapper';
import { GameEngineCore } from '@/engine/services/GameEngine';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { InputSystem } from '@/engine/systems/InputSystem';
import { IPanelSystem } from '@/engine/interfaces';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { useStore } from '@/engine/state/global/useStore';

export const GameDirector = memo(() => {
  const { viewport, size } = useThree();
  const engineRef = useRef<GameEngineCore | null>(null);
  const isMobileRef = useRef(false);
  const initialClickPos = useStore(state => state.initialClickPos);

  useEffect(() => {
    const checkMobile = () => {
        isMobileRef.current = window.matchMedia('(pointer: coarse)').matches || 
                              ('ontouchstart' in window) || 
                              (navigator.maxTouchPoints > 0);
    };
    checkMobile();
    window.addEventListener('resize', checkMobile);

    const engine = GameBootstrapper();
    engineRef.current = engine;
    engine.updateViewport(viewport.width, viewport.height, size.width, size.height);
    
    const refreshInterval = setInterval(() => {
        try {
            const panelSys = ServiceLocator.getSystem<IPanelSystem>('PanelRegistrySystem');
            panelSys.refreshAll();
        } catch {}
    }, 500);

    let initialPolls = 0;
    const fastPoll = setInterval(() => {
        try {
            const panelSys = ServiceLocator.getSystem<IPanelSystem>('PanelRegistrySystem');
            panelSys.refreshAll();
        } catch {}
        initialPolls++;
        if (initialPolls > 20) clearInterval(fastPoll); 
    }, 100);

    return () => {
      window.removeEventListener('resize', checkMobile);
      clearInterval(refreshInterval);
      clearInterval(fastPoll);
      engine.teardown();
      engineRef.current = null;
    };
  }, []); 

  useEffect(() => {
      if (!initialClickPos || isMobileRef.current || !engineRef.current) return;
      try {
          const input = ServiceLocator.getSystem<InputSystem>('InputSystem');
          input.updateBounds(viewport.width, viewport.height);
          const wx = (initialClickPos.x / size.width) * viewport.width - (viewport.width / 2);
          const wy = -((initialClickPos.y / size.height) * viewport.height - (viewport.height / 2));
          input.updateCursor(wx, wy);
      } catch {}
  }, [initialClickPos, viewport, size]);

  useEffect(() => {
    if (engineRef.current) {
      engineRef.current.updateViewport(viewport.width, viewport.height, size.width, size.height);
      try {
        const input = ServiceLocator.getSystem<InputSystem>('InputSystem');
        input.updateBounds(viewport.width, viewport.height);
      } catch {}
    }
  }, [viewport, size]);

  useFrame((state, delta) => {
    if (engineRef.current) {
      try {
          const input = ServiceLocator.getSystem<InputSystem>('InputSystem');
          if (!isMobileRef.current) {
              const x = (state.pointer.x * viewport.width) / 2;
              const y = (state.pointer.y * viewport.height) / 2;
              input.updateCursor(x, y);
          }
          engineRef.current.update(delta, state.clock.elapsedTime);
      } catch (e: any) {
          console.error("Game Loop Critical Failure:", e);
          GameEventBus.emit(GameEvents.LOG_DEBUG, { msg: `CRITICAL LOOP FAIL: ${e.message}`, source: 'GameDirector' });
      }
    }
  });

  return null;
});

GameDirector.displayName = 'GameDirector';


=====================================
FILE: ./src/ui/sim/GameCanvas.tsx
=====================================
'use client';

import { Canvas } from '@react-three/fiber';
import { GameDirector } from './GameDirector';
import { CameraRig } from './vfx/CameraRig';
import { GalleryStage } from './stages/GalleryStage';
import { LabStage } from './stages/LabStage';
import { RenderDirector } from './RenderDirector';
import { VirtualJoystick } from '@/ui/kit/atoms/VirtualJoystick';
import { ActionButton } from '@/ui/kit/atoms/ActionButton';
import { useStore } from '@/engine/state/global/useStore';
import { useEffect, useState, useLayoutEffect } from 'react';
import { registerAllAssets } from '@/ui/sim/assets/AssetCatalog';
import { CAMERA_CONFIG } from '@/engine/config/CameraConfig';

export const GameOverlay = () => {
  const { bootState, sandboxView } = useStore();
  const isGallery = bootState === 'sandbox' && sandboxView === 'gallery';
  const isLab = bootState === 'sandbox' && sandboxView === 'lab';
  
  const [isMobile, setIsMobile] = useState(false);
  const [mounted, setMounted] = useState(false);
  const [assetsReady, setAssetsReady] = useState(false);

  useLayoutEffect(() => {
      registerAllAssets();
      setAssetsReady(true);
  }, []);

  useEffect(() => {
      setMounted(true);
      const checkMobile = () => {
        const isCoarse = window.matchMedia('(pointer: coarse)').matches;
        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        setIsMobile(isCoarse || isTouch);
      };
      
      checkMobile();
      window.addEventListener('resize', checkMobile);
      return () => window.removeEventListener('resize', checkMobile);
  }, []);

  if (!mounted || !assetsReady) return null;

  return (
    <>
        <div className="fixed inset-0 z-[60] w-full h-full pointer-events-none overflow-hidden">
          <Canvas
            orthographic={!isGallery && !isLab}
            camera={
                isGallery ? { position: [5, 5, 10], fov: 45 } : 
                isLab ? { position: [0, 0, 10], fov: 50 } :
                { zoom: CAMERA_CONFIG.BASE_ZOOM, position: [0, 0, 100] }
            }
            gl={{ 
              alpha: true, 
              antialias: true,
              stencil: false,
              powerPreference: "high-performance"
            }}
            eventSource={document.body}
            eventPrefix="client"
          >
            {isLab ? (
                <LabStage />
            ) : isGallery ? (
                <GalleryStage />
            ) : (
                <>
                    <GameDirector />
                    <CameraRig />
                    <RenderDirector />
                </>
            )}
          </Canvas>
        </div>
        
        {isMobile && !isGallery && !isLab && (
            <>
                <VirtualJoystick />
                <ActionButton />
            </>
        )}
    </>
  );
};


=====================================
FILE: ./src/ui/sim/assets/AssetService.ts
=====================================
import { GeometryKey, MaterialKey } from '@/engine/config/AssetKeys';

export type AssetKey = GeometryKey | MaterialKey | string;

class AssetServiceController {
  private cache = new Map<string, any>();
  private generators = new Map<string, () => any>();

  // Init is now a no-op, kept for API compatibility if needed
  public init() {}

  public registerGenerator(key: AssetKey, generator: () => any) {
    this.generators.set(key, generator);
  }

  public get<T>(key: AssetKey): T {
    if (this.cache.has(key)) {
      return this.cache.get(key) as T;
    }

    const generator = this.generators.get(key);
    if (!generator) {
      throw new Error('[AssetService] No generator registered for asset: ' + key);
    }

    const asset = generator();
    this.cache.set(key, asset);
    return asset as T;
  }
}

export const AssetService = new AssetServiceController();


=====================================
FILE: ./src/ui/sim/assets/AssetCatalog.ts
=====================================
import * as THREE from 'three';
import { AssetService } from './AssetService';
import { addBarycentricCoordinates, createHunterSpear } from '@/engine/math/GeometryUtils';
import { MODEL_CONFIG } from '@/engine/config/ModelConfig';
import { MaterialFactory } from '@/engine/graphics/MaterialFactory';
import { ShaderLib } from '@/engine/graphics/ShaderLib';
import { GEOMETRY_IDS, MATERIAL_IDS } from '@/engine/config/AssetKeys';

export const registerAllAssets = () => {
  AssetService.registerGenerator(MATERIAL_IDS.ENEMY_BASE, () => MaterialFactory.create(MATERIAL_IDS.ENEMY_BASE, ShaderLib.presets.enemy));
  AssetService.registerGenerator(MATERIAL_IDS.PARTICLE, () => {
    const mat = MaterialFactory.create(MATERIAL_IDS.PARTICLE, ShaderLib.presets.particle);
    mat.blending = THREE.AdditiveBlending;
    mat.depthWrite = false;
    return mat;
  });
  AssetService.registerGenerator(MATERIAL_IDS.PLAYER, () => new THREE.MeshBasicMaterial({ color: 0xffffff }));
  AssetService.registerGenerator(MATERIAL_IDS.PROJECTILE, () => new THREE.MeshBasicMaterial({ color: 0xffffff, toneMapped: false }));

  AssetService.registerGenerator(GEOMETRY_IDS.HUNTER, () => createHunterSpear());
  AssetService.registerGenerator(GEOMETRY_IDS.DRILLER, () => addBarycentricCoordinates(new THREE.ConeGeometry(0.5, MODEL_CONFIG.DRILLER.height, MODEL_CONFIG.DRILLER.segments)));
  AssetService.registerGenerator(GEOMETRY_IDS.KAMIKAZE, () => addBarycentricCoordinates(new THREE.IcosahedronGeometry(MODEL_CONFIG.KAMIKAZE.radius, 0)));
  AssetService.registerGenerator(GEOMETRY_IDS.DAEMON, () => new THREE.OctahedronGeometry(0.6, 0));
  AssetService.registerGenerator(GEOMETRY_IDS.PRJ_SPHERE, () => new THREE.IcosahedronGeometry(1, 1));
  AssetService.registerGenerator(GEOMETRY_IDS.PRJ_CAPSULE, () => new THREE.CylinderGeometry(0.5, 0.5, 1, 6));
  AssetService.registerGenerator(GEOMETRY_IDS.PRJ_DIAMOND, () => new THREE.OctahedronGeometry(1, 0));
  AssetService.registerGenerator(GEOMETRY_IDS.PRJ_PYRAMID, () => new THREE.TetrahedronGeometry(1, 0));
  AssetService.registerGenerator(GEOMETRY_IDS.PRJ_RING, () => new THREE.TorusGeometry(0.8, 0.2, 4, 8));
  AssetService.registerGenerator(GEOMETRY_IDS.PRJ_ARROW, () => new THREE.ConeGeometry(0.5, 1, 4));
  AssetService.registerGenerator(GEOMETRY_IDS.PARTICLE, () => new THREE.PlaneGeometry(0.3, 0.3));
  AssetService.registerGenerator(GEOMETRY_IDS.PLAYER, () => new THREE.BoxGeometry(1, 1, 1));
};


=====================================
FILE: ./src/app/layout.tsx
=====================================
import type { Metadata, Viewport } from 'next';
import { Montserrat, JetBrains_Mono } from 'next/font/google';
import '@/styles/globals.css';

const montserrat = Montserrat({ 
  subsets: ['latin'],
  weight: ['400', '700', '900'], 
  variable: '--font-montserrat',
  display: 'swap',
});

const jetbrains = JetBrains_Mono({
  subsets: ['latin'],
  weight: ['400', '700'],
  variable: '--font-jetbrains',
  display: 'swap',
});

export const metadata: Metadata = {
  title: 'MESOELFY // LATENT SPACE BANDIT',
  description: 'The official digital HQ of Mesoelfy. Art, Lore, and Neural Network Injections.',
};

export const viewport: Viewport = {
  themeColor: '#000000',
  colorScheme: 'dark',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" className={`${montserrat.variable} ${jetbrains.variable}`}>
      <body 
        className="bg-black text-primary-green selection:bg-primary-green selection:text-black font-mono"
        style={{ backgroundColor: '#000000' }} 
      >
        <div className="relative w-full h-full">
          {children}
        </div>
      </body>
    </html>
  );
}


=====================================
FILE: ./src/app/page.tsx
=====================================
'use client';

import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { SceneCanvas } from '@/ui/sim/SceneCanvas';
import { GlassPanel } from '@/ui/kit/atoms/GlassPanel';
import { SocialRow } from '@/ui/kit/molecules/SocialRow';
import { LiveArtGrid } from '@/ui/kit/molecules/LiveArtGrid';
import { HoloCommLog } from '@/ui/kit/molecules/HoloCommLog';
import { IdentityHUD } from '@/ui/kit/molecules/IdentityHUD';
import { Header } from '@/ui/os/desktop/Header';
import { Footer } from '@/ui/os/desktop/Footer';
import { AboutModal } from '@/ui/os/apps/identity/AboutModal';
import { FeedModal } from '@/ui/os/apps/feed/FeedModal';
import { GalleryModal } from '@/ui/os/apps/gallery/GalleryModal';
import { ContactModal } from '@/ui/os/apps/contact/ContactModal';
import { SettingsModal } from '@/ui/os/apps/settings/SettingsModal';
import { MatrixBootSequence } from '@/ui/os/boot/MatrixBootSequence';
import { MobileExperience } from '@/ui/os/apps/mobile/MobileExperience'; 
import { GameOverlay } from '@/ui/sim/GameCanvas';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { CustomCursor } from '@/ui/kit/atoms/CustomCursor';
import { ZenBomb } from '@/ui/kit/atoms/ZenBomb';
import { DebugOverlay } from '@/ui/os/apps/debug/DebugOverlay';
import { SimulationHUD } from '@/ui/os/apps/sandbox/SimulationHUD';
import { WebGLErrorBoundary } from '@/ui/os/overlays/ErrorBoundary';
import { GlobalBackdrop } from '@/ui/os/overlays/GlobalBackdrop'; 
import { MetaManager } from '@/ui/os/system/MetaManager'; 
import { RotationLock } from '@/ui/os/overlays/RotationLock';
import { FeedAccessTerminal } from '@/ui/kit/molecules/FeedAccessTerminal'; 
import { HoloBackground } from '@/ui/os/apps/sandbox/layout/HoloBackground';
import { GameProvider } from '@/engine/state/GameContext';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { clsx } from 'clsx';
import { PanelId } from '@/engine/config/PanelConfig';
import { DOM_ID } from '@/ui/config/DOMConfig';

export default function Home() {
  const { 
    setIntroDone, 
    bootState, 
    setBootState, 
    isBreaching, 
    startBreach, 
    activeModal, 
    isDebugOpen, 
    isDebugMinimized,
    setSimulationPaused,
    sandboxView,
    sessionId 
  } = useStore(); 
  
  const startGame = useGameStore(s => s.startGame);
  const systemIntegrity = useGameStore(s => s.systemIntegrity);
  const isZenMode = useGameStore(s => s.isZenMode);
  
  const isGameOver = systemIntegrity <= 0;
  const isSandbox = bootState === 'sandbox';
  const isMobileLockdown = bootState === 'mobile_lockdown'; 

  const showHoloBackground = isSandbox && (sandboxView === 'lab' || sandboxView === 'audio');

  const [dashboardScale, setDashboardScale] = useState(1);
  const [showPanels, setShowPanels] = useState(true);
  const contentRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
      const unsub = GameEventBus.subscribe(GameEvents.LOG_DEBUG, (p) => {
          if (p.msg === 'UI_PURGE_TRIGGER') {
              setShowPanels(false);
          }
      });
      return unsub;
  }, []);

  useEffect(() => {
    let timeoutId: NodeJS.Timeout;

    const handleResize = () => {
        if (!contentRef.current) return;
        if (window.innerWidth >= 1024) {
            const HEADER_H = 48;
            const FOOTER_H = 32;
            const PADDING_Y = 48; 
            const availableHeight = window.innerHeight - HEADER_H - FOOTER_H;
            const naturalHeight = contentRef.current.scrollHeight + PADDING_Y;
            const ratio = Math.min(1, availableHeight / naturalHeight);
            setDashboardScale(Math.floor(ratio * 1000) / 1000);
        } else {
            setDashboardScale(1);
        }
    };

    const debouncedResize = () => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(handleResize, 100);
    };

    handleResize();
    const observer = new ResizeObserver(debouncedResize);
    if (contentRef.current) observer.observe(contentRef.current);
    window.addEventListener('resize', debouncedResize);
    
    return () => {
        window.removeEventListener('resize', debouncedResize);
        observer.disconnect();
        clearTimeout(timeoutId);
    };
  }, [bootState]); 

  useEffect(() => {
    if (bootState !== 'active') return;

    const checkPauseState = () => {
        const isMenuOpen = activeModal !== 'none';
        const isDebugActive = isDebugOpen && !isDebugMinimized;
        const isPortrait = window.matchMedia("(orientation: portrait)").matches;
        const isSmallScreen = window.innerWidth < 768;
        const isRotationLocked = isPortrait && isSmallScreen;

        if (isMenuOpen || isDebugActive || isRotationLocked) {
            setSimulationPaused(true);
        } else {
            setSimulationPaused(false);
        }
    };

    checkPauseState();
    window.addEventListener('resize', checkPauseState);
    return () => window.removeEventListener('resize', checkPauseState);
  }, [bootState, activeModal, isDebugOpen, isDebugMinimized, setSimulationPaused]);

  useEffect(() => {
      AudioSystem.init();
  }, []);

  const handleBreachStart = () => {
    AudioSystem.playSound('initialize_impact');
    startBreach();
  };

  const handleBootComplete = () => {
    setTimeout(() => {
      setBootState('active');
      setIntroDone(true);
      AudioSystem.startMusic(); 
      startGame();
    }, 200);
  };

  const isSceneVisible = bootState !== 'standby' || isBreaching;

  return (
    <GameProvider>
      <div id={DOM_ID.APP_ROOT} className="relative w-full h-screen overflow-hidden cursor-none bg-black">
        
        <MetaManager />
        {!isMobileLockdown && <RotationLock />}
        <CustomCursor />
        <GlobalBackdrop />
        <DebugOverlay />

        <main className="relative w-full h-full flex flex-col overflow-hidden text-primary-green selection:bg-primary-green selection:text-black font-mono">
          
          <AnimatePresence>
              {showHoloBackground && (
                  <motion.div
                      initial={{ opacity: 0 }}
                      animate={{ opacity: 1 }}
                      exit={{ opacity: 0 }}
                      transition={{ duration: 0.5 }}
                      className="absolute inset-0 z-holo"
                  >
                      <HoloBackground />
                  </motion.div>
              )}
          </AnimatePresence>

          <WebGLErrorBoundary key={sessionId}>
              <SceneCanvas className={clsx("blur-0 transition-opacity duration-[2000ms]", isSceneVisible ? "opacity-100" : "opacity-0")} />
              
              {!isMobileLockdown && (
                  <div className={clsx("absolute inset-0 z-game-overlay transition-opacity duration-[2000ms] pointer-events-none", isSceneVisible ? "opacity-100" : "opacity-0")}>
                      <GameOverlay />
                  </div>
              )}
          </WebGLErrorBoundary>

          {isSandbox && <SimulationHUD />}

          {!isSandbox && !isMobileLockdown && (
              <>
                  <AboutModal />
                  <FeedModal />
                  <GalleryModal />
                  <ContactModal />
                  <SettingsModal />
                  <ZenBomb />
              </>
          )}

          {bootState === 'standby' && (
            <MatrixBootSequence 
               onComplete={handleBootComplete} 
               onBreachStart={handleBreachStart} 
            />
          )}

          {isMobileLockdown && <MobileExperience />}

          {!isSandbox && !isMobileLockdown && (
              <div className={`relative z-base flex-1 flex flex-col h-full transition-all duration-1000 ease-in-out ${bootState === 'active' ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-4'}`}>
                <Header />

                <div className="flex-1 min-h-0 relative w-full overflow-hidden">
                  <div 
                      className="w-full origin-top transition-transform duration-300 ease-out"
                      style={{ 
                          transform: `scale(${dashboardScale})`,
                          marginBottom: `-${(1 - dashboardScale) * 100}%` 
                      }}
                  >
                      <div ref={contentRef} className="w-full max-w-[1600px] mx-auto p-4 md:p-6">
                      <AnimatePresence>
                          {!isZenMode && showPanels && (
                          <motion.div 
                              className="grid grid-cols-1 md:grid-cols-12 gap-4 md:gap-6 w-full pb-8"
                              initial="hidden"
                              animate="visible"
                              exit={{ opacity: 0, scale: 0.95, transition: { duration: 0.8 } }} // Slow dissolve
                              variants={{
                              hidden: { opacity: 0 },
                              visible: { 
                                  opacity: 1, 
                                  transition: { 
                                  staggerChildren: 0.05,
                                  delayChildren: 0.0
                                  } 
                              }
                              }}
                          >
                              <div className="md:col-span-4 flex flex-col gap-4 md:gap-6 h-auto">
                              <GlassPanel title="IDENTITY_CORE" className="h-auto min-h-[400px]" gameId={PanelId.IDENTITY}>
                                  <IdentityHUD />
                              </GlassPanel>

                              <GlassPanel title="SOCIAL_UPLINK" className="h-52 shrink-0" gameId={PanelId.SOCIAL}>
                                  <SocialRow />
                              </GlassPanel>
                              </div>

                              <div className="md:col-span-8 flex flex-col gap-4 md:gap-6 h-auto">
                              <GlassPanel title="LATEST_LOGS" className="h-[30vh] min-h-[150px] shrink-0" gameId={PanelId.FEED}>
                                  <FeedAccessTerminal />
                              </GlassPanel>

                              <div className="flex flex-col md:flex-row gap-4 md:gap-6 items-start w-full">
                                  <GlassPanel title="ART_DB" className="flex-1 h-auto" gameId={PanelId.ART}>
                                  <LiveArtGrid />
                                  </GlassPanel>

                                  <GlassPanel title="HOLO_COMM" className="w-full md:w-[45%] shrink-0 h-auto" gameId={PanelId.VIDEO}>
                                  <HoloCommLog />
                                  </GlassPanel>
                              </div>
                              </div>
                          </motion.div>
                          )}
                      </AnimatePresence>
                      </div>
                  </div>
                </div>
                
                <Footer />
              </div>
          )}
        </main>
      </div>
    </GameProvider>
  );
}


=====================================
FILE: ./src/styles/globals.css
=====================================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 255, 65;
  --shake-x: 0px;
  --shake-y: 0px;
  --shake-r: 0rad;
}

html, body {
  background-color: #000000;
  overscroll-behavior: none; 
  touch-action: none; 
  cursor: none !important;
}

* {
  cursor: none !important;
}

body {
  color: #78F654;
  overflow: hidden; 
  font-family: 'Courier New', monospace;
  height: 100dvh; 
  width: 100vw;
}

#global-app-root {
  height: 100dvh;
  transform: translate3d(var(--shake-x), var(--shake-y), 0) rotate(var(--shake-r));
  will-change: transform; 
}

::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #050505; 
  border-left: 1px solid #15530A;
}

::-webkit-scrollbar-thumb {
  background: #0BD426; 
  border: 1px solid #000;
  border-radius: 2px;
}

::-webkit-scrollbar-thumb:hover {
  background: #78F654;
}

.glitch-text {
  text-shadow: 2px 0 #ff003c, -2px 0 #008f11;
}

.clip-corner-btn {
  clip-path: polygon(0 0, 100% 0, 100% 70%, 90% 100%, 0 100%);
}

@keyframes marching {
  0% { background-position: 0 0, 0 100%, 0 0, 100% 0; }
  100% { background-position: 20px 0, -20px 100%, 0 -20px, 100% 20px; }
}

.marching-ants {
  background-image: 
    linear-gradient(to right, var(--ant-color) 50%, transparent 50%),
    linear-gradient(to right, var(--ant-color) 50%, transparent 50%),
    linear-gradient(to bottom, var(--ant-color) 50%, transparent 50%),
    linear-gradient(to bottom, var(--ant-color) 50%, transparent 50%);
  background-size: 20px 1px, 20px 1px, 1px 20px, 1px 20px;
  background-repeat: repeat-x, repeat-x, repeat-y, repeat-y;
  animation: marching 1s linear infinite;
  border: none !important; 
}

body > div[data-nextjs-toast],
body > div[data-nextjs-dialog-overlay],
#next-route-announcer,
[class*="nextjs-toast"],
[class*="build-activity"],
[class*="static-route-indicator"] {
  display: none !important;
  opacity: 0 !important;
  pointer-events: none !important;
  visibility: hidden !important;
}


=====================================
FILE: ./src/engine/types/game.types.ts
=====================================
import { PanelId } from '@/engine/config/PanelConfig';

export interface RegisteredPanel {
  id: PanelId;
  element: HTMLElement;
  health: number;
  isDestroyed: boolean;
}

export type UpgradeOption = 
  | 'OVERCLOCK'      // Attack Speed
  | 'EXECUTE'        // Damage
  | 'FORK'           // Multishot
  | 'SNIFFER'        // Homing
  | 'BACKDOOR'       // Rear Guard
  | 'DAEMON'         // Summon Ally
  | 'REPAIR_NANITES' // Heal
  | 'RESTORE'        // System Op
  | 'PURGE';         // System Op

export interface GameState {
  isPlaying: boolean;
  score: number;
  threatLevel: number;
  panels: Record<string, RegisteredPanel>;
  
  startGame: () => void;
  stopGame: () => void;
  registerPanel: (id: PanelId, element: HTMLElement) => void;
  unregisterPanel: (id: PanelId) => void;
  damagePanel: (id: PanelId, amount: number) => void;
  healPanel: (id: PanelId, amount: number) => void;
}

export interface Entity {
  id: number;
  x: number;
  y: number;
  radius: number;
  active: boolean;
  spawnTime: number; 
}


=====================================
FILE: ./src/engine/config/AIConfig.ts
=====================================
export const AI_CONFIG = {
  HUNTER: {
    ORBIT_SPEED: 0.5,
    TARGET_RADIUS: 10.0,
    AIM_LERP: 0.05,
    CHARGE_LERP: 0.15,
    SPIN_SPEED_IDLE: 2.0,
    SPIN_SPEED_CHARGE: -8.0,
    PROJECTILE_SPEED: 25,
    OFFSET_DIST: 1.6,
    RECOIL_FORCE: 2.0
  },
  KAMIKAZE: {
    ROTATION_SPEED: 10.0,
    ENGAGEMENT_DIST: 0.1
  },
  DRILLER: {
    SNAP_THRESHOLD: 0.1,
    TIP_OFFSET: 0.4, // Based on Model Height
    AUDIO_INTERVAL: 0.25
  },
  DAEMON: {
    SHIELD_CHARGE_TIME: 2.0,
    COOLDOWN_TIME: 0.5,
    RECOVERY_TIME: 2.0,
    ORBIT_RADIUS: 4.0,
    ORBIT_SPEED_MIN: 1.5,
    ROTATION_SPEED: {
      CHARGING: 15.0,
      READY: 3.0,
      FIRE: 20.0,
      COOLDOWN: -5.0,
      BROKEN: 30.0
    }
  }
};


=====================================
FILE: ./src/engine/config/ProjectileConfig.ts
=====================================
import { PALETTE } from './Palette';

export const ProjectileGeometry = {
  SPHERE: 'SPHERE',
  CAPSULE: 'CAPSULE',
  DIAMOND: 'DIAMOND',
  PYRAMID: 'PYRAMID',
  RING: 'RING',
  ARROW: 'ARROW'
} as const;

export type GeometryType = keyof typeof ProjectileGeometry;

export interface ProjectileDef {
  geometry: GeometryType;
  color: [number, number, number];
  scale: [number, number, number];
  spinSpeed: number;  
  pulseSpeed: number; 
  faceVelocity: boolean; 
}

const neon = (hex: string, intensity: number): [number, number, number] => {
  const c = parseInt(hex.replace('#', ''), 16);
  const r = ((c >> 16) & 255) / 255;
  const g = ((c >> 8) & 255) / 255;
  const b = (c & 255) / 255;
  return [r * intensity, g * intensity, b * intensity];
};

export const PROJECTILE_CONFIG: Record<string, ProjectileDef> = {
  'PLAYER_STANDARD': {
    geometry: 'CAPSULE',
    color: neon(PALETTE.GREEN.PRIMARY, 4.0),
    scale: [0.15, 0.6, 0.15],
    spinSpeed: 0, pulseSpeed: 0, faceVelocity: true
  },
  'PLAYER_FORK': {
    geometry: 'PYRAMID',
    color: neon(PALETTE.YELLOW.SOFT, 3.0),
    scale: [0.4, 0.4, 0.4],
    spinSpeed: 5.0, pulseSpeed: 0, faceVelocity: true
  },
  'PLAYER_SNIFFER': {
    geometry: 'DIAMOND',
    color: neon(PALETTE.CYAN.PRIMARY, 5.0),
    scale: [0.3, 0.3, 0.3],
    spinSpeed: 15.0, pulseSpeed: 0, faceVelocity: false
  },
  'PLAYER_BACKDOOR': {
    geometry: 'RING',
    color: neon(PALETTE.RED.LIGHT, 3.0),
    scale: [0.4, 0.4, 0.4],
    spinSpeed: -2.0, pulseSpeed: 2.0, faceVelocity: false
  },
  'PLAYER_PURGE': {
    geometry: 'DIAMOND',
    color: [10, 10, 10],
    scale: [0.6, 0.6, 0.6],
    spinSpeed: 20.0, pulseSpeed: 0, faceVelocity: false
  },
  'ENEMY_HUNTER': {
    geometry: 'ARROW',
    color: neon(PALETTE.YELLOW.ORANGE, 6.0),
    scale: [0.3, 1.0, 0.3],
    spinSpeed: 0, pulseSpeed: 0, faceVelocity: true
  },
  'DAEMON_ORB': {
    geometry: 'SPHERE',
    color: neon('#0088FF', 5.0), 
    scale: [0.5, 0.5, 0.5],
    spinSpeed: 1.0, pulseSpeed: 4.0, faceVelocity: false
  }
};


=====================================
FILE: ./src/engine/config/ModelConfig.ts
=====================================
export const MODEL_CONFIG = {
  DRILLER: {
    height: 0.64, 
    radius: 0.24, 
    segments: 4,
    spawnOffset: 0.32 
  },
  KAMIKAZE: {
    radius: 0.69,
    detail: 0
  },
  HUNTER: {
    scale: 2.1
  }
};


=====================================
FILE: ./src/engine/config/PlayerConfig.ts
=====================================
export const PLAYER_CONFIG = {
  maxHealth: 20,       // Was 100
  fireRate: 0.15, 
  bulletSpeed: 45,
  bulletRadius: 0.2,
  bulletLife: 1.5,
  
  // Scoring & Progression (FASTER LEVELING)
  scoreMultiplier: 1,
  baseXpRequirement: 20, // Was 100. First level up is quick.
  xpScalingFactor: 1.2,  // Was 1.5. Curve is much flatter now.
};


=====================================
FILE: ./src/engine/config/constants/MathConstants.ts
=====================================
export const GAME_MATH = {
  SPAWN_RADIUS_STD: 25,
  WEAPON_SPREAD_BASE: 0.15,
  SNIFFER_ANGLE_OFFSET: Math.PI / 4,
  FULL_CIRCLE: Math.PI * 2
} as const;


=====================================
FILE: ./src/engine/config/constants/SystemConstants.ts
=====================================
export const SYS_LIMITS = {
  MAX_ENTITIES: 30000,
  MAX_PARTICLES: 20000,
  MAX_COLLISION_RESULTS: 1024,
  SPATIAL_GRID_SIZE: 4096,
  SPATIAL_CELL_SIZE: 4,
  EVENT_BUFFER_SIZE: 4096,
  MAX_POLYPHONY: 100,
  SAMPLE_RATE: 44100,
} as const;


=====================================
FILE: ./src/engine/config/constants/UIConstants.ts
=====================================
import { PALETTE } from '../Palette';

export const UI_METRICS = {
  VITALS: {
    SIZE: 160,
    RADIUS_HP: 60,
    RADIUS_XP: 70,
    STROKE: 4,
    THRESHOLD_CRITICAL: 0.3,
    THRESHOLD_WARNING: 0.6
  },
  JOYSTICK: {
    MAX_RADIUS: 40,
    SENSITIVITY: 30.0
  }
} as const;

export const UI_COLORS = {
  HP_SAFE: PALETTE.GREEN.PRIMARY,
  HP_WARN: PALETTE.YELLOW.ALERT,
  HP_CRIT: PALETTE.RED.CRITICAL,
  XP_BAR: PALETTE.PURPLE.PRIMARY
} as const;


=====================================
FILE: ./src/engine/config/PanelConfig.ts
=====================================
export enum PanelId {
  IDENTITY = 'identity',
  SOCIAL = 'social',
  FEED = 'feed',
  ART = 'art',
  VIDEO = 'video',
}


=====================================
FILE: ./src/engine/config/CameraConfig.ts
=====================================
export const CAMERA_CONFIG = {
  BASE_ZOOM: 40,
  FOV: 45,
  NEAR: 0.1,
  FAR: 1000
} as const;


=====================================
FILE: ./src/engine/config/TextAssets.ts
=====================================
// Used for the 3D Intro UI (Block Style)
export const ASCII_TITLE = `
 â–ˆâ–ˆâ–ˆâ–„ â–„â–ˆâ–ˆâ–ˆâ–“â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–“      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–“â–ˆâ–ˆ   â–ˆâ–ˆâ–“
â–“â–ˆâ–ˆâ–’â–€â–ˆâ–€ â–ˆâ–ˆâ–’â–“â–ˆ   â–€â–’â–ˆâ–ˆ    â–’ â–’â–ˆâ–ˆâ–’  â–ˆâ–ˆâ–’â–“â–ˆ   â–€ â–“â–ˆâ–ˆâ–’    â–’â–“â–ˆ   â–’  â–’â–ˆâ–ˆ  â–ˆâ–ˆâ–’
â–“â–ˆâ–ˆ    â–“â–ˆâ–ˆâ–‘â–’â–ˆâ–ˆâ–ˆ  â–‘ â–“â–ˆâ–ˆâ–„   â–’â–ˆâ–ˆâ–‘  â–ˆâ–ˆâ–’â–’â–ˆâ–ˆâ–ˆ   â–’â–ˆâ–ˆâ–‘    â–’â–“â–ˆâ–ˆâ–ˆ â–‘   â–’â–ˆâ–ˆ â–ˆâ–ˆâ–‘
â–’â–ˆâ–ˆ    â–’â–ˆâ–ˆ â–’â–“â–ˆ  â–„  â–’   â–ˆâ–ˆâ–’â–’â–ˆâ–ˆ   â–ˆâ–ˆâ–‘â–’â–“â–ˆ  â–„ â–’â–ˆâ–ˆâ–‘    â–‘â–“â–ˆâ–’  â–‘   â–‘ â–â–ˆâ–ˆâ–‘â–‘
â–’â–ˆâ–ˆâ–’   â–‘â–ˆâ–ˆâ–’â–‘â–’â–ˆâ–ˆâ–ˆâ–ˆâ–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–‘ â–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–ˆâ–ˆâ–ˆâ–ˆâ–’â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–‘â–’â–ˆâ–‘      â–‘ â–ˆâ–ˆâ–’â–‘â–‘
â–‘ â–’â–‘   â–‘  â–‘â–‘â–‘ â–’â–‘ â–‘ â–’â–‘â–’  â–‘ â–‘ â–’â–‘â–’â–‘â–’â–‘ â–‘â–‘ â–’â–‘ â–‘â–‘ â–’â–‘â–’  â–‘ â–’ â–‘       â–ˆâ–ˆâ–’â–’â–’
â–‘  â–‘      â–‘ â–‘ â–‘  â–‘ â–‘ â–’  â–‘   â–‘ â–’ â–’â–‘  â–‘ â–‘  â–‘â–‘ â–‘ â–’  â–‘ â–‘       â–“â–ˆâ–ˆ â–‘â–’â–‘ 
â–‘      â–‘      â–‘    â–‘ â–‘    â–‘ â–‘ â–‘ â–’     â–‘     â–‘ â–‘    â–‘ â–‘     â–’ â–’ â–‘â–‘  
       â–‘      â–‘  â–‘   â–‘  â–‘     â–‘ â–‘     â–‘  â–‘    â–‘  â–‘         â–‘ â–‘     
`;

// Stylized Header for Console
export const ASCII_CONSOLE = `
   __  __  ____  ____  ____  ____  __    ____  _  _ 
  (  \\/  )(  __)/ ___)/  _ \\(  __)(  )  (  __)( \\/ )
   )    (  ) _) \\___ \\  (_) )) _) / (_/\\ ) _)  \\  / 
  (_/\\/\\_)(____)(____/\\____/(____)\\____/(_)    (__) 
`;

const BASE_STYLE = 'font-family: "Courier New", monospace; font-weight: bold; font-size: 10px; line-height: 12px;';

export const CONSOLE_STYLES = {
  GREEN:  `${BASE_STYLE} color: #78F654; background: #050505;`,
  PURPLE: `${BASE_STYLE} color: #9E4EA5; background: #050505;`,
  CYAN:   `${BASE_STYLE} color: #00F0FF; background: #050505;`,
  TAG:    `font-family: monospace; font-size: 9px; background: #9E4EA5; color: #000; padding: 2px 4px; border-radius: 2px; font-weight: bold;`,
  STATUS: `font-family: monospace; font-size: 9px; background: #78F654; color: #000; padding: 2px 4px; border-radius: 2px; font-weight: bold;`
};


=====================================
FILE: ./src/engine/config/Palette.ts
=====================================
export const PALETTE = {
  // Core Identity
  GREEN: {
    PRIMARY: '#78F654',
    DIM: '#1bb930',
    DARK: '#217e10',
    GLOW: '#C2FE9A'
  },
  PURPLE: {
    PRIMARY: '#9E4EA5',
    LIGHT: '#BC86BA',
    DEEP: '#350E3A',
    DIM: '#822B8A'
  },
  RED: {
    CRITICAL: '#FF003C',
    DIM: '#800010',
    LIGHT: '#FF4D6D'
  },
  YELLOW: {
    ALERT: '#eae747',
    SOFT: '#F7D277',
    ORANGE: '#FF8C00'
  },
  CYAN: {
    PRIMARY: '#00F0FF',
    DIM: '#008ba3'
  },
  MONO: {
    BLACK: '#050505',
    WHITE: '#FFFFFF',
    GRAY: '#27282A'
  }
} as const;

// Collections for Procedural Generation
export const COLOR_SETS = {
  PURPLE: [PALETTE.PURPLE.PRIMARY, '#D0A3D8', '#E0B0FF', '#7A2F8F', '#B57EDC'],
  YELLOW: [PALETTE.YELLOW.SOFT, '#FFE5A0', '#FFA500', PALETTE.MONO.WHITE],
  RED:    [PALETTE.RED.CRITICAL, PALETTE.RED.LIGHT, PALETTE.RED.DIM],
  CYAN:   [PALETTE.CYAN.PRIMARY, PALETTE.CYAN.DIM, PALETTE.MONO.WHITE],
  WHITE:  [PALETTE.MONO.WHITE]
};


=====================================
FILE: ./src/engine/config/InputConfig.ts
=====================================
export const INPUT_SETTINGS = {
  VIRTUAL_CURSOR: {
    SPEED: 30.0,
  }
} as const;


=====================================
FILE: ./src/engine/config/static/waves.json
=====================================
[
  { "at": 0,     "type": "driller", "count": 4, "interval": 0.1 },
  { "at": 1.5,   "type": "hunter",  "count": 2, "interval": 0.2 },
  { "at": 3.5,   "type": "driller", "count": 8, "interval": 0.15 },
  { "at": 5.5,   "type": "kamikaze", "count": 4, "interval": 0.5 },
  { "at": 8.0,   "type": "driller", "count": 12, "interval": 0.1 },
  { "at": 10.5,  "type": "hunter",  "count": 4, "interval": 0.8 },
  { "at": 14.0,  "type": "kamikaze", "count": 6, "interval": 0.3 },
  { "at": 18.0,  "type": "driller", "count": 15, "interval": 0.05 },
  { "at": 22.0,  "type": "hunter",  "count": 5, "interval": 0.5 },
  { "at": 26.0,  "type": "kamikaze", "count": 8, "interval": 0.2 }
]


=====================================
FILE: ./src/engine/config/static/gallery.json
=====================================
[
  {
    "id": "art_001",
    "title": "ELFY_GENESIS",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#78F654"
  },
  {
    "id": "art_002",
    "title": "NEON_HEIST",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#9E4EA5"
  },
  {
    "id": "art_003",
    "title": "VOID_WALKER",
    "url": "https://x.com/mesoelfy",
    "category": "ROGUES",
    "color": "#FF003C"
  },
  {
    "id": "art_004",
    "title": "LATENT_GHOST",
    "url": "https://x.com/mesoelfy",
    "category": "COLLEAGUES",
    "color": "#F7D277"
  },
  {
    "id": "art_005",
    "title": "ZERO_DAY",
    "url": "https://x.com/mesoelfy",
    "category": "ELFY_MAIN",
    "color": "#78F654"
  },
  {
    "id": "art_006",
    "title": "SYSTEM_CRASH",
    "url": "https://x.com/mesoelfy",
    "category": "ROGUES",
    "color": "#FF003C"
  }
]


=====================================
FILE: ./src/engine/config/static/identity.json
=====================================
{
  "name": "Elfy",
  "class": "Latent Space Bandit",
  "abilities": ["Green Flame", "Digital Heist", "Prompt Craft"],
  "stats": {
    "STR": "ERROR",
    "INT": 9001,
    "CHA": 50
  },
  "bio": "I manifest art from the void. My mission: Create cool s**t and annoy the haters."
}


=====================================
FILE: ./src/engine/config/static/socials.json
=====================================
[
  { "name": "X / Twitter", "url": "https://x.com/mesoelfy", "icon": "twitter", "color": "#1DA1F2" },
  { "name": "YouTube", "url": "https://youtube.com/@mesoelfy", "icon": "youtube", "color": "#FF0000" },
  { "name": "TikTok", "url": "https://tiktok.com/@mesoelfy", "icon": "video", "color": "#00f2ea" },
  { "name": "GitHub", "url": "https://github.com/mesoelfy", "icon": "github", "color": "#ffffff" },
  { "name": "Newgrounds", "url": "https://mesoelfy.newgrounds.com/", "icon": "crosshair", "color": "#ffa500" },
  { "name": "DeviantArt", "url": "https://www.deviantart.com/mesoelfy", "icon": "image", "color": "#05cc47" }
]


=====================================
FILE: ./src/engine/config/static/feed.json
=====================================
[
  {
    "id": 1,
    "date": "2023-10-27",
    "title": "Elfy vs. RoboGhoul",
    "desc": "The final showdown. Green flame algorithm engaged.",
    "link": "https://x.com/mesoelfy/status/123456"
  },
  {
    "id": 2,
    "date": "2023-10-20",
    "title": "Latent Space Update",
    "desc": "Exploring the void. Found some weird artifacts.",
    "link": "https://x.com/mesoelfy/status/789012"
  }
]


=====================================
FILE: ./src/engine/config/AudioConfig.ts
=====================================
export const AUDIO_CURVES = {
  FILTER: {
    BASE_HZ: 300,
    MULTIPLIER: 10,
  },
  PAN: {
    BASE_FREQ: 0.05,
    MULTIPLIER: 20,
  },
  LFO: {
    BASE_FREQ: 0.2,
    DEPTH_BASE: 10,
    MULTIPLIER: 30,
    DEPTH_MULT: 20
  },
  DISTORTION: {
    FACTOR: 400
  },
  STEREO: {
    GAIN_FACTOR: 0.8,
    POWER: 3
  }
} as const;


=====================================
FILE: ./src/engine/config/Identifiers.ts
=====================================
import { GameEvents as Events } from '@/engine/signals/GameEvents';

export const EnemyTypes = {
  DRILLER: 'driller',
  KAMIKAZE: 'kamikaze',
  HUNTER: 'hunter',
  DAEMON: 'daemon',
} as const;

export const ArchetypeIDs = {
  PLAYER: 'PLAYER',
  BULLET_PLAYER: 'BULLET_PLAYER',
  BULLET_ENEMY: 'BULLET_ENEMY',
  ...EnemyTypes
} as const;

export type EnemyType = typeof EnemyTypes[keyof typeof EnemyTypes];
export type ArchetypeID = typeof ArchetypeIDs[keyof typeof ArchetypeIDs] | string;

// Direct re-export for cleaner imports
export const GameEvents = Events;


=====================================
FILE: ./src/engine/config/WaveConfig.ts
=====================================
export const WAVE_CONFIG = {
  baseSpawnInterval: 0.8,
  difficultyScaler: 1.0 
};


=====================================
FILE: ./src/engine/config/VisualConfig.ts
=====================================
export const VISUAL_CONFIG = {
  SHAKE: {
    DECAY_RATE: 2.0,
    MAX_OFFSET_X: 0.2,
    MAX_OFFSET_Y: 0.12,
    MAX_ROTATION: 0.015,
    BASE_SPEED: 15.0,
    TRAUMA_SPEED_BOOST: 65.0,
    PIXELS_PER_UNIT: 40
  },
  RENDER: {
    FLASH_DECAY: 6.0,
    SHUDDER_DECAY: 15.0,
    FLASH_COLOR: { r: 4.0, g: 0.0, b: 0.2 }
  },
  DEFORMATION: {
    STRETCH_FACTOR: 0.005,
    SQUASH_FACTOR: 0.002,
    MAX_STRETCH: 1.1,
    MIN_SQUASH: 0.95,
    SPAWN_Y_OFFSET: 3.5,
    
    // High Elasticity (Bullets)
    // TUNING: Increased base stretch from 0.04 to 0.06 for better visuals at lower speeds
    BASE_STRETCH: 0.06, 
    BASE_SQUASH: 0.03,
    MAX_STRETCH_CAP: 4.0,
    MIN_SQUASH_CAP: 0.4
  }
} as const;


=====================================
FILE: ./src/engine/config/PhysicsConfig.ts
=====================================
export const CollisionLayers = {
  NONE: 0,
  PLAYER: 1,
  ENEMY: 2,
  PLAYER_PROJECTILE: 4,
  ENEMY_PROJECTILE: 8,
  PANEL: 16,
  PICKUP: 32
} as const;

export const PhysicsConfig = {
  HITBOX: {
    PLAYER: 0.6,
    DRILLER: 0.4, // Reduced (was 0.5)
    KAMIKAZE: 0.7, // Increased (was 0.6)
    HUNTER: 0.74, 
    BULLET: 0.25,
    HUNTER_BULLET: 0.4
  },
  MASKS: {
    PLAYER: 42,
    ENEMY: 5,
    PLAYER_PROJECTILE: 10,
    ENEMY_PROJECTILE: 1
  }
};


=====================================
FILE: ./src/engine/config/Archetypes.ts
=====================================
import { PLAYER_CONFIG } from './PlayerConfig';
import { PhysicsConfig, CollisionLayers } from './PhysicsConfig';
import { ArchetypeIDs } from './Identifiers';
import { Tag } from '@/engine/ecs/types';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { GAME_THEME } from '@/ui/sim/config/theme';
import { GEOMETRY_IDS, MATERIAL_IDS } from './AssetKeys';
import { AI_STATE } from '@/engine/ai/AIStateTypes';

const parseHex = (hex: string) => {
    const c = parseInt(hex.replace('#', ''), 16);
    return { 
        r: ((c >> 16) & 255) / 255, 
        g: ((c >> 8) & 255) / 255, 
        b: (c & 255) / 255 
    };
};

export interface EntityBlueprint {
  id: string;
  tags: Tag[];
  aiLogic?: string;
  assets?: {
      geometry: string;
      material: string;
  };
  components: { type: ComponentType; data?: any }[];
}

// Helper for Render Composition
const RenderComps = (geo: string, mat: string, colorHex: string, effectData: any = {}) => [
    { type: ComponentType.RenderModel, data: { geometryId: geo, materialId: mat, ...parseHex(colorHex) } },
    { type: ComponentType.RenderTransform, data: { scale: 1.0 } },
    { type: ComponentType.RenderEffect, data: { ...effectData } }
];

export const ARCHETYPES: Record<string, EntityBlueprint> = {
  [ArchetypeIDs.PLAYER]: {
    id: ArchetypeIDs.PLAYER,
    tags: [Tag.PLAYER],
    components: [
      { type: ComponentType.Identity, data: { variant: 'PLAYER' } },
      { type: ComponentType.Transform, data: { x: 0, y: 0, rotation: 0, scale: 1 } },
      { type: ComponentType.Motion, data: { friction: 0.9 } },
      { type: ComponentType.Health, data: { max: PLAYER_CONFIG.maxHealth } },
      { type: ComponentType.State, data: { current: AI_STATE.IDLE } },
      { type: ComponentType.Collider, data: { 
          radius: PhysicsConfig.HITBOX.PLAYER, 
          layer: CollisionLayers.PLAYER, 
          mask: PhysicsConfig.MASKS.PLAYER 
      }},
      ...RenderComps(GEOMETRY_IDS.PLAYER, MATERIAL_IDS.PLAYER, GAME_THEME.turret.base)
    ]
  },
  [ArchetypeIDs.BULLET_PLAYER]: {
    id: ArchetypeIDs.BULLET_PLAYER,
    tags: [Tag.BULLET, Tag.PLAYER],
    components: [
      { type: ComponentType.Transform, data: { scale: 1.0 } },
      { type: ComponentType.Motion, data: { friction: 0 } },
      { type: ComponentType.Lifetime, data: { remaining: 1.5, total: 1.5 } },
      { type: ComponentType.Combat, data: { damage: 1 } },
      { type: ComponentType.Health, data: { max: 1 } },
      { type: ComponentType.Collider, data: { 
          radius: PhysicsConfig.HITBOX.BULLET, 
          layer: CollisionLayers.PLAYER_PROJECTILE, 
          mask: PhysicsConfig.MASKS.PLAYER_PROJECTILE 
      }},
      { type: ComponentType.Projectile, data: { configId: 'PLAYER_STANDARD', state: 'FLIGHT' } },
      // Placeholders to allow EntitySpawner overrides to take effect
      { type: ComponentType.RenderModel, data: {} },
      { type: ComponentType.RenderTransform, data: {} },
      { type: ComponentType.RenderEffect, data: {} }
    ]
  },
  [ArchetypeIDs.BULLET_ENEMY]: {
    id: ArchetypeIDs.BULLET_ENEMY,
    tags: [Tag.BULLET, Tag.ENEMY],
    components: [
      { type: ComponentType.Transform, data: { scale: 1.0 } },
      { type: ComponentType.Motion, data: { friction: 0 } },
      { type: ComponentType.Lifetime, data: { remaining: 3.0, total: 3.0 } },
      { type: ComponentType.Combat, data: { damage: 10 } },
      { type: ComponentType.Health, data: { max: 1 } },
      { type: ComponentType.Collider, data: { 
          radius: PhysicsConfig.HITBOX.HUNTER_BULLET, 
          layer: CollisionLayers.ENEMY_PROJECTILE, 
          mask: PhysicsConfig.MASKS.ENEMY_PROJECTILE 
      }},
      { type: ComponentType.Projectile, data: { configId: 'ENEMY_HUNTER', state: 'FLIGHT' } },
      { type: ComponentType.RenderModel, data: {} },
      { type: ComponentType.RenderTransform, data: {} },
      { type: ComponentType.RenderEffect, data: {} }
    ]
  },
  [ArchetypeIDs.DRILLER]: {
    id: ArchetypeIDs.DRILLER,
    tags: [Tag.ENEMY, Tag.OBSTACLE],
    aiLogic: 'driller',
    assets: { geometry: GEOMETRY_IDS.DRILLER, material: MATERIAL_IDS.ENEMY_BASE },
    components: [
      { type: ComponentType.Identity, data: { variant: ArchetypeIDs.DRILLER } },
      { type: ComponentType.Transform, data: { scale: 1.0 } }, 
      { type: ComponentType.Health, data: { max: 1 } }, 
      { type: ComponentType.Motion, data: { friction: 0 } },
      { type: ComponentType.Combat, data: { damage: 1 } },
      { type: ComponentType.Collider, data: { radius: PhysicsConfig.HITBOX.DRILLER, layer: CollisionLayers.ENEMY, mask: PhysicsConfig.MASKS.ENEMY } },
      { type: ComponentType.State, data: { current: AI_STATE.SPAWN, timers: { spawn: 1.5 } } },
      { type: ComponentType.Target, data: { type: 'PANEL' } },
      ...RenderComps(GEOMETRY_IDS.DRILLER, MATERIAL_IDS.ENEMY_BASE, GAME_THEME.enemy.muncher, { elasticity: 0.1 })
    ]
  },
  [ArchetypeIDs.KAMIKAZE]: {
    id: ArchetypeIDs.KAMIKAZE,
    tags: [Tag.ENEMY, Tag.OBSTACLE],
    aiLogic: 'kamikaze',
    assets: { geometry: GEOMETRY_IDS.KAMIKAZE, material: MATERIAL_IDS.ENEMY_BASE },
    components: [
      { type: ComponentType.Identity, data: { variant: ArchetypeIDs.KAMIKAZE } },
      { type: ComponentType.Transform, data: { scale: 1.0 } }, 
      { type: ComponentType.Health, data: { max: 2 } }, 
      { type: ComponentType.Motion, data: { friction: 0 } },
      { type: ComponentType.Combat, data: { damage: 3 } },
      { type: ComponentType.Collider, data: { radius: PhysicsConfig.HITBOX.KAMIKAZE, layer: CollisionLayers.ENEMY, mask: PhysicsConfig.MASKS.ENEMY } },
      { type: ComponentType.State, data: { current: AI_STATE.SPAWN, timers: { spawn: 1.5 } } },
      { type: ComponentType.Target, data: { type: 'PLAYER' } },
      ...RenderComps(GEOMETRY_IDS.KAMIKAZE, MATERIAL_IDS.ENEMY_BASE, GAME_THEME.enemy.kamikaze, { elasticity: 0.1 })
    ]
  },
  [ArchetypeIDs.HUNTER]: {
    id: ArchetypeIDs.HUNTER,
    tags: [Tag.ENEMY, Tag.OBSTACLE],
    aiLogic: 'hunter',
    assets: { geometry: GEOMETRY_IDS.HUNTER, material: MATERIAL_IDS.ENEMY_BASE },
    components: [
      { type: ComponentType.Identity, data: { variant: ArchetypeIDs.HUNTER } },
      { type: ComponentType.Transform, data: { scale: 1.0 } }, 
      { type: ComponentType.Health, data: { max: 3 } }, 
      { type: ComponentType.Motion, data: { friction: 0 } },
      { type: ComponentType.Combat, data: { damage: 10 } }, 
      { type: ComponentType.Collider, data: { radius: PhysicsConfig.HITBOX.HUNTER, layer: CollisionLayers.ENEMY, mask: PhysicsConfig.MASKS.ENEMY } },
      { type: ComponentType.State, data: { current: AI_STATE.SPAWN, timers: { spawn: 1.5 } } },
      { type: ComponentType.Target, data: { type: 'PLAYER' } },
      ...RenderComps(GEOMETRY_IDS.HUNTER, MATERIAL_IDS.ENEMY_BASE, GAME_THEME.enemy.hunter, { elasticity: 0.1 })
    ]
  },
  [ArchetypeIDs.DAEMON]: {
    id: ArchetypeIDs.DAEMON,
    tags: [Tag.PLAYER],
    aiLogic: 'daemon',
    assets: { geometry: GEOMETRY_IDS.DAEMON, material: MATERIAL_IDS.ENEMY_BASE },
    components: [
      { type: ComponentType.Identity, data: { variant: ArchetypeIDs.DAEMON } },
      { type: ComponentType.Transform, data: { scale: 1.0 } },
      { type: ComponentType.Health, data: { max: 100 } }, 
      { type: ComponentType.Orbital, data: { radius: 4.0, speed: 1.5, angle: 0 } },
      { type: ComponentType.Target, data: { type: 'ENEMY' } }, 
      { type: ComponentType.Collider, data: { radius: 0.6, layer: CollisionLayers.PLAYER, mask: PhysicsConfig.MASKS.PLAYER } },
      { type: ComponentType.State, data: { current: AI_STATE.ORBIT } },
      ...RenderComps(GEOMETRY_IDS.DAEMON, MATERIAL_IDS.ENEMY_BASE, '#00F0FF', { elasticity: 0.05 })
    ]
  }
};


=====================================
FILE: ./src/engine/config/AssetKeys.ts
=====================================
import { AUDIO_MANIFEST } from './assets/AudioManifest';
import { VFX_MANIFEST } from './assets/VFXManifest';

// --- GEOMETRY ---
export const GEOMETRY_IDS = {
  DRILLER: 'GEO_DRILLER',
  KAMIKAZE: 'GEO_KAMIKAZE',
  HUNTER: 'GEO_HUNTER',
  DAEMON: 'GEO_DAEMON',
  PARTICLE: 'GEO_PARTICLE',
  PLAYER: 'PLAYER_GEO',
  PRJ_SPHERE: 'GEO_PRJ_SPHERE',
  PRJ_CAPSULE: 'GEO_PRJ_CAPSULE',
  PRJ_DIAMOND: 'GEO_PRJ_DIAMOND',
  PRJ_PYRAMID: 'GEO_PRJ_PYRAMID',
  PRJ_RING: 'GEO_PRJ_RING',
  PRJ_ARROW: 'GEO_PRJ_ARROW'
} as const;

export type GeometryKey = typeof GEOMETRY_IDS[keyof typeof GEOMETRY_IDS];

// --- MATERIALS ---
export const MATERIAL_IDS = {
  ENEMY_BASE: 'MAT_ENEMY_BASE',
  PARTICLE: 'MAT_PARTICLE',
  PLAYER: 'PLAYER_MAT',
  GLITCH: 'MAT_GLITCH',
  PLAYER_AMBIENT: 'MAT_PLAYER_AMBIENT',
  PLAYER_BACKING: 'MAT_PLAYER_BACKING',
  GALLERY_BODY: 'MAT_GALLERY_BODY',
  PROJECTILE: 'MAT_PROJECTILE'
} as const;

export type MaterialKey = typeof MATERIAL_IDS[keyof typeof MATERIAL_IDS];

export type AudioKey = keyof typeof AUDIO_MANIFEST;
export type VFXKey = keyof typeof VFX_MANIFEST;


=====================================
FILE: ./src/engine/config/StorageConfig.ts
=====================================
export const STORAGE_KEYS = {
  GAME_STATE: 'mesoelfy-os-storage-v3',
  UI_SETTINGS: 'mesoelfy-ui-settings-v3'
} as const;


=====================================
FILE: ./src/engine/config/assets/VFXManifest.ts
=====================================
import { COLOR_SETS } from '../Palette';

export type VFXPattern = 'RADIAL' | 'DIRECTIONAL';

export interface VFXRecipe {
  pattern: VFXPattern;
  colors: string[];
  count: [number, number];
  speed: [number, number];
  life: [number, number];
  spread?: number;
  size?: [number, number];
  shape?: number; 
  omniChance?: number; 
}

// --- FACTORY ---
const createExplosion = (
    colors: string[], 
    isDirectional: boolean,
    counts: [number, number],
    speeds: [number, number]
): VFXRecipe => {
  if (isDirectional) {
    return {
      pattern: 'DIRECTIONAL',
      colors: colors,
      count: counts,
      speed: speeds,
      life: [0.5, 0.9],
      spread: 1.6,
      omniChance: 0.15
    };
  }
  return {
    pattern: 'RADIAL',
    colors: colors,
    count: [Math.floor(counts[0] * 0.75), Math.floor(counts[1] * 0.75)],
    speed: speeds,
    life: [0.4, 0.8]
  };
};

export const VFX_MANIFEST: Record<string, VFXRecipe> = {
  // Driller: Medium Count, Medium Speed
  'EXPLOSION_PURPLE':     createExplosion(COLOR_SETS.PURPLE, false, [20, 30], [5, 10]),
  'EXPLOSION_PURPLE_DIR': createExplosion(COLOR_SETS.PURPLE, true,  [20, 30], [5, 10]),
  
  // Hunter: Lower Count, Higher Speed (Snappy)
  'EXPLOSION_YELLOW':     createExplosion(COLOR_SETS.YELLOW, false, [15, 25], [10, 18]),
  'EXPLOSION_YELLOW_DIR': createExplosion(COLOR_SETS.YELLOW, true,  [15, 25], [10, 18]),
  
  // Kamikaze: Max Count, Max Speed (Violent)
  'EXPLOSION_RED':        createExplosion(COLOR_SETS.RED, false, [20, 35], [12, 22]),
  'EXPLOSION_RED_DIR':    createExplosion(COLOR_SETS.RED, true,  [20, 35], [12, 22]),

  // Custom / Unique FX
  'IMPACT_WHITE': { pattern: 'RADIAL', colors: COLOR_SETS.WHITE, count: [3, 5], speed: [2, 5], life: [0.1, 0.2] },
  'IMPACT_RED':   { pattern: 'RADIAL', colors: COLOR_SETS.RED, count: [4, 7], speed: [3, 8], life: [0.2, 0.4] },
  'CLASH_YELLOW': { pattern: 'RADIAL', colors: COLOR_SETS.YELLOW, count: [5, 8], speed: [5, 10], life: [0.2, 0.4] },
  
  'DRILL_SPARKS':  { 
      pattern: 'DIRECTIONAL', 
      colors: COLOR_SETS.PURPLE, 
      count: [3, 6], 
      speed: [10, 10], 
      life: [0.1, 0.2], 
      spread: 0.7, 
      size: [0.5, 0.5],
      shape: 1 
  },
  
  'HUNTER_RECOIL': { pattern: 'DIRECTIONAL', colors: COLOR_SETS.YELLOW, count: [8, 12], speed: [10, 18], life: [0.3, 0.6], spread: 0.5 },
  
  'ENGINE_FLARE': { 
    pattern: 'DIRECTIONAL', 
    colors: [COLOR_SETS.YELLOW[0], COLOR_SETS.WHITE[0]], 
    count: [3, 5], 
    speed: [15, 25], 
    life: [0.1, 0.2], 
    spread: 0.05 
  },
  
  'REBOOT_HEAL': { pattern: 'RADIAL', colors: COLOR_SETS.CYAN, count: [8, 12], speed: [2, 5], life: [0.5, 1.0] },
  'PURGE_BLAST': { pattern: 'RADIAL', colors: ['#FFFFFF', '#FF003C'], count: [50, 50], speed: [10, 30], life: [1.5, 2.5] }
};


=====================================
FILE: ./src/engine/config/assets/AudioManifest.ts
=====================================
export type SoundType = 'oscillator' | 'noise';

export interface SoundDef {
  type: SoundType;
  wave?: OscillatorType; 
  frequency: [number, number]; 
  duration: number; 
  volume: number; 
  pitchVariance: number; 
  filter?: [number, number]; 
  distortion?: number; 
  attack?: number; 
  fm?: { modFreq: number; modIndex: number; modType: OscillatorType; };
  tremolo?: { rate: number; depth: number; wave?: OscillatorType; };
  label: string;
  category: 'UI' | 'COMBAT' | 'AMBIENCE' | 'LAB_RESOURCES';
}

export const AUDIO_MANIFEST: Record<string, SoundDef> = {
  // --- PRODUCTION UI ---
  'ui_click': { type: 'oscillator', wave: 'square', frequency: [400, 400], duration: 0.05, volume: 0.1, pitchVariance: 0, label: 'Click', category: 'UI' },
  'ui_hover': { type: 'oscillator', wave: 'sine', frequency: [800, 800], duration: 0.03, volume: 0.05, pitchVariance: 50, label: 'Hover', category: 'UI' },
  'ui_menu_open': { type: 'oscillator', wave: 'sine', frequency: [440, 660], duration: 0.15, volume: 0.1, pitchVariance: 0, attack: 0.02, label: 'Menu Open', category: 'UI' },
  'ui_menu_close': { type: 'oscillator', wave: 'sine', frequency: [660, 440], duration: 0.15, volume: 0.1, pitchVariance: 0, attack: 0.02, label: 'Menu Close', category: 'UI' },
  'ui_optimal': { type: 'oscillator', wave: 'sine', frequency: [1200, 1200], duration: 0.4, volume: 0.15, pitchVariance: 0, attack: 0.01, label: 'Optimal', category: 'UI' },
  'ui_error': { type: 'oscillator', wave: 'sawtooth', frequency: [150, 50], duration: 0.2, volume: 0.2, pitchVariance: 0, distortion: 50, label: 'Error', category: 'UI' },
  'ui_chirp': { type: 'oscillator', wave: 'triangle', frequency: [400, 600], duration: 0.1, volume: 0.1, pitchVariance: 0, label: 'Chirp', category: 'UI' },
  
  // --- PRODUCTION COMBAT ---
  'fx_player_fire': { type: 'oscillator', wave: 'sawtooth', frequency: [880, 110], duration: 0.15, volume: 0.35, pitchVariance: 100, attack: 0.005, label: 'Plasma Shot', category: 'COMBAT' },
  'fx_enemy_fire': { type: 'oscillator', wave: 'square', frequency: [440, 220], duration: 0.2, volume: 0.15, pitchVariance: 50, label: 'Enemy Shot', category: 'COMBAT' },
  'fx_impact_light': { type: 'noise', frequency: [0, 0], filter: [1000, 100], duration: 0.4, volume: 0.3, pitchVariance: 200, distortion: 20, label: 'Light Hit', category: 'COMBAT' },
  'fx_impact_heavy': { type: 'noise', frequency: [0, 0], filter: [600, 50], duration: 1.5, volume: 0.5, pitchVariance: 0, distortion: 50, label: 'Heavy Hit', category: 'COMBAT' },
  'fx_player_death': { type: 'noise', frequency: [0,0], filter: [500, 500], duration: 2.0, volume: 0.6, pitchVariance: 0, distortion: 200, tremolo: { rate: 12, depth: 1.0, wave: 'square' }, label: 'Flatline', category: 'COMBAT' },
  'fx_level_up': { type: 'oscillator', wave: 'triangle', frequency: [440, 880], duration: 0.4, volume: 0.2, pitchVariance: 0, label: 'Level Up', category: 'COMBAT' },
  'fx_reboot_success': { type: 'oscillator', wave: 'triangle', frequency: [440, 880], duration: 0.3, volume: 0.3, pitchVariance: 0, attack: 0.01, tremolo: { rate: 10, depth: 1.0, wave: 'square' }, label: 'Reboot', category: 'COMBAT' },
  'fx_teleport': { type: 'oscillator', wave: 'sine', frequency: [100, 1500], duration: 0.3, volume: 0.2, pitchVariance: 0, label: 'Teleport', category: 'COMBAT' },
  'fx_exhaust_sizzle': { type: 'noise', frequency: [0, 0], filter: [4000, 2000], duration: 0.3, volume: 0.1, pitchVariance: 0, distortion: 10, tremolo: { rate: 20, depth: 0.6, wave: 'sawtooth' }, label: 'Sizzle', category: 'COMBAT' },

  // --- PRODUCTION AMBIENCE ---
  'loop_heal': { type: 'oscillator', wave: 'sine', frequency: [300, 600], duration: 0.2, volume: 0.1, pitchVariance: 0, label: 'Repair Loop', category: 'AMBIENCE' },
  'loop_reboot': { type: 'oscillator', wave: 'sine', frequency: [100, 200], duration: 0.2, volume: 0.6, pitchVariance: 0, label: 'Reboot Loop', category: 'AMBIENCE' },
  'loop_warning': { type: 'oscillator', wave: 'sine', frequency: [55, 55], duration: 0.8, volume: 0.7, pitchVariance: 0, attack: 0.03, fm: { modType: 'sine', modFreq: 10, modIndex: 25 }, label: 'Low Health', category: 'AMBIENCE' },
  'loop_drill': { type: 'noise', frequency: [0,0], filter: [300, 50], duration: 0.25, volume: 0.5, pitchVariance: 50, distortion: 60, label: 'Drill Grind', category: 'COMBAT' },
  'ambience_core': { type: 'noise', frequency: [0,0], filter: [800, 800], duration: 40.0, volume: 0.24, pitchVariance: 0, label: 'Core Hum', category: 'AMBIENCE' },
  'fx_boot_sequence': { type: 'noise', frequency: [0, 0], filter: [1500, 50], duration: 2.0, volume: 0.6, pitchVariance: 0, distortion: 30, label: 'Boot Up', category: 'AMBIENCE' },

  // --- LAB RESOURCES: SYNTHETIC RISERS ---
  'syn_sine_rise': { type: 'oscillator', wave: 'sine', frequency: [200, 400], duration: 1.0, volume: 0.3, pitchVariance: 0, label: 'Sine Rise', category: 'LAB_RESOURCES' },
  'syn_saw_rise': { type: 'oscillator', wave: 'sawtooth', frequency: [100, 800], duration: 1.0, volume: 0.2, pitchVariance: 0, fm: { modType: 'sine', modFreq: 50, modIndex: 200 }, label: 'Saw Rise', category: 'LAB_RESOURCES' },
  'syn_sqr_rise': { type: 'oscillator', wave: 'square', frequency: [60, 60], duration: 1.0, volume: 0.2, pitchVariance: 0, fm: { modType: 'triangle', modFreq: 15, modIndex: 100 }, label: 'Square Rise', category: 'LAB_RESOURCES' },
  'syn_siren_wail': { type: 'oscillator', wave: 'sine', frequency: [60, 20], duration: 2.5, volume: 0.6, pitchVariance: 0, distortion: 20, label: 'Siren', category: 'LAB_RESOURCES' },
  
  // --- LAB RESOURCES: DATA & STATIC ---
  'syn_data_burst': { type: 'oscillator', wave: 'square', frequency: [25, 20], duration: 0.4, volume: 0.4, pitchVariance: 0, distortion: 50, label: 'Data Burst', category: 'LAB_RESOURCES' },
  'syn_static_burst': { type: 'noise', frequency: [0, 0], filter: [800, 2000], duration: 0.4, volume: 0.3, pitchVariance: 0, distortion: 400, label: 'Static', category: 'LAB_RESOURCES' },
  'syn_static_wash': { type: 'noise', frequency: [0, 0], filter: [2000, 200], duration: 1.5, volume: 0.4, pitchVariance: 0, distortion: 100, label: 'Wash', category: 'LAB_RESOURCES' },
  'syn_interference': { type: 'noise', frequency: [0,0], filter: [800, 400], duration: 3.0, volume: 0.4, pitchVariance: 0, distortion: 100, tremolo: { rate: 6, depth: 0.6, wave: 'square' }, label: 'Interference', category: 'LAB_RESOURCES' },

  // --- LAB RESOURCES: TEXTURES & BASS ---
  'syn_fm_scream': { type: 'oscillator', wave: 'sawtooth', frequency: [800, 1200], duration: 0.5, volume: 0.15, pitchVariance: 50, fm: { modType: 'sine', modFreq: 150, modIndex: 300 }, label: 'FM Scream', category: 'LAB_RESOURCES' },
  'syn_bass_drop': { type: 'oscillator', wave: 'triangle', frequency: [150, 100], duration: 0.6, volume: 0.3, pitchVariance: 20, fm: { modType: 'square', modFreq: 57, modIndex: 1000 }, label: 'Bass Drop', category: 'LAB_RESOURCES' },
  'syn_wobble_bass': { type: 'oscillator', wave: 'sine', frequency: [50, 50], duration: 0.5, volume: 0.6, pitchVariance: 0, fm: { modType: 'sine', modFreq: 10, modIndex: 50 }, label: 'Wobble', category: 'LAB_RESOURCES' },
  'syn_deep_hum': { type: 'noise', frequency: [0,0], filter: [80, 40], duration: 3.0, volume: 0.8, pitchVariance: 0, distortion: 20, tremolo: { rate: 0.5, depth: 0.9, wave: 'sine' }, label: 'Deep Hum', category: 'LAB_RESOURCES' },
  'syn_grind_loop': { type: 'noise', frequency: [0,0], filter: [200, 100], duration: 3.0, volume: 0.5, pitchVariance: 0, distortion: 50, tremolo: { rate: 2, depth: 0.8, wave: 'sine' }, label: 'Grind Loop', category: 'LAB_RESOURCES' },
  
  // --- LAB RESOURCES: ORGANIC ---
  'syn_insect_swarm': { type: 'noise', frequency: [0,0], filter: [1500, 800], duration: 3.0, volume: 0.3, pitchVariance: 0, distortion: 10, tremolo: { rate: 12, depth: 1.0, wave: 'sawtooth' }, label: 'Swarm', category: 'LAB_RESOURCES' },
  'syn_robot_chatter': { type: 'noise', frequency: [0,0], filter: [500, 500], duration: 3.0, volume: 0.5, pitchVariance: 0, distortion: 200, tremolo: { rate: 8, depth: 1.0, wave: 'square' }, label: 'Bot Chatter', category: 'LAB_RESOURCES' },
  'syn_wind_howl': { type: 'noise', frequency: [0,0], filter: [100, 1000], duration: 3.0, volume: 0.4, pitchVariance: 0, distortion: 20, tremolo: { rate: 15, depth: 0.5, wave: 'sine' }, label: 'Wind', category: 'LAB_RESOURCES' },
  'syn_alarm_chirp': { type: 'oscillator', wave: 'sawtooth', frequency: [400, 50], duration: 0.3, volume: 0.3, pitchVariance: 50, distortion: 100, label: 'Alarm Chirp', category: 'LAB_RESOURCES' },
  'syn_alert_pulse': { type: 'oscillator', wave: 'square', frequency: [400, 350], duration: 1.0, volume: 0.3, pitchVariance: 0, fm: { modType: 'square', modFreq: 8, modIndex: 50 }, label: 'Alert Pulse', category: 'LAB_RESOURCES' }
};


=====================================
FILE: ./src/engine/config/WorldConfig.ts
=====================================
export const WorldConfig = {
  bounds: {
    width: 32, // World Units
    height: 18,
    depth: 5
  },
  physics: {
    friction: 0.95,
    maxVelocity: 20
  },
  time: {
    fixedDelta: 1 / 60, // Logic runs at 60hz (0.0166s per tick)
    maxAccumulator: 0.1 // Prevent "Spiral of Death" if CPU lags hard
  }
};


=====================================
FILE: ./src/engine/config/GameplayConfig.ts
=====================================
export const GAMEPLAY_CONFIG = {
  INTERACTION: {
    REPAIR_RATE: 0.05,
    QUERY_RADIUS: 1.0,
    // Increased by ~15% (Was 2.8 -> 3.25)
    REPAIR_HEAL_AMOUNT: 3.25,
    // Increased by ~15% (Was 4.0 -> 4.6)
    REBOOT_TICK_AMOUNT: 4.6
  },
  WEAPON: {
    MUZZLE_OFFSET: 1.2
  },
  STRUCTURE: {
    DECAY_INTERVAL: 0.1,
    DECAY_AMOUNT: 2.0
  }
} as const;


=====================================
FILE: ./src/engine/config/BootConfig.ts
=====================================
export const BOOT_SEQUENCE = {
  TIMINGS: {
    INIT: 3000,
    LINK: 4000,
    SECURITY_CHECK: 8000,
    BYPASS: 9500,
    DECRYPT: 11500,
    READY: 13500
  },
  COMPLETION_DELAY: 800
};


=====================================
FILE: ./src/engine/input/VirtualJoystickService.ts
=====================================
export class VirtualJoystickServiceController {
  private _vector = { x: 0, y: 0 };
  private _isActive = false;

  public setVector(x: number, y: number) {
    this._vector.x = x;
    this._vector.y = y;
    this._isActive = (x !== 0 || y !== 0);
  }

  public getVector() {
    return this._vector;
  }

  public get isActive() {
    return this._isActive;
  }
}

export const VirtualJoystickService = new VirtualJoystickServiceController();


=====================================
FILE: ./src/engine/signals/GameEvents.ts
=====================================
import { PanelId } from '@/engine/config/PanelConfig';

export enum GameEvents {
  PLAYER_FIRED = 'PLAYER_FIRED',
  PLAYER_HIT = 'PLAYER_HIT',
  ENEMY_SPAWNED = 'ENEMY_SPAWNED',
  ENEMY_DAMAGED = 'ENEMY_DAMAGED',
  ENEMY_DESTROYED = 'ENEMY_DESTROYED',
  PROJECTILE_CLASH = 'PROJECTILE_CLASH',
  
  PANEL_DAMAGED = 'PANEL_DAMAGED',
  PANEL_HEALED = 'PANEL_HEALED',
  PANEL_RESTORED = 'PANEL_RESTORED',
  PANEL_DESTROYED = 'PANEL_DESTROYED',
  
  GAME_START = 'GAME_START',
  GAME_OVER = 'GAME_OVER',
  
  THREAT_LEVEL_UP = 'THREAT_LEVEL_UP',
  UPGRADE_SELECTED = 'UPGRADE_SELECTED',
  ZEN_MODE_ENABLED = 'ZEN_MODE_ENABLED',
  
  DEBUG_SPAWN = 'DEBUG_SPAWN',
  LOG_DEBUG = 'LOG_DEBUG',
  BOOT_LOG = 'BOOT_LOG',
  
  // VFX & Audio (Migrated from FastEvents)
  TRAUMA_ADDED = 'TRAUMA_ADDED',
  SPAWN_FX = 'SPAWN_FX',
  SPAWN_IMPACT = 'SPAWN_IMPACT',
  PLAY_SOUND = 'PLAY_SOUND',
  
  SPAWN_DAEMON = 'SPAWN_DAEMON',
  HEARTBEAT = 'HEARTBEAT',
  
  PLAYER_REBOOT_TICK = 'PLAYER_REBOOT_TICK',
  PLAYER_REBOOT_DECAY = 'PLAYER_REBOOT_DECAY'
}

export type FXVariant = 
  | 'EXPLOSION_PURPLE' 
  | 'EXPLOSION_YELLOW' 
  | 'EXPLOSION_RED'
  | 'IMPACT_WHITE'
  | 'IMPACT_RED'
  | 'IMPACT_YELLOW'
  | 'DRILL_SPARKS'
  | 'HUNTER_RECOIL'
  | 'CLASH_YELLOW'
  | 'REBOOT_HEAL'
  | 'PURGE_BLAST'
  | 'ENGINE_FLARE'
  | 'EXPLOSION_PURPLE_DIR'
  | 'EXPLOSION_YELLOW_DIR'
  | 'EXPLOSION_RED_DIR';

export interface GameEventPayloads {
  [GameEvents.PLAYER_FIRED]: { x: number; y: number };
  [GameEvents.PLAYER_HIT]: { damage: number };
  [GameEvents.ENEMY_SPAWNED]: { type: string; id: number };
  [GameEvents.ENEMY_DAMAGED]: { id: number; damage?: number; type?: string };
  [GameEvents.ENEMY_DESTROYED]: { id: number; type: string; x: number; y: number };
  [GameEvents.PROJECTILE_CLASH]: { x: number; y: number };
  
  [GameEvents.PANEL_DAMAGED]: { id: PanelId; amount: number; currentHealth: number; sourceX?: number; sourceY?: number };
  [GameEvents.PANEL_HEALED]: { id: PanelId; amount: number };
  [GameEvents.PANEL_RESTORED]: { id: PanelId; x?: number }; 
  [GameEvents.PANEL_DESTROYED]: { id: PanelId };
  
  [GameEvents.GAME_START]: null;
  [GameEvents.GAME_OVER]: { score: number };
  
  [GameEvents.THREAT_LEVEL_UP]: { level: number };
  [GameEvents.UPGRADE_SELECTED]: { option: string };
  [GameEvents.ZEN_MODE_ENABLED]: null;
  
  [GameEvents.DEBUG_SPAWN]: { type: string; count: number };
  [GameEvents.LOG_DEBUG]: { msg: string; source?: string };
  [GameEvents.BOOT_LOG]: { message: string };
  
  [GameEvents.TRAUMA_ADDED]: { amount: number };
  [GameEvents.SPAWN_FX]: { type: string; x: number; y: number; angle?: number };
  [GameEvents.SPAWN_IMPACT]: { x: number; y: number; hexColor: string; angle: number };
  [GameEvents.PLAY_SOUND]: { key: string; x?: number };
  
  [GameEvents.SPAWN_DAEMON]: null;
  [GameEvents.HEARTBEAT]: { urgency: number };
  
  [GameEvents.PLAYER_REBOOT_TICK]: { amount: number };
  [GameEvents.PLAYER_REBOOT_DECAY]: { amount: number };
}


=====================================
FILE: ./src/engine/signals/GameEventBus.ts
=====================================
import { GameEvents, GameEventPayloads } from './GameEvents';
import { IGameEventService } from '@/engine/interfaces';

type Handler<T extends GameEvents> = (payload: GameEventPayloads[T]) => void;

export class GameEventService implements IGameEventService {
  private listeners: { [K in GameEvents]?: Handler<K>[] } = {};
  
  public subscribe<T extends GameEvents>(event: T, handler: Handler<T>): () => void {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    (this.listeners[event] as Handler<T>[]).push(handler);

    return () => {
      if (!this.listeners[event]) return;
      this.listeners[event] = (this.listeners[event] as Handler<T>[]).filter(h => h !== handler) as any;
    };
  }

  public emit<T extends GameEvents>(event: T, payload: GameEventPayloads[T]): void {
    const handlers = this.listeners[event];
    if (handlers) {
        handlers.forEach(handler => handler(payload));
    }
  }

  public clear(): void {
    this.listeners = {};
  }
}

// --- SINGLETON INSTANCE ---
// This ensures that whether imported by UI or Engine, it's the same object.
export const SharedGameEventBus = new GameEventService();

// Export as default alias for compatibility
export const GameEventBus = SharedGameEventBus;


=====================================
FILE: ./src/engine/signals/FastEventBus.ts
=====================================
import { IFastEventService } from '@/engine/interfaces';
import { SYS_LIMITS } from '@/engine/config/constants/SystemConstants';
import { AudioKey, VFXKey } from '@/engine/config/AssetKeys';

export enum FastEventType {
  NONE = 0,
  PLAY_SOUND = 1,
  SPAWN_FX = 2,
  CAM_SHAKE = 3,
  HIT_STOP = 4,
  DUCK_MUSIC = 5
}

export enum SoundCode {
  NONE = 0,
  FX_PLAYER_FIRE = 1,
  FX_IMPACT_LIGHT = 2,
  FX_IMPACT_HEAVY = 3,
  FX_ENEMY_FIRE = 4,
  UI_CLICK = 5,
  UI_HOVER = 6,
  LOOP_DRILL = 7,
  FX_REBOOT_SUCCESS = 8,
  FX_LEVEL_UP = 9,
  LOOP_HEAL = 10,
  LOOP_WARNING = 11,
  FX_TELEPORT = 12,
  FX_EXHAUST_SIZZLE = 13,
  FX_PLAYER_DEATH = 14
}

export enum FXCode {
  NONE = 0,
  EXPLOSION_PURPLE = 1,
  EXPLOSION_YELLOW = 2,
  EXPLOSION_RED = 3,
  IMPACT_WHITE = 4,
  IMPACT_RED = 5,
  DRILL_SPARKS = 6,
  HUNTER_RECOIL = 7,
  CLASH_YELLOW = 8,
  EXPLOSION_PURPLE_DIR = 9,
  EXPLOSION_YELLOW_DIR = 10,
  EXPLOSION_RED_DIR = 11,
  REBOOT_HEAL = 12,
  PURGE_BLAST = 13,
  ENGINE_FLARE = 14,
  IMPACT_YELLOW = 4 
}

export const SOUND_LOOKUP: Record<SoundCode, AudioKey | null> = {
  [SoundCode.NONE]: null,
  [SoundCode.FX_PLAYER_FIRE]: 'fx_player_fire',
  [SoundCode.FX_IMPACT_LIGHT]: 'fx_impact_light',
  [SoundCode.FX_IMPACT_HEAVY]: 'fx_impact_heavy',
  [SoundCode.FX_ENEMY_FIRE]: 'fx_enemy_fire',
  [SoundCode.UI_CLICK]: 'ui_click',
  [SoundCode.UI_HOVER]: 'ui_hover',
  [SoundCode.LOOP_DRILL]: 'loop_drill',
  [SoundCode.FX_REBOOT_SUCCESS]: 'fx_reboot_success',
  [SoundCode.FX_LEVEL_UP]: 'fx_level_up',
  [SoundCode.LOOP_HEAL]: 'loop_heal',
  [SoundCode.LOOP_WARNING]: 'loop_warning',
  [SoundCode.FX_TELEPORT]: 'fx_teleport',
  [SoundCode.FX_EXHAUST_SIZZLE]: 'fx_exhaust_sizzle',
  [SoundCode.FX_PLAYER_DEATH]: 'fx_player_death'
};

export const FX_LOOKUP: Record<FXCode, VFXKey | null> = {
  [FXCode.NONE]: null,
  [FXCode.EXPLOSION_PURPLE]: 'EXPLOSION_PURPLE',
  [FXCode.EXPLOSION_YELLOW]: 'EXPLOSION_YELLOW',
  [FXCode.EXPLOSION_RED]: 'EXPLOSION_RED',
  [FXCode.IMPACT_WHITE]: 'IMPACT_WHITE',
  [FXCode.IMPACT_RED]: 'IMPACT_RED',
  [FXCode.DRILL_SPARKS]: 'DRILL_SPARKS',
  [FXCode.HUNTER_RECOIL]: 'HUNTER_RECOIL',
  [FXCode.CLASH_YELLOW]: 'CLASH_YELLOW',
  [FXCode.EXPLOSION_PURPLE_DIR]: 'EXPLOSION_PURPLE_DIR',
  [FXCode.EXPLOSION_YELLOW_DIR]: 'EXPLOSION_YELLOW_DIR',
  [FXCode.EXPLOSION_RED_DIR]: 'EXPLOSION_RED_DIR',
  [FXCode.REBOOT_HEAL]: 'REBOOT_HEAL',
  [FXCode.PURGE_BLAST]: 'PURGE_BLAST',
  [FXCode.ENGINE_FLARE]: 'ENGINE_FLARE',
  [FXCode.IMPACT_YELLOW]: 'IMPACT_WHITE'
};

export const getSoundCode = (key: string): SoundCode => {
    for (const [code, val] of Object.entries(SOUND_LOOKUP)) {
        if (val === key) return Number(code) as SoundCode;
    }
    return SoundCode.NONE;
};

export const getFXCode = (key: string): FXCode => {
    for (const [code, val] of Object.entries(FX_LOOKUP)) {
        if (val === key) return Number(code) as FXCode;
    }
    return FXCode.NONE;
};

const EVENT_STRIDE = 5;

export class FastEventBusImpl implements IFastEventService {
  private buffer = new Int32Array(SYS_LIMITS.EVENT_BUFFER_SIZE);
  private cursor = 0;

  public emit(eventId: number, a1: number = 0, a2: number = 0, a3: number = 0, a4: number = 0) {
    if (this.cursor + EVENT_STRIDE >= SYS_LIMITS.EVENT_BUFFER_SIZE) return; 

    this.buffer[this.cursor++] = eventId;
    this.buffer[this.cursor++] = a1;
    this.buffer[this.cursor++] = a2;
    this.buffer[this.cursor++] = a3;
    this.buffer[this.cursor++] = a4;
  }

  public getCursor(): number {
    return this.cursor;
  }

  public clear() {
    this.cursor = 0;
  }
  
  public process(callback: (id: number, a1: number, a2: number, a3: number, a4: number) => void) {
      for(let i=0; i<this.cursor; i+=EVENT_STRIDE) {
          callback(
              this.buffer[i],
              this.buffer[i+1],
              this.buffer[i+2],
              this.buffer[i+3],
              this.buffer[i+4]
          );
      }
  }
}


=====================================
FILE: ./src/engine/ecs/Component.ts
=====================================
import { ComponentType } from './ComponentType';

export abstract class Component {
  abstract readonly _type: ComponentType;
}


=====================================
FILE: ./src/engine/ecs/ComponentType.ts
=====================================
export enum ComponentType {
  Transform = 'Transform',
  Motion = 'Motion',
  Health = 'Health',
  Identity = 'Identity',
  Lifetime = 'Lifetime',
  Combat = 'Combat',
  State = 'State',
  Collider = 'Collider',
  Target = 'Target',
  Orbital = 'Orbital',
  Projectile = 'Projectile',
  
  // New Render Composition
  RenderModel = 'RenderModel',         // Geometry, Material, Base Color
  RenderTransform = 'RenderTransform', // Visual Offsets, Base Scale
  RenderEffect = 'RenderEffect'        // Flash, Shudder, Spawn Progress
}


=====================================
FILE: ./src/engine/ecs/ObjectPool.ts
=====================================
type FactoryFn<T> = () => T;
type ResetFn<T> = (item: T) => void;

export class ObjectPool<T> {
  private available: T[] = [];
  private factory: FactoryFn<T>;
  private resetFn: ResetFn<T>;
  private _totalCreated = 0;

  constructor(factory: FactoryFn<T>, resetFn: ResetFn<T>, initialSize: number = 100) {
    this.factory = factory;
    this.resetFn = resetFn;
    this.expand(initialSize);
  }

  private expand(amount: number) {
    for (let i = 0; i < amount; i++) {
      this.available.push(this.factory());
    }
    this._totalCreated += amount;
  }

  public acquire(): T {
    if (this.available.length === 0) {
      // Dynamic expansion: Double current size or add 50
      const expandAmount = Math.max(50, Math.floor(this._totalCreated * 0.5)); 
      this.expand(expandAmount);
    }

    const item = this.available.pop()!;
    this.resetFn(item); 
    return item;
  }

  public release(item: T) {
    this.available.push(item);
  }

  public get totalSize() {
    return this._totalCreated;
  }
  
  public get availableSize() {
      return this.available.length;
  }
}


=====================================
FILE: ./src/engine/ecs/Entity.ts
=====================================
import { EntityID, Tag } from './types';
import { Component } from './Component';
import { ComponentType } from './ComponentType';
import { ComponentPoolManager } from './ComponentPoolManager';

export class Entity {
  public id: EntityID; 
  public readonly tags = new Set<Tag>();
  public active = true;
  public pooled = false;

  public components = new Map<ComponentType, Component>();

  constructor(id: EntityID) {
    this.id = id;
  }

  public addComponent(component: Component): this {
    this.components.set(component._type, component);
    return this;
  }

  public getComponent<T extends Component>(type: ComponentType): T | undefined {
    return this.components.get(type) as T;
  }
  
  public requireComponent<T extends Component>(type: ComponentType): T {
    const c = this.components.get(type);
    if (!c) throw new Error(`Entity ${this.id} missing required component: ${type}`);
    return c as T;
  }

  public hasComponent(type: ComponentType): boolean {
    return this.components.has(type);
  }

  public addTag(tag: Tag): this {
    this.tags.add(tag);
    return this;
  }

  public hasTag(tag: Tag): boolean {
    return this.tags.has(tag);
  }

  public reset(newId: EntityID) {
      this.id = newId;
      this.active = true;
      this.pooled = false;
      this.components.clear();
      this.tags.clear();
  }

  public release() {
      this.active = false;
      this.pooled = true;
      
      for (const component of this.components.values()) {
          ComponentPoolManager.release(component);
      }
      
      this.components.clear(); 
      this.tags.clear();
  }
}


=====================================
FILE: ./src/engine/ecs/types.ts
=====================================
export type EntityID = number & { __brand: 'EntityID' };

export const createEntityID = (id: number): EntityID => id as EntityID;

export enum Tag {
  PLAYER = 'PLAYER',
  ENEMY = 'ENEMY',
  BULLET = 'BULLET',
  PARTICLE = 'PARTICLE',
  OBSTACLE = 'OBSTACLE',
  WORLD = 'WORLD' 
}

export enum Faction {
  FRIENDLY = 'FRIENDLY',
  HOSTILE = 'HOSTILE'
}

export enum ParticleShape {
  CIRCLE = 0,
  SQUARE = 1
}


=====================================
FILE: ./src/engine/ecs/components/ProjectileData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export type ProjectileState = 'CHARGING' | 'FLIGHT' | 'IMPACT';

export class ProjectileData extends Component {
  readonly _type = ComponentType.Projectile;

  constructor(
    public configId: string = 'DEFAULT', 
    public state: ProjectileState = 'FLIGHT',
    public ownerId: number = -1
  ) {
    super();
  }

  public reset(data: Partial<ProjectileData>) {
    this.configId = data.configId ?? 'DEFAULT';
    this.state = data.state ?? 'FLIGHT';
    this.ownerId = data.ownerId ?? -1;
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/TargetData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export type TargetType = 'PLAYER' | 'PANEL' | 'LOCATION' | 'ENEMY';

export class TargetData extends Component {
  readonly _type = ComponentType.Target;

  constructor(
    public id: string | null = null, 
    public type: TargetType = 'PLAYER',
    public x: number = 0, 
    public y: number = 0,
    public locked: boolean = false 
  ) {
    super();
  }

  public reset(data: Partial<TargetData>) {
    this.id = data.id ?? null;
    this.type = data.type ?? 'PLAYER';
    this.x = data.x ?? 0;
    this.y = data.y ?? 0;
    this.locked = data.locked ?? false;
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/ColliderData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export type ColliderShape = 'CIRCLE' | 'BOX';

export class ColliderData extends Component {
  readonly _type = ComponentType.Collider;

  constructor(
    public shape: ColliderShape = 'CIRCLE',
    public radius: number = 0,
    public width: number = 0,
    public height: number = 0,
    public layer: number = 0,
    public mask: number = 0
  ) {
    super();
  }

  public reset(data: Partial<ColliderData>) {
    this.shape = data.shape ?? 'CIRCLE';
    this.radius = data.radius ?? 0;
    this.width = data.width ?? 0;
    this.height = data.height ?? 0;
    this.layer = data.layer ?? 0;
    this.mask = data.mask ?? 0;
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/RenderTransform.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class RenderTransform extends Component {
  readonly _type = ComponentType.RenderTransform;

  constructor(
    public offsetX: number = 0,
    public offsetY: number = 0,
    public offsetZ: number = 0,
    public rotation: number = 0,
    public scale: number = 1.0,
    // Intrinsic Aspect Ratio (crucial for projectiles)
    public baseScaleX: number = 1.0,
    public baseScaleY: number = 1.0,
    public baseScaleZ: number = 1.0
  ) {
    super();
  }

  public reset(data: Partial<RenderTransform>) {
    this.offsetX = data.offsetX ?? 0;
    this.offsetY = data.offsetY ?? 0;
    this.offsetZ = data.offsetZ ?? 0;
    this.rotation = data.rotation ?? 0;
    this.scale = data.scale ?? 1.0;
    this.baseScaleX = data.baseScaleX ?? 1.0;
    this.baseScaleY = data.baseScaleY ?? 1.0;
    this.baseScaleZ = data.baseScaleZ ?? 1.0;
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/MotionData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class MotionData extends Component {
  readonly _type = ComponentType.Motion;

  constructor(
    public vx: number = 0,
    public vy: number = 0,
    public friction: number = 0,
    public angularVelocity: number = 0
  ) {
    super();
  }

  public reset(data: Partial<MotionData>) {
    this.vx = data.vx ?? 0;
    this.vy = data.vy ?? 0;
    this.friction = data.friction ?? 0;
    this.angularVelocity = data.angularVelocity ?? 0;
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/CombatData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class CombatData extends Component {
  readonly _type = ComponentType.Combat;

  constructor(
    public damage: number = 0,
    public cooldown: number = 0,
    public range: number = 0
  ) {
    super();
  }

  public reset(data: Partial<CombatData>) {
    this.damage = data.damage ?? 0;
    this.cooldown = data.cooldown ?? 0;
    this.range = data.range ?? 0;
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/RenderModel.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class RenderModel extends Component {
  readonly _type = ComponentType.RenderModel;

  constructor(
    public geometryId: string = 'DEFAULT_GEO',
    public materialId: string = 'DEFAULT_MAT',
    public r: number = 1,
    public g: number = 1,
    public b: number = 1,
    public opacity: number = 1.0
  ) {
    super();
  }

  public reset(data: Partial<RenderModel>) {
    this.geometryId = data.geometryId ?? 'DEFAULT_GEO';
    this.materialId = data.materialId ?? 'DEFAULT_MAT';
    this.r = data.r ?? 1;
    this.g = data.g ?? 1;
    this.b = data.b ?? 1;
    this.opacity = data.opacity ?? 1.0;
    return this;
  }
  
  public setColor(hex: string) {
      const c = parseInt(hex.replace('#', ''), 16);
      this.r = ((c >> 16) & 255) / 255;
      this.g = ((c >> 8) & 255) / 255;
      this.b = (c & 255) / 255;
  }
}


=====================================
FILE: ./src/engine/ecs/components/RenderEffect.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class RenderEffect extends Component {
  readonly _type = ComponentType.RenderEffect;

  constructor(
    public flash: number = 0,
    public shudder: number = 0,
    public spawnProgress: number = 1.0,
    public elasticity: number = 0.1,
    // Color overrides for flash
    public flashR: number = 4.0,
    public flashG: number = 0.0,
    public flashB: number = 0.2
  ) {
    super();
  }

  public reset(data: Partial<RenderEffect>) {
    this.flash = 0;
    this.shudder = 0;
    this.spawnProgress = data.spawnProgress ?? 1.0;
    this.elasticity = data.elasticity ?? 0.1;
    this.flashR = data.flashR ?? 4.0;
    this.flashG = data.flashG ?? 0.0;
    this.flashB = data.flashB ?? 0.2;
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/TransformData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class TransformData extends Component {
  readonly _type = ComponentType.Transform;

  constructor(
    public x: number = 0, 
    public y: number = 0, 
    public rotation: number = 0, 
    public scale: number = 1.0
  ) {
    super();
  }

  public reset(data: Partial<{ x: number, y: number, rotation: number, scale: number }>) {
    this.x = data.x ?? 0;
    this.y = data.y ?? 0;
    this.rotation = data.rotation ?? 0;
    this.scale = data.scale ?? 1.0;
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/LifetimeData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class LifetimeData extends Component {
  readonly _type = ComponentType.Lifetime;

  constructor(public remaining: number = 0, public total: number = 0) {
    super();
  }

  public reset(data: Partial<LifetimeData>) {
    this.remaining = data.remaining ?? 0;
    this.total = data.total ?? this.remaining;
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/HealthData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class HealthData extends Component {
  readonly _type = ComponentType.Health;
  public current: number;

  constructor(public max: number = 100, public invincibilityTime: number = 0) {
    super();
    this.current = max;
  }

  public reset(data: Partial<HealthData>) {
    this.max = data.max ?? 100;
    this.current = this.max;
    this.invincibilityTime = data.invincibilityTime ?? 0;
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/OrbitalData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class OrbitalData extends Component {
  readonly _type = ComponentType.Orbital;

  constructor(
    public parentId: number | null = null,
    public radius: number = 3.0,
    public speed: number = 2.0,
    public angle: number = 0,
    public active: boolean = true
  ) {
    super();
  }

  public reset(data: Partial<OrbitalData>) {
    this.parentId = data.parentId ?? null;
    this.radius = data.radius ?? 3.0;
    this.speed = data.speed ?? 2.0;
    this.angle = data.angle ?? 0;
    this.active = data.active ?? true;
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/IdentityData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class IdentityData extends Component {
  readonly _type = ComponentType.Identity;

  constructor(public variant: string = '') {
    super();
  }

  public reset(data: Partial<IdentityData>) {
    this.variant = data.variant ?? '';
    return this;
  }
}


=====================================
FILE: ./src/engine/ecs/components/AIStateData.ts
=====================================
import { Component } from '@/engine/ecs/Component';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { AIBehaviorState, AI_STATE } from '@/engine/ai/AIStateTypes';
import { AIBlackboard } from '@/engine/ai/AIBlackboard';
import { AITimerID } from '@/engine/ai/AITimerID';

export class AIStateData extends Component {
  readonly _type = ComponentType.State;
  constructor(
    public current: AIBehaviorState = AI_STATE.IDLE,
    public timers: Partial<Record<AITimerID, number>> = {},
    public data: AIBlackboard = {},
    public treeState: Record<string, number> = {},
    public stunTimer: number = 0
  ) {
    super();
  }

  public reset(data: Partial<AIStateData>) {
    this.current = data.current ?? AI_STATE.IDLE;
    this.timers = data.timers ?? {};
    this.data = data.data ?? {};
    this.treeState = data.treeState ?? {};
    this.stunTimer = data.stunTimer ?? 0;
    return this;
  }
  
  public set(state: AIBehaviorState) {
    this.current = state;
  }
}


=====================================
FILE: ./src/engine/ecs/Constants.ts
=====================================
import { SYS_LIMITS } from '@/engine/config/constants/SystemConstants';

export const MAX_ENTITIES = SYS_LIMITS.MAX_ENTITIES;
export const SPATIAL_GRID_SIZE = SYS_LIMITS.SPATIAL_GRID_SIZE;
export const SPATIAL_CELL_SIZE = SYS_LIMITS.SPATIAL_CELL_SIZE;


=====================================
FILE: ./src/engine/ecs/ComponentCatalog.ts
=====================================
import { ComponentRegistry } from './ComponentRegistry';
import { ComponentType } from './ComponentType';

import { TransformData } from './components/TransformData';
import { MotionData } from './components/MotionData';
import { HealthData } from './components/HealthData';
import { IdentityData } from './components/IdentityData';
import { LifetimeData } from './components/LifetimeData';
import { CombatData } from './components/CombatData';
import { AIStateData } from './components/AIStateData';
import { ColliderData } from './components/ColliderData';
import { TargetData } from './components/TargetData';
import { OrbitalData } from './components/OrbitalData';
import { ProjectileData } from './components/ProjectileData';

// New Render Components
import { RenderModel } from './components/RenderModel';
import { RenderTransform } from './components/RenderTransform';
import { RenderEffect } from './components/RenderEffect';

export const registerAllComponents = () => {
  ComponentRegistry.register(ComponentType.Transform, TransformData);
  ComponentRegistry.register(ComponentType.Motion, MotionData);
  ComponentRegistry.register(ComponentType.Health, HealthData);
  ComponentRegistry.register(ComponentType.Identity, IdentityData);
  ComponentRegistry.register(ComponentType.Lifetime, LifetimeData);
  ComponentRegistry.register(ComponentType.Combat, CombatData);
  ComponentRegistry.register(ComponentType.State, AIStateData);
  ComponentRegistry.register(ComponentType.Collider, ColliderData);
  ComponentRegistry.register(ComponentType.Target, TargetData);
  ComponentRegistry.register(ComponentType.Orbital, OrbitalData);
  ComponentRegistry.register(ComponentType.Projectile, ProjectileData);
  
  // New
  ComponentRegistry.register(ComponentType.RenderModel, RenderModel);
  ComponentRegistry.register(ComponentType.RenderTransform, RenderTransform);
  ComponentRegistry.register(ComponentType.RenderEffect, RenderEffect);
  
  console.log('[ComponentCatalog] Components Registered.');
};


=====================================
FILE: ./src/engine/ecs/ComponentRegistry.ts
=====================================
import { Component } from './Component';
import { ComponentType } from './ComponentType';
import { ComponentPoolManager } from './ComponentPoolManager';

type ComponentConstructor = new () => Component;

class ComponentRegistryController {
  private classes = new Map<ComponentType, ComponentConstructor>();

  public register(type: ComponentType, cls: ComponentConstructor) {
    this.classes.set(type, cls);
  }

  public create(type: ComponentType, data: any = {}): Component {
    const Cls = this.classes.get(type);
    if (!Cls) {
        throw new Error(`[ComponentRegistry] Unknown component type: ${type}`);
    }

    // Try Pool or Instantiate
    const component = ComponentPoolManager.acquire(type) || new Cls();
    
    // Generic Hydration: Assumes 'reset' accepts a data object
    if ('reset' in component && typeof (component as any).reset === 'function') {
        (component as any).reset(data);
    }
    
    return component;
  }
}

export const ComponentRegistry = new ComponentRegistryController();


=====================================
FILE: ./src/engine/ecs/ComponentPoolManager.ts
=====================================
import { Component } from './Component';
import { ComponentType } from './ComponentType';

class ComponentPoolManagerController {
  private pools = new Map<ComponentType, Component[]>();

  public acquire<T extends Component>(type: ComponentType): T | null {
    const pool = this.pools.get(type);
    if (pool && pool.length > 0) {
      return pool.pop() as T;
    }
    return null;
  }

  public release(component: Component) {
    const type = component._type;
    if (!this.pools.has(type)) {
      this.pools.set(type, []);
    }
    this.pools.get(type)!.push(component);
  }
  
  public getStats() {
      const stats: Record<string, number> = {};
      for(const [key, pool] of this.pools) {
          stats[key] = pool.length;
      }
      return stats;
  }
}

export const ComponentPoolManager = new ComponentPoolManagerController();


=====================================
FILE: ./src/engine/ecs/Query.ts
=====================================
import { Entity } from './Entity';
import { ComponentType } from './ComponentType';

export interface QueryDef {
  all?: ComponentType[];  // Must have ALL
  any?: ComponentType[];  // Must have AT LEAST ONE
  none?: ComponentType[]; // Must NOT have any
}

export class Query {
  public readonly id: string;
  public readonly def: QueryDef;

  constructor(def: QueryDef) {
    this.def = def;
    // Generate signature. Sort ensures order independence.
    this.id = `ALL:${(def.all || []).sort().join(',')}|ANY:${(def.any || []).sort().join(',')}|NONE:${(def.none || []).sort().join(',')}`;
  }

  public matches(entity: Entity): boolean {
    if (this.def.all) {
      for (const type of this.def.all) {
        if (!entity.hasComponent(type)) return false;
      }
    }

    if (this.def.none) {
      for (const type of this.def.none) {
        if (entity.hasComponent(type)) return false;
      }
    }

    if (this.def.any && this.def.any.length > 0) {
      let hasAny = false;
      for (const type of this.def.any) {
        if (entity.hasComponent(type)) {
          hasAny = true;
          break;
        }
      }
      if (!hasAny) return false;
    }

    return true;
  }
}


=====================================
FILE: ./src/engine/ecs/SpatialGrid.ts
=====================================
import { EntityID } from './types';
import { MAX_ENTITIES, SPATIAL_GRID_SIZE, SPATIAL_CELL_SIZE } from './Constants';

// Primes for Hashing
const HASH_X = 73856093;
const HASH_Y = 19349663;

export class SpatialGrid {
  // Head of the linked list for each cell
  // cellHead[cellHash] = firstEntityId (or -1 if empty)
  private cellHead = new Int32Array(SPATIAL_GRID_SIZE);

  // Next pointer for each entity
  // entityNext[entityId] = nextEntityId (or -1 if end of list)
  private entityNext = new Int32Array(MAX_ENTITIES);

  constructor() {
    this.cellHead.fill(-1);
    this.entityNext.fill(-1);
  }

  public clear() {
    // Only reset heads. entityNext is overwritten on insert.
    this.cellHead.fill(-1);
  }

  private getHash(x: number, y: number): number {
    const cx = Math.floor(x / SPATIAL_CELL_SIZE);
    const cy = Math.floor(y / SPATIAL_CELL_SIZE);
    return ((cx * HASH_X) ^ (cy * HASH_Y)) & (SPATIAL_GRID_SIZE - 1);
  }

  public insert(id: EntityID, x: number, y: number) {
    const eid = id as number;
    // Bounds check
    if (eid >= MAX_ENTITIES || eid < 0) return;

    const hash = this.getHash(x, y);

    // Prepend to linked list
    this.entityNext[eid] = this.cellHead[hash];
    this.cellHead[hash] = eid;
  }

  /**
   * Zero-GC Query
   * Writes results into 'outArray'.
   * Returns the number of results found.
   */
  public query(x: number, y: number, radius: number, outArray: Int32Array): number {
    let count = 0;
    const max = outArray.length;
    
    // Scan range
    const startX = Math.floor((x - radius) / SPATIAL_CELL_SIZE);
    const endX = Math.floor((x + radius) / SPATIAL_CELL_SIZE);
    const startY = Math.floor((y - radius) / SPATIAL_CELL_SIZE);
    const endY = Math.floor((y + radius) / SPATIAL_CELL_SIZE);

    // To prevent duplicates if an entity spans multiple cells,
    // we strictly rely on the fact that insert() puts an entity in ONE cell (center point).
    // This implies point-based spatial hashing (buckets), not bounds-based.
    // So we check all buckets the query radius touches.
    
    for (let cy = startY; cy <= endY; cy++) {
      for (let cx = startX; cx <= endX; cx++) {
        const hash = ((cx * HASH_X) ^ (cy * HASH_Y)) & (SPATIAL_GRID_SIZE - 1);
        
        let id = this.cellHead[hash];
        
        while (id !== -1) {
          if (count < max) {
            outArray[count++] = id;
          }
          id = this.entityNext[id];
        }
      }
    }
    
    return count;
  }
}


=====================================
FILE: ./src/engine/ecs/EntityRegistry.ts
=====================================
import { EntityID, createEntityID, Tag } from './types';
import { Entity } from './Entity';
import { ObjectPool } from './ObjectPool';
import { IEntityRegistry } from '../interfaces';
import { Query, QueryDef } from './Query';
import { MAX_ENTITIES } from './Constants';

export class EntityRegistry implements IEntityRegistry {
  private entities = new Map<EntityID, Entity>();
  
  // ID Management
  private nextId = 0;
  private freeIds: number[] = []; 
  
  // OPTIMIZATION: Cache Sets of Entities directly, not IDs.
  // This avoids O(N) lookups and Array allocations during getByTag()
  private tagCache = new Map<Tag, Set<Entity>>();
  private activeQueries = new Map<string, { query: Query, results: Set<Entity> }>();
  private entityPool: ObjectPool<Entity>;

  // Reusable empty set to prevent null checks in loops
  private static readonly EMPTY_SET = new Set<Entity>();

  constructor() {
      this.entityPool = new ObjectPool<Entity>(
          () => new Entity(createEntityID(0)),
          (e) => {}, 
          1000 
      );
  }

  public createEntity(): Entity {
    let idNum: number;

    if (this.freeIds.length > 0) {
        idNum = this.freeIds.pop()!;
    } else {
        idNum = ++this.nextId;
    }

    if (idNum >= MAX_ENTITIES) {
        console.warn(`[EntityRegistry] Max Entities Reached (${MAX_ENTITIES}).`);
    }

    const newId = createEntityID(idNum);
    const entity = this.entityPool.acquire();
    entity.reset(newId);
    this.entities.set(newId, entity);
    return entity;
  }

  public destroyEntity(id: number) {
    const eid = id as EntityID;
    const entity = this.entities.get(eid);
    
    if (!entity || !entity.active) return;

    entity.active = false;
    
    this.removeFromCache(entity);
    this.entities.delete(eid);
    this.freeIds.push(id);
    
    entity.release();
    this.entityPool.release(entity);
  }

  public getEntity(id: number): Entity | undefined {
    return this.entities.get(id as EntityID);
  }

  public getAll(): IterableIterator<Entity> {
    return this.entities.values();
  }

  public getByTag(tag: string): Iterable<Entity> {
    const t = tag as Tag;
    return this.tagCache.get(t) || EntityRegistry.EMPTY_SET;
  }

  public query(def: QueryDef): Iterable<Entity> {
    // We create a temporary query object to generate the ID string
    // This is lightweight compared to array allocation
    const tempQ = new Query(def);
    let cache = this.activeQueries.get(tempQ.id);
    
    if (!cache) {
        const results = new Set<Entity>();
        const q = new Query(def); 
        for (const entity of this.entities.values()) {
            if (entity.active && q.matches(entity)) {
                results.add(entity);
            }
        }
        cache = { query: q, results };
        this.activeQueries.set(q.id, cache);
    }
    return cache.results;
  }
  
  public updateCache(entity: Entity) {
      // 1. Update Tag Cache
      for (const tag of entity.tags) {
          if (!this.tagCache.has(tag)) this.tagCache.set(tag, new Set());
          this.tagCache.get(tag)!.add(entity);
      }
      
      // 2. Update Query Cache
      for (const cache of this.activeQueries.values()) {
          if (cache.query.matches(entity)) {
              cache.results.add(entity);
          } else {
              cache.results.delete(entity);
          }
      }
  }

  private removeFromCache(entity: Entity) {
      for (const tag of entity.tags) {
          if (this.tagCache.has(tag)) {
              this.tagCache.get(tag)!.delete(entity);
          }
      }
      for (const cache of this.activeQueries.values()) {
          cache.results.delete(entity);
      }
  }

  public clear() {
      for (const entity of this.entities.values()) {
          entity.release();
          this.entityPool.release(entity);
      }
      this.entities.clear();
      this.tagCache.clear();
      this.activeQueries.clear();
      
      this.nextId = 0;
      this.freeIds = [];
  }
  
  public getStats() {
      return {
          active: this.entities.size,
          pooled: this.entityPool.availableSize,
          totalAllocated: this.entityPool.totalSize
      };
  }
}


=====================================
FILE: ./src/engine/state/GameStream.ts
=====================================
import { ServiceLocator } from '@/engine/services/ServiceLocator';

export type StreamKey = 
  | 'PLAYER_HEALTH' 
  | 'PLAYER_MAX_HEALTH' 
  | 'PLAYER_REBOOT' 
  | 'SYSTEM_INTEGRITY' 
  | 'SCORE' 
  | 'XP' 
  | 'XP_NEXT' 
  | 'LEVEL';

type Listener = (val: number) => void;

class GameStreamService {
  private values = new Map<StreamKey, number>();
  private listeners = new Map<StreamKey, Set<Listener>>();

  constructor() {
    // Initialize defaults to avoid NaNs on UI mount
    this.values.set('PLAYER_HEALTH', 100);
    this.values.set('PLAYER_MAX_HEALTH', 100);
    this.values.set('SYSTEM_INTEGRITY', 100);
    this.values.set('SCORE', 0);
    this.values.set('XP', 0);
    this.values.set('XP_NEXT', 100);
    this.values.set('LEVEL', 1);
    this.values.set('PLAYER_REBOOT', 0);
  }

  public set(key: StreamKey, value: number) {
    // Only notify if value actually changed (Micro-optimization)
    if (this.values.get(key) === value) return;
    
    this.values.set(key, value);
    
    const subs = this.listeners.get(key);
    if (subs) {
      subs.forEach(fn => fn(value));
    }
  }

  public get(key: StreamKey): number {
    return this.values.get(key) || 0;
  }

  public subscribe(key: StreamKey, callback: Listener): () => void {
    if (!this.listeners.has(key)) {
      this.listeners.set(key, new Set());
    }
    this.listeners.get(key)!.add(callback);
    
    // Immediate callback with current value
    callback(this.get(key));

    return () => {
      const subs = this.listeners.get(key);
      if (subs) {
        subs.delete(callback);
      }
    };
  }
}

export const GameStream = new GameStreamService();


=====================================
FILE: ./src/engine/state/GameContext.tsx
=====================================
import React, { createContext, useContext, ReactNode } from 'react';
import { 
  IAudioService, 
  IInputService, 
  IGameEventService, 
  IEntityRegistry, 
  IEntitySpawner, 
  IGameSystem 
} from '@/engine/interfaces';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { AudioServiceImpl } from '@/engine/audio/AudioService';
import { InputSystem } from '@/engine/systems/InputSystem';
import { GameEventService } from '@/engine/signals/GameEventBus';
import { EntityRegistry } from '@/engine/ecs/EntityRegistry';
import { EntitySpawner } from '@/engine/services/EntitySpawner';

interface GameContextProps {
  audio: IAudioService;
  input: IInputService;
  events: IGameEventService;
  registry: IEntityRegistry;
  spawner: IEntitySpawner;
  // Generic accessor for specific systems (e.g. ShakeSystem)
  getSystem: <T extends IGameSystem>(id: string) => T | null;
}

// Fallbacks for initial render (before EngineFactory runs)
const mockRegistry = new EntityRegistry();
const mockSpawner = new EntitySpawner(mockRegistry);

const defaultContext: GameContextProps = {
  audio: new AudioServiceImpl(),
  input: new InputSystem(),
  events: new GameEventService(),
  registry: mockRegistry,
  spawner: mockSpawner,
  getSystem: () => null
};

const GameContext = createContext<GameContextProps>(defaultContext);

export const GameProvider = ({ children }: { children: ReactNode }) => {
  // We grab references from ServiceLocator ONCE during provider mount.
  // This bridges the imperative Engine world to the declarative React world.
  
  let audio: IAudioService;
  let input: IInputService;
  let events: IGameEventService;
  let registry: IEntityRegistry;
  let spawner: IEntitySpawner;

  // Safe retrieval with fallbacks
  const safeGet = <T,>(id: string, fallback: T): T => {
      try { return ServiceLocator.get<T>(id); } catch { return fallback; }
  };

  audio = safeGet('AudioService', new AudioServiceImpl());
  input = safeGet('InputSystem', new InputSystem());
  events = safeGet('GameEventService', new GameEventService());
  registry = safeGet('EntityRegistry', mockRegistry);
  spawner = safeGet('EntitySpawner', mockSpawner);

  const getSystem = <T extends IGameSystem>(id: string): T | null => {
      try { return ServiceLocator.getSystem<T>(id); } catch { return null; }
  };

  return (
    <GameContext.Provider value={{ audio, input, events, registry, spawner, getSystem }}>
      {children}
    </GameContext.Provider>
  );
};

export const useGameContext = () => useContext(GameContext);


=====================================
FILE: ./src/engine/state/game/slices/createProgressionSlice.ts
=====================================
import { StateCreator } from 'zustand';
import { GameState } from '../useGameStore';
import { PLAYER_CONFIG } from '@/engine/config/PlayerConfig';
import { UpgradeOption } from '@/engine/types/game.types';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';

export interface ProgressionSlice {
  score: number;
  highScore: number;
  xp: number;
  level: number;
  xpToNextLevel: number;
  upgradePoints: number;
  activeUpgrades: Record<string, number>;
  setScore: (val: number) => void;
  setProgressionData: (data: { xp: number, level: number, nextXp: number, points: number }) => void;
  selectUpgrade: (option: UpgradeOption) => void;
  resetProgressionState: () => void;
}

export const createProgressionSlice: StateCreator<GameState, [], [], ProgressionSlice> = (set) => ({
  score: 0,
  highScore: 0,
  xp: 0,
  level: 1,
  xpToNextLevel: PLAYER_CONFIG.baseXpRequirement,
  upgradePoints: 0,
  activeUpgrades: { 
    'OVERCLOCK': 0, 
    'EXECUTE': 0, 
    'FORK': 0, 
    'SNIFFER': 0, 
    'BACKDOOR': 0, 
    'DAEMON': 0 
  },

  setScore: (val) => set((state) => {
      const newHigh = Math.max(state.highScore, val);
      return { score: val, highScore: newHigh };
  }),

  setProgressionData: (data) => set({
      xp: data.xp,
      level: data.level,
      xpToNextLevel: data.nextXp,
      upgradePoints: data.points
  }),

  selectUpgrade: (option) => {
    GameEventBus.emit(GameEvents.UPGRADE_SELECTED, { option });
  },

  resetProgressionState: () => set({
      score: 0,
      xp: 0,
      level: 1,
      xpToNextLevel: PLAYER_CONFIG.baseXpRequirement,
      upgradePoints: 0,
      activeUpgrades: { 
        'OVERCLOCK': 0, 
        'EXECUTE': 0, 
        'FORK': 0, 
        'SNIFFER': 0, 
        'BACKDOOR': 0, 
        'DAEMON': 0 
      }
  })
});


=====================================
FILE: ./src/engine/state/game/slices/createCombatSlice.ts
=====================================
import { StateCreator } from 'zustand';
import { GameState } from '../useGameStore';
import { PLAYER_CONFIG } from '@/engine/config/PlayerConfig';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';

export interface CombatSlice {
  isPlaying: boolean;
  isZenMode: boolean;
  playerHealth: number;
  maxPlayerHealth: number;
  playerRebootProgress: number;
  systemIntegrity: number;

  // Actions
  setPlaying: (isPlaying: boolean) => void;
  activateZenMode: () => void;
  
  // Setters (Called by ECS)
  setPlayerHealth: (val: number) => void;
  setPlayerRebootProgress: (val: number) => void;
  setSystemIntegrity: (val: number) => void;
  
  resetCombatState: () => void;
}

export const createCombatSlice: StateCreator<GameState, [], [], CombatSlice> = (set, get) => ({
  isPlaying: false,
  isZenMode: false,
  playerHealth: PLAYER_CONFIG.maxHealth,
  maxPlayerHealth: PLAYER_CONFIG.maxHealth,
  playerRebootProgress: 0,
  systemIntegrity: 100,

  setPlaying: (isPlaying) => {
      if (isPlaying) get().resetGame();
      set({ isPlaying });
  },

  activateZenMode: () => {
    set({ isZenMode: true });
    GameEventBus.emit(GameEvents.ZEN_MODE_ENABLED, null);
  },

  // DUMB SETTERS - No Logic Allowed
  setPlayerHealth: (val) => set({ playerHealth: val }),
  setPlayerRebootProgress: (val) => set({ playerRebootProgress: val }),
  setSystemIntegrity: (val) => set({ systemIntegrity: val }),

  resetCombatState: () => set({
      isPlaying: false,
      isZenMode: false,
      playerHealth: PLAYER_CONFIG.maxHealth,
      playerRebootProgress: 0,
      systemIntegrity: 100
  })
});


=====================================
FILE: ./src/engine/state/game/slices/createUISlice.ts
=====================================
import { StateCreator } from 'zustand';
import { GameState } from '../useGameStore';
import { UpgradeOption } from '@/engine/types/game.types';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';
import { GameStream } from '@/engine/state/GameStream';
import { PanelId } from '@/engine/config/PanelConfig';
import { DamageOptions } from '@/engine/interfaces';

const MAX_PANEL_HEALTH = 100;

export interface UISlice {
  panels: Record<string, { id: PanelId, health: number, isDestroyed: boolean, element?: HTMLElement }>;
  interactionTarget: PanelId | null;
  availableUpgrades: UpgradeOption[];

  registerPanel: (id: PanelId, element: HTMLElement) => void;
  unregisterPanel: (id: PanelId) => void;
  setInteractionTarget: (id: PanelId | null) => void;
  
  healPanel: (id: PanelId, amount: number, sourceX?: number) => void;
  damagePanel: (id: PanelId, amount: number, options?: DamageOptions) => void;
  decayPanel: (id: PanelId, amount: number) => void;
  restoreAllPanels: () => number;
  destroyAllPanels: () => void;
  resetUIState: () => void;
}

const calculateIntegrity = (panels: Record<string, { health: number, isDestroyed: boolean }>) => {
    let current = 0;
    let max = 0;
    const values = Object.values(panels);
    if (values.length === 0) return 100;

    for (const p of values) {
        max += MAX_PANEL_HEALTH;
        if (!p.isDestroyed) current += p.health;
    }
    return max > 0 ? (current / max) * 100 : 100;
};

const updateIntegrity = (state: GameState, panels: any) => {
    const integrity = calculateIntegrity(panels);
    GameStream.set('SYSTEM_INTEGRITY', integrity);
    state.setSystemIntegrity(integrity);
};

export const createUISlice: StateCreator<GameState, [], [], UISlice> = (set, get) => ({
  panels: {},
  interactionTarget: null,
  availableUpgrades: [],

  registerPanel: (id, element) => {
      set((state) => {
          const existing = state.panels[id];
          const panels = { 
              ...state.panels, 
              [id]: { 
                  id, 
                  element, 
                  health: existing ? existing.health : MAX_PANEL_HEALTH, 
                  isDestroyed: existing ? existing.isDestroyed : false 
              } 
          };
          updateIntegrity(state as GameState, panels);
          return { panels };
      });
  },
  
  unregisterPanel: (id) => set((state) => {
      const next = { ...state.panels };
      delete next[id];
      updateIntegrity(state as GameState, next);
      return { panels: next };
  }),

  setInteractionTarget: (id) => set({ interactionTarget: id }),

  healPanel: (id, amount, sourceX) => {
      const state = get();
      const panel = state.panels[id];
      if (!panel) return;

      const wasDestroyed = panel.isDestroyed;
      let newHealth = panel.health;
      let newDestroyed = panel.isDestroyed;

      newHealth = Math.min(MAX_PANEL_HEALTH, newHealth + amount);

      if (wasDestroyed && newHealth >= MAX_PANEL_HEALTH) {
          newDestroyed = false;
          newHealth = MAX_PANEL_HEALTH * 0.3; 
          GameEventBus.emit(GameEvents.PANEL_RESTORED, { id, x: sourceX });
          GameEventBus.emit(GameEvents.LOG_DEBUG, { msg: `SECTOR RESTORED: ${id}`, source: 'UISlice' });
      } else if (!wasDestroyed) {
          GameEventBus.emit(GameEvents.PANEL_HEALED, { id, amount });
      }

      set(s => {
          const nextPanels = { ...s.panels, [id]: { ...panel, health: newHealth, isDestroyed: newDestroyed } };
          updateIntegrity(s as GameState, nextPanels);
          return { panels: nextPanels };
      });
  },

  damagePanel: (id, amount, options) => {
      const state = get();
      const panel = state.panels[id];
      if (!panel || panel.isDestroyed) return;

      const silent = options?.silent ?? false;
      const source = options?.source;

      let newHealth = Math.max(0, panel.health - amount);
      let newDestroyed = panel.isDestroyed;

      if (newHealth <= 0) {
          newDestroyed = true;
          newHealth = 0;
          if (!silent) {
              GameEventBus.emit(GameEvents.PANEL_DESTROYED, { id });
              GameEventBus.emit(GameEvents.LOG_DEBUG, { msg: `SECTOR LOST: ${id}`, source: 'UISlice' });
          }
      } else if (!silent) {
          GameEventBus.emit(GameEvents.PANEL_DAMAGED, { 
              id, amount, currentHealth: newHealth, 
              sourceX: source?.x, sourceY: source?.y 
          });
      }

      set(s => {
          const nextPanels = { ...s.panels, [id]: { ...panel, health: newHealth, isDestroyed: newDestroyed } };
          updateIntegrity(s as GameState, nextPanels);
          return { panels: nextPanels };
      });
  },

  decayPanel: (id, amount) => {
      const state = get();
      const panel = state.panels[id];
      if (!panel || !panel.isDestroyed) return;

      const newHealth = Math.max(0, panel.health - amount);
      if (newHealth !== panel.health) {
          set(s => ({
              panels: { ...s.panels, [id]: { ...panel, health: newHealth } }
          }));
      }
  },

  restoreAllPanels: () => {
      const state = get();
      let restoredCount = 0;
      const nextPanels = { ...state.panels };

      for (const key in nextPanels) {
          const pid = key as PanelId;
          const p = nextPanels[key];
          if (p.isDestroyed) {
              nextPanels[key] = { ...p, isDestroyed: false, health: MAX_PANEL_HEALTH * 0.3 };
              GameEventBus.emit(GameEvents.PANEL_RESTORED, { id: pid });
              restoredCount++;
          } else if (p.health < MAX_PANEL_HEALTH) {
              nextPanels[key] = { ...p, health: MAX_PANEL_HEALTH };
          }
      }

      set(s => {
          updateIntegrity(s as GameState, nextPanels);
          return { panels: nextPanels };
      });
      return restoredCount;
  },

  destroyAllPanels: () => {
      const state = get();
      const nextPanels = { ...state.panels };
      for (const key in nextPanels) {
          const pid = key as PanelId;
          const p = nextPanels[key];
          nextPanels[key] = { ...p, health: 0, isDestroyed: true };
          GameEventBus.emit(GameEvents.PANEL_DESTROYED, { id: pid });
      }
      set(s => {
          updateIntegrity(s as GameState, nextPanels);
          return { panels: nextPanels };
      });
  },

  resetUIState: () => {
      const { panels } = get();
      const resetPanels = Object.fromEntries(
          Object.entries(panels).map(([k, v]) => [k, { ...v, health: MAX_PANEL_HEALTH, isDestroyed: false }])
      );
      set({ panels: resetPanels, interactionTarget: null, availableUpgrades: [] });
      GameStream.set('SYSTEM_INTEGRITY', 100);
      get().setSystemIntegrity(100);
  }
});


=====================================
FILE: ./src/engine/state/game/useGameStore.ts
=====================================
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { STORAGE_KEYS } from '@/engine/config/StorageConfig';

import { createCombatSlice, CombatSlice } from './slices/createCombatSlice';
import { createProgressionSlice, ProgressionSlice } from './slices/createProgressionSlice';
import { createUISlice, UISlice } from './slices/createUISlice';

export type GameState = CombatSlice & ProgressionSlice & UISlice & {
  resetGame: () => void;
  startGame: () => void;
  stopGame: () => void;
};

export const useGameStore = create<GameState>()(
  persist(
    (set, get, api) => ({
      ...createCombatSlice(set, get, api),
      ...createProgressionSlice(set, get, api),
      ...createUISlice(set, get, api),

      startGame: () => {
          get().resetGame();
          get().setPlaying(true);
      },

      stopGame: () => {
          get().setPlaying(false);
      },

      resetGame: () => {
          get().resetCombatState();
          get().resetProgressionState();
          get().resetUIState();
      },
    }),
    {
      name: STORAGE_KEYS.GAME_STATE, 
      partialize: (state) => ({ highScore: state.highScore }), 
    }
  )
);


=====================================
FILE: ./src/engine/state/global/useStore.ts
=====================================
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { STORAGE_KEYS } from '@/engine/config/StorageConfig';

interface AudioSettings {
  master: boolean;
  music: boolean;
  sfx: boolean;
  ambience: boolean;
  volumeMaster: number;
  volumeMusic: number;
  volumeSfx: number;
  volumeAmbience: number;
  ambFilter: number;   
  ambSpeed: number;    
  ambWidth: number;    
  ambModSpeed: number; 
  ambModDepth: number; 
  fxReverbMix: number; 
  fxDelayMix: number;  
  fxDelayTime: number; 
  fxDelayFeedback: number; 
}

const DEFAULT_AUDIO: AudioSettings = {
  master: true,
  music: false,
  sfx: true,
  ambience: true,
  volumeMaster: 1.0,
  volumeMusic: 1.0,
  volumeSfx: 1.0,
  volumeAmbience: 1.0,
  ambFilter: 0.5,
  ambSpeed: 0.5,
  ambWidth: 0.5,
  ambModSpeed: 0.5, 
  ambModDepth: 0.5, 
  fxReverbMix: 0.2,     
  fxDelayMix: 0.1,      
  fxDelayTime: 0.25,    
  fxDelayFeedback: 0.3  
};

type ModalType = 'none' | 'about' | 'gallery' | 'feed' | 'contact' | 'settings';
type BootState = 'standby' | 'active' | 'sandbox' | 'mobile_lockdown';
export type SandboxView = 'lab' | 'arena' | 'gallery' | 'audio';
type GraphicsMode = 'HIGH' | 'POTATO';
export type LabExperiment = 'NONE' | 'GLITCH';

interface DebugFlags {
  godMode: boolean;
  panelGodMode: boolean;
  peaceMode: boolean;
  showHitboxes: boolean;
  timeScale: number;
}

interface AppState {
  sessionId: number; 
  bootState: BootState;
  introDone: boolean;
  isBreaching: boolean;
  activeModal: ModalType;
  isSimulationPaused: boolean;
  initialClickPos: { x: number, y: number } | null;
  sandboxView: SandboxView;
  labExperiment: LabExperiment;
  galleryTarget: string;
  galleryAction: 'IDLE' | 'ATTACK' | 'SPAWN' | 'DIE';
  audioSettings: AudioSettings;
  graphicsMode: GraphicsMode;
  screenShakeStrength: number; 
  isDebugOpen: boolean;
  isDebugMinimized: boolean;
  debugFlags: DebugFlags;
  setBootState: (state: BootState) => void;
  setIntroDone: (done: boolean) => void;
  startBreach: () => void;
  setSandboxView: (view: SandboxView) => void;
  setLabExperiment: (exp: LabExperiment) => void;
  setGalleryTarget: (target: string) => void;
  setGalleryAction: (action: 'IDLE' | 'ATTACK' | 'SPAWN' | 'DIE') => void;
  openModal: (modal: ModalType) => void;
  closeModal: () => void;
  toggleSettings: () => void;
  resetApplication: () => void;
  toggleMaster: () => void;
  toggleMusic: () => void;
  toggleSfx: () => void;
  toggleAmbience: () => void;
  setVolume: (channel: keyof AudioSettings, value: number, max?: number) => void;
  resetAudioSettings: () => void;
  setGraphicsMode: (mode: GraphicsMode) => void;
  setScreenShake: (val: number) => void;
  toggleDebugMenu: () => void;
  toggleDebugMinimize: () => void;
  setDebugFlag: (key: keyof DebugFlags, value: any) => void;
  resetDebugFlags: () => void;
  setSimulationPaused: (paused: boolean) => void;
  setInitialClickPos: (pos: { x: number, y: number } | null) => void;
}

export const useStore = create<AppState>()(
  persist(
    (set, get) => ({
      sessionId: 0,
      bootState: 'standby',
      introDone: false,
      isBreaching: false,
      activeModal: 'none',
      isSimulationPaused: false,
      initialClickPos: null,
      sandboxView: 'lab',
      labExperiment: 'NONE',
      galleryTarget: EnemyTypes.DRILLER,
      galleryAction: 'IDLE',
      audioSettings: { ...DEFAULT_AUDIO },
      graphicsMode: 'HIGH',
      screenShakeStrength: 1.0, 
      isDebugOpen: false,
      isDebugMinimized: false,
      debugFlags: {
        godMode: false,
        panelGodMode: false,
        peaceMode: false,
        showHitboxes: false,
        timeScale: 1.0,
      },

      setBootState: (bs) => set({ 
          bootState: bs,
          isBreaching: bs === 'active' || bs === 'mobile_lockdown' ? false : get().isBreaching 
      }),
      setIntroDone: (done) => set({ introDone: done }),
      startBreach: () => set({ isBreaching: true }),
      setSandboxView: (view) => set({ sandboxView: view }),
      setLabExperiment: (exp) => set({ labExperiment: exp }),
      setGalleryTarget: (target) => set({ galleryTarget: target }),
      setGalleryAction: (action) => set({ galleryAction: action }),
      openModal: (modal) => set({ activeModal: modal }),
      closeModal: () => set({ activeModal: 'none' }),
      toggleSettings: () => {
          const current = get().activeModal;
          if (current === 'settings') get().closeModal();
          else get().openModal('settings');
      },
      resetApplication: () => {
          AudioSystem.stopAll();
          useGameStore.getState().stopGame();
          useGameStore.getState().resetGame(); 
          set(state => ({
              sessionId: state.sessionId + 1,
              bootState: 'standby',
              introDone: false,
              isBreaching: false,
              activeModal: 'none',
              isDebugOpen: false,
              isDebugMinimized: false,
              sandboxView: 'lab',
              labExperiment: 'NONE',
              galleryTarget: EnemyTypes.DRILLER,
              galleryAction: 'IDLE',
              isSimulationPaused: false,
              initialClickPos: null
          }));
      },
      toggleMaster: () => {
          set(s => ({ audioSettings: { ...s.audioSettings, master: !s.audioSettings.master } }));
          AudioSystem.updateVolumes();
          if (get().audioSettings.master) AudioSystem.playClick(); 
      },
      toggleMusic: () => {
          set(s => ({ audioSettings: { ...s.audioSettings, music: !s.audioSettings.music } }));
          AudioSystem.updateVolumes();
          if (get().audioSettings.music) AudioSystem.playClick();
      },
      toggleSfx: () => {
          set(s => ({ audioSettings: { ...s.audioSettings, sfx: !s.audioSettings.sfx } }));
          AudioSystem.updateVolumes();
          if (get().audioSettings.sfx) AudioSystem.playClick();
      },
      toggleAmbience: () => {
          set(s => ({ audioSettings: { ...s.audioSettings, ambience: !s.audioSettings.ambience } }));
          AudioSystem.updateVolumes();
          if (get().audioSettings.ambience) AudioSystem.playClick();
      },
      setVolume: (channel, value, max = 2.0) => {
          const limit = max || 2.0;
          const clamped = Math.max(0, Math.min(limit, value));
          set(s => ({ audioSettings: { ...s.audioSettings, [channel]: clamped } }));
          AudioSystem.updateVolumes();
      },
      resetAudioSettings: () => {
          set({ audioSettings: { ...DEFAULT_AUDIO } });
          AudioSystem.updateVolumes();
          AudioSystem.playClick();
      },
      setGraphicsMode: (mode) => set({ graphicsMode: mode }),
      setScreenShake: (val) => set({ screenShakeStrength: val }),
      toggleDebugMenu: () => set(state => ({ isDebugOpen: !state.isDebugOpen })),
      toggleDebugMinimize: () => set(state => ({ isDebugMinimized: !state.isDebugMinimized })),
      setDebugFlag: (key, value) => set(state => ({ 
          debugFlags: { ...state.debugFlags, [key]: value } 
      })),
      resetDebugFlags: () => set({
          debugFlags: { godMode: false, panelGodMode: false, peaceMode: false, showHitboxes: false, timeScale: 1.0 }
      }),
      setSimulationPaused: (paused) => set({ isSimulationPaused: paused }),
      setInitialClickPos: (pos) => set({ initialClickPos: pos })
    }),
    {
      name: STORAGE_KEYS.UI_SETTINGS, 
      partialize: (state) => ({ 
          audioSettings: state.audioSettings,
          screenShakeStrength: state.screenShakeStrength,
          graphicsMode: state.graphicsMode,
          introDone: state.introDone
      }), 
    }
  )
);


=====================================
FILE: ./src/engine/math/RenderUtils.ts
=====================================
import * as THREE from 'three';

// Zero-allocation reusable objects for the render loop
export const axisY = new THREE.Vector3(0, 1, 0); // Model Axis (Up)
export const axisZ = new THREE.Vector3(0, 0, 1); // World Axis (Forward/Screen)
export const qSpin = new THREE.Quaternion();
export const qAim = new THREE.Quaternion();

/**
 * Applies a local Y-axis spin and a global Z-axis aim to an object.
 */
export const applyRotation = (obj: THREE.Object3D, spin: number, aim: number) => {
  // 1. Spin around Local Y (Model Axis)
  qSpin.setFromAxisAngle(axisY, spin);
  
  // 2. Aim around World Z
  // Offset by -PI/2 because model points Up, but 0 radians is Right.
  qAim.setFromAxisAngle(axisZ, aim - Math.PI/2);
  
  // 3. Combine: Aim * Spin
  qAim.multiply(qSpin);
  
  obj.quaternion.copy(qAim);
};


=====================================
FILE: ./src/engine/math/Noise.ts
=====================================
// Simple 1D Gradient Noise
// Returns value between -1 and 1 based on input 'x'
export function noise(x: number): number {
  const i = Math.floor(x);
  const f = x - i;
  const u = f * f * (3.0 - 2.0 * f); // Cubic smoothing
  return mix(hash(i), hash(i + 1), u);
}

function hash(n: number): number {
  return (Math.sin(n) * 43758.5453) % 1.0;
}

function mix(a: number, b: number, t: number): number {
  return a * (1 - t) + b * t;
}


=====================================
FILE: ./src/engine/math/ViewportHelper.ts
=====================================
export interface WorldRect {
  id: string;
  x: number;
  y: number;
  width: number;
  height: number;
  left: number;
  right: number;
  top: number;
  bottom: number;
}

export class ViewportHelperCore {
  public viewport = { width: 1, height: 1 }; // R3F Viewport units
  public screenSize = { width: 1, height: 1 }; // Window Pixels

  public update(vpW: number, vpH: number, screenW: number, screenH: number) {
    this.viewport = { width: vpW, height: vpH };
    this.screenSize = { width: screenW, height: screenH };
  }

  // Pure Math: Converts Pixel Rect -> World Rect
  public domToWorld(id: string, domRect: DOMRect): WorldRect {
    const sw = this.screenSize.width || 1;
    const sh = this.screenSize.height || 1;
    
    const vw = this.viewport.width;
    const vh = this.viewport.height;
    
    const cx = domRect.left + domRect.width / 2;
    const cy = domRect.top + domRect.height / 2;
    
    // Screen (Pixels) -> World (Orthographic Units)
    // 0,0 is center of screen in World
    const wx = (cx / sw) * vw - (vw / 2);
    const wy = -((cy / sh) * vh - (vh / 2));
    
    const wWidth = (domRect.width / sw) * vw;
    const wHeight = (domRect.height / sh) * vh;

    return {
      id: id,
      x: wx, y: wy,
      width: wWidth, height: wHeight,
      left: wx - wWidth / 2, right: wx + wWidth / 2,
      top: wy + wHeight / 2, bottom: wy - wHeight / 2,
    };
  }
}

export const ViewportHelper = new ViewportHelperCore();


=====================================
FILE: ./src/engine/math/GeometryUtils.ts
=====================================
import * as THREE from 'three';

export const addBarycentricCoordinates = (bufferGeometry: THREE.BufferGeometry) => {
  const geometry = bufferGeometry.index ? bufferGeometry.toNonIndexed() : bufferGeometry.clone();
  
  const count = geometry.attributes.position.count;
  const centers = new Float32Array(count * 3);

  for (let i = 0; i < count; i += 3) {
    centers[i * 3] = 1;
    centers[i * 3 + 1] = 0;
    centers[i * 3 + 2] = 0;

    centers[i * 3 + 3] = 0;
    centers[i * 3 + 4] = 1;
    centers[i * 3 + 5] = 0;

    centers[i * 3 + 6] = 0;
    centers[i * 3 + 7] = 0;
    centers[i * 3 + 8] = 1;
  }

  geometry.setAttribute('barycentric', new THREE.BufferAttribute(centers, 3));
  return geometry;
};

export const createHunterSpear = () => {
  const positions: number[] = [];
  const numWings = 3;
  const length = 1.25; // Tuned value from Worker
  const wingWidth = 0.4;
  const wingThickness = 0.05;

  const tipY = length / 2;
  const baseY = -length / 2;

  const rotateY = (x: number, y: number, z: number, rad: number) => {
    return [
      x * Math.cos(rad) - z * Math.sin(rad),
      y,
      x * Math.sin(rad) + z * Math.cos(rad)
    ];
  };

  for(let i=0; i<numWings; i++) {
      const angle = (i / numWings) * Math.PI * 2;
      
      const pTip = [0, tipY, 0];
      const pBaseOut = [wingWidth, baseY, 0];
      const pBaseInBack = [0, baseY, -wingThickness];
      const pBaseInFront = [0, baseY, wingThickness];

      // Front Face
      positions.push(...rotateY(pTip[0], pTip[1], pTip[2], angle));
      positions.push(...rotateY(pBaseOut[0], pBaseOut[1], pBaseOut[2], angle));
      positions.push(...rotateY(pBaseInFront[0], pBaseInFront[1], pBaseInFront[2], angle));
      
      // Back Face
      positions.push(...rotateY(pTip[0], pTip[1], pTip[2], angle));
      positions.push(...rotateY(pBaseInBack[0], pBaseInBack[1], pBaseInBack[2], angle));
      positions.push(...rotateY(pBaseOut[0], pBaseOut[1], pBaseOut[2], angle));
  }
  
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  geometry.computeVertexNormals();
  return addBarycentricCoordinates(geometry);
};


=====================================
FILE: ./src/engine/math/Vector2.ts
=====================================
export interface Vec2 {
  x: number;
  y: number;
}

export const vec2 = (x: number, y: number): Vec2 => ({ x, y });
export const vecZero = (): Vec2 => ({ x: 0, y: 0 });


=====================================
FILE: ./src/engine/math/coords.ts
=====================================
import { CAMERA_CONFIG } from '@/engine/config/CameraConfig';

const ZOOM = CAMERA_CONFIG.BASE_ZOOM; 

export const screenToWorld = (screenX: number, screenY: number, screenW: number, screenH: number) => {
  const worldX = (screenX - screenW / 2) / ZOOM;
  const worldY = -(screenY - screenH / 2) / ZOOM; 
  
  return { x: worldX, y: worldY };
};

export const domRectToWorldRect = (rect: { x: number, y: number, width: number, height: number }, screenW: number, screenH: number) => {
  const centerX = rect.x + rect.width / 2;
  const centerY = rect.y + rect.height / 2;
  
  const centerWorld = screenToWorld(centerX, centerY, screenW, screenH);
  
  return {
    x: centerWorld.x,
    y: centerWorld.y,
    width: rect.width / ZOOM,
    height: rect.height / ZOOM,
    left: centerWorld.x - (rect.width / ZOOM / 2),
    right: centerWorld.x + (rect.width / ZOOM / 2),
    top: centerWorld.y + (rect.height / ZOOM / 2),
    bottom: centerWorld.y - (rect.height / ZOOM / 2),
  };
};


=====================================
FILE: ./src/engine/audio/AudioService.ts
=====================================
import { useStore } from '@/engine/state/global/useStore';
import { AUDIO_MANIFEST, SoundDef } from '@/engine/config/assets/AudioManifest';
import { IAudioService } from '@/engine/interfaces';
import { AudioContextManager } from './modules/AudioContextManager';
import { AudioSynthesizer } from './modules/AudioSynthesizer';
import { AudioMixer } from './modules/AudioMixer';
import { SoundBank } from './modules/SoundBank';
import { VoiceManager } from './modules/VoiceManager';
import { AudioKey } from '@/engine/config/AssetKeys';

// Sounds needed immediately for the UI/Menu
const CRITICAL_SOUNDS: AudioKey[] = [
    'ui_click', 'ui_hover', 'ui_menu_open', 'ui_menu_close', 
    'fx_boot_sequence', 'ambience_core'
];

export class AudioServiceImpl implements IAudioService {
  private ctxManager = new AudioContextManager();
  private mixer = new AudioMixer(this.ctxManager);
  private bank = new SoundBank();
  private voices = new VoiceManager(this.ctxManager, this.bank, this.mixer);
  
  public isReady = false;
  private hasInteracted = false; 
  private _autoStartAmbience = false; 
  
  // Generation Queue
  private genQueue: AudioKey[] = [];
  private isGenerating = false;
  
  // Playback Queue (for sounds triggered during init)
  private pendingSounds: { key: AudioKey, pan: number }[] = [];

  public async init() {
    if (this.isReady) { this.ctxManager.resume(); return; }
    const ctx = this.ctxManager.init();
    if (!ctx) return;

    this.mixer.init();
    this.updateVolumes();
    
    // 1. Generate Critical Sounds (Blocking)
    await this.generateList(CRITICAL_SOUNDS);
    
    // 2. Queue the rest (Non-blocking)
    const allKeys = Object.keys(AUDIO_MANIFEST) as AudioKey[];
    this.genQueue = allKeys.filter(k => !this.bank.has(k));
    this.processQueue();

    this.setupGlobalInteraction();
    this.isReady = true;

    // 3. Flush Pending Playback
    if (this.pendingSounds.length > 0) {
        this.pendingSounds.forEach(s => this.playSound(s.key, s.pan));
        this.pendingSounds = [];
    }

    if (this._autoStartAmbience) {
        this.playAmbience('ambience_core');
    }
  }

  private async generateList(keys: AudioKey[]) {
      const promises = keys.map(key => this.generateSingle(key));
      await Promise.all(promises);
  }

  private async generateSingle(key: AudioKey) {
      if (this.bank.has(key)) return;
      
      const recipe = AUDIO_MANIFEST[key];
      if (!recipe) return;

      const buffer = await AudioSynthesizer.generate(recipe);
      if (buffer) this.bank.add(key, buffer);
  }

  private processQueue() {
      if (this.genQueue.length === 0) return;
      if (this.isGenerating) return;

      this.isGenerating = true;

      const nextKey = this.genQueue.shift();
      if (nextKey) {
          // Process one, then schedule next
          this.generateSingle(nextKey).then(() => {
              this.isGenerating = false;
              // Small delay to let UI breathe
              setTimeout(() => this.processQueue(), 10);
          });
      } else {
          this.isGenerating = false;
      }
  }

  private setupGlobalInteraction() {
      const wakeUp = () => {
          if (this.hasInteracted) return;
          this.hasInteracted = true; 
          this.ctxManager.resume();
          if (this.isReady) this.playAmbience('ambience_core');
          window.removeEventListener('pointerdown', wakeUp);
          window.removeEventListener('keydown', wakeUp);
      };
      window.addEventListener('pointerdown', wakeUp);
      window.addEventListener('keydown', wakeUp);
  }

  public updateVolumes() {
      this.mixer.updateVolumes(useStore.getState().audioSettings);
  }

  public playSound(key: AudioKey, pan: number = 0) {
      if (this.isReady) {
          if (this.bank.has(key)) {
              this.voices.playSFX(key, pan);
          }
      } else {
          // If we are still booting, queue critical UI sounds so they play the moment we are ready
          if (CRITICAL_SOUNDS.includes(key)) {
              this.pendingSounds.push({ key, pan });
          }
      }
  }

  public playAmbience(key: AudioKey) {
      if (!this.isReady) return;
      
      if (this.bank.has(key)) {
          this.voices.playAmbience(key);
      } else {
          this.generateSingle(key).then(() => {
              this.voices.playAmbience(key);
          });
      }
  }

  public startMusic() {
    this.ctxManager.resume();
    this.voices.startMusic('/assets/audio/bg_music_placeholder.mp3');
    
    if (this.isReady && this.bank.has('ambience_core')) {
        this.playAmbience('ambience_core');
    } else {
        this._autoStartAmbience = true;
    }
  }
  
  public duckMusic(intensity: number, duration: number) { 
      this.mixer.duckMusic(intensity, duration); 
  }
  
  public getFrequencyData(array: Uint8Array) { 
      this.mixer.getByteFrequencyData(array); 
  }
  
  public stopAll() {
      this.voices.stopAll();
      this._autoStartAmbience = false;
      this.pendingSounds = [];
  }

  public playClick(pan: number = 0) { this.playSound('ui_click', pan); }
  public playHover(pan: number = 0) { this.playSound('ui_hover', pan); }
  public playBootSequence() { this.playSound('fx_boot_sequence'); } 
  public playDrillSound() { this.playSound('loop_drill'); }
  public playRebootZap() { this.playSound('loop_reboot'); }
}


=====================================
FILE: ./src/engine/audio/AudioUtils.ts
=====================================
import { MouseEvent as ReactMouseEvent } from 'react';

/**
 * Calculates stereo pan value (-1.0 to 1.0) based on mouse X position.
 * Handles both React Synthetic Events and Native DOM Events.
 */
export const getPan = (e: ReactMouseEvent | MouseEvent | TouchEvent): number => {
  if (typeof window === 'undefined') return 0;
  
  let clientX = 0;
  
  if ('touches' in e && e.touches.length > 0) {
      clientX = e.touches[0].clientX;
  } else if ('clientX' in e) {
      clientX = (e as MouseEvent).clientX;
  } else {
      return 0;
  }

  const width = window.innerWidth;
  if (width === 0) return 0;

  // Normalize: 0 to 1
  const normalized = clientX / width;
  
  // Map: -1 to 1
  const pan = (normalized * 2) - 1;
  
  // Clamp for safety
  return Math.max(-1, Math.min(1, pan));
};


=====================================
FILE: ./src/engine/audio/AudioMath.ts
=====================================
import { AUDIO_CURVES } from '@/engine/config/AudioConfig';

/**
 * AUDIO MATH LIBRARY
 */

export const getAmbienceFilterHz = (val: number): number => {
  const { BASE_HZ, MULTIPLIER } = AUDIO_CURVES.FILTER;
  return BASE_HZ * Math.pow(MULTIPLIER, (val - 0.5) * 2);
};

export const getAmbiencePanFreq = (val: number): number => {
  const { BASE_FREQ, MULTIPLIER } = AUDIO_CURVES.PAN;
  return BASE_FREQ * Math.pow(MULTIPLIER, (val - 0.5) * 2);
};

export const getAmbienceModFreq = (val: number): number => {
  const { BASE_FREQ, MULTIPLIER } = AUDIO_CURVES.LFO;
  return BASE_FREQ * Math.pow(MULTIPLIER, (val - 0.5) * 2);
};

export const getAmbienceModDepth = (val: number): number => {
  const { DEPTH_BASE, DEPTH_MULT } = AUDIO_CURVES.LFO;
  return DEPTH_BASE * Math.pow(DEPTH_MULT, (val - 0.5) * 2);
};

export const getAmbienceStereoGain = (val: number): number => {
  const { GAIN_FACTOR, POWER } = AUDIO_CURVES.STEREO;
  return Math.pow(val, POWER) * GAIN_FACTOR;
};

export const getAmbienceDistortion = (val: number): number => {
  return val * AUDIO_CURVES.DISTORTION.FACTOR;
};

/**
 * Generates a synthetic impulse response for reverb.
 */
export const generateImpulseResponse = (ctx: AudioContext, duration: number = 2.0, decay: number = 2.0, reverse: boolean = false): AudioBuffer => {
  const sampleRate = ctx.sampleRate;
  const length = sampleRate * duration;
  const impulse = ctx.createBuffer(2, length, sampleRate);
  
  const left = impulse.getChannelData(0);
  const right = impulse.getChannelData(1);

  for (let i = 0; i < length; i++) {
    const n = reverse ? length - i : i;
    // Exponential decay
    const e = Math.pow(1 - n / length, decay);
    
    // Noise burst
    left[i] = (Math.random() * 2 - 1) * e;
    right[i] = (Math.random() * 2 - 1) * e;
  }

  return impulse;
};


=====================================
FILE: ./src/engine/audio/AudioSystem.ts
=====================================
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { IAudioService } from '@/engine/interfaces';
import { AudioServiceImpl } from './AudioService';

class AudioSystemFacade implements IAudioService {
  
  private get service(): IAudioService {
    try {
      return ServiceLocator.getAudioService();
    } catch (e) {
      // Lazy Initialization
      const impl = new AudioServiceImpl();
      ServiceLocator.register('AudioService', impl);
      return impl;
    }
  }

  public async init() { return this.service.init(); }
  public startMusic() { this.service.startMusic(); }
  public stopAll() { this.service.stopAll(); }
  public updateVolumes() { this.service.updateVolumes(); }
  
  public playSound(key: string, pan?: number) { this.service.playSound(key, pan); }
  public playAmbience(key: string) { this.service.playAmbience(key); }
  public duckMusic(intensity: number, duration: number) { this.service.duckMusic(intensity, duration); }
  public getFrequencyData(array: Uint8Array) { this.service.getFrequencyData(array); }
  
  public playClick(pan?: number) { this.service.playClick(pan); }
  public playHover(pan?: number) { this.service.playHover(pan); }
  public playBootSequence() { this.service.playBootSequence(); }
  public playDrillSound() { this.service.playDrillSound(); }
  public playRebootZap() { this.service.playRebootZap(); }
}

export const AudioSystem = new AudioSystemFacade();


=====================================
FILE: ./src/engine/audio/hooks/useAudioVisualizer.ts
=====================================
import { useEffect, useRef } from 'react';
import { AudioSystem } from '../AudioSystem';

/**
 * Hooks into the AnalyserNode and returns a ref to the data buffer.
 * It does NOT trigger re-renders. Use requestAnimationFrame in your component to read it.
 */
export const useAudioVisualizer = (fftSize: number = 32) => {
  const dataRef = useRef(new Uint8Array(fftSize));
  const active = useRef(true);

  useEffect(() => {
    active.current = true;
    
    const loop = () => {
      if (!active.current) return;
      AudioSystem.getFrequencyData(dataRef.current);
      requestAnimationFrame(loop);
    };
    
    loop();

    return () => {
      active.current = false;
    };
  }, []);

  // Return the buffer itself so components can read it
  return dataRef;
};


=====================================
FILE: ./src/engine/audio/AudioDirector.ts
=====================================
import { IGameSystem, IPanelSystem, IGameEventService, IFastEventService, IAudioService } from '@/engine/interfaces';
import { FastEventType, SOUND_LOOKUP, SoundCode } from '@/engine/signals/FastEventBus';
import { ViewportHelper } from '@/engine/math/ViewportHelper';
import { AudioKey } from '@/engine/config/AssetKeys';
import { PanelId } from '@/engine/config/PanelConfig';

export class AudioDirector implements IGameSystem {
  
  constructor(
    private panelSystem: IPanelSystem,
    private events: IGameEventService,
    private fastEvents: IFastEventService,
    private audio: IAudioService
  ) {}

  update(delta: number, time: number): void {
    // READ ONLY FROM FAST BUS
    // The bus is cleared at the end of every frame by GameEngine, 
    // so we process everything currently in the buffer.
    this.fastEvents.process((id, a1, a2, a3, a4) => {
        if (id === FastEventType.PLAY_SOUND) {
            // a1: SoundCode, a2: Pan * 100
            const key = SOUND_LOOKUP[a1 as SoundCode];
            if (key) {
                const pan = this.calculatePan(a2 / 100); 
                this.audio.playSound(key as AudioKey, pan);
            }
        }
        else if (id === FastEventType.DUCK_MUSIC) {
            // a1: Intensity * 100, a2: Duration * 100
            this.audio.duckMusic(a1 / 100, a2 / 100);
        }
    });
  }

  private calculatePan(worldX: number): number {
      const halfWidth = ViewportHelper.viewport.width / 2;
      if (halfWidth === 0) return 0;
      return Math.max(-1, Math.min(1, worldX / halfWidth));
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/audio/modules/AudioMixer.ts
=====================================
import { AudioContextManager } from './AudioContextManager';
import { 
  getAmbienceFilterHz, getAmbiencePanFreq, getAmbienceModFreq, 
  getAmbienceModDepth, getAmbienceStereoGain, generateImpulseResponse
} from '../AudioMath';

export class AudioMixer {
  public masterGain!: GainNode;
  public sfxGain!: GainNode;
  public musicGain!: GainNode;
  public ambienceGain!: GainNode;
  public compressor!: DynamicsCompressorNode;
  public analyser!: AnalyserNode;

  private reverbNode!: ConvolverNode;
  private reverbSend!: GainNode;
  private delayNode!: DelayNode;
  private delayFeedback!: GainNode;
  private delaySend!: GainNode;
  private ambiencePanner!: StereoPannerNode;
  private ambiencePanConstraint!: GainNode;
  private ambienceLFO!: OscillatorNode;
  private ambienceFilter!: BiquadFilterNode;
  private ambienceDepthLFO!: OscillatorNode;
  private ambienceDepthGain!: GainNode;

  private ctxManager: AudioContextManager;
  private _targetMusicVol: number = 0;
  private _isMusicMuted: boolean = true;

  constructor(manager: AudioContextManager) {
    this.ctxManager = manager;
  }

  public init() {
    const ctx = this.ctxManager.ctx;
    if (!ctx) return;

    this.masterGain = ctx.createGain();
    this.sfxGain = ctx.createGain();
    this.musicGain = ctx.createGain();
    this.ambienceGain = ctx.createGain();
    this.compressor = ctx.createDynamicsCompressor();
    this.analyser = ctx.createAnalyser();

    this.compressor.threshold.value = -12; this.compressor.knee.value = 30;       
    this.compressor.ratio.value = 12; this.compressor.attack.value = 0.003;  
    this.compressor.release.value = 0.25; this.analyser.fftSize = 64; 
    this.analyser.smoothingTimeConstant = 0.8;

    this.reverbNode = ctx.createConvolver();
    this.reverbNode.buffer = generateImpulseResponse(ctx, 1.5, 2.0);
    this.reverbSend = ctx.createGain(); 
    this.delayNode = ctx.createDelay(1.0);
    this.delayFeedback = ctx.createGain();
    this.delaySend = ctx.createGain(); 

    this.delayNode.connect(this.delayFeedback);
    this.delayFeedback.connect(this.delayNode);
    this.delayNode.connect(this.masterGain);
    this.reverbNode.connect(this.masterGain);

    this.musicGain.connect(this.masterGain);
    this.sfxGain.connect(this.masterGain);
    this.sfxGain.connect(this.reverbSend);
    this.sfxGain.connect(this.delaySend);
    this.reverbSend.connect(this.reverbNode);
    this.delaySend.connect(this.delayNode);
    this.masterGain.connect(this.compressor);
    this.compressor.connect(this.analyser);
    this.analyser.connect(ctx.destination);

    this.ambiencePanner = ctx.createStereoPanner();
    this.ambienceFilter = ctx.createBiquadFilter();
    this.ambienceLFO = ctx.createOscillator();
    this.ambiencePanConstraint = ctx.createGain();
    this.ambienceDepthLFO = ctx.createOscillator();
    this.ambienceDepthGain = ctx.createGain();

    this.ambienceGain.connect(this.ambienceFilter);
    this.ambienceFilter.connect(this.ambiencePanner); 
    this.ambiencePanner.connect(this.masterGain);
    this.ambienceLFO.type = 'sine';
    this.ambienceLFO.connect(this.ambiencePanConstraint);
    this.ambiencePanConstraint.connect(this.ambiencePanner.pan);
    this.ambienceFilter.type = 'lowpass';
    this.ambienceDepthLFO.type = 'sine';
    this.ambienceDepthLFO.connect(this.ambienceDepthGain);
    this.ambienceDepthGain.connect(this.ambienceFilter.frequency);
    this.ambienceLFO.start(); this.ambienceDepthLFO.start();
  }

  public updateVolumes(settings: any) {
    if (!this.masterGain) return;
    this._isMusicMuted = !settings.music;
    this._targetMusicVol = this._isMusicMuted ? 0 : (settings.volumeMusic * 0.4);
    this.masterGain.gain.value = settings.master ? (settings.volumeMaster * 0.5) : 0;
    this.musicGain.gain.cancelScheduledValues(this.ctxManager.ctx!.currentTime);
    this.musicGain.gain.value = this._targetMusicVol;
    this.sfxGain.gain.value = settings.sfx ? (settings.volumeSfx * 0.8) : 0;
    this.ambienceGain.gain.value = settings.ambience ? settings.volumeAmbience : 0.0;

    this.ambienceFilter.frequency.value = getAmbienceFilterHz(settings.ambFilter ?? 0.5);
    this.ambienceLFO.frequency.value = getAmbiencePanFreq(settings.ambSpeed ?? 0.5);
    this.ambiencePanConstraint.gain.value = getAmbienceStereoGain(settings.ambWidth ?? 0.5);
    this.ambienceDepthLFO.frequency.value = getAmbienceModFreq(settings.ambModSpeed ?? 0.5);
    this.ambienceDepthGain.gain.value = getAmbienceModDepth(settings.ambModDepth ?? 0.5);

    if (this.reverbSend) {
        this.reverbSend.gain.value = settings.fxReverbMix ?? 0.2;
        this.delaySend.gain.value = settings.fxDelayMix ?? 0.1;
        this.delayNode.delayTime.value = 0.1 + ((Number.isFinite(settings.fxDelayTime) ? settings.fxDelayTime : 0.25) * 0.9);
        this.delayFeedback.gain.value = settings.fxDelayFeedback ?? 0.3;
    }
  }

  public duckMusic(intensity: number, duration: number) {
    if (!this.musicGain || this._isMusicMuted) return;
    const ctx = this.ctxManager.ctx;
    const baseVol = this._targetMusicVol;
    if (!ctx || baseVol < 0.001) return;
    const now = ctx.currentTime;
    const targetVol = Math.max(0, baseVol * (1.0 - intensity));
    this.musicGain.gain.cancelScheduledValues(now);
    this.musicGain.gain.setValueAtTime(this.musicGain.gain.value, now);
    this.musicGain.gain.linearRampToValueAtTime(targetVol, now + 0.05);
    this.musicGain.gain.exponentialRampToValueAtTime(baseVol, now + duration);
  }
  
  public getByteFrequencyData(array: Uint8Array) { if (this.analyser) this.analyser.getByteFrequencyData(array); }
}


=====================================
FILE: ./src/engine/audio/modules/VoiceManager.ts
=====================================
import { AudioContextManager } from './AudioContextManager';
import { SoundBank } from './SoundBank';
import { AudioMixer } from './AudioMixer';
import { AudioKey } from '@/engine/config/AssetKeys';
import { AUDIO_MANIFEST } from '@/engine/config/assets/AudioManifest';
import { SYS_LIMITS } from '@/engine/config/constants/SystemConstants';

export class VoiceManager {
  private activeCount = 0;
  private currentAmbienceNode: AudioBufferSourceNode | null = null;
  private currentAmbienceGain: GainNode | null = null; 
  private currentAmbienceKey: string | null = null;
  private musicElement: HTMLAudioElement | null = null;

  constructor(
    private ctxManager: AudioContextManager,
    private bank: SoundBank,
    private mixer: AudioMixer
  ) {}

  public playSFX(key: AudioKey, pan: number = 0) {
    if (this.activeCount >= SYS_LIMITS.MAX_POLYPHONY) return;

    const ctx = this.ctxManager.ctx;
    const buffer = this.bank.get(key);
    const recipe = AUDIO_MANIFEST[key];
    
    if (!ctx || !this.mixer.sfxGain || !buffer || !recipe) return;

    const source = ctx.createBufferSource();
    source.buffer = buffer;
    
    if (recipe.pitchVariance > 0) {
        source.detune.value = (Math.random() * recipe.pitchVariance * 2) - recipe.pitchVariance;
    }

    const panner = ctx.createStereoPanner();
    panner.pan.value = Math.max(-1, Math.min(1, Number.isFinite(pan) ? pan : 0));

    source.connect(panner);
    panner.connect(this.mixer.sfxGain);

    source.onended = () => {
        this.activeCount--;
    };
    
    this.activeCount++;
    source.start();
  }

  public playAmbience(key: AudioKey) {
    const ctx = this.ctxManager.ctx;
    if (!ctx || !this.mixer.ambienceGain) return;
    
    if (this.currentAmbienceKey === key && this.currentAmbienceNode) return;

    if (this.currentAmbienceNode && this.currentAmbienceGain) {
        const oldGain = this.currentAmbienceGain;
        const oldNode = this.currentAmbienceNode;
        try {
            oldGain.gain.cancelScheduledValues(ctx.currentTime);
            oldGain.gain.setValueAtTime(oldGain.gain.value, ctx.currentTime);
            oldGain.gain.linearRampToValueAtTime(0, ctx.currentTime + 1.0);
            oldNode.stop(ctx.currentTime + 1.1);
        } catch {}
    }

    const buffer = this.bank.get(key);
    if (!buffer) return;

    const source = ctx.createBufferSource();
    source.buffer = buffer; 
    source.loop = true;
    
    const fadeGain = ctx.createGain();
    fadeGain.gain.setValueAtTime(0, ctx.currentTime);
    fadeGain.gain.linearRampToValueAtTime(1.0, ctx.currentTime + 2.0); 
    
    source.connect(fadeGain); 
    fadeGain.connect(this.mixer.ambienceGain); 
    source.start();
    
    this.currentAmbienceNode = source; 
    this.currentAmbienceGain = fadeGain; 
    this.currentAmbienceKey = key;
  }

  public startMusic(url: string) {
    const ctx = this.ctxManager.ctx;
    if (!ctx || !this.mixer.musicGain || this.musicElement) return;

    this.musicElement = new Audio(url);
    this.musicElement.loop = true; 
    this.musicElement.crossOrigin = "anonymous";
    
    const source = ctx.createMediaElementSource(this.musicElement);
    source.connect(this.mixer.musicGain);
    
    this.musicElement.play().catch(() => console.warn("[Audio] Autoplay blocked"));
  }

  public stopAll() {
    if (this.musicElement) { 
        this.musicElement.pause(); 
        this.musicElement.currentTime = 0; 
    }
    
    if (this.currentAmbienceNode) { 
        try { this.currentAmbienceNode.stop(); } catch {} 
        this.currentAmbienceNode = null; 
        this.currentAmbienceGain = null;
        this.currentAmbienceKey = null; 
    }
    
    this.activeCount = 0;
  }
}


=====================================
FILE: ./src/engine/audio/modules/AudioSynthesizer.ts
=====================================
import { SoundDef } from '@/engine/config/assets/AudioManifest';
import { SYS_LIMITS } from '@/engine/config/constants/SystemConstants';

export class AudioSynthesizer {
  
  public static async generate(recipe: SoundDef): Promise<AudioBuffer | null> {
    if (typeof window === 'undefined') return null;

    const AudioContextClass = (window as any).AudioContext || (window as any).webkitAudioContext;
    if (!AudioContextClass) return null;

    const OfflineContextClass = (window as any).OfflineAudioContext || (window as any).webkitOfflineAudioContext;
    if (!OfflineContextClass) return null;

    const sampleRate = SYS_LIMITS.SAMPLE_RATE;
    const length = Math.ceil(sampleRate * recipe.duration);
    
    if (length <= 0) return null;

    const offline = new OfflineContextClass(1, length, sampleRate);

    const mainGain = offline.createGain();
    mainGain.connect(offline.destination);
    
    const attack = recipe.attack || 0.005; 
    
    mainGain.gain.setValueAtTime(0, 0);
    mainGain.gain.linearRampToValueAtTime(recipe.volume, attack);
    
    if (recipe.duration < 10.0) {
        mainGain.gain.exponentialRampToValueAtTime(0.01, recipe.duration);
    } else {
        mainGain.gain.setValueAtTime(recipe.volume, recipe.duration);
    }

    let outputNode: AudioNode = mainGain;

    if (recipe.distortion) {
        const shaper = offline.createWaveShaper();
        shaper.curve = this.makeDistortionCurve(recipe.distortion);
        shaper.connect(outputNode);
        outputNode = shaper; 
    }

    if (recipe.tremolo) {
        const tremoloNode = offline.createGain();
        tremoloNode.connect(outputNode);
        outputNode = tremoloNode;

        const lfo = offline.createOscillator();
        lfo.type = recipe.tremolo.wave || 'sine';
        lfo.frequency.value = recipe.tremolo.rate;
        
        const lfoGain = offline.createGain();
        lfoGain.gain.value = recipe.tremolo.depth; 
        
        tremoloNode.gain.value = 1.0 - (recipe.tremolo.depth / 2);
        lfo.connect(lfoGain);
        lfoGain.connect(tremoloNode.gain);
        
        lfo.start();
    }

    if (recipe.type === 'oscillator') {
        const osc = offline.createOscillator();
        osc.type = recipe.wave || 'sine';
        osc.frequency.setValueAtTime(recipe.frequency[0], 0);
        if (recipe.frequency[1] !== recipe.frequency[0]) {
            osc.frequency.exponentialRampToValueAtTime(recipe.frequency[1], recipe.duration);
        }

        if (recipe.fm) {
           const modOsc = offline.createOscillator();
           const modGain = offline.createGain();
           modOsc.type = recipe.fm.modType;
           modOsc.frequency.value = recipe.fm.modFreq;
           modGain.gain.value = recipe.fm.modIndex;
           modOsc.connect(modGain);
           modGain.connect(osc.frequency); 
           modOsc.start();
        }

        osc.connect(outputNode);
        osc.start();
    } 
    else if (recipe.type === 'noise') {
        const bufferSize = length;
        const noiseBuffer = offline.createBuffer(1, bufferSize, sampleRate);
        const data = noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = offline.createBufferSource();
        noise.buffer = noiseBuffer;

        if (recipe.filter) {
            const filter = offline.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(recipe.filter[0], 0);
            filter.frequency.exponentialRampToValueAtTime(recipe.filter[1], recipe.duration);
            noise.connect(filter);
            filter.connect(outputNode);
        } else {
            noise.connect(outputNode);
        }
        noise.start();
    }

    return await offline.startRendering();
  }

  private static makeDistortionCurve(amount: number) {
    const k = typeof amount === 'number' ? amount : 50;
    const n_samples = SYS_LIMITS.SAMPLE_RATE;
    const curve = new Float32Array(n_samples);
    const deg = Math.PI / 180;
    for (let i = 0; i < n_samples; ++i) {
      const x = (i * 2) / n_samples - 1;
      curve[i] = ((3 + k) * x * 20 * deg) / (Math.PI + k * Math.abs(x));
    }
    return curve;
  }
}


=====================================
FILE: ./src/engine/audio/modules/SoundBank.ts
=====================================
export class SoundBank {
  private buffers = new Map<string, AudioBuffer>();

  public add(key: string, buffer: AudioBuffer) {
    this.buffers.set(key, buffer);
  }

  public get(key: string): AudioBuffer | undefined {
    return this.buffers.get(key);
  }

  public has(key: string): boolean {
    return this.buffers.has(key);
  }
}


=====================================
FILE: ./src/engine/audio/modules/AudioContextManager.ts
=====================================
export class AudioContextManager {
  private _ctx: AudioContext | null = null;

  public get ctx(): AudioContext | null {
    return this._ctx;
  }

  public init(): AudioContext | null {
    if (this._ctx) return this._ctx;
    
    if (typeof window === 'undefined') return null;

    const AudioContextClass = (window as any).AudioContext || (window as any).webkitAudioContext;
    if (!AudioContextClass) return null;

    this._ctx = new AudioContextClass();
    return this._ctx;
  }

  public async resume() {
    if (this._ctx && this._ctx.state === 'suspended') {
      try {
        await this._ctx.resume();
      } catch (e) {
        console.warn('[AudioContext] Resume failed:', e);
      }
    }
  }

  public get currentTime(): number {
    return this._ctx ? this._ctx.currentTime : 0;
  }
}


=====================================
FILE: ./src/engine/ai/behavior/decorators.ts
=====================================
import { BTNode, NodeState } from './types';
import { Entity } from '@/engine/ecs/Entity';
import { AIContext } from '@/engine/handlers/ai/types';

export class Inverter extends BTNode {
  constructor(private child: BTNode) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const status = this.child.tick(entity, context);
    if (status === NodeState.SUCCESS) return NodeState.FAILURE;
    if (status === NodeState.FAILURE) return NodeState.SUCCESS;
    return NodeState.RUNNING;
  }
}

export class Succeeder extends BTNode {
  constructor(private child: BTNode) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const status = this.child.tick(entity, context);
    if (status === NodeState.RUNNING) return NodeState.RUNNING;
    return NodeState.SUCCESS;
  }
}


=====================================
FILE: ./src/engine/ai/behavior/types.ts
=====================================
import { Entity } from '@/engine/ecs/Entity';
import { AIContext } from '@/engine/handlers/ai/types';

export enum NodeState {
  SUCCESS = 'SUCCESS',
  FAILURE = 'FAILURE',
  RUNNING = 'RUNNING'
}

export abstract class BTNode {
  abstract tick(entity: Entity, context: AIContext): NodeState;
}


=====================================
FILE: ./src/engine/ai/behavior/composites.ts
=====================================
import { BTNode, NodeState } from './types';
import { Entity } from '@/engine/ecs/Entity';
import { AIContext } from '@/engine/handlers/ai/types';

/**
 * Runs children in order. 
 * Returns RUNNING if a child is running.
 * Returns FAILURE if a child fails (and stops).
 * Returns SUCCESS if all children succeed.
 */
export class Sequence extends BTNode {
  constructor(private children: BTNode[]) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    for (const child of this.children) {
      const status = child.tick(entity, context);
      if (status !== NodeState.SUCCESS) {
        return status;
      }
    }
    return NodeState.SUCCESS;
  }
}

/**
 * Runs children in order.
 * Returns SUCCESS if a child succeeds (and stops).
 * Returns RUNNING if a child is running.
 * Returns FAILURE if all children fail.
 */
export class Selector extends BTNode {
  constructor(private children: BTNode[]) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    for (const child of this.children) {
      const status = child.tick(entity, context);
      if (status !== NodeState.FAILURE) {
        return status;
      }
    }
    return NodeState.FAILURE;
  }
}

/**
 * Runs ALL children every tick.
 * Returns FAILURE if any child fails.
 * Returns RUNNING if any child is running.
 * Returns SUCCESS if all children succeed.
 */
export class Parallel extends BTNode {
  constructor(private children: BTNode[]) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    let anyRunning = false;

    for (const child of this.children) {
      const status = child.tick(entity, context);
      
      if (status === NodeState.FAILURE) {
        return NodeState.FAILURE;
      }
      
      if (status === NodeState.RUNNING) {
        anyRunning = true;
      }
    }

    return anyRunning ? NodeState.RUNNING : NodeState.SUCCESS;
  }
}

/**
 * Stateful Sequence (Memory Sequence).
 * Remembers the running child index and resumes from there.
 * Resets index to 0 only when the whole sequence Succeeds or Fails.
 */
export class MemSequence extends BTNode {
  constructor(private children: BTNode[], private id: string) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const state = entity.getComponent<any>('State'); // Generic access
    if (!state) return NodeState.FAILURE;

    // Initialize Tree State if missing
    if (!state.treeState) state.treeState = {};
    
    // Get running index (default 0)
    let startIndex = state.treeState[this.id] || 0;

    for (let i = startIndex; i < this.children.length; i++) {
      const child = this.children[i];
      const status = child.tick(entity, context);

      if (status === NodeState.RUNNING) {
        state.treeState[this.id] = i; // Remember this child is running
        return NodeState.RUNNING;
      }

      if (status === NodeState.FAILURE) {
        state.treeState[this.id] = 0; // Reset on failure
        return NodeState.FAILURE;
      }
    }

    // All children succeeded
    state.treeState[this.id] = 0; // Reset on success
    return NodeState.SUCCESS;
  }
}


=====================================
FILE: ./src/engine/ai/StateMachine.ts
=====================================
import { Entity } from '@/engine/ecs/Entity';

export interface State {
  name: string;
  enter?: (entity: Entity, data?: any) => void;
  update?: (entity: Entity, delta: number, time: number, data?: any) => void;
  exit?: (entity: Entity, data?: any) => void;
}

export class StateMachine {
  private states = new Map<string, State>();
  private currentState: State | null = null;

  public addState(state: State) {
    this.states.set(state.name, state);
    return this;
  }

  public setState(name: string, entity: Entity, data?: any) {
    if (this.currentState && this.currentState.name === name) return;

    if (this.currentState && this.currentState.exit) {
      this.currentState.exit(entity, data);
    }

    this.currentState = this.states.get(name) || null;

    if (this.currentState && this.currentState.enter) {
      this.currentState.enter(entity, data);
    }
  }

  public update(entity: Entity, delta: number, time: number, data?: any) {
    if (this.currentState && this.currentState.update) {
      this.currentState.update(entity, delta, time, data);
    }
  }

  public getCurrentState() {
    return this.currentState?.name || null;
  }
}


=====================================
FILE: ./src/engine/ai/AITimerID.ts
=====================================
export enum AITimerID {
  SPAWN = 'spawn',
  WAIT = 'wait',
  HOVER = 'hover',
  AIM = 'aim',
  SIZZLE = 'sizzle',
  DRILL_AUDIO = 'drillAudio',
  DRILL_DMG = 'drillDmg'
}


=====================================
FILE: ./src/engine/ai/nodes/hunterNodes.ts
=====================================
import { BTNode, NodeState } from '@/engine/ai/behavior/types';
import { Entity } from '@/engine/ecs/Entity';
import { AIContext } from '@/engine/handlers/ai/types';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { MotionData } from '@/engine/ecs/components/MotionData';
import { TargetData } from '@/engine/ecs/components/TargetData';
import { AIStateData } from '@/engine/ecs/components/AIStateData';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { ParticleShape } from '@/engine/ecs/types';
import { AITimerID } from '@/engine/ai/AITimerID';

export class HoverDrift extends BTNode {
  private minDur: number;
  private maxDur: number;
  constructor(private minRange: number, private maxRange: number, minDuration: number, maxDuration?: number) { 
      super();
      this.minDur = minDuration;
      this.maxDur = maxDuration ?? minDuration;
  }

  tick(entity: Entity, context: AIContext): NodeState {
    const transform = entity.getComponent<TransformData>(ComponentType.Transform);
    const motion = entity.getComponent<MotionData>(ComponentType.Motion);
    const target = entity.getComponent<TargetData>(ComponentType.Target);
    const state = entity.getComponent<AIStateData>(ComponentType.State);

    if (!transform || !motion || !target || !state) return NodeState.FAILURE;
    if (state.stunTimer > 0) {
        state.stunTimer -= context.delta;
        return NodeState.RUNNING;
    }

    if (!state.timers[AITimerID.HOVER]) {
        state.timers[AITimerID.HOVER] = this.minDur + Math.random() * (this.maxDur - this.minDur);
        state.data.driftX = (Math.random() - 0.5) * 4;
        state.data.driftY = (Math.random() - 0.5) * 4;
    }

    state.timers[AITimerID.HOVER]! -= context.delta;
    if (state.timers[AITimerID.HOVER]! <= 0) {
        state.timers[AITimerID.HOVER] = undefined;
        return NodeState.SUCCESS;
    }

    const dx = target.x - transform.x;
    const dy = target.y - transform.y;
    const distSq = dx*dx + dy*dy;
    const dist = Math.sqrt(distSq);
    if (dist < 0.001) {
        motion.vx *= 0.9;
        motion.vy *= 0.9;
        return NodeState.RUNNING;
    }

    const angleToTarget = Math.atan2(dy, dx);
    let tx = state.data.driftX || 0;
    let ty = state.data.driftY || 0;

    if (dist < this.minRange) {
        tx -= dx * 0.5;
        ty -= dy * 0.5;
    } else if (dist > this.maxRange) {
        tx += dx * 0.5;
        ty += dy * 0.5;
    }

    motion.vx += (tx - motion.vx) * context.delta * 2.0;
    motion.vy += (ty - motion.vy) * context.delta * 2.0;
    transform.rotation = angleToTarget;
    return NodeState.RUNNING;
  }
}

export class AimAndFire extends BTNode {
  constructor(private aimDuration: number, private projectileSpeed: number, private configId: string) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const transform = entity.getComponent<TransformData>(ComponentType.Transform);
    const target = entity.getComponent<TargetData>(ComponentType.Target);
    const motion = entity.getComponent<MotionData>(ComponentType.Motion);
    const state = entity.getComponent<AIStateData>(ComponentType.State);

    if (!transform || !target || !state) return NodeState.FAILURE;
    if (state.timers[AITimerID.AIM] === undefined) {
        state.timers[AITimerID.AIM] = this.aimDuration;
    }

    if (motion) {
        motion.vx *= 0.8;
        motion.vy *= 0.8;
    }

    const dx = target.x - transform.x;
    const dy = target.y - transform.y;
    transform.rotation = Math.atan2(dy, dx);

    if (!state.timers[AITimerID.SIZZLE] || state.timers[AITimerID.SIZZLE]! <= 0) {
        context.playSound('fx_exhaust_sizzle', transform.x);
        state.timers[AITimerID.SIZZLE] = 0.15;
    } else {
        state.timers[AITimerID.SIZZLE]! -= context.delta;
    }

    const rearAngle = transform.rotation + Math.PI;
    const offset = 0.5;
    const spreadAngle = 0.2; 
    const density = 2; 

    for (let i = 0; i < density; i++) {
        const spread = (Math.random() - 0.5) * spreadAngle;
        const angle = rearAngle + spread;
        const speed = 15.0 + (Math.random() * 10.0);
        const px = transform.x + Math.cos(rearAngle) * offset;
        const py = transform.y + Math.sin(rearAngle) * offset;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        context.spawnParticle(px, py, '#F7D277', vx, vy, 0.3 + (Math.random() * 0.2), 1.0, ParticleShape.SQUARE);
    }

    state.timers[AITimerID.AIM]! -= context.delta;
    if (state.timers[AITimerID.AIM]! <= 0) {
        state.timers[AITimerID.AIM] = undefined; 
        const dirX = Math.cos(transform.rotation);
        const dirY = Math.sin(transform.rotation);

        context.spawnProjectile(
            transform.x + dirX * 1.5, 
            transform.y + dirY * 1.5, 
            dirX * this.projectileSpeed, 
            dirY * this.projectileSpeed, 
            undefined, 
            this.configId, 
            entity.id as number
        );

        context.playSound('fx_enemy_fire', transform.x);
        if (motion) {
            motion.vx = -dirX * 5.0;
            motion.vy = -dirY * 5.0;
        }

        context.spawnFX('HUNTER_RECOIL', transform.x + dirX, transform.y + dirY, transform.rotation);
        return NodeState.SUCCESS;
    }
    return NodeState.RUNNING;
  }
}


=====================================
FILE: ./src/engine/ai/nodes/daemonNodes.ts
=====================================
import { BTNode, NodeState } from '@/engine/ai/behavior/types';
import { Entity } from '@/engine/ecs/Entity';
import { AIContext } from '@/engine/handlers/ai/types';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { AIStateData } from '@/engine/ecs/components/AIStateData';
import { TargetData } from '@/engine/ecs/components/TargetData';
import { OrbitalData } from '@/engine/ecs/components/OrbitalData';
import { RenderTransform } from '@/engine/ecs/components/RenderTransform';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { AI_STATE } from '@/engine/ai/AIStateTypes';

export class OrbitControl extends BTNode {
  constructor(private state: 'ACTIVE' | 'IDLE') { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const orbital = entity.getComponent<OrbitalData>(ComponentType.Orbital);
    if (!orbital) return NodeState.FAILURE;
    orbital.active = (this.state === 'ACTIVE');
    return NodeState.SUCCESS;
  }
}

export class ChargeMechanic extends BTNode {
  constructor(private duration: number) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const state = entity.getComponent<AIStateData>(ComponentType.State);
    if (!state) return NodeState.FAILURE;

    const currentProgress = state.data.chargeProgress || 0;

    if (currentProgress < 1.0) {
        state.data.chargeProgress = currentProgress + (context.delta / this.duration);
        
        if (state.data.chargeProgress >= 1.0) {
            state.data.chargeProgress = 1.0;
            state.current = AI_STATE.READY;
            context.playSound('ui_optimal', 0); 
            return NodeState.SUCCESS;
        }
        state.current = AI_STATE.CHARGING;
        return NodeState.RUNNING;
    }

    return NodeState.SUCCESS;
  }
}

export class FireDaemonShot extends BTNode {
  constructor(private speed: number, private damage: number) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const transform = entity.getComponent<TransformData>(ComponentType.Transform);
    const target = entity.getComponent<TargetData>(ComponentType.Target);
    const state = entity.getComponent<AIStateData>(ComponentType.State);

    if (!transform || !target || !state) return NodeState.FAILURE;

    const dx = target.x - transform.x;
    const dy = target.y - transform.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    let dirX = 1, dirY = 0;
    
    if (dist > 0.001) {
        dirX = dx / dist;
        dirY = dy / dist;
    }

    context.spawnProjectile(
        transform.x + (dirX * 0.5), 
        transform.y + (dirY * 0.5), 
        dirX * this.speed, 
        dirY * this.speed, 
        this.damage, 
        'DAEMON_ORB', 
        entity.id as number
    );

    context.spawnFX('IMPACT_WHITE', transform.x, transform.y);
    context.playSound('fx_teleport', transform.x);

    state.data.chargeProgress = 0;
    state.data.lastFireTime = context.time;
    state.current = AI_STATE.ORBIT;

    return NodeState.SUCCESS;
  }
}

export class DaemonAim extends BTNode {
  private readonly TURN_SPEED = 5.0;

  tick(entity: Entity, context: AIContext): NodeState {
    const transform = entity.getComponent<TransformData>(ComponentType.Transform);
    const target = entity.getComponent<TargetData>(ComponentType.Target);
    const state = entity.getComponent<AIStateData>(ComponentType.State);
    const visual = entity.getComponent<RenderTransform>(ComponentType.RenderTransform);

    if (!transform || !target || !state || !visual) return NodeState.FAILURE;

    let targetAngle = 0;
    const charge = state.data.chargeProgress || 0;
    const isCharged = charge >= 1.0;
    const hasEnemy = target.id !== null && target.id !== undefined;

    if (isCharged && hasEnemy) {
        const dx = target.x - transform.x;
        const dy = target.y - transform.y;
        targetAngle = Math.atan2(dy, dx);
    } else {
        targetAngle = Math.atan2(-transform.y, -transform.x);
    }

    let diff = targetAngle - transform.rotation;
    while (diff > Math.PI) diff -= Math.PI * 2;
    while (diff < -Math.PI) diff += Math.PI * 2;
    
    transform.rotation += diff * this.TURN_SPEED * context.delta;
    visual.rotation += context.delta * 2.0;

    return NodeState.SUCCESS;
  }
}

export class HasTargetLock extends BTNode {
  tick(entity: Entity, context: AIContext): NodeState {
    const target = entity.getComponent<TargetData>(ComponentType.Target);
    if (target && target.id) {
        return NodeState.SUCCESS;
    }
    return NodeState.FAILURE;
  }
}


=====================================
FILE: ./src/engine/ai/nodes/drillerNodes.ts
=====================================
import { BTNode, NodeState } from '@/engine/ai/behavior/types';
import { Entity } from '@/engine/ecs/Entity';
import { AIContext } from '@/engine/handlers/ai/types';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { TargetData } from '@/engine/ecs/components/TargetData';
import { MotionData } from '@/engine/ecs/components/MotionData';
import { CombatData } from '@/engine/ecs/components/CombatData';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { MODEL_CONFIG } from '@/engine/config/ModelConfig';
import { PanelId } from '@/engine/config/PanelConfig';
import { AITimerID } from '@/engine/ai/AITimerID';

export class DrillAttack extends BTNode {
  private readonly TIP_OFFSET = MODEL_CONFIG.DRILLER.spawnOffset;
  constructor(private interval: number) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const target = entity.getComponent<TargetData>(ComponentType.Target);
    const state = entity.getComponent<any>(ComponentType.State);
    const transform = entity.getComponent<TransformData>(ComponentType.Transform);
    const motion = entity.getComponent<MotionData>(ComponentType.Motion);
    const combat = entity.getComponent<CombatData>(ComponentType.Combat);

    if (!target || !state || !transform) return NodeState.FAILURE;

    let destX = target.x;
    let destY = target.y;
    if (target.type === 'PANEL' && target.id) {
        const rect = context.getPanelRect(target.id as PanelId);
        if (rect) {
            destX = Math.max(rect.left, Math.min(transform.x, rect.right));
            destY = Math.max(rect.bottom, Math.min(transform.y, rect.top));
        }
    }

    const dx = destX - transform.x;
    const dy = destY - transform.y;
    const angle = Math.atan2(dy, dx);
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist > 0.001) {
        const normX = dx / dist;
        const normY = dy / dist;
        transform.x = destX - (normX * this.TIP_OFFSET);
        transform.y = destY - (normY * this.TIP_OFFSET);
        transform.rotation = angle;
    }

    if (motion) {
        motion.vx = 0;
        motion.vy = 0;
    }

    context.spawnFX('DRILL_SPARKS', destX, destY, transform.rotation);
    if (!state.timers[AITimerID.DRILL_AUDIO] || state.timers[AITimerID.DRILL_AUDIO] <= 0) {
        context.playSound('loop_drill', transform.x);
        state.timers[AITimerID.DRILL_AUDIO] = 0.25;
    } else {
        state.timers[AITimerID.DRILL_AUDIO] -= context.delta;
    }

    if (!state.timers[AITimerID.DRILL_DMG] || state.timers[AITimerID.DRILL_DMG] <= 0) {
        const damage = combat ? combat.damage : 1;
        if (target.type === 'PANEL' && target.id) {
            context.damagePanel(target.id as PanelId, damage, { 
                source: { x: transform.x, y: transform.y } 
            });
            state.timers[AITimerID.DRILL_DMG] = this.interval;
        } else {
            state.timers[AITimerID.DRILL_DMG] = this.interval;
        }
    } else {
        state.timers[AITimerID.DRILL_DMG] -= context.delta;
    }
    return NodeState.RUNNING;
  }
}


=====================================
FILE: ./src/engine/ai/nodes/conditions.ts
=====================================
import { BTNode, NodeState } from '@/engine/ai/behavior/types';
import { Entity } from '@/engine/ecs/Entity';
import { AIContext } from '@/engine/handlers/ai/types';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { TargetData } from '@/engine/ecs/components/TargetData';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class IsTargetInRange extends BTNode {
  constructor(private range: number) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const transform = entity.getComponent<TransformData>(ComponentType.Transform);
    const target = entity.getComponent<TargetData>(ComponentType.Target);
    
    if (!transform || !target) return NodeState.FAILURE;

    let tx = target.x;
    let ty = target.y;

    // Logic: If target is a Panel, clamp destination to the panel edges
    if (target.type === 'PANEL' && target.id) {
        const rect = context.getPanelRect(target.id);
        if (rect) {
            tx = Math.max(rect.left, Math.min(transform.x, rect.right));
            ty = Math.max(rect.bottom, Math.min(transform.y, rect.top));
        }
    }

    const dx = tx - transform.x;
    const dy = ty - transform.y;
    const distSq = dx*dx + dy*dy;

    return distSq <= (this.range * this.range) ? NodeState.SUCCESS : NodeState.FAILURE;
  }
}


=====================================
FILE: ./src/engine/ai/nodes/logic.ts
=====================================
import { BTNode, NodeState } from '@/engine/ai/behavior/types';
import { Entity } from '@/engine/ecs/Entity';
import { AIContext } from '@/engine/handlers/ai/types';
import { AIStateData } from '@/engine/ecs/components/AIStateData';
import { RenderEffect } from '@/engine/ecs/components/RenderEffect';
import { RenderTransform } from '@/engine/ecs/components/RenderTransform';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { TargetData } from '@/engine/ecs/components/TargetData';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { AI_STATE } from '@/engine/ai/AIStateTypes';
import { AITimerID } from '@/engine/ai/AITimerID';

export class SpawnPhase extends BTNode {
  constructor(private duration: number) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const state = entity.getComponent<AIStateData>(ComponentType.State);
    const effect = entity.getComponent<RenderEffect>(ComponentType.RenderEffect);
    const visual = entity.getComponent<RenderTransform>(ComponentType.RenderTransform);
    const transform = entity.getComponent<TransformData>(ComponentType.Transform);
    const target = entity.getComponent<TargetData>(ComponentType.Target);
    
    if (!state) return NodeState.SUCCESS;
    if (state.timers[AITimerID.SPAWN] === undefined) {
        state.timers[AITimerID.SPAWN] = this.duration;
        state.current = AI_STATE.SPAWN;
        if (effect) {
            effect.spawnProgress = 0.0;
        }
    }

    if (state.timers[AITimerID.SPAWN]! > 0) {
        state.timers[AITimerID.SPAWN]! -= context.delta;
        
        if (transform && target) {
            const dx = target.x - transform.x;
            const dy = target.y - transform.y;
            if (Math.abs(dx) > 0.01 || Math.abs(dy) > 0.01) {
                const targetAngle = Math.atan2(dy, dx);
                transform.rotation = targetAngle;
            }
        }

        if (effect && visual) {
            const t = 1.0 - (state.timers[AITimerID.SPAWN]! / this.duration);
            effect.spawnProgress = Math.max(0, Math.min(1, t));
            
            if (t < 0.8) {
                visual.scale = t / 0.8;
            } else {
                const popT = (t - 0.8) / 0.2;
                visual.scale = 1.0 + (Math.sin(popT * Math.PI) * 0.25);
            }
            visual.rotation += (1.0 - t) * 15.0 * context.delta;
        }
        return NodeState.RUNNING;
    }

    if (state.current === AI_STATE.SPAWN) {
        state.current = AI_STATE.ACTIVE;
        if (effect && visual) {
            effect.spawnProgress = 1.0;
            visual.scale = 1.0;
            effect.flash = 0.6; 
        }
    }
    return NodeState.SUCCESS;
  }
}


=====================================
FILE: ./src/engine/ai/nodes/actions.ts
=====================================
import { BTNode, NodeState } from '@/engine/ai/behavior/types';
import { Entity } from '@/engine/ecs/Entity';
import { AIContext } from '@/engine/handlers/ai/types';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { MotionData } from '@/engine/ecs/components/MotionData';
import { TargetData } from '@/engine/ecs/components/TargetData';
import { RenderTransform } from '@/engine/ecs/components/RenderTransform';
import { AIStateData } from '@/engine/ecs/components/AIStateData';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { PanelId } from '@/engine/config/PanelConfig';
import { AITimerID } from '@/engine/ai/AITimerID';

export class MoveToTarget extends BTNode {
  constructor(private speed: number, private stopDistance: number = 0) { super(); }

  tick(entity: Entity, context: AIContext): NodeState {
    const transform = entity.getComponent<TransformData>(ComponentType.Transform);
    const motion = entity.getComponent<MotionData>(ComponentType.Motion);
    const target = entity.getComponent<TargetData>(ComponentType.Target);
    const state = entity.getComponent<AIStateData>(ComponentType.State);

    if (!transform || !motion || !target) return NodeState.FAILURE;
    if (state && state.stunTimer > 0) {
        state.stunTimer -= context.delta;
        return NodeState.RUNNING;
    }

    let tx = target.x;
    let ty = target.y;
    if (target.type === 'PANEL' && target.id) {
        const rect = context.getPanelRect(target.id as PanelId);
        if (rect) {
            tx = Math.max(rect.left, Math.min(transform.x, rect.right));
            ty = Math.max(rect.bottom, Math.min(transform.y, rect.top));
        }
    }

    const dx = tx - transform.x;
    const dy = ty - transform.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist <= this.stopDistance) {
        motion.vx = 0;
        motion.vy = 0;
        return NodeState.SUCCESS;
    }

    const nx = dx / dist;
    const ny = dy / dist;
    motion.vx = nx * this.speed;
    motion.vy = ny * this.speed;
    transform.rotation = Math.atan2(dy, dx);
    return NodeState.RUNNING;
  }
}

export class Wait extends BTNode {
  private min: number;
  private max: number;
  constructor(min: number, max?: number) { 
    super(); 
    this.min = min;
    this.max = max ?? min;
  }

  tick(entity: Entity, context: AIContext): NodeState {
    const state = entity.getComponent<AIStateData>(ComponentType.State);
    if (!state) return NodeState.FAILURE;
    if (state.timers[AITimerID.WAIT] === undefined) {
        state.timers[AITimerID.WAIT] = this.min + Math.random() * (this.max - this.min);
    }

    state.timers[AITimerID.WAIT]! -= context.delta;
    if (state.timers[AITimerID.WAIT]! <= 0) {
        state.timers[AITimerID.WAIT] = undefined;
        return NodeState.SUCCESS;
    }
    return NodeState.RUNNING;
  }
}

export class SpinVisual extends BTNode {
  constructor(private speed: number) { super(); }
  tick(entity: Entity, context: AIContext): NodeState {
      const visual = entity.getComponent<RenderTransform>(ComponentType.RenderTransform);
      if (visual) {
          visual.rotation += context.delta * this.speed;
      }
      return NodeState.SUCCESS;
  }
}


=====================================
FILE: ./src/engine/ai/AIStateTypes.ts
=====================================
export const AI_STATE = {
  IDLE: 'IDLE',
  SPAWN: 'SPAWN',
  ACTIVE: 'ACTIVE',
  ATTACK: 'ATTACK',
  ORBIT: 'ORBIT',
  CHARGING: 'CHARGING',
  READY: 'READY',
  COOLDOWN: 'COOLDOWN',
  REBOOTING: 'REBOOTING',
  HEALING: 'HEALING',
  FLIGHT: 'FLIGHT' // Projectiles
} as const;

export type AIBehaviorState = typeof AI_STATE[keyof typeof AI_STATE];


=====================================
FILE: ./src/engine/ai/BehaviorTreeBuilder.ts
=====================================
import { BehaviorNodeRegistry } from './BehaviorNodeRegistry';
import { BTNode } from './behavior/types';

export interface NodeDef {
  type: string;
  args?: any[];
  children?: NodeDef[];
  id?: string; // For MemSequence
}

export class BehaviorTreeBuilder {
  
  public static build(def: NodeDef): BTNode {
    const Ctor = BehaviorNodeRegistry.get(def.type);
    
    if (!Ctor) {
      throw new Error(`[BehaviorTreeBuilder] Unknown node type: ${def.type}`);
    }

    // 1. Build Children recursively
    let childrenInstances: BTNode[] = [];
    if (def.children) {
      childrenInstances = def.children.map(childDef => this.build(childDef));
    }

    // 2. Construct Instance
    // Case A: Composites (Sequence, Selector, Parallel) take children as first arg
    // Case B: Decorators (Inverter, Succeeder) take single child as first arg
    // Case C: Leafs take args...
    
    const isComposite = ['Sequence', 'Selector', 'Parallel', 'MemSequence'].includes(def.type);
    const isDecorator = ['Inverter', 'Succeeder'].includes(def.type);

    if (isComposite) {
        if (def.type === 'MemSequence') {
             // MemSequence(children, id)
             return new Ctor(childrenInstances, def.id || 'default_mem_seq');
        }
        return new Ctor(childrenInstances);
    } 
    else if (isDecorator) {
        if (childrenInstances.length === 0) {
            throw new Error(`[BehaviorTreeBuilder] Decorator ${def.type} requires a child.`);
        }
        return new Ctor(childrenInstances[0]);
    } 
    else {
        // Leaf Node
        const args = def.args || [];
        return new Ctor(...args);
    }
  }
}


=====================================
FILE: ./src/engine/ai/AIBlackboard.ts
=====================================
export interface DaemonBlackboard {
  chargeProgress?: number;
  shieldHP?: number;
  lastFireTime?: number;
  wasHit?: boolean;
}

export interface HunterBlackboard {
  driftX?: number;
  driftY?: number;
}

export interface DrillerBlackboard {
  penetrationDepth?: number;
}

export type AIBlackboard = DaemonBlackboard & HunterBlackboard & DrillerBlackboard & Record<string, any>;


=====================================
FILE: ./src/engine/ai/BehaviorNodeRegistry.ts
=====================================
import { BTNode } from './behavior/types';
import { Sequence, Selector, Parallel, MemSequence } from './behavior/composites';
import { Inverter, Succeeder } from './behavior/decorators';

// Actions
import { MoveToTarget, Wait, SpinVisual } from './nodes/actions';
import { SpawnPhase } from './nodes/logic';

// Conditions
import { IsTargetInRange } from './nodes/conditions';

// Specifics
import { DrillAttack } from './nodes/drillerNodes';
import { HoverDrift, AimAndFire } from './nodes/hunterNodes';
import { OrbitControl, ChargeMechanic, FireDaemonShot, HasTargetLock, DaemonAim } from './nodes/daemonNodes';

type NodeConstructor = new (...args: any[]) => BTNode;

class NodeRegistry {
  private map = new Map<string, NodeConstructor>();

  constructor() {
    // Composites
    this.register('Sequence', Sequence);
    this.register('Selector', Selector);
    this.register('Parallel', Parallel);
    this.register('MemSequence', MemSequence);

    // Decorators
    this.register('Inverter', Inverter);
    this.register('Succeeder', Succeeder);

    // Common Actions
    this.register('MoveToTarget', MoveToTarget);
    this.register('Wait', Wait);
    this.register('SpinVisual', SpinVisual);
    this.register('SpawnPhase', SpawnPhase);

    // Conditions
    this.register('IsTargetInRange', IsTargetInRange);

    // Driller
    this.register('DrillAttack', DrillAttack);

    // Hunter
    this.register('HoverDrift', HoverDrift);
    this.register('AimAndFire', AimAndFire); // NEW

    // Daemon
    this.register('OrbitControl', OrbitControl);
    this.register('ChargeMechanic', ChargeMechanic);
    this.register('FireDaemonShot', FireDaemonShot);
    this.register('HasTargetLock', HasTargetLock);
    this.register('DaemonAim', DaemonAim);
  }

  public register(key: string, ctor: NodeConstructor) {
    this.map.set(key, ctor);
  }

  public get(key: string): NodeConstructor | undefined {
    return this.map.get(key);
  }
}

export const BehaviorNodeRegistry = new NodeRegistry();


=====================================
FILE: ./src/engine/graphics/gpgpu/GPGPUManager.ts
=====================================
import { GPUComputationRenderer, Variable } from 'three/examples/jsm/misc/GPUComputationRenderer';
import * as THREE from 'three';

export class GPGPUManager {
  private gpuCompute: GPUComputationRenderer;
  private variables = new Map<string, Variable>();

  constructor(renderer: THREE.WebGLRenderer, size: number) {
    this.gpuCompute = new GPUComputationRenderer(size, size, renderer);
    
    // Check support
    const status = this.gpuCompute.init();
    if (status !== null) {
        console.error("GPGPU Init Failed:", status);
    }
  }

  public createVariable(name: string, shader: string, initialData: THREE.DataTexture) {
    const variable = this.gpuCompute.addVariable(`texture${name}`, shader, initialData);
    variable.wrapS = THREE.RepeatWrapping;
    variable.wrapT = THREE.RepeatWrapping;
    this.variables.set(name, variable);
    
    // Resolve dependencies automatically (self-referential for simulation)
    this.gpuCompute.setVariableDependencies(variable, [variable]);
    
    return variable;
  }

  public init() {
    const error = this.gpuCompute.init();
    if (error !== null) {
        console.error(error);
    }
  }

  public update() {
    this.gpuCompute.compute();
  }

  public getTexture(name: string) {
    const v = this.variables.get(name);
    if (!v) return null;
    return this.gpuCompute.getCurrentRenderTarget(v).texture;
  }
}


=====================================
FILE: ./src/engine/graphics/RenderBuffer.ts
=====================================
import { RENDER_STRIDE } from './RenderSchema';

const DEFAULT_CAPACITY = 2000;

export interface RenderGroup {
  count: number;
  buffer: Float32Array;
}

class RenderBufferService {
  private groups = new Map<string, RenderGroup>();

  public getGroup(key: string): RenderGroup {
    let group = this.groups.get(key);
    if (!group) {
      group = {
        count: 0,
        buffer: new Float32Array(DEFAULT_CAPACITY * RENDER_STRIDE)
      };
      this.groups.set(key, group);
    }
    return group;
  }

  public reset() {
    for (const group of this.groups.values()) {
      group.count = 0;
    }
  }

  public ensureCapacity(group: RenderGroup, requiredIndex: number) {
    if (requiredIndex >= group.buffer.length) {
      const newSize = group.buffer.length * 2;
      const newBuffer = new Float32Array(newSize);
      newBuffer.set(group.buffer);
      group.buffer = newBuffer;
      console.log(`[RenderBuffer] Resized group buffer to ${newSize}`);
    }
  }
}

export const RenderBuffer = new RenderBufferService();
export { RENDER_STRIDE };


=====================================
FILE: ./src/engine/graphics/ShaderLib.ts
=====================================
import { chunk_noise } from './glsl/noise';
import { chunk_math } from './glsl/math';

export const ShaderLib = {
  chunks: {
    noise: chunk_noise,
    math: chunk_math,
    
    vertexHeader: `
      #ifndef USE_INSTANCING_COLOR
      attribute vec3 instanceColor;
      #endif
      attribute vec3 barycentric;
      attribute float spawnProgress;
      
      varying vec3 vColor;
      varying vec3 vBarycentric;
      varying vec2 vUv;
      varying vec3 vPos;
      varying float vSpawn;
      
      uniform float uTime;
    `,

    fragmentHeader: `
      varying vec3 vColor;
      varying vec3 vBarycentric;
      varying vec2 vUv;
      varying vec3 vPos;
      varying float vSpawn;
      
      uniform float uTime;
    `,
  },

  presets: {
    enemy: {
      vertex: `
        void main() {
          vColor = instanceColor;
          vBarycentric = barycentric;
          vUv = uv;
          vPos = position;
          vSpawn = spawnProgress;
          
          gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
        }
      `,
      fragment: `
        void main() {
          // --- SPAWN DISSOLVE LOGIC ---
          float noise = snoise(vPos * 3.0 + vec3(0.0, uTime * 0.5, 0.0)) * 0.5 + 0.5;
          float threshold = (1.0 - vSpawn) * 1.4 - 0.2;
          
          if (noise < threshold) discard;

          float edgeWidth = 0.1;
          float burn = smoothstep(threshold, threshold + edgeWidth, noise);
          float edgeIntensity = 1.0 - burn; 
          
          // --- COLOR LOGIC ---
          float width = 1.5;
          float wireEdge = edgeFactor(vBarycentric, width);
          
          // 'glow' represents how close we are to the wireframe line (1.0 = on line, 0.0 = face center)
          float glow = pow(1.0 - wireEdge, 0.4);
          
          vec3 coreColor = vColor;
          float intensity = max(max(vColor.r, vColor.g), vColor.b);
          
          // Determine if we are in "High Intensity" (Flash) mode
          // 0.0 = Normal, 1.0 = Flash
          float isFlash = smoothstep(1.0, 3.0, intensity);
          
          // Normal: Edges are White. Flash: Edges are colored (to prevent pink/pastel look).
          vec3 wireColor = mix(vec3(1.0), vColor, isFlash);
          
          // Mix: Face -> Wireframe
          vec3 finalColor = mix(coreColor, wireColor, glow);

          // Apply Burn Edge (Blue/White Dissolve Line)
          vec3 burnColor = vec3(0.8, 1.0, 1.0) * 4.0; 
          finalColor += burnColor * edgeIntensity;

          gl_FragColor = vec4(finalColor, 1.0);
        }
      `
    },

    particle: {
      vertex: `
        attribute float shapeID;
        varying float vShape;
        void main() {
          vUv = uv;
          vColor = instanceColor;
          vShape = shapeID;
          gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
        }
      `,
      fragment: `
        varying float vShape;
        void main() {
          float alpha = 0.0;
          if (vShape < 0.5) {
            vec2 d = abs(vUv - 0.5) * 2.0;
            float shape = max(d.x, d.y);
            alpha = 1.0 - smoothstep(0.8, 1.0, shape);
          } else {
            float T = vUv.x; 
            float distY = abs(vUv.y - 0.5) * 2.0;
            alpha = 1.0 - smoothstep(sqrt(T) - 0.2, sqrt(T), distY);
            if (T < 0.01) alpha = 0.0;
          }
          if (alpha < 0.01) discard;
          gl_FragColor = vec4(vColor, alpha);
        }
      `
    },

    glitch: {
      vertex: `
        uniform float uIntensity;
        uniform float uFrequency;
        uniform float uSpeed;

        void main() {
          vUv = uv;
          vColor = vec3(0.0, 1.0, 0.4); 
          vBarycentric = barycentric;
          vPos = position; 
          
          float noiseVal = snoise(vec3(position * uFrequency + uTime * uSpeed));
          vec3 displaced = position + normal * noiseVal * uIntensity;
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
        }
      `,
      fragment: `
        void main() {
          float width = 1.0; 
          float edge = edgeFactor(vBarycentric, width);
          float scan = sin(vPos.y * 20.0 - uTime * 5.0) * 0.5 + 0.5;
          float alpha = 0.1 + (1.0 - edge) * 0.9 + (scan * 0.3);
          gl_FragColor = vec4(vColor, alpha);
        }
      `
    },

    playerAmbient: {
      vertex: `
        void main() { 
          vUv = uv; 
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); 
        }
      `,
      fragment: `
        uniform vec3 uColor; uniform float uOpacity; uniform float uEnergy;
        
        void main() {
          vec2 pos = vUv - 0.5;
          float angle = atan(pos.y, pos.x);
          float warble = (0.005 + 0.015 * uEnergy) * sin(angle * 10.0 + uTime * 2.0);
          float dist = length(pos) + warble;
          float alphaBase = pow(1.0 - smoothstep(0.0, 0.5, dist), 3.5);
          float ringsIdle = 0.6 + 0.4 * sin(dist * 80.0 - uTime * 1.5);
          float ringsActive = 0.5 + 0.5 * sin(dist * 30.0 - uTime * 8.0);
          float ringMix = mix(ringsIdle, ringsActive, uEnergy);
          float scan = 0.85 + 0.15 * sin(dist * 150.0 - uTime * 5.0);
          float finalAlpha = alphaBase * ringMix * scan * uOpacity * (1.0 + (uEnergy * 2.5));
          if (finalAlpha < 0.01) discard;
          gl_FragColor = vec4(uColor, finalAlpha);
        }
      `
    },

    playerBacking: {
      vertex: `
        void main() { 
          vUv = uv; 
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); 
        }
      `,
      fragment: `
        uniform vec3 uColor; uniform float uOpacity; 
        void main() { 
          float dist = distance(vUv, vec2(0.5)); 
          float alpha = 1.0 - smoothstep(0.25, 0.5, dist); 
          if (alpha < 0.01) discard; 
          gl_FragColor = vec4(uColor, alpha * uOpacity); 
        }
      `
    },

    galleryBody: {
      vertex: `
        void main() {
          vBarycentric = barycentric;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragment: `
        uniform vec3 uColor;
        uniform float uGlow;
        uniform float uDissolve;
        
        void main() {
          if (uDissolve > 0.0) {
              float stripes = sin(gl_FragCoord.y * 0.1 + gl_FragCoord.x * 0.1);
              if (stripes < (uDissolve * 2.0 - 1.0)) discard;
          }

          float width = 1.0; 
          float edge = edgeFactor(vBarycentric, width);
          float glow = 1.0 - edge;
          glow = pow(glow, 0.4) + uGlow; 
          
          vec3 coreColor = uColor;
          vec3 edgeColor = vec3(1.0);
          vec3 finalColor = mix(coreColor, edgeColor, 1.0 - smoothstep(0.0, 0.1, edge));
          finalColor += coreColor * uGlow * 0.5;

          gl_FragColor = vec4(finalColor, 1.0);
        }
      `
    }
  }
};


=====================================
FILE: ./src/engine/graphics/RenderSchema.ts
=====================================
export const RenderOffset = {
  POSITION_X: 0,
  POSITION_Y: 1,
  POSITION_Z: 2,
  ROTATION_X: 3,
  ROTATION_Y: 4,
  ROTATION_Z: 5,
  ROTATION_W: 6,
  SCALE_X: 7,
  SCALE_Y: 8,
  SCALE_Z: 9,
  COLOR_R: 10,
  COLOR_G: 11,
  COLOR_B: 12,
  SPAWN_PROGRESS: 13
} as const;

export const RENDER_STRIDE = 14;


=====================================
FILE: ./src/engine/graphics/Uniforms.ts
=====================================
export enum Uniforms {
  TIME = 'uTime',
  COLOR = 'uColor',
  OPACITY = 'uOpacity',
  ENERGY = 'uEnergy',
  GLOW = 'uGlow',
  DISSOLVE = 'uDissolve',
  INTENSITY = 'uIntensity',
  FREQUENCY = 'uFrequency',
  SPEED = 'uSpeed',
  OFFSET = 'offset',
  DARKNESS = 'darkness',
  DAMP = 'damp'
}


=====================================
FILE: ./src/engine/graphics/glsl/math.ts
=====================================
export const chunk_math = `
  // --- BARYCENTRIC WIREFRAME LOGIC ---
  float edgeFactor(vec3 bary, float width) {
    vec3 d = fwidth(bary);
    vec3 a3 = smoothstep(vec3(0.0), d * width, bary);
    return min(min(a3.x, a3.y), a3.z);
  }

  // --- UTILITY ---
  float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
  }
`;


=====================================
FILE: ./src/engine/graphics/glsl/noise.ts
=====================================
export const chunk_noise = `
  // --- 3D NOISE ---
  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
  vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

  float snoise(vec3 v) {
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 = v - i + dot(i, C.xxx) ;

    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );

    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy;
    vec3 x3 = x0 - D.yyy;

    i = mod289(i);
    vec4 p = permute( permute( permute(
              i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

    float n_ = 0.142857142857;
    vec3  ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );

    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );

    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);

    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                  dot(p2,x2), dot(p3,x3) ) );
  }
`;


=====================================
FILE: ./src/engine/graphics/MaterialFactory.ts
=====================================
import * as THREE from 'three';
import { ShaderLib } from './ShaderLib';
import { Uniforms } from './Uniforms';

class MaterialFactoryController {
  private materials = new Map<string, THREE.ShaderMaterial>();
  public create(id: string, definition: { vertex: string; fragment: string; uniforms?: Record<string, any> }) {
    if (id === 'MAT_GLITCH' || !this.materials.has(id)) {
        const vertexHeader = ShaderLib.chunks.vertexHeader;
        const fragmentHeader = ShaderLib.chunks.fragmentHeader;
        const math = ShaderLib.chunks.math;
        const noise = ShaderLib.chunks.noise;
        const fullVertex = `${vertexHeader}${noise}${definition.vertex}`;
        const fullFragment = `${fragmentHeader}${math}${noise}${definition.fragment}`;
        const mat = new THREE.ShaderMaterial({
          vertexShader: fullVertex,
          fragmentShader: fullFragment,
          uniforms: {
            [Uniforms.TIME]: { value: 0 },
            ...(definition.uniforms || {})
          },
          vertexColors: true,
          side: THREE.DoubleSide,
          transparent: true,
          depthWrite: true
        });
        this.materials.set(id, mat);
        return mat;
    }
    return this.materials.get(id)!;
  }

  public updateUniforms(time: number) {
    for (const mat of this.materials.values()) {
        if (mat.uniforms[Uniforms.TIME]) {
            mat.uniforms[Uniforms.TIME].value = time;
        }
    }
  }
}

export const MaterialFactory = new MaterialFactoryController();


=====================================
FILE: ./src/engine/systems/CollisionSystem.ts
=====================================
import { IGameSystem, IPhysicsSystem, ICombatSystem, IEntityRegistry } from '@/engine/interfaces';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { AIStateData } from '@/engine/ecs/components/AIStateData';
import { ColliderData } from '@/engine/ecs/components/ColliderData';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { SYS_LIMITS } from '@/engine/config/constants/SystemConstants';

export class CollisionSystem implements IGameSystem {
  private queryBuffer = new Int32Array(SYS_LIMITS.MAX_COLLISION_RESULTS);
  private handledPairs = new Set<number>(); 

  constructor(
    private physicsSystem: IPhysicsSystem,
    private combatSystem: ICombatSystem,
    private registry: IEntityRegistry
  ) {}

  update(delta: number, time: number): void {
    const spatial = this.physicsSystem.spatialGrid;
    const collidables = this.registry.query({ all: [ComponentType.Collider, ComponentType.Transform] });
    this.handledPairs.clear();

    for (const entity of collidables) {
        if (!entity.active) continue;
        const collider = entity.getComponent<ColliderData>(ComponentType.Collider);
        const transform = entity.getComponent<TransformData>(ComponentType.Transform);
        
        if (!collider || collider.mask === 0 || !transform) continue;

        const state = entity.getComponent<AIStateData>(ComponentType.State);
        if (state && state.current === 'SPAWN') continue;

        const queryRad = collider.shape === 'BOX' 
            ? Math.sqrt((collider.width/2)**2 + (collider.height/2)**2) + 1.0
            : collider.radius + 1.0;

        const count = spatial.query(transform.x, transform.y, queryRad, this.queryBuffer);

        for (let i = 0; i < count; i++) {
            const otherId = this.queryBuffer[i];
            if (otherId === entity.id) continue;

            const idA = entity.id as number;
            const idB = otherId;
            const pairKey = (Math.min(idA, idB) << 16) | Math.max(idA, idB);
            if (this.handledPairs.has(pairKey)) continue;
            this.handledPairs.add(pairKey);

            const other = this.registry.getEntity(otherId);
            if (!other || !other.active) continue;

            const otherCollider = other.getComponent<ColliderData>(ComponentType.Collider);
            if (!otherCollider) continue;

            const aHitsB = (collider.mask & otherCollider.layer) !== 0;
            const bHitsA = (otherCollider.mask & collider.layer) !== 0;
            if (!aHitsB && !bHitsA) continue;

            const otherTransform = other.getComponent<TransformData>(ComponentType.Transform);
            if (!otherTransform) continue;

            if (this.checkCollision(transform, collider, otherTransform, otherCollider)) {
                this.combatSystem.resolveCollision(entity, other);
            }
        }
    }
  }

  private checkCollision(
      tA: TransformData, cA: ColliderData, 
      tB: TransformData, cB: ColliderData
  ): boolean {
      if (cA.shape === 'CIRCLE' && cB.shape === 'CIRCLE') {
          const dx = tA.x - tB.x;
          const dy = tA.y - tB.y;
          const rSum = cA.radius + cB.radius;
          return (dx * dx + dy * dy) < (rSum * rSum);
      }

      if (cA.shape === 'BOX' && cB.shape === 'BOX') {
          return (
              Math.abs(tA.x - tB.x) * 2 < (cA.width + cB.width) &&
              Math.abs(tA.y - tB.y) * 2 < (cA.height + cB.height)
          );
      }

      const circle = cA.shape === 'CIRCLE' ? { t: tA, c: cA } : { t: tB, c: cB };
      const box = cA.shape === 'BOX' ? { t: tA, c: cA } : { t: tB, c: cB };

      const boxHalfW = box.c.width / 2;
      const boxHalfH = box.c.height / 2;

      const distX = Math.abs(circle.t.x - box.t.x);
      const distY = Math.abs(circle.t.y - box.t.y);

      if (distX > (boxHalfW + circle.c.radius)) return false;
      if (distY > (boxHalfH + circle.c.radius)) return false;

      if (distX <= boxHalfW) return true; 
      if (distY <= boxHalfH) return true;

      const dx = distX - boxHalfW;
      const dy = distY - boxHalfH;
      return (dx*dx + dy*dy <= (circle.c.radius * circle.c.radius));
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/HealthSystem.ts
=====================================
import { IGameSystem, IGameEventService, IAudioService, IPanelSystem } from '@/engine/interfaces';
import { GameEvents } from '@/engine/signals/GameEvents';
import { PLAYER_CONFIG } from '@/engine/config/PlayerConfig';
import { useStore } from '@/engine/state/global/useStore';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { GameStream } from '@/engine/state/GameStream';

export class HealthSystem implements IGameSystem {
  public playerHealth: number = PLAYER_CONFIG.maxHealth;
  public maxPlayerHealth: number = PLAYER_CONFIG.maxHealth;
  public playerRebootProgress: number = 0;
  public isGameOver: boolean = false;
  
  constructor(
    private events: IGameEventService,
    private audio: IAudioService,
    private panelSystem: IPanelSystem
  ) {
    this.reset();
    
    this.events.subscribe(GameEvents.PLAYER_REBOOT_TICK, (p) => this.tickReboot(p.amount));
    this.events.subscribe(GameEvents.PLAYER_REBOOT_DECAY, (p) => this.decayReboot(p.amount));
    this.events.subscribe(GameEvents.PLAYER_HIT, (p) => {
        this.damagePlayer(p.damage);
    });
  }

  update(delta: number, time: number): void {
    if (this.isGameOver) return;
    
    if (this.panelSystem.systemIntegrity <= 0) {
        this.isGameOver = true;
        this.events.emit(GameEvents.GAME_OVER, { score: 0 });
        this.events.emit(GameEvents.TRAUMA_ADDED, { amount: 1.0 });
        
        // Sync final state to React for Game Over Screen
        useGameStore.setState({ systemIntegrity: 0 });
        GameStream.set('SYSTEM_INTEGRITY', 0);
    }
  }

  public damagePlayer(amount: number) {
    if (this.isGameOver) return;
    const { godMode } = useStore.getState().debugFlags;
    if (godMode) return;
    
    if (this.playerHealth > 0) {
        this.playerHealth = Math.max(0, this.playerHealth - amount);
        this.pushStream();
        
        if (this.playerHealth <= 0) {
            this.audio.playSound('fx_player_death');
            // Sync death state to React once
            useGameStore.setState({ playerHealth: 0 }); 
        }
    } else {
        this.playerRebootProgress = Math.max(0, this.playerRebootProgress - (amount * 2));
        this.pushStream();
    }
  }

  public healPlayer(amount: number) {
    const wasDead = this.playerHealth <= 0;
    this.playerHealth = Math.min(this.maxPlayerHealth, this.playerHealth + amount);
    this.pushStream();
    
    // Sync revival state to React once
    if (!wasDead && this.playerHealth > 0) {
       // Only if transitioning from dead to alive, but here we usually heal alive players
    }
    if (wasDead && this.playerHealth > 0) {
        useGameStore.setState({ playerHealth: this.playerHealth });
    }
  }

  public tickReboot(amount: number) {
    if (this.playerHealth > 0) return;
    this.playerRebootProgress = Math.max(0, Math.min(100, this.playerRebootProgress + amount));
    this.pushStream();
    
    if (this.playerRebootProgress >= 100) {
        this.playerHealth = this.maxPlayerHealth; 
        this.playerRebootProgress = 0;
        this.audio.playSound('fx_reboot_success');
        this.pushStream();
        
        // React State Sync (Low Frequency)
        useGameStore.setState({ playerHealth: this.playerHealth, playerRebootProgress: 0 });
    }
  }

  public decayReboot(amount: number) {
      if (this.playerHealth > 0) return; 
      this.playerRebootProgress = Math.max(0, this.playerRebootProgress - amount);
      if (Math.random() > 0.5) this.pushStream();
  }

  private pushStream() {
      GameStream.set('PLAYER_HEALTH', this.playerHealth);
      GameStream.set('PLAYER_MAX_HEALTH', this.maxPlayerHealth);
      GameStream.set('PLAYER_REBOOT', this.playerRebootProgress);
  }

  public reset() {
      this.playerHealth = this.maxPlayerHealth;
      this.playerRebootProgress = 0;
      this.isGameOver = false;
      this.pushStream();
      
      useGameStore.setState({ 
          playerHealth: this.maxPlayerHealth,
          playerRebootProgress: 0,
          systemIntegrity: 100 
      });
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/InteractionSystem.ts
=====================================
import { IInteractionSystem, IEntitySpawner, IGameStateSystem, IPanelSystem, IInputService, IGameEventService, IEntityRegistry, IPhysicsSystem } from '@/engine/interfaces';
import { GameEvents } from '@/engine/signals/GameEvents';
import { AudioSystem } from '@/engine/audio/AudioSystem';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { ColliderData } from '@/engine/ecs/components/ColliderData';
import { IdentityData } from '@/engine/ecs/components/IdentityData';
import { Tag } from '@/engine/ecs/types';
import { GAMEPLAY_CONFIG } from '@/engine/config/GameplayConfig';
import { PanelId } from '@/engine/config/PanelConfig';

export type RepairState = 'IDLE' | 'HEALING' | 'REBOOTING';

export class InteractionSystem implements IInteractionSystem {
  public repairState: RepairState = 'IDLE';
  public hoveringPanelId: PanelId | null = null;
  
  private lastRepairTime = 0;
  private previousHoverId: PanelId | null = null;

  constructor(
    private input: IInputService,
    private spawner: IEntitySpawner,
    private gameSystem: IGameStateSystem,
    private panelSystem: IPanelSystem,
    private events: IGameEventService,
    private physics: IPhysicsSystem,
    private registry: IEntityRegistry
  ) {}

  update(delta: number, time: number): void {
    this.repairState = 'IDLE';
    this.hoveringPanelId = null;
    
    if (this.gameSystem.isGameOver) {
        this.syncInteractionState();
        return; 
    }
    
    const cursor = this.input.getCursor();
    
    if (this.gameSystem.playerHealth <= 0) {
        this.handleRevival(cursor, time);
        if (this.repairState !== 'REBOOTING' && this.gameSystem.playerRebootProgress > 0) {
            this.events.emit(GameEvents.PLAYER_REBOOT_DECAY, { amount: delta * 15 });
        }
    } else {
        this.handlePanelRepair(cursor, time);
    }

    this.syncInteractionState();
  }

  private syncInteractionState() {
      if (this.hoveringPanelId !== this.previousHoverId) {
          useGameStore.getState().setInteractionTarget(this.hoveringPanelId);
          this.previousHoverId = this.hoveringPanelId;
      }
  }

  teardown(): void {
      useGameStore.getState().setInteractionTarget(null);
  }

  private handleRevival(cursor: {x: number, y: number}, time: number) {
    const rect = this.panelSystem.getPanelRect(PanelId.IDENTITY);
    if (!rect) return;
    
    const padding = 0.1; 
    const isHovering = 
        cursor.x >= rect.left - padding && 
        cursor.x <= rect.right + padding && 
        cursor.y >= rect.bottom - padding && 
        cursor.y <= rect.top + padding;

    if (isHovering) {
        this.hoveringPanelId = PanelId.IDENTITY;
        this.repairState = 'REBOOTING';
        if (time > this.lastRepairTime + GAMEPLAY_CONFIG.INTERACTION.REPAIR_RATE) {
            this.events.emit(GameEvents.PLAYER_REBOOT_TICK, { amount: GAMEPLAY_CONFIG.INTERACTION.REBOOT_TICK_AMOUNT });
            this.lastRepairTime = time;
            AudioSystem.playSound('loop_reboot'); 
            this.spawnRepairParticles(cursor, '#9E4EA5');
        }
    }
  }

  private handlePanelRepair(cursor: {x: number, y: number}, time: number) {
    const panels = this.registry.getByTag(Tag.OBSTACLE);

    for (const entity of panels) {
        if (!entity.active) continue;

        const transform = entity.getComponent<TransformData>(ComponentType.Transform);
        const collider = entity.getComponent<ColliderData>(ComponentType.Collider);
        const identity = entity.getComponent<IdentityData>(ComponentType.Identity);

        if (!transform || !collider || !identity) continue;

        const halfW = collider.width / 2;
        const halfH = collider.height / 2;
        
        const inX = cursor.x >= transform.x - halfW && cursor.x <= transform.x + halfW;
        const inY = cursor.y >= transform.y - halfH && cursor.y <= transform.y + halfH;

        if (inX && inY) {
            const panelId = identity.variant as PanelId;
            this.hoveringPanelId = panelId;

            const panelState = this.panelSystem.getPanelState(panelId);
            if (!panelState) continue;

            if (!panelState.isDestroyed && panelState.health >= 100) continue;

            this.repairState = panelState.isDestroyed ? 'REBOOTING' : 'HEALING';

            if (time > this.lastRepairTime + GAMEPLAY_CONFIG.INTERACTION.REPAIR_RATE) {
                this.panelSystem.healPanel(panelId, GAMEPLAY_CONFIG.INTERACTION.REPAIR_HEAL_AMOUNT, cursor.x);
                this.lastRepairTime = time;

                if (panelState.isDestroyed) {
                    AudioSystem.playSound('loop_reboot');
                } else {
                    this.events.emit(GameEvents.PANEL_HEALED, { id: panelId, amount: 4 });
                }

                const color = panelState.isDestroyed ? '#9E4EA5' : '#00F0FF';
                this.spawnRepairParticles(cursor, color);
            }
            break; 
        }
    }
  }

  private spawnRepairParticles(cursor: {x: number, y: number}, color: string) {
      if (Math.random() > 0.3) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 2 + Math.random() * 2;
          this.spawner.spawnParticle(cursor.x, cursor.y, color, Math.cos(angle)*speed, Math.sin(angle)*speed, 0.5);
      }
  }
}


=====================================
FILE: ./src/engine/systems/ProjectileSystem.ts
=====================================
import { IGameSystem, IEntityRegistry } from '@/engine/interfaces';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { ProjectileData } from '@/engine/ecs/components/ProjectileData';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { MotionData } from '@/engine/ecs/components/MotionData';
import { RenderTransform } from '@/engine/ecs/components/RenderTransform';
import { PROJECTILE_CONFIG } from '@/engine/config/ProjectileConfig';

export class ProjectileSystem implements IGameSystem {
  constructor(private registry: IEntityRegistry) {}

  update(delta: number, time: number): void {
    const entities = this.registry.query({ all: [ComponentType.Projectile, ComponentType.Transform] });

    for (const entity of entities) {
        if (!entity.active) continue;

        const proj = entity.getComponent<ProjectileData>(ComponentType.Projectile);
        const transform = entity.getComponent<TransformData>(ComponentType.Transform);
        const render = entity.getComponent<RenderTransform>(ComponentType.RenderTransform);
        const motion = entity.getComponent<MotionData>(ComponentType.Motion);
        
        if (!proj || !transform) continue;

        const config = PROJECTILE_CONFIG[proj.configId];
        if (!config) continue;

        if (proj.state === 'CHARGING' && proj.ownerId !== -1) {
            const owner = this.registry.getEntity(proj.ownerId);
            
            if (!owner || !owner.active) {
                this.registry.destroyEntity(entity.id);
                continue;
            }

            const ownerTransform = owner.getComponent<TransformData>(ComponentType.Transform);
            if (ownerTransform) {
                const offsetDist = 1.6; 
                const cos = Math.cos(ownerTransform.rotation);
                const sin = Math.sin(ownerTransform.rotation);
                
                transform.x = ownerTransform.x + (cos * offsetDist);
                transform.y = ownerTransform.y + (sin * offsetDist);
                transform.rotation = ownerTransform.rotation;
                
                if (motion) { motion.vx = 0; motion.vy = 0; }
            }
        }
        else if (proj.state === 'FLIGHT' && render) {
            if (!config.faceVelocity && config.spinSpeed !== 0) {
                render.rotation += delta * config.spinSpeed;
            }
            if (config.pulseSpeed > 0) {
                render.scale = 1.0 + Math.sin(time * config.pulseSpeed) * 0.2;
            }
        }
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/VFXSystem.ts
=====================================
import { IGameSystem, IParticleSystem, IGameEventService, IFastEventService } from '@/engine/interfaces';
import { GameEvents } from '@/engine/signals/GameEvents';
import { FastEventType, FX_LOOKUP, FXCode } from '@/engine/signals/FastEventBus';
import { ShakeSystem } from './ShakeSystem';
import { VFX_MANIFEST } from '@/engine/config/assets/VFXManifest';
import { useStore } from '@/engine/state/global/useStore';
import { ParticleShape } from '@/engine/ecs/types';

export class VFXSystem implements IGameSystem {
  constructor(
    private particleSystem: IParticleSystem,
    private shakeSystem: ShakeSystem,
    private events: IGameEventService,
    private fastEvents: IFastEventService
  ) {
    this.events.subscribe(GameEvents.SPAWN_IMPACT, (p) => {
        this.spawnDynamicImpact(p.x, p.y, p.hexColor, p.angle);
    });
  }

  update(delta: number, time: number): void {
      this.fastEvents.process((id, a1, a2, a3, a4) => {
          if (id === FastEventType.SPAWN_FX) {
              const key = FX_LOOKUP[a1 as FXCode];
              if (key) {
                  this.executeRecipe(key, a2 / 100, a3 / 100, a4 / 100);
              }
          }
          else if (id === FastEventType.CAM_SHAKE) {
              this.shakeSystem.addTrauma(a1 / 100);
          }
      });
  }

  teardown(): void {}

  private spawnDynamicImpact(x: number, y: number, hexColor: string, impactAngle: number) {
      const count = this.randomRange(2, 3);
      
      for(let i=0; i<count; i++) {
          const side = Math.random() > 0.5 ? 1 : -1;
          const deflection = 0.6 + (Math.random() * 1.2);
          const angle = impactAngle + (side * deflection);
          
          const speed = this.randomRange(10, 22); 
          const vx = Math.cos(angle) * speed;
          const vy = Math.sin(angle) * speed;
          const life = this.randomRange(0.1, 0.3);
          
          this.particleSystem.spawn(x, y, hexColor, vx, vy, life, 1.0, ParticleShape.SQUARE); 
      }
  }

  private executeRecipe(key: string, x: number, y: number, angle: number = 0) {
      const recipe = VFX_MANIFEST[key];
      if (!recipe) return;

      const graphicsMode = useStore.getState().graphicsMode;
      const isPotato = graphicsMode === 'POTATO';
      const multiplier = isPotato ? 0.3 : 1.0;

      const rawCount = this.randomRange(recipe.count[0], recipe.count[1]);
      let count = Math.floor(rawCount * multiplier);
      if (rawCount > 0 && count === 0) count = 1;

      for (let i = 0; i < count; i++) {
          const color = recipe.colors[Math.floor(Math.random() * recipe.colors.length)];
          const speed = this.randomRange(recipe.speed[0], recipe.speed[1]);
          const life = this.randomRange(recipe.life[0], recipe.life[1]);
          
          let size = 1.0;
          if (recipe.size) {
              size = this.randomRange(recipe.size[0], recipe.size[1]);
          }
          
          let vx = 0;
          let vy = 0;

          const isBackblast = recipe.omniChance && Math.random() < recipe.omniChance;
          const isDirectional = recipe.pattern === 'DIRECTIONAL';
          
          const finalSpeed = (isDirectional && isBackblast) ? speed * 0.5 : speed;
          const finalLife = (isDirectional && isBackblast) ? life * 0.8 : life;

          if (recipe.pattern === 'RADIAL') {
              const a = Math.random() * Math.PI * 2;
              vx = Math.cos(a) * finalSpeed;
              vy = Math.sin(a) * finalSpeed;
          } 
          else if (isDirectional) {
              let dir = angle + Math.PI; 
              let spread = recipe.spread || 0.5;

              if (isBackblast) {
                  dir += Math.PI; 
                  spread *= 1.5; 
              }

              const a = dir + (Math.random() - 0.5) * spread;
              vx = Math.cos(a) * finalSpeed;
              vy = Math.sin(a) * finalSpeed;
          }

          const shape = (recipe.shape === 1) ? ParticleShape.SQUARE : ParticleShape.CIRCLE;
          this.particleSystem.spawn(x, y, color, vx, vy, finalLife, size, shape);
      }
  }

  private randomRange(min: number, max: number) {
      return min + Math.random() * (max - min);
  }
}


=====================================
FILE: ./src/engine/systems/PlayerMovementSystem.ts
=====================================
import { IGameSystem, IInputService, IEntityRegistry, IInteractionSystem, IGameStateSystem } from '@/engine/interfaces';
import { Tag } from '@/engine/ecs/types';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { AIStateData } from '@/engine/ecs/components/AIStateData';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class PlayerMovementSystem implements IGameSystem {
  constructor(
    private input: IInputService,
    private registry: IEntityRegistry,
    private interaction: IInteractionSystem,
    private gameSystem: IGameStateSystem
  ) {}

  update(delta: number, time: number): void {
    let playerEntity = null;
    for (const p of this.registry.getByTag(Tag.PLAYER)) { playerEntity = p; break; }
    if (!playerEntity) return;

    const transform = playerEntity.getComponent<TransformData>(ComponentType.Transform);
    const cursor = this.input.getCursor();
    
    // 1. Position Sync
    if (transform) { 
        transform.x = cursor.x; 
        transform.y = cursor.y; 
    }

    if (this.gameSystem.isGameOver || this.gameSystem.playerHealth <= 0) return;

    // 2. Logic State Sync
    const stateComp = playerEntity.getComponent<AIStateData>(ComponentType.State);
    if (stateComp) {
        stateComp.current = this.interaction.repairState !== 'IDLE' ? 'REBOOTING' : 'ACTIVE';
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/StructureSystem.ts
=====================================
import { IGameSystem, IPanelSystem } from '@/engine/interfaces';

export class StructureSystem implements IGameSystem {
  private decayTimer = 0;
  private readonly DECAY_INTERVAL = 0.1; 
  private readonly DECAY_AMOUNT = 2; 

  constructor(private panelSystem: IPanelSystem) {}

  update(delta: number, time: number): void {
    this.decayTimer += delta;
    
    if (this.decayTimer >= this.DECAY_INTERVAL) {
        this.processDecay();
        this.decayTimer = 0;
    }
  }

  private processDecay() {
      const panels = this.panelSystem.getAllPanels();
      for (const p of panels) {
          if (p.isDestroyed && p.health > 0) {
               this.panelSystem.decayPanel(p.id, this.DECAY_AMOUNT);
          }
      }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/ParticleSystem.ts
=====================================
import { IGameSystem, IParticleSystem } from '@/engine/interfaces';
import { SYS_LIMITS } from '@/engine/config/constants/SystemConstants';
import { ParticleShape } from '@/engine/ecs/types';
import * as THREE from 'three';

const MAX_PARTICLES = SYS_LIMITS.MAX_PARTICLES;

export class ParticleSystem implements IParticleSystem {
  public count = 0;

  public x = new Float32Array(MAX_PARTICLES);
  public y = new Float32Array(MAX_PARTICLES);
  public vx = new Float32Array(MAX_PARTICLES);
  public vy = new Float32Array(MAX_PARTICLES);
  public life = new Float32Array(MAX_PARTICLES);
  public maxLife = new Float32Array(MAX_PARTICLES);
  public size = new Float32Array(MAX_PARTICLES);
  public shape = new Float32Array(MAX_PARTICLES); 
  
  public r = new Float32Array(MAX_PARTICLES);
  public g = new Float32Array(MAX_PARTICLES);
  public b = new Float32Array(MAX_PARTICLES);

  private tempColor = new THREE.Color();

  constructor() {
    this.count = 0;
  }

  update(delta: number, time: number): void {
    if (this.count === 0) return;

    let i = 0;
    while (i < this.count) {
      this.life[i] -= delta;

      if (this.life[i] <= 0) {
        this.swap(i, this.count - 1);
        this.count--;
        continue;
      }

      this.x[i] += this.vx[i] * delta;
      this.y[i] += this.vy[i] * delta;
      
      this.vx[i] *= 0.95;
      this.vy[i] *= 0.95;

      i++;
    }
  }

  public spawn(
      x: number, y: number, 
      colorHex: string, 
      vx: number, vy: number, 
      life: number, 
      size: number = 1.0, 
      shape: ParticleShape = ParticleShape.CIRCLE
  ) {
    if (this.count >= MAX_PARTICLES) return;

    const idx = this.count;
    this.x[idx] = x;
    this.y[idx] = y;
    this.vx[idx] = vx;
    this.vy[idx] = vy;
    this.life[idx] = life;
    this.maxLife[idx] = life;
    this.size[idx] = size;
    this.shape[idx] = shape;

    this.tempColor.set(colorHex);
    this.r[idx] = this.tempColor.r;
    this.g[idx] = this.tempColor.g;
    this.b[idx] = this.tempColor.b;

    this.count++;
  }

  private swap(a: number, b: number) {
    if (a === b) return;
    
    this.x[a] = this.x[b];
    this.y[a] = this.y[b];
    this.vx[a] = this.vx[b];
    this.vy[a] = this.vy[b];
    this.life[a] = this.life[b];
    this.maxLife[a] = this.maxLife[b];
    this.size[a] = this.size[b];
    this.shape[a] = this.shape[b];
    this.r[a] = this.r[b];
    this.g[a] = this.g[b];
    this.b[a] = this.b[b];
  }

  public getCount() { return this.count; }

  public getData() {
    return {
        x: this.x,
        y: this.y,
        life: this.life,
        maxLife: this.maxLife,
        color: this.r 
    };
  }

  teardown(): void {
    this.count = 0;
  }
}


=====================================
FILE: ./src/engine/systems/OrbitalSystem.ts
=====================================
import { IGameSystem, IEntityRegistry } from '@/engine/interfaces';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { OrbitalData } from '@/engine/ecs/components/OrbitalData';
import { Tag } from '@/engine/ecs/types';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class OrbitalSystem implements IGameSystem {
  constructor(private registry: IEntityRegistry) {}

  update(delta: number, time: number): void {
    const orbitals = this.registry.getAll();
    let player = null;
    const players = this.registry.getByTag(Tag.PLAYER);
    for (const p of players) {
        player = p;
        break; 
    }

    if (!player) return;
    
    const pPos = player.getComponent<TransformData>(ComponentType.Transform);
    if (!pPos) return;

    for (const entity of orbitals) {
        if (!entity.active) continue;
        
        const orb = entity.getComponent<OrbitalData>(ComponentType.Orbital);
        const transform = entity.getComponent<TransformData>(ComponentType.Transform);

        if (!orb || !transform) continue;

        if (orb.active) {
            orb.angle += orb.speed * delta;
        }

        transform.x = pPos.x + Math.cos(orb.angle) * orb.radius;
        transform.y = pPos.y + Math.sin(orb.angle) * orb.radius;
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/MobileCombatSystem.ts
=====================================
import { IGameSystem, ICombatSystem, IGameEventService, IFastEventService, IAudioService, IEntityRegistry } from '@/engine/interfaces';
import { GameEvents } from '@/engine/signals/GameEvents';
import { FastEventType, FXCode } from '@/engine/signals/FastEventBus';
import { Entity } from '@/engine/ecs/Entity';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class MobileCombatSystem implements IGameSystem, ICombatSystem {
    constructor(
        private registry: IEntityRegistry,
        private events: IGameEventService,
        private fastEvents: IFastEventService,
        private audio: IAudioService
    ) {
        this.events.subscribe(GameEvents.ENEMY_DAMAGED, (p) => {
            const entity = this.registry.getEntity(p.id);
            if (entity && entity.active) {
                this.kill(entity);
            }
        });
    }
    
    update() {}
    teardown() {}
    resolveCollision() {}

    private kill(entity: Entity) {
        const t = entity.getComponent<TransformData>(ComponentType.Transform);
        if (t) {
            this.fastEvents.emit(FastEventType.SPAWN_FX, FXCode.EXPLOSION_PURPLE, t.x * 100, t.y * 100, 0); 
            this.audio.playSound('fx_impact_light');
        }
        this.registry.destroyEntity(entity.id);
    }
}


=====================================
FILE: ./src/engine/systems/FeedbackBridgeSystem.ts
=====================================
import { IGameSystem, IGameEventService, IFastEventService, IPanelSystem } from '@/engine/interfaces';
import { GameEvents } from '@/engine/signals/GameEvents';
import { FastEventType, getSoundCode, getFXCode } from '@/engine/signals/FastEventBus';
import { ViewportHelper } from '@/engine/math/ViewportHelper';
import { PanelId } from '@/engine/config/PanelConfig';

export class FeedbackBridgeSystem implements IGameSystem {
  constructor(
    private events: IGameEventService,
    private fastEvents: IFastEventService,
    private panelSystem: IPanelSystem
  ) {
    this.setupRoutes();
  }

  update(): void {}
  teardown(): void {}

  private setupRoutes() {
    this.events.subscribe(GameEvents.PANEL_HEALED, (p) => {
        this.emitSound('loop_heal', this.getPanelX(p.id));
    });

    this.events.subscribe(GameEvents.PANEL_RESTORED, (p) => {
        const x = p.x !== undefined ? p.x : this.getPanelX(p.id);
        this.emitSound('fx_reboot_success', x);
        this.emitFX('REBOOT_HEAL', x, 0); 
    });

    this.events.subscribe(GameEvents.PANEL_DESTROYED, (p) => {
        const x = this.getPanelX(p.id);
        this.emitSound('fx_impact_heavy', x); 
        this.fastEvents.emit(FastEventType.DUCK_MUSIC, 80, 150);
        this.fastEvents.emit(FastEventType.CAM_SHAKE, 75); 
        this.fastEvents.emit(FastEventType.HIT_STOP, 100);
    });

    this.events.subscribe(GameEvents.GAME_OVER, () => {
        this.emitSound('fx_player_death');
        this.fastEvents.emit(FastEventType.DUCK_MUSIC, 100, 300);
        this.fastEvents.emit(FastEventType.CAM_SHAKE, 100);
        this.fastEvents.emit(FastEventType.HIT_STOP, 500);
    });

    this.events.subscribe(GameEvents.UPGRADE_SELECTED, () => {
        this.emitSound('fx_level_up');
    });
    
    this.events.subscribe(GameEvents.SPAWN_FX, (p) => {
        this.emitFX(p.type, p.x, p.y, p.angle);
    });
    
    this.events.subscribe(GameEvents.PLAY_SOUND, (p) => {
        this.emitSound(p.key, p.x);
    });
  }

  private emitSound(key: string, x: number = 0) {
      const id = getSoundCode(key);
      if (id) {
          const pan = this.calculatePan(x);
          this.fastEvents.emit(FastEventType.PLAY_SOUND, id, pan);
      }
  }

  private emitFX(key: string, x: number, y: number, angle: number = 0) {
      const id = getFXCode(key);
      if (id) {
          this.fastEvents.emit(FastEventType.SPAWN_FX, id, x * 100, y * 100, angle * 100);
      }
  }

  private calculatePan(worldX: number): number {
      const halfWidth = ViewportHelper.viewport.width / 2;
      if (halfWidth === 0) return 0;
      return Math.floor(Math.max(-1, Math.min(1, worldX / halfWidth)) * 100);
  }

  private getPanelX(panelId: PanelId): number {
      const rect = this.panelSystem.getPanelRect(panelId);
      return rect ? rect.x : 0;
  }
}


=====================================
FILE: ./src/engine/systems/TimeSystem.ts
=====================================
import { IGameSystem } from '@/engine/interfaces';

export class TimeSystem implements IGameSystem {
  public timeScale: number = 1.0;
  public elapsedTime: number = 0; // Game World Time
  
  private freezeTimer: number = 0; // Real World Time duration

  // FPS Counting
  public fps: number = 60;
  private frames: number = 0;
  private lastFpsTime: number = 0;

  constructor() {
    this.reset();
  }

  // Called by GameEngine every render frame (Variable Interval)
  public tickRealTime(dt: number) {
      // 1. Handle Freeze Timer (Real Time)
      if (this.freezeTimer > 0) {
          this.freezeTimer -= dt;
          if (this.freezeTimer < 0) this.freezeTimer = 0;
      }

      // 2. FPS Calculation (Real Time)
      const now = performance.now() / 1000;
      this.frames++;
      if (now >= this.lastFpsTime + 1.0) {
          this.fps = this.frames;
          this.frames = 0;
          this.lastFpsTime = now;
      }
  }

  // Called by GameEngine only during simulation steps (Fixed Interval)
  update(delta: number, time: number): void {
    // This delta is always 0.0166 (Fixed Step)
    this.elapsedTime += delta;
  }

  teardown(): void {
    this.reset();
  }

  private reset() {
    this.timeScale = 1.0;
    this.elapsedTime = 0;
    this.freezeTimer = 0;
    this.frames = 0;
    this.lastFpsTime = 0;
    this.fps = 60;
  }
  
  public setScale(scale: number, duration?: number) {
    this.timeScale = scale;
    if (duration) {
      setTimeout(() => {
        this.timeScale = 1.0;
      }, duration * 1000);
    }
  }

  public freeze(duration: number) {
      this.freezeTimer = duration;
  }

  public isFrozen(): boolean {
      return this.freezeTimer > 0;
  }
}


=====================================
FILE: ./src/engine/systems/WeaponSystem.ts
=====================================
import { IGameSystem, IEntitySpawner, IGameStateSystem, IEntityRegistry, IGameEventService, IFastEventService } from '@/engine/interfaces';
import { Tag, Faction } from '@/engine/ecs/types';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { AIStateData } from '@/engine/ecs/components/AIStateData';
import { RenderModel } from '@/engine/ecs/components/RenderModel';
import { TargetData } from '@/engine/ecs/components/TargetData';
import { GameEvents } from '@/engine/signals/GameEvents';
import { FastEventType, SoundCode, FXCode } from '@/engine/signals/FastEventBus';
import { ConfigService } from '@/engine/services/ConfigService';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { calculatePlayerShots } from '@/engine/handlers/weapons/WeaponLogic';
import { AI_STATE } from '@/engine/ai/AIStateTypes';

export class WeaponSystem implements IGameSystem {
  private lastFireTime = 0;
  private unsubPurge: () => void;

  constructor(
    private spawner: IEntitySpawner,
    private registry: IEntityRegistry,
    private gameSystem: IGameStateSystem,
    private events: IGameEventService,
    private fastEvents: IFastEventService,
    private config: typeof ConfigService
  ) {
    this.unsubPurge = this.events.subscribe(GameEvents.UPGRADE_SELECTED, (p) => {
        if (p.option === 'PURGE') this.triggerPurge();
    });
  }

  update(delta: number, time: number): void {
    if (this.gameSystem.isGameOver || this.gameSystem.playerHealth <= 0) return;

    let playerEntity = null;
    for (const p of this.registry.getByTag(Tag.PLAYER)) { playerEntity = p; break; }
    if (!playerEntity) return;

    const stateComp = playerEntity.getComponent<AIStateData>(ComponentType.State);
    if (!stateComp || (stateComp.current !== AI_STATE.ACTIVE && stateComp.current !== AI_STATE.REBOOTING)) return;

    const upgrades = this.gameSystem.activeUpgrades;
    const currentFireRate = this.config.player.fireRate / Math.pow(1.5, upgrades['OVERCLOCK'] || 0);

    if (time > this.lastFireTime + currentFireRate) {
        const transform = playerEntity.getComponent<TransformData>(ComponentType.Transform);
        const renderModel = playerEntity.getComponent<RenderModel>(ComponentType.RenderModel);
        if (transform) {
            this.attemptAutoFire(time, transform, upgrades, renderModel);
        }
    }
  }

  private triggerPurge() {
      let startX = 0, startY = 0;
      
      const player = Array.from(this.registry.getByTag(Tag.PLAYER))[0];
      if (player) {
          const t = player.getComponent<TransformData>(ComponentType.Transform);
          if (t) { startX = t.x; startY = t.y; }
      }

      const count = 360; 
      const speed = 45; 
      const damage = 100;
      
      this.fastEvents.emit(FastEventType.SPAWN_FX, FXCode.PURGE_BLAST, startX * 100, startY * 100, 0);
      this.fastEvents.emit(FastEventType.CAM_SHAKE, 100); 

      for (let i = 0; i < count; i++) {
          const angle = (Math.PI * 2 * i) / count;
          this.spawner.spawnBullet(startX, startY, Math.cos(angle) * speed, Math.sin(angle) * speed, Faction.FRIENDLY, 3.0, damage, 'PLAYER_PURGE');
      }
  }

  private attemptAutoFire(time: number, pPos: TransformData, upgrades: Record<string, number>, pRender?: RenderModel) {
    const enemies = this.registry.getByTag(Tag.ENEMY);
    let nearestDist = Infinity; let targetEnemy = null;

    for (const e of enemies) {
      if (!e.active || e.hasTag(Tag.BULLET)) continue;
      const state = e.getComponent<AIStateData>(ComponentType.State);
      if (state && state.current === AI_STATE.SPAWN) continue;
      const t = e.getComponent<TransformData>(ComponentType.Transform);
      if (!t) continue;
      const dist = (t.x - pPos.x)**2 + (t.y - pPos.y)**2; 
      if (dist < 196 && dist < nearestDist) { nearestDist = dist; targetEnemy = e; }
    }

    if (!targetEnemy) return;

    const tPos = targetEnemy.getComponent<TransformData>(ComponentType.Transform)!;
    const shots = calculatePlayerShots({ x: pPos.x, y: pPos.y }, { x: tPos.x, y: tPos.y }, upgrades);

    shots.forEach(shot => {
        const bullet = this.spawner.spawnBullet(shot.x, shot.y, shot.vx, shot.vy, Faction.FRIENDLY, shot.life, shot.damage, shot.configId);
        if (pRender) {
            const bModel = bullet.getComponent<RenderModel>(ComponentType.RenderModel);
            if (bModel) { bModel.r = pRender.r * 4; bModel.g = pRender.g * 4; bModel.b = pRender.b * 4; }
        }
        if (shot.isHoming) {
            bullet.addComponent(new TargetData(null, 'ENEMY'));
        }
    });

    this.fastEvents.emit(FastEventType.PLAY_SOUND, SoundCode.FX_PLAYER_FIRE, pPos.x * 100);
    this.lastFireTime = time;
  }

  teardown(): void {
    this.unsubPurge();
  }
}


=====================================
FILE: ./src/engine/systems/ShakeSystem.ts
=====================================
import { IGameSystem, IGameEventService, IFastEventService } from '@/engine/interfaces';
import { GameEvents } from '@/engine/signals/GameEvents';
import { noise } from '@/engine/math/Noise';
import { useStore } from '@/engine/state/global/useStore';
import { VISUAL_CONFIG } from '@/engine/config/VisualConfig';

export class ShakeSystem implements IGameSystem {
  private trauma = 0;
  private time = 0;
  public currentOffset = { x: 0, y: 0, r: 0 };
  
  private cleanupListeners: (() => void) | null = null;

  constructor(
      private events: IGameEventService,
      private fastEvents: IFastEventService
  ) {
    const unsub1 = this.events.subscribe(GameEvents.TRAUMA_ADDED, (p) => this.addTrauma(p.amount));
    const unsub2 = this.events.subscribe(GameEvents.PLAYER_HIT, (p) => {
        const amount = p.damage >= 5 ? 0.4 : 0.3;
        this.addTrauma(amount);
    });
    
    this.cleanupListeners = () => {
        unsub1();
        unsub2();
    };
  }

  update(delta: number, time: number): void {
    const strength = useStore.getState().screenShakeStrength;
    const CFG = VISUAL_CONFIG.SHAKE;
    
    if (this.trauma > 0) {
      this.trauma = Math.max(0, this.trauma - (delta * CFG.DECAY_RATE));
    }

    const shake = (this.trauma * this.trauma) * strength;
    
    if (shake > 0.001) {
        const currentSpeed = CFG.BASE_SPEED + (this.trauma * CFG.TRAUMA_SPEED_BOOST);
        this.time += delta * currentSpeed;
        
        const x = CFG.MAX_OFFSET_X * shake * noise(this.time);
        const y = CFG.MAX_OFFSET_Y * shake * noise(this.time + 100);
        const r = CFG.MAX_ROTATION * shake * noise(this.time + 200);
        
        this.currentOffset = { x, y, r };

        const domX = -x * CFG.PIXELS_PER_UNIT;
        const domY = -y * CFG.PIXELS_PER_UNIT; 
        
        const root = document.documentElement;
        root.style.setProperty('--shake-x', `${domX.toFixed(2)}px`);
        root.style.setProperty('--shake-y', `${-domY.toFixed(2)}px`);
        root.style.setProperty('--shake-r', `${r.toFixed(4)}rad`);
    } else {
        if (this.currentOffset.x !== 0) {
            this.resetDOM();
        }
    }
  }

  public addTrauma(amount: number) {
    this.trauma = Math.min(1.0, this.trauma + amount);
  }

  private resetDOM() {
      this.currentOffset = { x: 0, y: 0, r: 0 };
      const root = document.documentElement;
      root.style.setProperty('--shake-x', '0px');
      root.style.setProperty('--shake-y', '0px');
      root.style.setProperty('--shake-r', '0rad');
  }

  teardown(): void {
    if (this.cleanupListeners) this.cleanupListeners();
    this.resetDOM();
  }
}


=====================================
FILE: ./src/engine/systems/RenderSystem.ts
=====================================
import { IGameSystem, IEntityRegistry, IGameStateSystem, IInteractionSystem, IGameEventService } from '@/engine/interfaces';
import { RenderModel } from '@/engine/ecs/components/RenderModel';
import { RenderTransform } from '@/engine/ecs/components/RenderTransform';
import { RenderEffect } from '@/engine/ecs/components/RenderEffect';
import { IdentityData } from '@/engine/ecs/components/IdentityData';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { Tag } from '@/engine/ecs/types';
import { GAME_THEME } from '@/ui/sim/config/theme';
import { MaterialFactory } from '@/engine/graphics/MaterialFactory';
import { GameEvents } from '@/engine/signals/GameEvents';
import { VISUAL_CONFIG } from '@/engine/config/VisualConfig';
import { useGameStore } from '@/engine/state/game/useGameStore';
import * as THREE from 'three';

const COL_BASE = new THREE.Color(GAME_THEME.turret.base);
const COL_REPAIR = new THREE.Color(GAME_THEME.turret.repair);
const COL_REBOOT = new THREE.Color('#9E4EA5');
const COL_DEAD = new THREE.Color('#FF003C');

export class RenderSystem implements IGameSystem {
  private tempColor = new THREE.Color();
  constructor(
    private registry: IEntityRegistry,
    private gameSystem: IGameStateSystem,
    private interactionSystem: IInteractionSystem,
    events: IGameEventService
  ) {
    events.subscribe(GameEvents.ENEMY_DAMAGED, (p) => {
        const entity = this.registry.getEntity(p.id);
        if (entity) {
            const effect = entity.getComponent<RenderEffect>(ComponentType.RenderEffect);
            if (effect) effect.flash = 1.0; 
        }
    });
  }

  update(delta: number, time: number): void {
    MaterialFactory.updateUniforms(time);
    const CFG = VISUAL_CONFIG.RENDER;
    const entities = this.registry.query({ all: [ComponentType.RenderModel] });
    const interactState = this.interactionSystem.repairState;
    const isDead = this.gameSystem.playerHealth <= 0;
    const isZenMode = useGameStore.getState().isZenMode;

    for (const entity of entities) {
        if (!entity.active) continue;
        const model = entity.getComponent<RenderModel>(ComponentType.RenderModel);
        const transform = entity.getComponent<RenderTransform>(ComponentType.RenderTransform);
        const effect = entity.getComponent<RenderEffect>(ComponentType.RenderEffect);
        const identity = entity.getComponent<IdentityData>(ComponentType.Identity);
        
        if (!model) continue;
        const isPlayer = entity.hasTag(Tag.PLAYER) && (!identity || identity.variant === 'PLAYER');
        if (isPlayer) {
            let targetCol = COL_BASE;
            let spinSpeed = 0.02; 
            if (isZenMode) {
                spinSpeed = -0.03;
            } else if (isDead) {
                targetCol = COL_DEAD;
                if (interactState === 'REBOOTING') {
                    targetCol = COL_REBOOT;
                    spinSpeed = -0.3; 
                } else {
                    spinSpeed = 1.5;
                }
            } else {
                if (interactState === 'HEALING') {
                    targetCol = COL_REPAIR;
                    spinSpeed = -0.24;
                } else if (interactState === 'REBOOTING') {
                    targetCol = COL_REBOOT;
                    spinSpeed = -0.24;
                }
            }
            this.tempColor.setRGB(model.r, model.g, model.b);
            this.tempColor.lerp(targetCol, delta * 3.0);
            model.r = this.tempColor.r;
            model.g = this.tempColor.g;
            model.b = this.tempColor.b;
            if (transform) {
                transform.rotation += spinSpeed;
                transform.scale = 1.0;
            }
        }
        else if (effect) {
            if (effect.shudder > 0) effect.shudder = Math.max(0, effect.shudder - (delta * CFG.SHUDDER_DECAY));
            if (effect.flash > 0) {
                effect.flash = Math.max(0, effect.flash - (delta * CFG.FLASH_DECAY));
                if (transform) transform.scale = 1.0 + (effect.flash * 0.25);
            } else {
                if (transform && transform.scale !== 1.0) transform.scale = 1.0;
            }
        }
    }
  }
  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/GuidanceSystem.ts
=====================================
import { IGameSystem, IEntityRegistry } from '@/engine/interfaces';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { MotionData } from '@/engine/ecs/components/MotionData';
import { TargetData } from '@/engine/ecs/components/TargetData';
import { Tag } from '@/engine/ecs/types';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class GuidanceSystem implements IGameSystem {
  constructor(private registry: IEntityRegistry) {}

  update(delta: number, time: number): void {
    const bullets = this.registry.getByTag(Tag.BULLET);

    for (const b of bullets) {
        if (!b.active) continue;
        
        const target = b.getComponent<TargetData>(ComponentType.Target);
        const motion = b.getComponent<MotionData>(ComponentType.Motion);
        const transform = b.getComponent<TransformData>(ComponentType.Transform);

        if (!target || !motion || !transform || !target.id) continue;

        const dx = target.x - transform.x;
        const dy = target.y - transform.y;
        
        const desiredAngle = Math.atan2(dy, dx);
        const currentAngle = Math.atan2(motion.vy, motion.vx);
        
        let diff = desiredAngle - currentAngle;
        while (diff > Math.PI) diff -= Math.PI * 2;
        while (diff < -Math.PI) diff += Math.PI * 2;

        const turnSpeed = 4.0; 
        
        const maxTurn = turnSpeed * delta;
        const actualTurn = Math.max(-maxTurn, Math.min(maxTurn, diff));
        const newAngle = currentAngle + actualTurn;
        
        const speed = Math.sqrt(motion.vx * motion.vx + motion.vy * motion.vy);
        motion.vx = Math.cos(newAngle) * speed;
        motion.vy = Math.sin(newAngle) * speed;
        
        transform.rotation = newAngle;
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/CombatSystem.ts
=====================================
import { IGameSystem, IEntityRegistry, IGameEventService, IFastEventService, IAudioService } from '@/engine/interfaces';
import { Entity } from '@/engine/ecs/Entity';
import { ColliderData } from '@/engine/ecs/components/ColliderData';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { CollisionMatrix } from '@/engine/handlers/combat/CollisionMatrix';
import { CombatContext } from '@/engine/handlers/combat/types';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { IdentityData } from '@/engine/ecs/components/IdentityData';
import { GameEvents } from '@/engine/signals/GameEvents';
import { FastEventType, getFXCode, getSoundCode } from '@/engine/signals/FastEventBus';

export class CombatSystem implements IGameSystem {
  constructor(
    private registry: IEntityRegistry,
    private events: IGameEventService,
    private fastEvents: IFastEventService,
    private audio: IAudioService
  ) {}

  update(delta: number, time: number): void {}

  public resolveCollision(e1: Entity, e2: Entity) {
      const col1 = e1.getComponent<ColliderData>(ComponentType.Collider);
      const col2 = e2.getComponent<ColliderData>(ComponentType.Collider);
      if (!col1 || !col2) return;

      const handler = CollisionMatrix.getHandler(col1.layer, col2.layer);
      if (!handler) return;

      let a = e1, b = e2;
      if (col1.layer > col2.layer) {
          a = e2; b = e1;
      }

      const context: CombatContext = {
          damagePlayer: (amount) => {
              this.events.emit(GameEvents.PLAYER_HIT, { damage: amount });
          },
          destroyEntity: (entity, fx, angle) => this.destroyEntity(entity, fx, angle),
          spawnFX: (type, x, y) => {
              const typeId = getFXCode(type);
              if (typeId) {
                  this.fastEvents.emit(FastEventType.SPAWN_FX, typeId, x * 100, y * 100, 0);
              }
          },
          spawnImpact: (x, y, r, g, b, angle) => {
              const toHex = (c: number) => Math.floor(Math.max(0, Math.min(1, c)) * 255).toString(16).padStart(2, '0');
              const hexColor = `#${toHex(r)}${toHex(g)}${toHex(b)}`;
              this.events.emit(GameEvents.SPAWN_IMPACT, { x, y, hexColor, angle });
          },
          playAudio: (key) => {
              const keyId = getSoundCode(key.toLowerCase());
              if (keyId) this.fastEvents.emit(FastEventType.PLAY_SOUND, keyId, 0);
          },
          playSpatialAudio: (key, x) => {
              const keyId = getSoundCode(key.toLowerCase());
              if (keyId) {
                  this.fastEvents.emit(FastEventType.PLAY_SOUND, keyId, (x || 0) * 100);
              }
          },
          addTrauma: (amount) => {
              this.fastEvents.emit(FastEventType.CAM_SHAKE, amount * 100);
          },
          flashEntity: (id) => {
              this.events.emit(GameEvents.ENEMY_DAMAGED, { id });
          }
      };

      handler(a, b, context);
  }

  private destroyEntity(entity: Entity, fx?: string, impactAngle?: number) {
      const transform = entity.getComponent<TransformData>(ComponentType.Transform);
      const identity = entity.getComponent<IdentityData>(ComponentType.Identity);
      
      if (identity && transform) {
          const isEnemy = Object.values(EnemyTypes).includes(identity.variant as any);
          if (isEnemy && identity.variant !== EnemyTypes.DAEMON) {
              this.events.emit(GameEvents.ENEMY_DESTROYED, { 
                  id: entity.id as number, 
                  x: transform.x, 
                  y: transform.y, 
                  type: identity.variant 
              });
          }
      }

      this.registry.destroyEntity(entity.id);
      
      if (fx && transform) {
          let finalFX = fx;
          const angleToUse = impactAngle || 0;
          
          if (identity?.variant === EnemyTypes.HUNTER) {
              finalFX = impactAngle !== undefined ? 'EXPLOSION_YELLOW_DIR' : 'EXPLOSION_YELLOW';
          }
          else if (identity?.variant === EnemyTypes.KAMIKAZE) {
              finalFX = impactAngle !== undefined ? 'EXPLOSION_RED_DIR' : 'EXPLOSION_RED';
          }
          else if (identity?.variant === EnemyTypes.DRILLER) {
              finalFX = impactAngle !== undefined ? 'EXPLOSION_PURPLE_DIR' : 'EXPLOSION_PURPLE';
          }
          
          const fxId = getFXCode(finalFX);
          if (fxId) {
              this.fastEvents.emit(FastEventType.SPAWN_FX, fxId, transform.x * 100, transform.y * 100, angleToUse * 100);
          }
      }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/AudioDirector.ts
=====================================
import { IGameSystem, IPanelSystem, IGameEventService, IFastEventService, IAudioService } from '@/engine/interfaces';
import { FastEvents, SOUND_ID_MAP } from '@/engine/signals/FastEventBus';
import { ViewportHelper } from '@/engine/math/ViewportHelper';
import { AudioKey } from '@/engine/config/AssetKeys';

export class AudioDirector implements IGameSystem {
  private readCursor = 0;
  
  constructor(
    private panelSystem: IPanelSystem,
    private events: IGameEventService,
    private fastEvents: IFastEventService,
    private audio: IAudioService
  ) {
    this.readCursor = this.fastEvents.getCursor();
  }

  update(delta: number, time: number): void {
    // READ ONLY FROM FAST BUS
    // Logic -> Bridge -> FastBus -> AudioDirector
    // Combat -> FastBus -> AudioDirector
    
    this.readCursor = this.fastEvents.readEvents(this.readCursor, (id, a1, a2, a3, a4) => {
        if (id === FastEvents.PLAY_SOUND) {
            // a1: SoundID, a2: Pan * 100
            const key = SOUND_ID_MAP[a1];
            if (key) {
                const pan = this.calculatePan(a2 / 100); 
                this.audio.playSound(key as AudioKey, pan);
            }
        }
        else if (id === FastEvents.DUCK_MUSIC) {
            // a1: Intensity * 100, a2: Duration * 100
            this.audio.duckMusic(a1 / 100, a2 / 100);
        }
    });
  }

  private calculatePan(worldX: number): number {
      const halfWidth = ViewportHelper.viewport.width / 2;
      if (halfWidth === 0) return 0;
      return Math.max(-1, Math.min(1, worldX / halfWidth));
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/InputSystem.ts
=====================================
import { IGameSystem, IInputService } from '@/engine/interfaces';
import { VirtualJoystickService } from '@/engine/input/VirtualJoystickService';
import { INPUT_SETTINGS } from '@/engine/config/InputConfig';

export class InputSystem implements IGameSystem, IInputService {
  private _cursor = { x: 0, y: 0 };
  
  // Bounds for clamping (updated by GameEngine/ViewportHelper)
  private _bounds = { width: 30, height: 20 }; 

  update(delta: number, time: number): void {
    // Poll Providers
    if (VirtualJoystickService.isActive) {
        const joyVector = VirtualJoystickService.getVector();
        const speed = INPUT_SETTINGS.VIRTUAL_CURSOR.SPEED; 
        
        this._cursor.x += joyVector.x * speed * delta;
        this._cursor.y += joyVector.y * speed * delta;

        // Clamp to logical world bounds
        const halfW = this._bounds.width / 2;
        const halfH = this._bounds.height / 2;
        
        this._cursor.x = Math.max(-halfW, Math.min(halfW, this._cursor.x));
        this._cursor.y = Math.max(-halfH, Math.min(halfH, this._cursor.y));
    }
  }

  teardown(): void {}

  // --- IInputService Implementation ---
  
  public updateCursor(x: number, y: number) {
    // Mouse movement takes precedence over joystick relative motion
    if (!VirtualJoystickService.isActive) {
        this._cursor.x = x;
        this._cursor.y = y;
    }
  }
  
  public updateBounds(width: number, height: number) {
      this._bounds.width = width;
      this._bounds.height = height;
  }

  public getCursor() {
    return this._cursor;
  }

  public isPressed(action: string): boolean {
    return false;
  }
}


=====================================
FILE: ./src/engine/systems/PanelRegistrySystem.ts
=====================================
import { IPanelSystem, IGameEventService, IAudioService, DamageOptions } from '@/engine/interfaces';
import { GameEvents } from '@/engine/signals/GameEvents';
import { WorldRect, ViewportHelper } from '@/engine/math/ViewportHelper';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { useStore } from '@/engine/state/global/useStore';
import { ServiceLocator } from '@/engine/services/ServiceLocator';
import { Entity } from '@/engine/ecs/Entity';
import { Tag } from '@/engine/ecs/types';
import { ComponentRegistry } from '@/engine/ecs/ComponentRegistry';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { CollisionLayers } from '@/engine/config/PhysicsConfig';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { ColliderData } from '@/engine/ecs/components/ColliderData';
import { PanelId } from '@/engine/config/PanelConfig';

export class PanelRegistrySystem implements IPanelSystem {
  private entityMap = new Map<string, Entity>();
  private observer: ResizeObserver | null = null;
  private elements = new Map<string, HTMLElement>();

  public get systemIntegrity() {
      return useGameStore.getState().systemIntegrity;
  }

  constructor(
    private events: IGameEventService,
    private audio: IAudioService
  ) {
    if (typeof window !== 'undefined') {
        this.observer = new ResizeObserver((entries) => {
            for (const entry of entries) {
                for (const [id, el] of this.elements) {
                    if (el === entry.target) {
                        this.syncEntity(id as PanelId, entry.contentRect);
                        break;
                    }
                }
            }
        });
    }

    this.events.subscribe(GameEvents.UPGRADE_SELECTED, (p) => {
        if (p.option === 'RESTORE') {
            const restoredCount = useGameStore.getState().restoreAllPanels();
            if (restoredCount > 0) {
                this.events.emit(GameEvents.TRAUMA_ADDED, { amount: 0.3 }); 
                this.audio.playSound('fx_reboot_success'); 
            }
        }
    });

    this.events.subscribe(GameEvents.ZEN_MODE_ENABLED, () => {
        this.destroyAll();
    });
  }

  update(delta: number, time: number): void {}

  teardown(): void {
      this.observer?.disconnect();
      this.entityMap.clear();
      this.elements.clear();
  }

  public register(id: PanelId, element: HTMLElement) {
      this.elements.set(id, element);
      useGameStore.getState().registerPanel(id, element);
      this.observer?.observe(element);
      
      const registry = ServiceLocator.getRegistry();
      const entity = registry.createEntity();
      entity.addTag(Tag.OBSTACLE); 
      
      entity.addComponent(ComponentRegistry.create(ComponentType.Transform));
      entity.addComponent(ComponentRegistry.create(ComponentType.Identity, { variant: id })); 
      
      entity.addComponent(ComponentRegistry.create(ComponentType.Collider, {
          shape: 'BOX',
          layer: CollisionLayers.PANEL,
          mask: 0 
      }));

      this.entityMap.set(id, entity);
      registry.updateCache(entity);
      this.syncEntity(id, element.getBoundingClientRect());
  }

  public unregister(id: PanelId) {
      const el = this.elements.get(id);
      if (el) this.observer?.unobserve(el);
      this.elements.delete(id);
      
      useGameStore.getState().unregisterPanel(id);

      const entity = this.entityMap.get(id);
      if (entity) {
          ServiceLocator.getRegistry().destroyEntity(entity.id as number);
          this.entityMap.delete(id);
      }
  }

  private syncEntity(id: PanelId, rect: DOMRect | { width: number, height: number }) {
      const entity = this.entityMap.get(id);
      const el = this.elements.get(id);
      if (!entity || !el) return;

      const fullRect = el.getBoundingClientRect();
      const worldRect = ViewportHelper.domToWorld(id, fullRect);

      const transform = entity.getComponent<TransformData>(ComponentType.Transform);
      const collider = entity.getComponent<ColliderData>(ComponentType.Collider);

      if (transform && collider) {
          transform.x = worldRect.x;
          transform.y = worldRect.y;
          collider.width = worldRect.width;
          collider.height = worldRect.height;
      }
  }

  public refreshAll() { 
      for (const [id, el] of this.elements) {
          this.syncEntity(id as PanelId, el.getBoundingClientRect());
      }
  }
  
  public refreshSingle(id: PanelId) { 
      const el = this.elements.get(id);
      if (el) this.syncEntity(id, el.getBoundingClientRect());
  }

  public damagePanel(id: PanelId, amount: number, options?: DamageOptions) {
      if (useStore.getState().debugFlags.panelGodMode) return;
      useGameStore.getState().damagePanel(id, amount, options);
  }

  public healPanel(id: PanelId, amount: number, sourceX?: number) {
      useGameStore.getState().healPanel(id, amount, sourceX);
  }
  
  public decayPanel(id: PanelId, amount: number) {
      useGameStore.getState().decayPanel(id, amount);
  }

  public destroyAll() { 
      useGameStore.getState().destroyAllPanels();
  }

  public getPanelRect(id: PanelId): WorldRect | undefined {
      const entity = this.entityMap.get(id);
      if (entity) {
          const t = entity.getComponent<TransformData>(ComponentType.Transform);
          const c = entity.getComponent<ColliderData>(ComponentType.Collider);
          if (t && c) {
              const halfW = c.width / 2;
              const halfH = c.height / 2;
              return {
                  id,
                  x: t.x, y: t.y,
                  width: c.width, height: c.height,
                  left: t.x - halfW, right: t.x + halfW,
                  top: t.y + halfH, bottom: t.y - halfH
              };
          }
      }
      return undefined;
  }

  public getPanelState(id: PanelId) {
      const panel = useGameStore.getState().panels[id];
      if (!panel) return undefined;
      return { health: panel.health, isDestroyed: panel.isDestroyed };
  }
  
  public getAllPanels() {
      const results = [];
      const state = useGameStore.getState();
      
      for(const [id, entity] of this.entityMap) {
          const pid = id as PanelId;
          const rect = this.getPanelRect(pid);
          const panel = state.panels[pid];
          if (rect && panel) {
              results.push({ ...rect, health: panel.health, isDestroyed: panel.isDestroyed });
          }
      }
      return results;
  }
}


=====================================
FILE: ./src/engine/systems/index.ts
=====================================
export * from './AudioDirector';
export * from './BehaviorSystem';
export * from './CollisionSystem';
export * from './CombatSystem';
export * from './FeedbackBridgeSystem';
export * from './GameStateSystem';
export * from './GuidanceSystem';
export * from './HealthSystem';
export * from './InputSystem';
export * from './InteractionSystem';
export * from './LifeCycleSystem';
export * from './MobileCombatSystem';
export * from './MobileWaveSystem';
export * from './OrbitalSystem';
export * from './PanelRegistrySystem';
export * from './ParticleSystem';
export * from './PhysicsSystem';
export * from './PlayerMovementSystem';
export * from './ProgressionSystem';
export * from './ProjectileSystem';
export * from './RenderSystem';
export * from './ShakeSystem';
export * from './StructureSystem';
export * from './TargetingSystem';
export * from './TimeSystem';
export * from './VFXSystem';
export * from './VisualSystem';
export * from './WaveSystem';
export * from './WeaponSystem';
export * from './WorldSystem';


=====================================
FILE: ./src/engine/systems/ProgressionSystem.ts
=====================================
import { IGameSystem, IGameEventService } from '@/engine/interfaces';
import { GameEvents } from '@/engine/signals/GameEvents';
import { PLAYER_CONFIG } from '@/engine/config/PlayerConfig';
import { GameStream } from '@/engine/state/GameStream';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { UpgradeOption } from '@/engine/types/game.types';

export class ProgressionSystem implements IGameSystem {
  public score: number = 0;
  public xp: number = 0;
  public level: number = 1;
  public xpToNextLevel: number = PLAYER_CONFIG.baseXpRequirement;
  public upgradePoints: number = 0;
  
  public activeUpgrades: Partial<Record<UpgradeOption, number>> = {};

  constructor(private events: IGameEventService) {
    this.events.subscribe(GameEvents.UPGRADE_SELECTED, (p) => {
        this.applyUpgrade(p.option as UpgradeOption);
    });
    
    this.events.subscribe(GameEvents.ENEMY_DESTROYED, () => {
        this.addScore(1);
        this.addXp(10);
    });
    
    this.reset();
  }

  update(delta: number, time: number): void {}

  public addScore(amount: number) {
    this.score += amount;
    GameStream.set('SCORE', this.score);
  }

  public addXp(amount: number) {
    this.xp += amount;
    while (this.xp >= this.xpToNextLevel) {
        this.xp -= this.xpToNextLevel;
        this.level++;
        this.upgradePoints++;
        this.xpToNextLevel = Math.floor(this.xpToNextLevel * PLAYER_CONFIG.xpScalingFactor);
        
        this.events.emit(GameEvents.THREAT_LEVEL_UP, { level: this.level });
        this.syncStore(); 
    }
    
    GameStream.set('XP', this.xp);
    GameStream.set('XP_NEXT', this.xpToNextLevel);
    GameStream.set('LEVEL', this.level);
  }

  public applyUpgrade(option: UpgradeOption) {
      if (this.upgradePoints > 0) {
          this.upgradePoints--;
          
          if (option === 'PURGE' || option === 'RESTORE' || option === 'DAEMON') {
              this.syncStore(); 
              return;
          }
          
          const current = this.activeUpgrades[option] || 0;
          this.activeUpgrades[option] = current + 1;
          this.syncStore();
      }
  }

  private syncStore() {
      useGameStore.getState().setProgressionData({
          xp: this.xp,
          level: this.level,
          nextXp: this.xpToNextLevel,
          points: this.upgradePoints
      });
  }

  public reset() {
      this.score = 0;
      this.xp = 0;
      this.level = 1;
      this.xpToNextLevel = PLAYER_CONFIG.baseXpRequirement;
      this.upgradePoints = 0;
      this.activeUpgrades = { 
        'OVERCLOCK': 0, 'EXECUTE': 0, 'FORK': 0,
        'SNIFFER': 0, 'BACKDOOR': 0, 'REPAIR_NANITES': 0
      };
      
      GameStream.set('SCORE', 0);
      GameStream.set('XP', 0);
      GameStream.set('XP_NEXT', this.xpToNextLevel);
      GameStream.set('LEVEL', 1);
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/GameStateSystem.ts
=====================================
import { IGameSystem, IGameStateSystem, IPanelSystem, IGameEventService, IAudioService } from '@/engine/interfaces';
import { GameEvents } from '@/engine/signals/GameEvents';
import { HealthSystem } from './HealthSystem';
import { ProgressionSystem } from './ProgressionSystem';

export class GameStateSystem implements IGameStateSystem {
  private heartbeatTimer: number = 0;

  constructor(
    private healthSys: HealthSystem,
    private progSys: ProgressionSystem,
    private panelSystem: IPanelSystem,
    private events: IGameEventService,
    private audio: IAudioService
  ) {
    this.events.subscribe(GameEvents.UPGRADE_SELECTED, (p) => {
        if (p.option === 'REPAIR_NANITES') {
            // Buffed: Now heals 75% of max health
            this.healthSys.healPlayer(this.healthSys.maxPlayerHealth * 0.75);
            this.audio.playSound('ui_optimal');
        } else if (p.option === 'DAEMON') {
            this.events.emit(GameEvents.SPAWN_DAEMON, null);
        }
    });
  }

  update(delta: number, time: number): void {
      if (this.isGameOver) return;

      const integrity = this.panelSystem.systemIntegrity;
      
      if (integrity < 30 && integrity > 0) {
          this.heartbeatTimer -= delta;
          if (this.heartbeatTimer <= 0) {
              const urgency = 1.0 - (integrity / 30);
              this.audio.playSound('loop_warning');
              this.events.emit(GameEvents.HEARTBEAT, { urgency });
              this.heartbeatTimer = 1.4 - (urgency * 1.05); 
          }
      } else {
          this.heartbeatTimer = 0;
      }
  }

  teardown(): void {
      this.healthSys.reset();
      this.progSys.reset();
  }

  get playerHealth() { return this.healthSys.playerHealth; }
  get maxPlayerHealth() { return this.healthSys.maxPlayerHealth; }
  get playerRebootProgress() { return this.healthSys.playerRebootProgress; }
  get isGameOver() { return this.healthSys.isGameOver; }
  set isGameOver(v: boolean) { this.healthSys.isGameOver = v; }

  get score() { return this.progSys.score; }
  get xp() { return this.progSys.xp; }
  get level() { return this.progSys.level; }
  get xpToNextLevel() { return this.progSys.xpToNextLevel; }
  get upgradePoints() { return this.progSys.upgradePoints; }
  get activeUpgrades() { return this.progSys.activeUpgrades; }

  damagePlayer(amount: number) { this.healthSys.damagePlayer(amount); }
  healPlayer(amount: number) { this.healthSys.healPlayer(amount); }
  tickReboot(amount: number) { this.healthSys.tickReboot(amount); }
  decayReboot(amount: number) { this.healthSys.decayReboot(amount); }
  addScore(amount: number) { this.progSys.addScore(amount); }
  addXp(amount: number) { this.progSys.addXp(amount); }
}


=====================================
FILE: ./src/engine/systems/WorldSystem.ts
=====================================
import { IGameSystem, IPanelSystem, IEntityRegistry } from '@/engine/interfaces';
import { useStore } from '@/engine/state/global/useStore'; 
import { RenderModel } from '@/engine/ecs/components/RenderModel';
import { RenderTransform } from '@/engine/ecs/components/RenderTransform';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { ComponentRegistry } from '@/engine/ecs/ComponentRegistry';
import { Tag } from '@/engine/ecs/types';
import * as THREE from 'three';

const COL_SAFE = new THREE.Color("#00FF41");
const COL_WARN = new THREE.Color("#FFD700");
const COL_CRIT = new THREE.Color("#FF003C");
const COL_SBX  = new THREE.Color("#00FFFF");

export class WorldSystem implements IGameSystem {
  private targetColor = new THREE.Color();
  private currentColor = new THREE.Color();
  private worldEntityId: number | null = null;

  constructor(
    private panelSystem: IPanelSystem,
    private registry: IEntityRegistry
  ) {
    this.ensureWorldEntity();
  }

  private ensureWorldEntity() {
      // Check if exists
      for(const e of this.registry.getByTag(Tag.WORLD)) {
          this.worldEntityId = e.id;
          return;
      }

      // Create if missing
      const world = this.registry.createEntity();
      world.addTag(Tag.WORLD);
      
      // Add split render components
      world.addComponent(ComponentRegistry.create(ComponentType.RenderModel, { 
          r: 0, g: 0.2, b: 0
      }));
      world.addComponent(ComponentRegistry.create(ComponentType.RenderTransform, {
          scale: 1.0, 
          rotation: 0 
      }));

      this.registry.updateCache(world);
      this.worldEntityId = world.id;
  }

  update(delta: number, time: number): void {
    // Only handling lighting color interpolation here for system consistency.
    // Visual movement (WireframeFloor) is now handled in the View layer
    // to ensure it persists during Game Over / Paused states.

    if (this.worldEntityId === null) return;
    
    const world = this.registry.getEntity(this.worldEntityId);
    if (!world || !world.active) return;

    const model = world.getComponent<RenderModel>(ComponentType.RenderModel);
    if (!model) return;

    const integrity = this.panelSystem.systemIntegrity;
    const bootState = useStore.getState().bootState;
    
    // 1. Determine Target Color
    if (bootState === 'sandbox') this.targetColor.copy(COL_SBX);
    else if (integrity < 30) this.targetColor.copy(COL_CRIT);
    else if (integrity < 60) this.targetColor.copy(COL_WARN);
    else this.targetColor.copy(COL_SAFE);

    // 2. Smooth Lerp
    this.currentColor.setRGB(model.r, model.g, model.b);
    this.currentColor.lerp(this.targetColor, delta * 2.0);
    
    model.r = this.currentColor.r;
    model.g = this.currentColor.g;
    model.b = this.currentColor.b;
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/MobileWaveSystem.ts
=====================================
import { IGameSystem, IEntitySpawner } from '@/engine/interfaces';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { ViewportHelper } from '@/engine/math/ViewportHelper';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { MODEL_CONFIG } from '@/engine/config/ModelConfig';

// Dynamic offset to match Driller model
const DRILLER_OFFSET = MODEL_CONFIG.DRILLER.height / 2; 

export class MobileWaveSystem implements IGameSystem {
  private time = 0;
  private nextSpawn = 0;
  
  // Difficulty Config
  private readonly START_INTERVAL = 1.2;
  private readonly MIN_INTERVAL = 0.4;
  private readonly RAMP_DURATION = 60.0;

  constructor(private spawner: IEntitySpawner) {}

  update(delta: number, time: number): void {
    this.time += delta;

    if (this.time >= this.nextSpawn) {
        this.spawnDriller();
        
        const progress = Math.min(1.0, this.time / this.RAMP_DURATION);
        const currentInterval = this.START_INTERVAL - (progress * (this.START_INTERVAL - this.MIN_INTERVAL));
        
        this.nextSpawn = this.time + currentInterval;
    }
  }

  private spawnDriller() {
      const { width, height } = ViewportHelper.viewport;
      const pad = 3.0; 
      
      const isTop = Math.random() > 0.5;
      
      let x = (Math.random() - 0.5) * (width * 0.6); 
      let y = 0;

      if (isTop) { 
          y = (height / 2) + pad;
      } else { 
          y = -(height / 2) - pad;
      }

      this.spawner.spawn(EnemyTypes.DRILLER, {
          [ComponentType.Transform]: { 
              x, y, 
              scale: 1.0, 
              rotation: Math.atan2(isTop ? -1 : 1, 0) // Point towards center
          },
          [ComponentType.State]: { 
              current: 'ACTIVE',
              timers: { 
                  spawn: 0,
                  drillAudio: Math.random() * 0.2 
              } 
          },
          [ComponentType.RenderTransform]: { 
              scale: 1.0 
          }
      });
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/TargetingSystem.ts
=====================================
import { IGameSystem, IPanelSystem, IEntityRegistry } from '@/engine/interfaces';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { TargetData } from '@/engine/ecs/components/TargetData';
import { Tag } from '@/engine/ecs/types';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { PanelId } from '@/engine/config/PanelConfig';

export class TargetingSystem implements IGameSystem {
  private playerCache: { x: number, y: number } | null = null;

  constructor(
    private registry: IEntityRegistry,
    private panelSystem: IPanelSystem
  ) {}

  update(delta: number, time: number): void {
    this.updatePlayerCache();
    const entities = this.registry.getAll();
    
    for (const entity of entities) {
        if (!entity.active) continue;

        const target = entity.getComponent<TargetData>(ComponentType.Target);
        if (!target) continue;

        const transform = entity.getComponent<TransformData>(ComponentType.Transform);
        if (!transform) continue;

        if (target.locked && target.id) {
            if (target.type === 'PANEL') {
                const panel = this.panelSystem.getPanelState(target.id as PanelId);
                if (!panel || panel.isDestroyed) {
                    target.locked = false;
                    target.id = null;
                } else {
                    const rect = this.panelSystem.getPanelRect(target.id as PanelId);
                    if (rect) {
                        target.x = Math.max(rect.left, Math.min(transform.x, rect.right));
                        target.y = Math.max(rect.bottom, Math.min(transform.y, rect.top));
                    }
                }
            }
            else if (target.type === 'ENEMY') {
                target.locked = false; 
            }
            else if (target.type === 'PLAYER' && this.playerCache) {
                target.x = this.playerCache.x;
                target.y = this.playerCache.y;
            }
            
            if (target.locked) continue; 
        }

        if (target.type === 'PLAYER') {
            if (this.playerCache) {
                target.x = this.playerCache.x;
                target.y = this.playerCache.y;
                target.id = 'PLAYER';
            }
        }
        else if (target.type === 'PANEL') {
            const bestPanel = this.findNearestPanel(transform.x, transform.y);
            if (bestPanel) {
                target.id = bestPanel.id;
                target.x = Math.max(bestPanel.left, Math.min(transform.x, bestPanel.right));
                target.y = Math.max(bestPanel.bottom, Math.min(transform.y, bestPanel.top));
                target.locked = true; 
            } else {
                if (this.playerCache) {
                    target.x = this.playerCache.x;
                    target.y = this.playerCache.y;
                    target.id = 'PLAYER';
                }
            }
        }
        else if (target.type === 'ENEMY') {
            const bestEnemy = this.findNearestEnemy(transform.x, transform.y);
            if (bestEnemy) {
                target.x = bestEnemy.x;
                target.y = bestEnemy.y;
                target.id = 'ENEMY_LOCKED';
            } else {
                target.id = null; 
            }
        }
    }
  }

  private updatePlayerCache() {
      const players = this.registry.getByTag(Tag.PLAYER);
      for (const p of players) {
          const t = p.getComponent<TransformData>(ComponentType.Transform);
          if (t) {
              this.playerCache = { x: t.x, y: t.y };
              return;
          }
      }
      this.playerCache = null;
  }

  private findNearestPanel(x: number, y: number) {
      const panels = this.panelSystem.getAllPanels();
      let nearest: any = null;
      let minDist = Infinity;

      for (const p of panels) {
          if (p.isDestroyed) continue;
          
          const clampedX = Math.max(p.left, Math.min(x, p.right));
          const clampedY = Math.max(p.bottom, Math.min(y, p.top));
          
          const dx = clampedX - x;
          const dy = clampedY - y;
          const distSq = dx*dx + dy*dy;
          
          if (distSq < minDist) {
              minDist = distSq;
              nearest = p;
          }
      }
      return nearest;
  }

  private findNearestEnemy(x: number, y: number) {
      const enemies = this.registry.getByTag(Tag.ENEMY);
      let nearest: { x: number, y: number } | null = null;
      let minDist = Infinity;
      const MAX_RANGE_SQ = 15 * 15; 

      for (const e of enemies) {
          if (!e.active) continue;
          if (e.hasTag(Tag.BULLET)) continue;

          const t = e.getComponent<TransformData>(ComponentType.Transform);
          if (!t) continue;
          
          const dx = t.x - x;
          const dy = t.y - y;
          const distSq = dx*dx + dy*dy;
          
          if (distSq < minDist && distSq < MAX_RANGE_SQ) {
              minDist = distSq;
              nearest = { x: t.x, y: t.y };
          }
      }
      return nearest;
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/BehaviorSystem.ts
=====================================
import { IGameSystem, IEntitySpawner, IPanelSystem, IParticleSystem, IEntityRegistry, IAudioService, IGameEventService, IFastEventService } from '@/engine/interfaces';
import { IdentityData } from '@/engine/ecs/components/IdentityData';
import { ProjectileData } from '@/engine/ecs/components/ProjectileData';
import { OrbitalData } from '@/engine/ecs/components/OrbitalData';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { GameEvents } from '@/engine/signals/GameEvents'; 
import { FastEventType, getFXCode, getSoundCode } from '@/engine/signals/FastEventBus';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { ConfigService } from '@/engine/services/ConfigService';
import { ViewportHelper } from '@/engine/math/ViewportHelper';
import { AIRegistry } from '@/engine/handlers/ai/AIRegistry';
import { AIContext } from '@/engine/handlers/ai/types';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { Faction } from '@/engine/ecs/types';

export class BehaviorSystem implements IGameSystem {
  constructor(
    private registry: IEntityRegistry,
    private spawner: IEntitySpawner,
    private config: typeof ConfigService,
    private panelSystem: IPanelSystem,
    private particleSystem: IParticleSystem,
    private audio: IAudioService,
    private events: IGameEventService,
    private fastEvents: IFastEventService
  ) {
    events.subscribe(GameEvents.SPAWN_DAEMON, () => {
        const e = this.spawner.spawnEnemy(EnemyTypes.DAEMON, 0, 0);
        const orbital = e.getComponent<OrbitalData>(ComponentType.Orbital);
        if (orbital) {
            orbital.radius = 4.0;
            orbital.speed = 1.5 + Math.random() * 1.0; 
            orbital.angle = Math.random() * Math.PI * 2;
        }
    });
  }

  update(delta: number, time: number): void {
    const upgrades = useGameStore.getState().activeUpgrades;
    const halfWidth = ViewportHelper.viewport.width / 2;

    const aiContext: AIContext = {
      delta,
      time,
      spawnProjectile: (x, y, vx, vy, damage, configId, ownerId) => {
          let bullet;
          if (damage) {
              const finalConfig = configId || 'DAEMON_ORB';
              bullet = this.spawner.spawnBullet(x, y, vx, vy, Faction.FRIENDLY, 2.0, damage, finalConfig);
              bullet.addComponent(new IdentityData('DAEMON_SHOT'));
          } else {
              const finalConfig = configId || 'ENEMY_HUNTER';
              bullet = this.spawner.spawnBullet(x, y, vx, vy, Faction.HOSTILE, 3.0, 4, finalConfig);
          }
          if (ownerId !== undefined) {
              const proj = bullet.getComponent<ProjectileData>(ComponentType.Projectile);
              if (proj) proj.ownerId = ownerId;
          }
          return bullet;
      },
      spawnFX: (type, x, y, angle) => {
          const id = getFXCode(type);
          if (id) this.fastEvents.emit(FastEventType.SPAWN_FX, id, x * 100, y * 100, (angle || 0) * 100);
      },
      spawnParticle: (x, y, color, vx, vy, life, size) => {
          this.particleSystem.spawn(x, y, color, vx, vy, life, size, 1);
      },
      damagePanel: (id, amount, options) => this.panelSystem.damagePanel(id, amount, options),
      getPanelRect: (id) => this.panelSystem.getPanelRect(id),
      playSound: (key, x) => {
          const pan = x !== undefined && halfWidth > 0 
            ? Math.max(-1, Math.min(1, x / halfWidth)) 
            : 0;
          const id = getSoundCode(key.toLowerCase());
          if (id) {
              this.fastEvents.emit(FastEventType.PLAY_SOUND, id, pan * 100);
          } else {
              this.audio.playSound(key as any, pan);
          }
      },
      getUpgradeLevel: (key) => upgrades[key] || 0,
      config: this.config
    };

    const entities = this.registry.getAll();
    for (const entity of entities) {
        if (!entity.active) continue;
        const identity = entity.getComponent<IdentityData>(ComponentType.Identity);
        if (!identity) continue;
        const behavior = AIRegistry.get(identity.variant);
        if (behavior) {
            behavior.update(entity, aiContext);
        }
    }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/WaveSystem.ts
=====================================
import { IGameSystem, IEntitySpawner, IPanelSystem, IGameEventService } from '@/engine/interfaces';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { useStore } from '@/engine/state/global/useStore';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { MODEL_CONFIG } from '@/engine/config/ModelConfig';
import { GameEvents } from '@/engine/signals/GameEvents';
import { ViewportHelper } from '@/engine/math/ViewportHelper';
import { PanelId } from '@/engine/config/PanelConfig';
import waves from '@/engine/config/static/waves.json';

interface WaveDef {
    at: number;
    type: string;
    count: number;
    interval: number;
}

export class WaveSystem implements IGameSystem {
  private waveTime = 0;
  private currentWaveIndex = 0;
  private spawnQueue: { type: string, time: number }[] = [];
  private loopCount = 0;
  private timeline: WaveDef[] = waves as WaveDef[];
  private scenarioInit = false;
  private hasStressTested = false;

  constructor(
    private spawner: IEntitySpawner,
    private panelSystem: IPanelSystem,
    private events: IGameEventService
  ) {
    this.reset();
    this.events.subscribe(GameEvents.GAME_OVER, () => this.triggerStressTest());
  }

  private reset() {
    this.waveTime = 0;
    this.currentWaveIndex = 0;
    this.spawnQueue = [];
    this.loopCount = 0;
    this.scenarioInit = false;
    this.hasStressTested = false;
  }

  update(delta: number, time: number): void {
    if (useGameStore.getState().isZenMode) return;
    if (useStore.getState().bootState === 'sandbox') return;
    
    if (this.panelSystem.systemIntegrity <= 0) return;

    if (!this.scenarioInit) {
        const panels = this.panelSystem.getAllPanels();
        const ready = panels.some(p => p.width > 0);
        
        if (ready) {
            this.runScenario(panels);
            this.scenarioInit = true;
        }
    }

    this.waveTime += delta;
    
    if (!useStore.getState().debugFlags.peaceMode) {
        this.checkTimeline();
        this.processQueue(time);
    }

    this.handleBreaches(delta);
  }

  private triggerStressTest() {
      if (this.hasStressTested) return;
      this.hasStressTested = true;

      const { width, height } = ViewportHelper.viewport;
      
      const types = [EnemyTypes.DRILLER, EnemyTypes.HUNTER, EnemyTypes.KAMIKAZE];
      const countPerType = 100;

      types.forEach(type => {
          for(let i = 0; i < countPerType; i++) {
              const x = (Math.random() - 0.5) * width * 1.5;
              const y = (Math.random() - 0.5) * height * 1.5;
              this.spawner.spawnEnemy(type, x, y);
          }
      });
  }

  private runScenario(panels: any[]) {
      this.panelSystem.damagePanel(PanelId.ART, 9999, { silent: true }); 
      this.panelSystem.damagePanel(PanelId.VIDEO, 85, { silent: true }); 
      
      const videoPanel = panels.find(p => p.id === PanelId.VIDEO);
      if (videoPanel) {
          this.spawnDrillerOn(videoPanel, 3);
      }

      const targets = panels.filter(p => p.id !== PanelId.ART && p.id !== PanelId.VIDEO);
      
      targets.forEach(p => {
          const dmg = 20 + Math.floor(Math.random() * 30);
          this.panelSystem.damagePanel(p.id, dmg, { silent: true }); 
          const count = 1 + Math.floor(Math.random() * 3);
          this.spawnDrillerOn(p, count);
      });
  }

  private spawnDrillerOn(panel: any, count: number) {
      const offset = MODEL_CONFIG.DRILLER.spawnOffset;

      for(let i=0; i<count; i++) {
          const side = Math.floor(Math.random() * 4);
          let edgeX = 0, edgeY = 0; 
          let normalX = 0, normalY = 0; 
          
          const halfW = panel.width / 2;
          const halfH = panel.height / 2;
          
          switch(side) {
              case 0:
                  edgeX = (Math.random() - 0.5) * panel.width;
                  edgeY = halfH;
                  normalX = 0; normalY = 1;
                  break;
              case 1:
                  edgeX = (Math.random() - 0.5) * panel.width;
                  edgeY = -halfH;
                  normalX = 0; normalY = -1;
                  break;
              case 2:
                  edgeX = -halfW;
                  edgeY = (Math.random() - 0.5) * panel.height;
                  normalX = -1; normalY = 0;
                  break;
              case 3:
                  edgeX = halfW;
                  edgeY = (Math.random() - 0.5) * panel.height;
                  normalX = 1; normalY = 0;
                  break;
          }

          const spawnX = panel.x + edgeX + (normalX * offset);
          const spawnY = panel.y + edgeY + (normalY * offset);
          const angle = Math.atan2(-normalY, -normalX);

          this.spawner.spawn(EnemyTypes.DRILLER, {
              [ComponentType.Transform]: { 
                  x: spawnX, 
                  y: spawnY, 
                  scale: 1.0, 
                  rotation: angle 
              },
              [ComponentType.State]: { 
                  current: 'ACTIVE',
                  timers: { 
                      spawn: 0,
                      drillAudio: Math.random() * 0.2 
                  } 
              },
              [ComponentType.RenderTransform]: { 
                  scale: 1.0 
              }
          });
      }
  }

  private handleBreaches(delta: number) {
      const flags = useStore.getState().debugFlags;
      if (flags.panelGodMode || flags.peaceMode) return;

      const allPanels = this.panelSystem.getAllPanels();
      const deadPanels = allPanels.filter(p => p.isDestroyed && p.width > 0);
      
      if (deadPanels.length === 0) return;

      const enemiesPerSecondPerPanel = 0.2 + (this.waveTime * 0.005);
      const spawnChance = enemiesPerSecondPerPanel * delta;

      for (const p of deadPanels) {
          if (Math.random() < spawnChance) {
              this.spawnBreachEnemy(p);
          }
      }
  }

  private spawnBreachEnemy(p: any) {
      const rand = Math.random();
      let type = EnemyTypes.DRILLER;
      if (rand > 0.85) type = EnemyTypes.HUNTER;
      else if (rand > 0.60) type = EnemyTypes.KAMIKAZE;

      const safeW = p.width * 0.7; 
      const safeH = p.height * 0.7;
      
      const offsetX = (Math.random() - 0.5) * safeW;
      const offsetY = (Math.random() - 0.5) * safeH;
      
      this.spawner.spawnEnemy(type, p.x + offsetX, p.y + offsetY);
  }

  private checkTimeline() {
    if (this.currentWaveIndex >= this.timeline.length) {
        this.waveTime = 0;
        this.currentWaveIndex = 0;
        this.loopCount++;
    }

    const nextWave = this.timeline[this.currentWaveIndex];
    if (nextWave && this.waveTime >= nextWave.at) {
        this.queueSpawns(nextWave);
        this.currentWaveIndex++;
    }
  }

  private queueSpawns(wave: WaveDef) {
    const count = wave.count + (this.loopCount * 2);
    for (let i = 0; i < count; i++) {
        this.spawnQueue.push({
            type: wave.type,
            time: this.waveTime + (i * wave.interval)
        });
    }
  }

  private processQueue(currentTime: number) {
    for (let i = this.spawnQueue.length - 1; i >= 0; i--) {
        const spawn = this.spawnQueue[i];
        if (this.waveTime >= spawn.time) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 25; 
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            this.spawner.spawnEnemy(spawn.type, x, y);
            this.spawnQueue.splice(i, 1);
        }
    }
  }

  teardown(): void {
    this.reset();
  }
}


=====================================
FILE: ./src/engine/systems/LifeCycleSystem.ts
=====================================
import { IGameSystem, IEntityRegistry, IGameEventService } from '@/engine/interfaces';
import { LifetimeData } from '@/engine/ecs/components/LifetimeData';
import { HealthData } from '@/engine/ecs/components/HealthData';
import { IdentityData } from '@/engine/ecs/components/IdentityData';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { GameEvents, FXVariant } from '@/engine/signals/GameEvents';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { Tag } from '@/engine/ecs/types';

export class LifeCycleSystem implements IGameSystem {
  constructor(
    private registry: IEntityRegistry,
    private events: IGameEventService
  ) {
    this.events.subscribe(GameEvents.ZEN_MODE_ENABLED, () => {
        this.purgeHostiles();
    });
  }

  update(delta: number, time: number): void {
    const mortals = this.registry.query({ any: [ComponentType.Lifetime, ComponentType.Health] });

    for (const entity of mortals) {
      if (!entity.active) continue;

      const lifetime = entity.getComponent<LifetimeData>(ComponentType.Lifetime);
      if (lifetime) {
        lifetime.remaining -= delta;
        if (lifetime.remaining <= 0) {
          this.registry.destroyEntity(entity.id);
          continue;
        }
      }

      const health = entity.getComponent<HealthData>(ComponentType.Health);
      if (health && health.current <= 0) {
          const identity = entity.getComponent<IdentityData>(ComponentType.Identity);
          const transform = entity.getComponent<TransformData>(ComponentType.Transform);
          
          if (identity && transform) {
             this.events.emit(GameEvents.ENEMY_DESTROYED, { 
                id: entity.id as number, 
                type: identity.variant, 
                x: transform.x, 
                y: transform.y 
             });
             
             let fx: FXVariant = 'EXPLOSION_PURPLE';
             if (identity.variant === EnemyTypes.HUNTER) fx = 'EXPLOSION_YELLOW';
             else if (identity.variant === EnemyTypes.KAMIKAZE) fx = 'EXPLOSION_RED';
             
             this.events.emit(GameEvents.SPAWN_FX, { type: fx, x: transform.x, y: transform.y });
          }
          
          this.registry.destroyEntity(entity.id);
      }
    }
  }

  private purgeHostiles() {
      // Destroy everything EXCEPT the player
      // This keeps the reticle moving and the camera logic working
      const allEntities = this.registry.getAll();
      for (const entity of allEntities) {
          if (!entity.hasTag(Tag.PLAYER)) {
              // Optional: Spawn disappearing FX for enemies?
              // For now, just silent wipe to be instant
              this.registry.destroyEntity(entity.id);
          }
      }
  }

  teardown(): void {}
}


=====================================
FILE: ./src/engine/systems/VisualSystem.ts
=====================================
import { IGameSystem, IEntityRegistry } from '@/engine/interfaces';
import { RenderBuffer } from '@/engine/graphics/RenderBuffer';
import { RenderOffset, RENDER_STRIDE } from '@/engine/graphics/RenderSchema';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { RenderModel } from '@/engine/ecs/components/RenderModel';
import { RenderTransform } from '@/engine/ecs/components/RenderTransform';
import { RenderEffect } from '@/engine/ecs/components/RenderEffect';
import { MotionData } from '@/engine/ecs/components/MotionData';
import { VISUAL_CONFIG } from '@/engine/config/VisualConfig';
import * as THREE from 'three';

const axisY = new THREE.Vector3(0, 1, 0); 
const axisZ = new THREE.Vector3(0, 0, 1); 
const qSpin = new THREE.Quaternion();
const qAim = new THREE.Quaternion();
const qFinal = new THREE.Quaternion();

export class VisualSystem implements IGameSystem {
  constructor(private registry: IEntityRegistry) {}

  update(delta: number, time: number): void {
    RenderBuffer.reset();
    const CFG = VISUAL_CONFIG.DEFORMATION;

    // Query: Must have Position + Visual Model
    const entities = this.registry.query({ all: [ComponentType.Transform, ComponentType.RenderModel] });

    for (const entity of entities) {
      if (!entity.active) continue;

      const transform = entity.getComponent<TransformData>(ComponentType.Transform);
      const model = entity.getComponent<RenderModel>(ComponentType.RenderModel);
      
      const visual = entity.getComponent<RenderTransform>(ComponentType.RenderTransform);
      const effect = entity.getComponent<RenderEffect>(ComponentType.RenderEffect);
      const motion = entity.getComponent<MotionData>(ComponentType.Motion);

      if (!transform || !model) continue;

      const key = `${model.geometryId}|${model.materialId}`;
      const group = RenderBuffer.getGroup(key);
      const idx = group.count * RENDER_STRIDE;
      
      RenderBuffer.ensureCapacity(group, idx + RENDER_STRIDE);

      // --- 1. Position ---
      let vx = transform.x;
      let vy = transform.y;
      const vz = visual ? visual.offsetZ : 0;
      
      let spawnP = 1.0;
      if (effect) {
          spawnP = effect.spawnProgress;
          if (spawnP < 1.0) {
              const t = spawnP;
              const ease = 1 - Math.pow(1 - t, 3); 
              const yOffset = -CFG.SPAWN_Y_OFFSET * (1.0 - ease);
              vy += yOffset;
          }
          if (effect.shudder > 0) {
              const shake = effect.shudder * 0.2; 
              vx += (Math.random() - 0.5) * shake;
              vy += (Math.random() - 0.5) * shake;
          }
      }

      if (visual) {
          vx += visual.offsetX;
          vy += visual.offsetY;
      }

      // --- 2. Scale ---
      let sX = transform.scale;
      let sY = transform.scale;
      let sZ = transform.scale;

      if (visual) {
          sX *= visual.scale * visual.baseScaleX;
          sY *= visual.scale * visual.baseScaleY;
          sZ *= visual.scale * visual.baseScaleZ;
      }
      
      // Velocity Deformation
      if (effect && motion && effect.elasticity > 0.01) {
          const speedSq = motion.vx * motion.vx + motion.vy * motion.vy;
          const threshold = effect.elasticity > 1.0 ? 1.0 : 4.0;

          if (speedSq > threshold) {
              const speed = Math.sqrt(speedSq);
              let stretchY, squashXZ;
              
              if (effect.elasticity > 1.0) {
                  // High Elasticity (Bullets)
                  stretchY = Math.min(CFG.MAX_STRETCH_CAP, 1.0 + (speed * CFG.BASE_STRETCH * effect.elasticity));
                  squashXZ = Math.max(CFG.MIN_SQUASH_CAP, 1.0 - (speed * CFG.BASE_SQUASH * effect.elasticity));
              } else {
                  // Rigid (Entities)
                  stretchY = Math.min(CFG.MAX_STRETCH, 1.0 + (speed * CFG.STRETCH_FACTOR));
                  squashXZ = Math.max(CFG.MIN_SQUASH, 1.0 - (speed * CFG.SQUASH_FACTOR));
              }
              
              sY *= stretchY;
              sX *= squashXZ;
              sZ *= squashXZ;
          }
      }

      // --- 3. Rotation ---
      const visRot = visual ? visual.rotation : 0;
      qSpin.setFromAxisAngle(axisY, visRot);
      qAim.setFromAxisAngle(axisZ, transform.rotation - Math.PI/2);
      qFinal.copy(qAim).multiply(qSpin);

      // --- 4. Color ---
      let r = model.r;
      let g = model.g;
      let b = model.b;

      if (effect && effect.flash > 0) {
          const t = effect.flash; 
          r = r + (effect.flashR - r) * t;
          g = g + (effect.flashG - g) * t;
          b = b + (effect.flashB - b) * t;
      }

      // --- 5. Pack ---
      group.buffer[idx + RenderOffset.POSITION_X] = vx;
      group.buffer[idx + RenderOffset.POSITION_Y] = vy;
      group.buffer[idx + RenderOffset.POSITION_Z] = vz;
      
      group.buffer[idx + RenderOffset.ROTATION_X] = qFinal.x;
      group.buffer[idx + RenderOffset.ROTATION_Y] = qFinal.y;
      group.buffer[idx + RenderOffset.ROTATION_Z] = qFinal.z;
      group.buffer[idx + RenderOffset.ROTATION_W] = qFinal.w;
      
      group.buffer[idx + RenderOffset.SCALE_X] = sX;
      group.buffer[idx + RenderOffset.SCALE_Y] = sY;
      group.buffer[idx + RenderOffset.SCALE_Z] = sZ;
      
      group.buffer[idx + RenderOffset.COLOR_R] = r;
      group.buffer[idx + RenderOffset.COLOR_G] = g;
      group.buffer[idx + RenderOffset.COLOR_B] = b;
      
      group.buffer[idx + RenderOffset.SPAWN_PROGRESS] = spawnP;

      group.count++;
    }
  }

  teardown(): void {
    RenderBuffer.reset();
  }
}


=====================================
FILE: ./src/engine/systems/PhysicsSystem.ts
=====================================
import { IPhysicsSystem, IEntityRegistry } from '@/engine/interfaces';
import { SpatialGrid } from '@/engine/ecs/SpatialGrid';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { MotionData } from '@/engine/ecs/components/MotionData';
import { ColliderData } from '@/engine/ecs/components/ColliderData';
import { EntityRegistry } from '@/engine/ecs/EntityRegistry';
import { ComponentType } from '@/engine/ecs/ComponentType';

export class PhysicsSystem implements IPhysicsSystem {
  public spatialGrid: SpatialGrid;
  private registry: EntityRegistry;

  constructor(registry: IEntityRegistry) {
    this.spatialGrid = new SpatialGrid();
    this.registry = registry as EntityRegistry;
    this.spatialGrid.clear();
  }

  update(delta: number, time: number): void {
    this.spatialGrid.clear();
    
    // 1. INTEGRATION STEP (Movement)
    // Only entities with Motion need position updates
    const movables = this.registry.query({ all: [ComponentType.Transform, ComponentType.Motion] });
    
    for (const entity of movables) {
      if (!entity.active) continue;

      const transform = entity.getComponent<TransformData>(ComponentType.Transform);
      const motion = entity.getComponent<MotionData>(ComponentType.Motion);
      
      if (transform && motion) {
        transform.x += motion.vx * delta;
        transform.y += motion.vy * delta;
        
        if (motion.friction > 0) {
            motion.vx *= (1 - motion.friction);
            motion.vy *= (1 - motion.friction);
        }
      }
    }

    // 2. BROADPHASE STEP (Spatial Hashing)
    // Insert ALL colliders (Static + Dynamic) into the grid
    const collidables = this.registry.query({ all: [ComponentType.Transform, ComponentType.Collider] });

    for (const entity of collidables) {
        if (!entity.active) continue;
        const transform = entity.getComponent<TransformData>(ComponentType.Transform);
        // We don't need the Collider component to insert, just the position, 
        // but we filter by Collider existence to avoid inserting pure visual effects.
        if (transform) {
            this.spatialGrid.insert(entity.id, transform.x, transform.y);
        }
    }
  }

  teardown(): void {
    this.spatialGrid.clear();
  }
}


=====================================
FILE: ./src/engine/handlers/combat/CombatHandlers.ts
=====================================
import { Entity } from '@/engine/ecs/Entity';
import { CombatContext } from './types';
import { HealthData } from '@/engine/ecs/components/HealthData';
import { IdentityData } from '@/engine/ecs/components/IdentityData';
import { AIStateData } from '@/engine/ecs/components/AIStateData';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { CombatData } from '@/engine/ecs/components/CombatData';
import { RenderModel } from '@/engine/ecs/components/RenderModel';
import { RenderEffect } from '@/engine/ecs/components/RenderEffect';
import { MotionData } from '@/engine/ecs/components/MotionData';
import { EnemyTypes } from '@/engine/config/Identifiers';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { VFXKey } from '@/engine/config/AssetKeys';
import { PanelId } from '@/engine/config/PanelConfig';

const getHp = (e: Entity) => e.getComponent<HealthData>(ComponentType.Health);
const getId = (e: Entity) => e.getComponent<IdentityData>(ComponentType.Identity);
const getPos = (e: Entity) => e.getComponent<TransformData>(ComponentType.Transform);
const getCombat = (e: Entity) => e.getComponent<CombatData>(ComponentType.Combat);
const getModel = (e: Entity) => e.getComponent<RenderModel>(ComponentType.RenderModel);
const getEffect = (e: Entity) => e.getComponent<RenderEffect>(ComponentType.RenderEffect);
const getMotion = (e: Entity) => e.getComponent<MotionData>(ComponentType.Motion);
const getAI = (e: Entity) => e.getComponent<AIStateData>(ComponentType.State);

const THEME_MAP: Record<string, string> = {
    [EnemyTypes.KAMIKAZE]: 'RED',
    [EnemyTypes.HUNTER]: 'YELLOW',
    [EnemyTypes.DRILLER]: 'PURPLE',
    [EnemyTypes.DAEMON]: 'PURPLE',
};

const getExplosionKey = (variant: string, directional: boolean): VFXKey => {
    const theme = THEME_MAP[variant] || 'PURPLE';
    return (directional ? `EXPLOSION_${theme}_DIR` : `EXPLOSION_${theme}`) as VFXKey;
};

const resolveImpactVisuals = (source: Entity, x: number, y: number, angle: number, ctx: CombatContext, overrideFX?: string) => {
    if (overrideFX) { ctx.spawnFX(overrideFX as VFXKey, x, y); return; }
    const model = getModel(source);
    if (model) {
        const maxC = Math.max(model.r, model.g, model.b, 1.0); 
        ctx.spawnImpact(x, y, model.r / maxC, model.g / maxC, model.b / maxC, angle);
    } else { ctx.spawnFX('IMPACT_WHITE', x, y); }
};

const applyKnockback = (entity: Entity, sourcePos: TransformData | undefined, force: number) => {
    const motion = getMotion(entity); const pos = getPos(entity);
    const ai = getAI(entity); const effect = getEffect(entity);
    if (motion && pos && sourcePos) {
        const dx = pos.x - sourcePos.x; const dy = pos.y - sourcePos.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist > 0.001) {
            motion.vx += (dx / dist) * force; motion.vy += (dy / dist) * force;
            if (ai) ai.stunTimer = 0.15; if (effect) effect.shudder = 1.0;
        }
    }
};

export const handlePlayerCrash = (player: Entity, enemy: Entity, ctx: CombatContext) => {
  const pId = getId(player);
  if (pId?.variant === EnemyTypes.DAEMON) { resolveDaemonCollision(player, enemy, ctx); return; }
  const combat = getCombat(enemy); const pos = getPos(enemy); const pPos = getPos(player);
  const damage = combat ? combat.damage : 1;
  let sprayAngle = 0;
  if (pos && pPos) sprayAngle = Math.atan2(pos.y - pPos.y, pos.x - pPos.x) + Math.PI;
  ctx.damagePlayer(damage); ctx.addTrauma(damage >= 3 ? 0.5 : 0.3);
  const variant = getId(enemy)?.variant || 'UNKNOWN';
  ctx.destroyEntity(enemy, getExplosionKey(variant, true), sprayAngle);
  ctx.playSpatialAudio(damage >= 3 ? 'fx_impact_heavy' : 'fx_impact_light', pos ? pos.x : 0);
};

export const handlePlayerHit = (player: Entity, bullet: Entity, ctx: CombatContext) => {
  const pId = getId(player);
  if (pId?.variant === EnemyTypes.DAEMON) { resolveDaemonCollision(player, bullet, ctx, 1); return; }
  const combat = getCombat(bullet); const pos = getPos(bullet);
  const damage = combat ? combat.damage : 1;
  ctx.damagePlayer(damage); ctx.addTrauma(0.1);
  ctx.destroyEntity(bullet, 'IMPACT_RED'); 
  ctx.playSpatialAudio('fx_impact_heavy', pos ? pos.x : 0);
};

export const handleEnemyHit = (enemy: Entity, bullet: Entity, ctx: CombatContext) => {
  const bPos = getPos(bullet); applyKnockback(enemy, bPos, 3.0);
  handleMassExchange(enemy, bullet, ctx, undefined, bPos ? bPos.rotation + Math.PI : 0);
};

export const handleBulletClash = (bulletA: Entity, bulletB: Entity, ctx: CombatContext) => {
  handleMassExchange(bulletA, bulletB, ctx, 'CLASH_YELLOW');
};

export const handleEnemyPanelHit = (enemy: Entity, panel: Entity, ctx: CombatContext) => {
    const id = getId(enemy); const pId = getId(panel); 
    if (id?.variant === EnemyTypes.KAMIKAZE && pId) {
        const combat = getCombat(enemy); const dmg = combat ? combat.damage : 1;
        const pos = getPos(enemy);
        ctx.damagePanel(pId.variant as PanelId, dmg * 5, { source: pos ? { x: pos.x, y: pos.y } : undefined }); 
        ctx.destroyEntity(enemy, 'EXPLOSION_RED');
        ctx.playSpatialAudio('fx_impact_heavy', pos ? pos.x : 0);
        ctx.addTrauma(0.3);
    }
};

function resolveDaemonCollision(daemon: Entity, attacker: Entity, ctx: CombatContext, fixedDamage?: number) {
  const state = daemon.getComponent<AIStateData>(ComponentType.State);
  if (!state) return;
  const pos = getPos(attacker);
  const incomingDamage = fixedDamage || (getCombat(attacker)?.damage || 1);
  const shield = state.data.shieldHP || 0;
  if (state.current === 'CHARGING' || state.current === 'READY') {
      if (shield > 0) {
          state.data.shieldHP = Math.max(0, shield - incomingDamage);
          state.data.wasHit = true; 
          const isEnemy = attacker.hasTag('ENEMY');
          ctx.destroyEntity(attacker, isEnemy ? 'CLASH_YELLOW' : 'IMPACT_WHITE');
          ctx.playSpatialAudio('fx_impact_light', pos ? pos.x : 0);
          return;
      }
  }
  const isEnemy = attacker.hasTag('ENEMY');
  ctx.destroyEntity(attacker, isEnemy ? 'EXPLOSION_RED' : 'IMPACT_RED');
  ctx.playSpatialAudio('fx_impact_light', pos ? pos.x : 0);
}

function handleMassExchange(a: Entity, b: Entity, ctx: CombatContext, forceFX?: string, sprayAngle?: number) {
  const hpA = getHp(a); const hpB = getHp(b); const cA = getCombat(a); const cB = getCombat(b);
  const dmgA = cA ? cA.damage : 1; const dmgB = cB ? cB.damage : 1;
  if (hpA) { hpA.current = Math.max(0, hpA.current - dmgB); if (hpA.current > 0) ctx.flashEntity(a.id as number); }
  if (hpB) { hpB.current = Math.max(0, hpB.current - dmgA); if (hpB.current > 0) ctx.flashEntity(b.id as number); }
  const posA = getPos(a); const posB = getPos(b);
  if (posA) { const angle = posB ? Math.atan2(posB.y - posA.y, posB.x - posA.x) : 0; resolveImpactVisuals(b, posA.x, posA.y, angle, ctx, forceFX); }
  let soundKey = '';
  if (hpA && hpA.current <= 0) { ctx.destroyEntity(a, 'IMPACT_WHITE', sprayAngle); soundKey = 'fx_impact_light'; }
  if (hpB && hpB.current <= 0) { ctx.destroyEntity(b, 'IMPACT_WHITE', sprayAngle); soundKey = 'fx_impact_light'; }
  if (soundKey) ctx.playSpatialAudio(soundKey, posA ? posA.x : 0);
}


=====================================
FILE: ./src/engine/handlers/combat/CollisionMatrix.ts
=====================================
import { CollisionLayers } from '@/engine/config/PhysicsConfig';
import { CollisionHandler } from './types';
import * as Handlers from './CombatHandlers';

class CollisionMatrixController {
  private matrix = new Map<string, CollisionHandler>();

  constructor() {
    this.register(CollisionLayers.PLAYER, CollisionLayers.ENEMY, Handlers.handlePlayerCrash);
    this.register(CollisionLayers.PLAYER, CollisionLayers.ENEMY_PROJECTILE, Handlers.handlePlayerHit);
    this.register(CollisionLayers.ENEMY, CollisionLayers.PLAYER_PROJECTILE, Handlers.handleEnemyHit);
    this.register(CollisionLayers.PLAYER_PROJECTILE, CollisionLayers.ENEMY_PROJECTILE, Handlers.handleBulletClash);
    
    // NEW: Panel Collisions
    this.register(CollisionLayers.ENEMY, CollisionLayers.PANEL, Handlers.handleEnemyPanelHit);
    // Player vs Panel? Usually player flies over panels. 
    // If we wanted player to bounce off panels, we'd add it here.
  }

  private getKey(layerA: number, layerB: number): string {
    return layerA < layerB ? `${layerA}:${layerB}` : `${layerB}:${layerA}`;
  }

  private register(layerA: number, layerB: number, handler: CollisionHandler) {
    this.matrix.set(this.getKey(layerA, layerB), handler);
  }

  public getHandler(layerA: number, layerB: number): CollisionHandler | undefined {
    return this.matrix.get(this.getKey(layerA, layerB));
  }
}

export const CollisionMatrix = new CollisionMatrixController();


=====================================
FILE: ./src/engine/handlers/combat/types.ts
=====================================
import { Entity } from '@/engine/ecs/Entity';

export interface CombatContext {
  damagePlayer: (amount: number) => void;
  destroyEntity: (entity: Entity, fx?: string, impactAngle?: number) => void;
  spawnFX: (type: string, x: number, y: number) => void;
  spawnImpact: (x: number, y: number, r: number, g: number, b: number, angle: number) => void;
  playAudio: (key: string) => void;
  playSpatialAudio: (key: string, x: number) => void;
  addTrauma: (amount: number) => void;
  // NEW: Flash visual support
  flashEntity: (id: number) => void;
}

export type CollisionHandler = (entityA: Entity, entityB: Entity, ctx: CombatContext) => void;


=====================================
FILE: ./src/engine/handlers/weapons/WeaponLogic.ts
=====================================
import { Entity } from '@/engine/ecs/Entity';
import { ConfigService } from '@/engine/services/ConfigService';
import { TransformData } from '@/engine/ecs/components/TransformData';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { GAMEPLAY_CONFIG } from '@/engine/config/GameplayConfig';
import { GAME_MATH } from '@/engine/config/constants/MathConstants';

export interface ShotDef {
  x: number;
  y: number;
  vx: number;
  vy: number;
  damage: number;
  life: number;
  configId: string;
  isHoming: boolean;
}

const MUZZLE_OFFSET = GAMEPLAY_CONFIG.WEAPON.MUZZLE_OFFSET;

export const calculatePlayerShots = (
  origin: { x: number, y: number },
  target: { x: number, y: number },
  upgrades: Record<string, number>
): ShotDef[] => {
  const shots: ShotDef[] = [];
  const config = ConfigService.player;

  const forkLevel = upgrades['FORK'] || 0;
  const dmgLevel = upgrades['EXECUTE'] || 0;
  const snifferLevel = upgrades['SNIFFER'] || 0;
  const backdoorLevel = upgrades['BACKDOOR'] || 0;

  const projectileCount = 1 + (forkLevel * 2);
  const damage = 1 + dmgLevel;
  const speed = config.bulletSpeed;
  const life = config.bulletLife;

  const dx = target.x - origin.x;
  const dy = target.y - origin.y;
  const baseAngle = Math.atan2(dy, dx);

  let configId = 'PLAYER_STANDARD';
  if (forkLevel > 0) configId = 'PLAYER_FORK';
  
  const spreadAngle = GAME_MATH.WEAPON_SPREAD_BASE; 
  const startAngle = baseAngle - ((projectileCount - 1) * spreadAngle) / 2;

  // Standard / Fork Shots
  for (let i = 0; i < projectileCount; i++) {
      const angle = startAngle + (i * spreadAngle);
      
      const spawnX = origin.x + Math.cos(angle) * MUZZLE_OFFSET;
      const spawnY = origin.y + Math.sin(angle) * MUZZLE_OFFSET;

      shots.push({
          x: spawnX,
          y: spawnY,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          damage,
          life,
          configId,
          isHoming: false
      });
  }

  // Backdoor Shots
  if (backdoorLevel > 0) {
      const rearAngle = baseAngle + Math.PI; 
      
      const spawnX = origin.x + Math.cos(rearAngle) * MUZZLE_OFFSET;
      const spawnY = origin.y + Math.sin(rearAngle) * MUZZLE_OFFSET;

      shots.push({
          x: spawnX,
          y: spawnY,
          vx: Math.cos(rearAngle) * speed,
          vy: Math.sin(rearAngle) * speed,
          damage,
          life,
          configId: 'PLAYER_BACKDOOR',
          isHoming: false
      });
  }

  // Sniffer (Homing) Shots
  if (snifferLevel > 0) {
      const angleStep = GAME_MATH.FULL_CIRCLE / snifferLevel;
      for (let i = 0; i < snifferLevel; i++) {
          const angle = i * angleStep;
          
          // FIX: Use MUZZLE_OFFSET instead of hardcoded 10
          const spawnX = origin.x + Math.cos(angle) * MUZZLE_OFFSET;
          const spawnY = origin.y + Math.sin(angle) * MUZZLE_OFFSET;
          
          shots.push({
              x: spawnX,
              y: spawnY,
              vx: Math.cos(angle) * speed * 0.5,
              vy: Math.sin(angle) * speed * 0.5,
              damage: damage * 0.5,
              life: life * 2,
              configId: 'PLAYER_SNIFFER',
              isHoming: true
          });
      }
  }

  return shots;
};


=====================================
FILE: ./src/engine/handlers/ai/KamikazeLogic.ts
=====================================
import { Entity } from '@/engine/ecs/Entity';
import { EnemyLogic, AIContext } from './types';
import { BehaviorTreeBuilder, NodeDef } from '@/engine/ai/BehaviorTreeBuilder';

const KAMIKAZE_DEF: NodeDef = {
  type: 'Sequence',
  children: [
    { type: 'SpawnPhase', args: [1.5] },
    {
      type: 'Parallel',
      children: [
        { 
            type: 'Succeeder', 
            children: [{ type: 'SpinVisual', args: [10.0] }] 
        },
        { type: 'MoveToTarget', args: [12] } // Speed
      ]
    }
  ]
};

let treeRoot: any = null;

export const KamikazeLogic: EnemyLogic = {
  update: (e: Entity, ctx: AIContext) => {
    if (!treeRoot) {
        treeRoot = BehaviorTreeBuilder.build(KAMIKAZE_DEF);
    }
    treeRoot.tick(e, ctx);
  }
};


=====================================
FILE: ./src/engine/handlers/ai/HunterLogic.ts
=====================================
import { Entity } from '@/engine/ecs/Entity';
import { EnemyLogic, AIContext } from './types';
import { BehaviorTreeBuilder, NodeDef } from '@/engine/ai/BehaviorTreeBuilder';

const HUNTER_DEF: NodeDef = {
  type: 'Sequence',
  children: [
    { type: 'SpawnPhase', args: [1.5] },
    {
        type: 'MemSequence',
        id: 'hunter_tactics',
        children: [
            // 1. Approach & Drift
            { type: 'HoverDrift', args: [10.0, 18.0, 0.8, 1.5] },
            
            // 2. Aim & Fire (Atomic Operation)
            // AimDuration, ProjectileSpeed, ConfigID
            { type: 'AimAndFire', args: [0.5, 40.0, 'ENEMY_HUNTER'] },
            
            // 3. Cooldown
            { type: 'Wait', args: [0.3, 0.6] }
        ]
    }
  ]
};

let treeRoot: any = null;

export const HunterLogic: EnemyLogic = {
  update: (e: Entity, ctx: AIContext) => {
    if (!treeRoot) {
        treeRoot = BehaviorTreeBuilder.build(HUNTER_DEF);
    }
    treeRoot.tick(e, ctx);
  }
};


=====================================
FILE: ./src/engine/handlers/ai/types.ts
=====================================
import { Entity } from '@/engine/ecs/Entity';
import { ConfigService } from '@/engine/services/ConfigService';
import { WorldRect } from '@/engine/math/ViewportHelper';
import { AudioKey, VFXKey } from '@/engine/config/AssetKeys';
import { PanelId } from '@/engine/config/PanelConfig';
import { DamageOptions } from '@/engine/interfaces';

export interface AIContext {
  delta: number;
  time: number;
  
  spawnProjectile: (
      x: number, y: number, 
      vx: number, vy: number, 
      damage?: number, 
      configId?: string, 
      ownerId?: number
  ) => Entity;

  spawnFX: (type: VFXKey, x: number, y: number, angle?: number) => void;
  spawnParticle: (x: number, y: number, color: string, vx: number, vy: number, life: number, size?: number) => void;
  
  playSound: (key: AudioKey, x?: number) => void;
  damagePanel: (id: PanelId, amount: number, options?: DamageOptions) => void;
  
  getPanelRect: (id: PanelId) => WorldRect | undefined;
  getUpgradeLevel: (key: string) => number;
  
  config: typeof ConfigService;
}

export interface EnemyLogic {
  update(entity: Entity, ctx: AIContext): void;
}


=====================================
FILE: ./src/engine/handlers/ai/DaemonLogic.ts
=====================================
import { Entity } from '@/engine/ecs/Entity';
import { EnemyLogic, AIContext } from './types';
import { BehaviorTreeBuilder, NodeDef } from '@/engine/ai/BehaviorTreeBuilder';

const DAEMON_DEF: NodeDef = {
  type: 'Sequence',
  children: [
    { type: 'SpawnPhase', args: [1.0] },
    {
        type: 'Parallel',
        children: [
            { type: 'OrbitControl', args: ['ACTIVE'] },
            { type: 'DaemonAim' },
            {
                type: 'MemSequence',
                id: 'daemon_cycle',
                children: [
                    { type: 'ChargeMechanic', args: [2.0] },
                    { type: 'HasTargetLock' },
                    { type: 'FireDaemonShot', args: [35.0, 20] },
                    { type: 'Wait', args: [0.5] }
                ]
            }
        ]
    }
  ]
};

let treeRoot: any = null;

export const DaemonLogic: EnemyLogic = {
  update: (e: Entity, ctx: AIContext) => {
    if (!treeRoot) treeRoot = BehaviorTreeBuilder.build(DAEMON_DEF);
    treeRoot.tick(e, ctx);
  }
};


=====================================
FILE: ./src/engine/handlers/ai/AIRegistry.ts
=====================================
import { EnemyLogic } from './types';

class AIRegistryController {
  private behaviors = new Map<string, EnemyLogic>();

  public register(id: string, logic: EnemyLogic) {
    if (this.behaviors.has(id)) {
        console.warn(`[AIRegistry] Overwriting behavior for ${id}`);
    }
    this.behaviors.set(id, logic);
  }

  public get(id: string): EnemyLogic | undefined {
    return this.behaviors.get(id);
  }
}

export const AIRegistry = new AIRegistryController();


=====================================
FILE: ./src/engine/handlers/ai/DrillerLogic.ts
=====================================
import { Entity } from '@/engine/ecs/Entity';
import { EnemyLogic, AIContext } from './types';
import { BehaviorTreeBuilder, NodeDef } from '@/engine/ai/BehaviorTreeBuilder';

const DRILLER_DEF: NodeDef = {
  type: 'Sequence',
  children: [
    { type: 'SpawnPhase', args: [1.5] },
    {
      type: 'Sequence',
      children: [
        { type: 'Succeeder', children: [{ type: 'SpinVisual', args: [5.0] }] },
        {
          type: 'Selector',
          children: [
            {
              type: 'Sequence',
              children: [
                { type: 'IsTargetInRange', args: [0.5] },
                { type: 'Succeeder', children: [{ type: 'SpinVisual', args: [15.0] }] },
                { type: 'DrillAttack', args: [0.2] }
              ]
            },
            { type: 'MoveToTarget', args: [8] }
          ]
        }
      ]
    }
  ]
};

let treeRoot: any = null;

export const DrillerLogic: EnemyLogic = {
  update: (e: Entity, ctx: AIContext) => {
    if (!treeRoot) treeRoot = BehaviorTreeBuilder.build(DRILLER_DEF);
    treeRoot.tick(e, ctx);
  }
};


=====================================
FILE: ./src/engine/handlers/ai/BehaviorCatalog.ts
=====================================
import { AIRegistry } from './AIRegistry';
import { EnemyTypes } from '@/engine/config/Identifiers';

// Logic Implementations
import { DrillerLogic } from './DrillerLogic';
import { KamikazeLogic } from './KamikazeLogic';
import { HunterLogic } from './HunterLogic';
import { DaemonLogic } from './DaemonLogic';

export const registerAllBehaviors = () => {
  AIRegistry.register(EnemyTypes.DRILLER, DrillerLogic);
  AIRegistry.register(EnemyTypes.KAMIKAZE, KamikazeLogic);
  AIRegistry.register(EnemyTypes.HUNTER, HunterLogic);
  AIRegistry.register(EnemyTypes.DAEMON, DaemonLogic);
  
  console.log('[BehaviorCatalog] AI Behaviors Registered.');
};


=====================================
FILE: ./src/engine/services/MobileBootstrapper.ts
=====================================
import { EngineFactory } from './EngineFactory';

export const MobileBootstrapper = () => {
  return EngineFactory.create('MOBILE');
};


=====================================
FILE: ./src/engine/services/EngineFactory.ts
=====================================
import { ServiceLocator } from './ServiceLocator';
import { GameEngineCore } from './GameEngine';
import { EntityRegistry } from '@/engine/ecs/EntityRegistry';
import { EntitySpawner } from './EntitySpawner';
import { ConfigService } from './ConfigService';
import { AudioServiceImpl } from '@/engine/audio/AudioService';
import { SharedGameEventBus } from '@/engine/signals/GameEventBus'; // IMPORT SHARED
import { FastEventBusImpl } from '@/engine/signals/FastEventBus';
import { HUDService } from '@/engine/services/HUDService'; 
import { registerAllComponents } from '@/engine/ecs/ComponentCatalog';
import { registerAllBehaviors } from '@/engine/handlers/ai/BehaviorCatalog';
import { registerAllAssets } from '@/ui/sim/assets/AssetCatalog';
import { SystemPhase } from '@/engine/interfaces';

// Common Systems
import { TimeSystem } from '@/engine/systems/TimeSystem';
import { InputSystem } from '@/engine/systems/InputSystem';
import { PhysicsSystem } from '@/engine/systems/PhysicsSystem';
import { HealthSystem } from '@/engine/systems/HealthSystem';
import { ProgressionSystem } from '@/engine/systems/ProgressionSystem';
import { GameStateSystem } from '@/engine/systems/GameStateSystem';
import { PanelRegistrySystem } from '@/engine/systems/PanelRegistrySystem';
import { InteractionSystem } from '@/engine/systems/InteractionSystem';
import { ParticleSystem } from '@/engine/systems/ParticleSystem';
import { ShakeSystem } from '@/engine/systems/ShakeSystem';
import { RenderSystem } from '@/engine/systems/RenderSystem';
import { VisualSystem } from '@/engine/systems/VisualSystem';
import { AudioDirector } from '@/engine/audio/AudioDirector';
import { LifeCycleSystem } from '@/engine/systems/LifeCycleSystem';
import { TargetingSystem } from '@/engine/systems/TargetingSystem';
import { OrbitalSystem } from '@/engine/systems/OrbitalSystem';
import { GuidanceSystem } from '@/engine/systems/GuidanceSystem';
import { ProjectileSystem } from '@/engine/systems/ProjectileSystem';
import { WorldSystem } from '@/engine/systems/WorldSystem';
import { BehaviorSystem } from '@/engine/systems/BehaviorSystem';
import { VFXSystem } from '@/engine/systems/VFXSystem';
import { FeedbackBridgeSystem } from '@/engine/systems/FeedbackBridgeSystem';

// Mode Specific Systems
import { PlayerMovementSystem } from '@/engine/systems/PlayerMovementSystem';
import { WeaponSystem } from '@/engine/systems/WeaponSystem';
import { CollisionSystem } from '@/engine/systems/CollisionSystem';
import { CombatSystem } from '@/engine/systems/CombatSystem';
import { StructureSystem } from '@/engine/systems/StructureSystem';
import { WaveSystem } from '@/engine/systems/WaveSystem';
import { MobileWaveSystem } from '@/engine/systems/MobileWaveSystem';
import { MobileCombatSystem } from '@/engine/systems/MobileCombatSystem';

export type EngineMode = 'DESKTOP' | 'MOBILE';

export class EngineFactory {
  public static create(mode: EngineMode): GameEngineCore {
    // 1. Core Services
    const registry = new EntityRegistry();
    
    // USE SHARED BUS (Do not create new)
    const eventBus = SharedGameEventBus; 
    
    const fastEventBus = new FastEventBusImpl();
    const audioService = new AudioServiceImpl();
    const inputSystem = new InputSystem();
    const hudService = new HUDService(); 
    const spawner = new EntitySpawner(registry);
    
    // 2. Global Registration
    ServiceLocator.reset();
    ServiceLocator.register('EntityRegistry', registry);
    ServiceLocator.register('GameEventService', eventBus);
    ServiceLocator.register('FastEventService', fastEventBus);
    ServiceLocator.register('AudioService', audioService);
    ServiceLocator.register('InputSystem', inputSystem);
    ServiceLocator.register('EntitySpawner', spawner);
    ServiceLocator.register('HUDService', hudService);

    // 3. Content Registration
    registerAllComponents();
    registerAllBehaviors();
    registerAllAssets();

    // 4. Common Systems Instantiation
    const timeSystem = new TimeSystem();
    const physicsSystem = new PhysicsSystem(registry);
    const particleSystem = new ParticleSystem();
    const shakeSystem = new ShakeSystem(eventBus, fastEventBus);
    
    const panelSystem = new PanelRegistrySystem(eventBus, audioService);
    const healthSystem = new HealthSystem(eventBus, audioService, panelSystem);
    const progressionSystem = new ProgressionSystem(eventBus);
    const gameStateSystem = new GameStateSystem(healthSystem, progressionSystem, panelSystem, eventBus, audioService);
    
    const interactionSystem = new InteractionSystem(inputSystem, spawner, gameStateSystem, panelSystem, eventBus, physicsSystem, registry);
    
    const lifeCycleSystem = new LifeCycleSystem(registry, eventBus);
    const worldSystem = new WorldSystem(panelSystem, registry);
    
    const projectileSystem = new ProjectileSystem(registry);
    const targetingSystem = new TargetingSystem(registry, panelSystem);
    const orbitalSystem = new OrbitalSystem(registry);
    const guidanceSystem = new GuidanceSystem(registry);
    
    const behaviorSystem = new BehaviorSystem(registry, spawner, ConfigService, panelSystem, particleSystem, audioService, eventBus, fastEventBus);
    const feedbackBridge = new FeedbackBridgeSystem(eventBus, fastEventBus, panelSystem);
    
    // Directors
    const audioDirector = new AudioDirector(panelSystem, eventBus, fastEventBus, audioService);
    const vfxSystem = new VFXSystem(particleSystem, shakeSystem, eventBus, fastEventBus);
    const renderSystem = new RenderSystem(registry, gameStateSystem, interactionSystem, eventBus);
    const visualSystem = new VisualSystem(registry);

    // 5. Engine Injection
    const engine = new GameEngineCore(registry);
    engine.injectCoreSystems(panelSystem, gameStateSystem, timeSystem);
    engine.injectFastEventBus(fastEventBus);

    // 6. System Registration Helpers
    const register = (sys: any, phase: SystemPhase, name?: string) => {
        engine.registerSystem(sys, phase);
        if (name) ServiceLocator.registerSystem(name, sys);
    };

    // --- PIPELINE CONSTRUCTION ---

    // PHASE 0: INPUT
    register(timeSystem, SystemPhase.INPUT, 'TimeSystem');
    register(inputSystem, SystemPhase.INPUT);
    register(interactionSystem, SystemPhase.INPUT, 'InteractionSystem');
    
    if (mode === 'DESKTOP') {
        const movementSystem = new PlayerMovementSystem(inputSystem, registry, interactionSystem, gameStateSystem);
        register(movementSystem, SystemPhase.INPUT);
    }

    // PHASE 1: LOGIC
    register(panelSystem, SystemPhase.LOGIC, 'PanelRegistrySystem');
    register(gameStateSystem, SystemPhase.LOGIC, 'GameStateSystem');
    register(targetingSystem, SystemPhase.LOGIC);
    
    if (mode === 'DESKTOP') {
        const waveSystem = new WaveSystem(spawner, panelSystem, eventBus);
        const structureSystem = new StructureSystem(panelSystem);
        const weaponSystem = new WeaponSystem(spawner, registry, gameStateSystem, eventBus, fastEventBus, ConfigService);
        
        register(waveSystem, SystemPhase.LOGIC, 'WaveSystem');
        register(structureSystem, SystemPhase.LOGIC);
        register(behaviorSystem, SystemPhase.LOGIC); 
        register(weaponSystem, SystemPhase.LOGIC);   
    } else {
        const mobileWaveSystem = new MobileWaveSystem(spawner);
        register(mobileWaveSystem, SystemPhase.LOGIC);
        register(behaviorSystem, SystemPhase.LOGIC); 
    }

    // PHASE 2: PHYSICS
    register(physicsSystem, SystemPhase.PHYSICS, 'PhysicsSystem');
    register(orbitalSystem, SystemPhase.PHYSICS);
    register(guidanceSystem, SystemPhase.PHYSICS);
    register(projectileSystem, SystemPhase.PHYSICS);

    // PHASE 3: COLLISION
    if (mode === 'DESKTOP') {
        const combatSystem = new CombatSystem(registry, eventBus, fastEventBus, audioService);
        const collisionSystem = new CollisionSystem(physicsSystem, combatSystem, registry);
        
        register(collisionSystem, SystemPhase.COLLISION);
        register(combatSystem, SystemPhase.COLLISION, 'CombatSystem');
    } else {
        const mobileCombat = new MobileCombatSystem(registry, eventBus, fastEventBus, audioService);
        register(mobileCombat, SystemPhase.COLLISION);
    }

    // PHASE 4: STATE
    register(healthSystem, SystemPhase.STATE, 'HealthSystem');
    register(progressionSystem, SystemPhase.STATE, 'ProgressionSystem');
    register(lifeCycleSystem, SystemPhase.STATE);
    register(feedbackBridge, SystemPhase.STATE); 
    register(hudService, SystemPhase.STATE);

    // PHASE 5: RENDER
    register(renderSystem, SystemPhase.RENDER, 'RenderSystem');
    register(visualSystem, SystemPhase.RENDER, 'VisualSystem');
    register(particleSystem, SystemPhase.RENDER, 'ParticleSystem');
    register(vfxSystem, SystemPhase.RENDER);
    register(shakeSystem, SystemPhase.RENDER, 'ShakeSystem');
    register(worldSystem, SystemPhase.RENDER, 'WorldSystem');
    register(audioDirector, SystemPhase.RENDER);

    // 7. Final Setup
    engine.setup(ServiceLocator);

    // 8. Player Spawn (Desktop Only)
    if (mode === 'DESKTOP') {
        spawner.spawnPlayer();
    }

    return engine;
  }
}


=====================================
FILE: ./src/engine/services/GameBootstrapper.ts
=====================================
import { EngineFactory } from './EngineFactory';

export const GameBootstrapper = () => {
  return EngineFactory.create('DESKTOP');
};


=====================================
FILE: ./src/engine/services/ConfigService.ts
=====================================
import { PLAYER_CONFIG } from '@/engine/config/PlayerConfig';
import { WAVE_CONFIG } from '@/engine/config/WaveConfig';
import { WorldConfig } from '@/engine/config/WorldConfig';
import { AI_CONFIG } from '@/engine/config/AIConfig';
import { PhysicsConfig } from '@/engine/config/PhysicsConfig';

type PlayerConfigType = typeof PLAYER_CONFIG;
type WorldConfigType = typeof WorldConfig;
type AIConfigType = typeof AI_CONFIG;
type PhysicsConfigType = typeof PhysicsConfig;
type WaveConfigType = typeof WAVE_CONFIG;

class ConfigServiceController {
  public player: PlayerConfigType = { ...PLAYER_CONFIG };
  public world: WorldConfigType = { ...WorldConfig };
  public ai: AIConfigType = JSON.parse(JSON.stringify(AI_CONFIG));
  public physics: PhysicsConfigType = { ...PhysicsConfig };
  public waves: WaveConfigType = { ...WAVE_CONFIG };

  public reset() {
    this.player = { ...PLAYER_CONFIG };
    this.world = { ...WorldConfig };
    this.ai = JSON.parse(JSON.stringify(AI_CONFIG));
    this.physics = { ...PhysicsConfig };
    this.waves = { ...WAVE_CONFIG };
  }
}

export const ConfigService = new ConfigServiceController();


=====================================
FILE: ./src/engine/services/EntitySpawner.ts
=====================================
import { IEntitySpawner, IEntityRegistry } from '@/engine/interfaces';
import { Entity } from '@/engine/ecs/Entity';
import { Tag, Faction, ParticleShape } from '@/engine/ecs/types';
import { EntityRegistry } from '@/engine/ecs/EntityRegistry';
import { ARCHETYPES } from '@/engine/config/Archetypes';
import { ComponentRegistry } from '@/engine/ecs/ComponentRegistry';
import { ArchetypeIDs } from '@/engine/config/Identifiers';
import { ComponentType } from '@/engine/ecs/ComponentType';
import { PROJECTILE_CONFIG } from '@/engine/config/ProjectileConfig';
import { GEOMETRY_IDS, MATERIAL_IDS } from '@/engine/config/AssetKeys';

const GEO_MAP: Record<string, string> = {
    'SPHERE': GEOMETRY_IDS.PRJ_SPHERE,
    'CAPSULE': GEOMETRY_IDS.PRJ_CAPSULE,
    'DIAMOND': GEOMETRY_IDS.PRJ_DIAMOND,
    'PYRAMID': GEOMETRY_IDS.PRJ_PYRAMID,
    'RING': GEOMETRY_IDS.PRJ_RING,
    'ARROW': GEOMETRY_IDS.PRJ_ARROW
};

export class EntitySpawner implements IEntitySpawner {
  private registry: EntityRegistry;

  constructor(registry: IEntityRegistry) {
    this.registry = registry as EntityRegistry;
  }

  public spawn(archetypeId: string, overrides: Record<string, any> = {}, extraTags: Tag[] = []): Entity {
    const blueprint = ARCHETYPES[archetypeId];
    if (!blueprint) return this.registry.createEntity();

    const e = this.registry.createEntity();
    blueprint.tags.forEach(tag => e.addTag(tag));
    extraTags.forEach(tag => e.addTag(tag));

    for (const compDef of blueprint.components) {
        const blueprintData = JSON.parse(JSON.stringify(compDef.data || {}));
        const runtimeData = overrides[compDef.type] || {};
        const mergedData = { ...blueprintData, ...runtimeData };
        e.addComponent(ComponentRegistry.create(compDef.type, mergedData));
    }

    if (blueprint.assets) {
        const render: any = e.getComponent(ComponentType.RenderModel);
        if (render) {
            render.geometryId = blueprint.assets.geometry;
            render.materialId = blueprint.assets.material;
        }
    }

    this.registry.updateCache(e);
    return e;
  }

  public spawnPlayer(): Entity { return this.spawn(ArchetypeIDs.PLAYER); }
  public spawnEnemy(type: string, x: number, y: number): Entity {
    return this.spawn(type, { [ComponentType.Transform]: { x, y } });
  }

  public spawnBullet(
      x: number, y: number, 
      vx: number, vy: number, 
      faction: Faction, 
      life: number, 
      damage: number = 1, 
      projectileId: string = 'PLAYER_STANDARD', 
      ownerId?: number
  ): Entity {
    const isEnemy = faction === Faction.HOSTILE;
    const id = isEnemy ? ArchetypeIDs.BULLET_ENEMY : ArchetypeIDs.BULLET_PLAYER;
    const rotation = Math.atan2(vy, vx);
    const config = PROJECTILE_CONFIG[projectileId];
    
    const color = config ? config.color : [1, 1, 1];
    const shape = config ? config.geometry : 'CAPSULE';
    const geoId = GEO_MAP[shape] || GEOMETRY_IDS.PRJ_CAPSULE;
    const s = config ? config.scale : [1,1,1]; 

    const overrides: Record<string, any> = {
        [ComponentType.Transform]: { x, y, rotation, scale: 1.0 }, 
        [ComponentType.Motion]: { vx, vy },
        [ComponentType.Lifetime]: { remaining: life, total: life },
        [ComponentType.Combat]: { damage },
        [ComponentType.Health]: { max: damage },
        [ComponentType.RenderModel]: {
            geometryId: geoId,
            materialId: MATERIAL_IDS.PROJECTILE,
            r: color[0], g: color[1], b: color[2],
        },
        [ComponentType.RenderTransform]: {
            scale: 1.0,
            baseScaleX: s[0], baseScaleY: s[1], baseScaleZ: s[2]
        },
        [ComponentType.RenderEffect]: { elasticity: 2.0 },
        [ComponentType.Projectile]: { configId: projectileId, state: 'FLIGHT', ownerId: ownerId ?? -1 }
    };
    
    return this.spawn(id, overrides);
  }

  public spawnParticle(
      x: number, y: number, 
      color: string, 
      vx: number, vy: number, 
      life: number, 
      size: number = 1.0, 
      shape: ParticleShape = ParticleShape.CIRCLE
  ): void {
    const e = this.registry.createEntity();
    e.addTag(Tag.PARTICLE);
    e.addComponent(ComponentRegistry.create(ComponentType.Transform, { x, y, scale: size }));
    e.addComponent(ComponentRegistry.create(ComponentType.Motion, { vx, vy, friction: 0.05 }));
    e.addComponent(ComponentRegistry.create(ComponentType.Lifetime, { remaining: life, total: life }));
    e.addComponent(ComponentRegistry.create(ComponentType.Identity, { variant: color }));
    
    e.addComponent(ComponentRegistry.create(ComponentType.RenderModel, {
        geometryId: GEOMETRY_IDS.PARTICLE,
        materialId: MATERIAL_IDS.PARTICLE
    }));
    
    this.registry.updateCache(e);
  }
}


=====================================
FILE: ./src/engine/services/HUDService.ts
=====================================
import { IGameSystem } from '@/engine/interfaces';

export class HUDService implements IGameSystem {
  private scoreNode: HTMLElement | null = null;
  private vitalsContainer: HTMLElement | null = null;
  private levelTextNode: Element | null = null;

  update(delta: number, time: number): void {}
  teardown(): void {
      this.scoreNode = null;
      this.vitalsContainer = null;
      this.levelTextNode = null;
  }

  public bindScore(el: HTMLElement | null) { this.scoreNode = el; }
  public bindVitals(el: HTMLElement | null) { this.vitalsContainer = el; }
  public bindLevelText(el: Element | null) { this.levelTextNode = el; }

  public updateScore(val: number) {
    if (this.scoreNode) {
        this.scoreNode.innerText = val.toString().padStart(4, '0');
    }
  }

  public updateHealth(percent: number, color: string) {
    if (this.vitalsContainer) {
        this.vitalsContainer.style.setProperty('--hp-progress', String(percent));
        this.vitalsContainer.style.setProperty('--hp-color', color);
    }
  }

  public updateXP(percent: number) {
    if (this.vitalsContainer) {
        this.vitalsContainer.style.setProperty('--xp-progress', String(percent));
    }
  }

  public updateLevel(level: number) {
    if (this.levelTextNode) {
        this.levelTextNode.textContent = `LVL_${level.toString().padStart(2, '0')}`;
    }
  }
}


=====================================
FILE: ./src/engine/services/ServiceLocator.ts
=====================================
import { 
  IServiceLocator, 
  IGameSystem, 
  IAudioService, 
  IInputService, 
  IEntityRegistry, 
  IEntitySpawner, 
  IParticleSystem,
  IGameEventService,
  IFastEventService,
  IHUDService
} from '@/engine/interfaces';
import { ConfigService } from '@/engine/services/ConfigService';

class ServiceLocatorImpl implements IServiceLocator {
  private services = new Map<string, any>();

  public register<T>(id: string, instance: T): void {
    if (this.services.has(id)) {
      console.warn(`[ServiceLocator] Overwriting service: ${id}`);
    }
    this.services.set(id, instance);
  }

  public get<T>(id: string): T {
    const service = this.services.get(id);
    if (!service) {
      throw new Error(`[ServiceLocator] Service not found: ${id}`);
    }
    return service as T;
  }

  public reset(): void {
    this.services.clear();
    ConfigService.reset();
  }

  public getGameEventBus(): IGameEventService { return this.get<IGameEventService>('GameEventService'); }
  public getFastEventBus(): IFastEventService { return this.get<IFastEventService>('FastEventService'); }
  
  public getAudioService(): IAudioService { return this.get<IAudioService>('AudioService'); }
  public getInputService(): IInputService { return this.get<IInputService>('InputSystem'); }
  public getParticleSystem(): IParticleSystem { return this.get<IParticleSystem>('ParticleSystem'); }
  public getHUDService(): IHUDService { return this.get<IHUDService>('HUDService'); }
  
  public getRegistry(): IEntityRegistry { return this.get<IEntityRegistry>('EntityRegistry'); }
  public getSpawner(): IEntitySpawner { return this.get<IEntitySpawner>('EntitySpawner'); }
  public getConfigService() { return ConfigService; }

  public registerSystem(id: string, system: IGameSystem) { this.register(id, system); }
  public getSystem<T extends IGameSystem>(id: string): T { return this.get<T>(id); }
  public registerRegistry(r: IEntityRegistry) { this.register('EntityRegistry', r); }
  public registerSpawner(s: IEntitySpawner) { this.register('EntitySpawner', s); }
}

export const ServiceLocator = new ServiceLocatorImpl();


=====================================
FILE: ./src/engine/services/GameEngine.ts
=====================================
import { IGameSystem, IServiceLocator, IEntityRegistry, IPanelSystem, IGameStateSystem, IFastEventService, SystemPhase } from '@/engine/interfaces';
import { useGameStore } from '@/engine/state/game/useGameStore';
import { useStore } from '@/engine/state/global/useStore';
import { ViewportHelper } from '@/engine/math/ViewportHelper';
import { WorldConfig } from '@/engine/config/WorldConfig';
import { TimeSystem } from '@/engine/systems/TimeSystem';
import { GameEventBus } from '@/engine/signals/GameEventBus';
import { GameEvents } from '@/engine/signals/GameEvents';

export class GameEngineCore implements IGameSystem {
  private systems: IGameSystem[][] = [[], [], [], [], [], []];
  
  public registry: IEntityRegistry; 
  private accumulator: number = 0;
  private simulationTime: number = 0;

  private panelSystem: IPanelSystem | null = null;
  private gameSystem: IGameStateSystem | null = null;
  private timeSystem: TimeSystem | null = null;
  private fastEventBus: IFastEventService | null = null;

  constructor(registry: IEntityRegistry) {
      this.registry = registry;
  }

  public injectCoreSystems(panel: IPanelSystem, game: IGameStateSystem, time: TimeSystem) {
      this.panelSystem = panel;
      this.gameSystem = game;
      this.timeSystem = time;
  }

  public injectFastEventBus(bus: IFastEventService) {
      this.fastEventBus = bus;
  }

  setup(locator: IServiceLocator): void {}

  public registerSystem(system: IGameSystem, phase: SystemPhase) {
    this.systems[phase].push(system);
  }

  update(renderDelta: number, renderTime: number): void {
    const store = useStore.getState();
    const gameStore = useGameStore.getState();
    
    if (store.bootState === 'standby') return;
    if (store.activeModal === 'settings' || store.isDebugOpen) return;
    if (store.isSimulationPaused) return;

    // --- GAME OVER LOGIC CHANGE ---
    // Instead of returning (stopping the loop), we just flag it.
    // This allows physics (projectiles) and rendering to continue.
    if (this.gameSystem && this.panelSystem) {
        if (gameStore.isPlaying && this.panelSystem.systemIntegrity <= 0) {
            gameStore.stopGame();
            GameEventBus.emit(GameEvents.TRAUMA_ADDED, { amount: 1.0 });
            this.gameSystem.isGameOver = true; 
        }
    }

    // Time Management
    let timeScale = 1.0;
    if (this.timeSystem) {
        this.timeSystem.tickRealTime(renderDelta);
        if (this.timeSystem.isFrozen()) timeScale = 0.0;
        else timeScale = this.timeSystem.timeScale;
    }

    const effectiveDelta = renderDelta * timeScale * store.debugFlags.timeScale;
    this.accumulator += effectiveDelta;

    if (this.accumulator > WorldConfig.time.maxAccumulator) {
        this.accumulator = WorldConfig.time.maxAccumulator;
    }

    const fixedStep = WorldConfig.time.fixedDelta;

    while (this.accumulator >= fixedStep) {
        for (let phase = 0; phase < this.systems.length; phase++) {
            const phaseSystems = this.systems[phase];
            for (let i = 0; i < phaseSystems.length; i++) {
                try {
                    phaseSystems[i].update(fixedStep, this.simulationTime);
                } catch (e: any) {
                    console.error(`System Update Error [Phase ${phase}]:`, e);
                }
            }
        }
        this.simulationTime += fixedStep;
        this.accumulator -= fixedStep;
    }
    
    if (this.fastEventBus) {
        this.fastEventBus.clear();
    }
  }

  teardown(): void {
    for (const phase of this.systems) {
        for (const sys of phase) {
            sys.teardown();
        }
    }
    this.systems = [[], [], [], [], [], []];
    this.panelSystem = null;
    this.gameSystem = null;
    this.timeSystem = null;
    this.fastEventBus = null;
  }
  
  public updateViewport(vpW: number, vpH: number, screenW: number, screenH: number) {
    ViewportHelper.update(vpW, vpH, screenW, screenH);
    if (this.panelSystem) {
        this.panelSystem.refreshAll();
    }
  }
}


=====================================
FILE: ./src/engine/interfaces.ts
=====================================
import { Entity } from './ecs/Entity';
import { SpatialGrid } from './ecs/SpatialGrid';
import { WorldRect } from '@/engine/math/ViewportHelper';
import { ConfigService } from '@/engine/services/ConfigService';
import { QueryDef } from './ecs/Query';
import { Tag, Faction, ParticleShape } from './ecs/types';
import { GameEvents, GameEventPayloads } from '@/engine/signals/GameEvents';
import { AudioKey, VFXKey } from '@/engine/config/AssetKeys';
import { PanelId } from '@/engine/config/PanelConfig';

export enum SystemPhase {
  INPUT = 0,
  LOGIC = 1,
  PHYSICS = 2,
  COLLISION = 3,
  STATE = 4,
  RENDER = 5
}

export interface IGameSystem {
  update(delta: number, time: number): void;
  teardown(): void;
}

export interface IServiceLocator {
  register<T>(id: string, instance: T): void;
  get<T>(id: string): T;
  getGameEventBus(): IGameEventService;
  getFastEventBus(): IFastEventService; 
  getAudioService(): IAudioService;
  getInputService(): IInputService;
  getRegistry(): IEntityRegistry;
  getSpawner(): IEntitySpawner;
  getConfigService(): typeof ConfigService;
  getParticleSystem(): IParticleSystem;
  getHUDService(): IHUDService; 

  getSystem<T extends IGameSystem>(id: string): T;
  registerSystem(id: string, system: IGameSystem): void;
}

export interface IHUDService extends IGameSystem {
  bindScore(el: HTMLElement | null): void;
  bindVitals(el: HTMLElement | null): void;
  bindLevelText(el: Element | null): void;
  updateScore(val: number): void;
  updateHealth(percent: number, color: string): void;
  updateXP(percent: number): void;
  updateLevel(level: number): void;
}

export interface IFastEventService {
  emit(eventId: number, a1?: number, a2?: number, a3?: number, a4?: number): void;
  process(callback: (id: number, a1: number, a2: number, a3: number, a4: number) => void): void;
  clear(): void;
  getCursor(): number;
}

export interface IGameEventService {
  subscribe<T extends GameEvents>(event: T, handler: (payload: GameEventPayloads[T]) => void): () => void;
  emit<T extends GameEvents>(event: T, payload: GameEventPayloads[T]): void;
  clear(): void;
}

export interface IVitalsRead {
  playerHealth: number;
  maxPlayerHealth: number;
  playerRebootProgress: number;
  isGameOver: boolean;
}

export interface IProgressionRead {
  score: number;
  xp: number;
  level: number;
  xpToNextLevel: number;
  upgradePoints: number;
  activeUpgrades: Record<string, number>;
}

export interface IGameStateSystem extends IGameSystem, IVitalsRead, IProgressionRead {
  damagePlayer(amount: number): void;
  healPlayer(amount: number): void;
  addScore(amount: number): void;
  addXp(amount: number): void;
  tickReboot(amount: number): void;
  decayReboot(amount: number): void;
}

export interface IEntityRegistry {
  createEntity(): Entity;
  destroyEntity(id: number): void;
  getEntity(id: number): Entity | undefined;
  getAll(): IterableIterator<Entity>;
  getByTag(tag: string): Iterable<Entity>; 
  query(def: QueryDef): Iterable<Entity>;
  clear(): void;
  getStats(): { active: number; pooled: number; totalAllocated: number };
  updateCache(entity: Entity): void; 
}

export interface IEntitySpawner {
  spawn(archetypeId: string, overrides?: Record<string, any>, extraTags?: Tag[]): Entity;
  spawnPlayer(): Entity;
  spawnEnemy(type: string, x: number, y: number): Entity;
  spawnBullet(
      x: number, y: number, 
      vx: number, vy: number, 
      faction: Faction, 
      life: number, 
      damage?: number, 
      projectileId?: string, 
      ownerId?: number
  ): Entity;
  spawnParticle(
      x: number, y: number, 
      color: string, 
      vx: number, vy: number, 
      life: number, 
      size?: number, 
      shape?: ParticleShape
  ): void;
}

export interface IAudioService {
  init(): Promise<void>;
  startMusic(): void;
  stopAll(): void;
  updateVolumes(): void;
  playSound(key: AudioKey, pan?: number): void;
  playAmbience(key: AudioKey): void;
  duckMusic(intensity: number, duration: number): void;
  getFrequencyData(array: Uint8Array): void;
  playClick(pan?: number): void;
  playHover(pan?: number): void;
  playBootSequence(): void;
  playDrillSound(): void;
  playRebootZap(): void;
}

export interface IInputService {
  getCursor(): { x: number, y: number };
  isPressed(action: string): boolean;
  updateCursor(x: number, y: number): void;
  updateBounds(width: number, height: number): void; 
}

export interface IParticleSystem extends IGameSystem {
  spawn(
      x: number, y: number, 
      colorHex: string, 
      vx: number, vy: number, 
      life: number, 
      size?: number, 
      shape?: ParticleShape
  ): void;
  getCount(): number;
  getData(): { x: Float32Array; y: Float32Array; life: Float32Array; maxLife: Float32Array; color: Float32Array; };
}

export interface IPhysicsSystem extends IGameSystem {
  spatialGrid: SpatialGrid;
}

export interface ICombatSystem extends IGameSystem {
  resolveCollision(e1: Entity, e2: Entity): void;
}

export interface IInteractionSystem extends IGameSystem {
  repairState: 'IDLE' | 'HEALING' | 'REBOOTING';
  hoveringPanelId: PanelId | null;
}

export interface DamageOptions {
    silent?: boolean;
    source?: { x: number; y: number };
}

export interface IPanelSystem extends IGameSystem {
  systemIntegrity: number;
  register(id: PanelId, element: HTMLElement): void;
  unregister(id: PanelId): void;
  refreshAll(): void;
  refreshSingle(id: PanelId): void;
  damagePanel(id: PanelId, amount: number, options?: DamageOptions): void;
  healPanel(id: PanelId, amount: number, sourceX?: number): void;
  decayPanel(id: PanelId, amount: number): void;
  destroyAll(): void;
  getPanelRect(id: PanelId): WorldRect | undefined;
  getPanelState(id: PanelId): { health: number; isDestroyed: boolean } | undefined;
  getAllPanels(): any[]; 
}


